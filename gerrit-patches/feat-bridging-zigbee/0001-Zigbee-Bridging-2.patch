From 81259c11f84f5c79104c6a50d853d5a043adce36 Mon Sep 17 00:00:00 2001
From: Oleksandr Andrieiev <o.andrieiev@samsung.com>
Date: Wed, 23 Jan 2019 16:09:22 +0900
Subject: [PATCH] Zigbee Bridging

Change-Id: I0056f1ca1b52433aaa08b76fa89127e9187611f2
Signed-off-by: Oleksandr Andrieiev <o.andrieiev@samsung.com>
---
 auto_build.py                                      |    0
 bridging/SConscript                                |   21 +-
 .../Device_Operations/Device_Operations.cpp        |  787 +++++++
 .../Device_Operations/Device_Operations.h          |  282 +++
 bridging/plugins/zigbee_plugin/README              |   51 +
 bridging/plugins/zigbee_plugin/SConscript          |  132 ++
 bridging/plugins/zigbee_plugin/Zigbee_Device.cpp   | 1027 +++++++++
 bridging/plugins/zigbee_plugin/Zigbee_Device.h     |  599 ++++++
 .../Zigbee_Devices/Zigbee_ColorDimmableLight.cpp   |   90 +
 .../Zigbee_Devices/Zigbee_ColorDimmableLight.h     |   38 +
 .../Zigbee_ColorTemperatureLight.cpp               |   90 +
 .../Zigbee_Devices/Zigbee_ColorTemperatureLight.h  |   39 +
 .../Zigbee_Devices/Zigbee_DimmableLight.cpp        |   60 +
 .../Zigbee_Devices/Zigbee_DimmableLight.h          |   38 +
 .../Zigbee_Devices/Zigbee_ExtendedColorLight.cpp   |   90 +
 .../Zigbee_Devices/Zigbee_ExtendedColorLight.h     |   38 +
 .../Zigbee_Devices/Zigbee_IASZone.cpp              |   80 +
 .../zigbee_plugin/Zigbee_Devices/Zigbee_IASZone.h  |   40 +
 .../Zigbee_Devices/Zigbee_MainsPowerOutlet.cpp     |   49 +
 .../Zigbee_Devices/Zigbee_MainsPowerOutlet.h       |   38 +
 .../Zigbee_Devices/Zigbee_OccupancySensor.cpp      |   49 +
 .../Zigbee_Devices/Zigbee_OccupancySensor.h        |   38 +
 .../Zigbee_Devices/Zigbee_OnoffLight.cpp           |   50 +
 .../Zigbee_Devices/Zigbee_OnoffLight.h             |   39 +
 .../Zigbee_Devices/Zigbee_OnoffOutput.cpp          |   50 +
 .../Zigbee_Devices/Zigbee_OnoffOutput.h            |   37 +
 .../Zigbee_Devices/Zigbee_SmartPlug.cpp            |   50 +
 .../Zigbee_Devices/Zigbee_SmartPlug.h              |   38 +
 .../Zigbee_Devices/Zigbee_TemperatureSensor.cpp    |   51 +
 .../Zigbee_Devices/Zigbee_TemperatureSensor.h      |   38 +
 .../Zigbee_Devices/Zigbee_Thermostat.cpp           |   73 +
 .../Zigbee_Devices/Zigbee_Thermostat.h             |   38 +
 .../Zigbee_Devices/Zigbee_WindowCoveringDevice.cpp |   90 +
 .../Zigbee_Devices/Zigbee_WindowCoveringDevice.h   |   38 +
 bridging/plugins/zigbee_plugin/Zigbee_Resource.cpp |  984 +++++++++
 bridging/plugins/zigbee_plugin/Zigbee_Resource.h   |  150 ++
 .../plugins/zigbee_plugin/bridge_introspection.dat |  Bin 0 -> 154 bytes
 .../zigbee_plugin/bridge_introspection.json        |   15 +
 .../plugins/zigbee_plugin/cloud/Zigbee_Cloud.cpp   |  132 ++
 .../plugins/zigbee_plugin/cloud/Zigbee_Cloud.h     |   34 +
 .../zigbee_ColorDimmableLight_introspection.json   |  872 ++++++++
 ...zigbee_ColorTemperatureLight_introspection.json |  872 ++++++++
 .../idd/zigbee_DimmableLight_introspection.json    |  562 +++++
 .../zigbee_ExtendedColorLight_introspection.json   |  872 ++++++++
 .../idd/zigbee_IASZone_introspection.json          |  214 ++
 .../idd/zigbee_MainsPowerOutlet_introspection.json |  465 ++++
 .../idd/zigbee_OccupancySensor_introspection.json  |  468 ++++
 .../idd/zigbee_OnoffLight_introspection.json       |  465 ++++
 .../idd/zigbee_OnoffOutput_introspection.json      |  465 ++++
 .../idd/zigbee_SmartPlug_introspection.json        |  466 ++++
 .../zigbee_TemperatureSensor_introspection.json    |  506 +++++
 .../idd/zigbee_Thermostat_introspection.json       |  591 +++++
 .../zigbee_WindowCoveringDevice_introspection.json |  260 +++
 .../zigbee_plugin/virtual_server/SConscript        |  118 +
 .../virtual_server/Virtual_Server.cpp              | 2127 ++++++++++++++++++
 .../plugins/zigbee_plugin/zigbee_oic_svr_db.dat    |  Bin 0 -> 1149 bytes
 .../plugins/zigbee_plugin/zigbee_oic_svr_db.json   |   93 +
 .../zigbee_plugin/zigbee_oic_virtualsvr_db.dat     |  Bin 0 -> 2017 bytes
 .../zigbee_plugin/zigbee_oic_virtualsvr_db.json    |  143 ++
 build_common/windows/SConscript                    |    0
 cloud/account/start.sh                             |    0
 cloud/interface/start.sh                           |    0
 cloud/messagequeue/start.sh                        |    0
 cloud/resourcedirectory/start.sh                   |    0
 extlibs/buildDependencies.sh                       |    0
 extlibs/gtest/prep.sh                              |    0
 extlibs/hippomocks/prep.sh                         |    0
 extlibs/libcoap/SConscript                         |    0
 extlibs/libstrophe/prep.sh                         |    0
 extlibs/mbedtls/prep.sh                            |    0
 extlibs/rapidjson/prep.sh                          |    0
 extlibs/raxmpp/prep.sh                             |    0
 extlibs/socket/sio_client.cpp                      |  128 ++
 extlibs/socket/sio_client.h                        |   92 +
 extlibs/socket/sio_client_impl.cpp                 |  601 ++++++
 extlibs/socket/sio_client_impl.h                   |  232 ++
 extlibs/socket/sio_message.h                       |  569 +++++
 extlibs/socket/sio_packet.cpp                      |  517 +++++
 extlibs/socket/sio_packet.h                        |  106 +
 extlibs/socket/sio_socket.cpp                      |  611 ++++++
 extlibs/socket/sio_socket.h                        |  101 +
 extlibs/tinycbor/prep.sh                           |    0
 extlibs/websocketpp/.gitattributes                 |   18 +
 extlibs/websocketpp/.gitignore                     |   90 +
 extlibs/websocketpp/.travis.yml                    |   23 +
 extlibs/websocketpp/CMakeLists.txt                 |  244 +++
 extlibs/websocketpp/COPYING                        |  145 ++
 extlibs/websocketpp/Doxyfile                       | 1874 ++++++++++++++++
 extlibs/websocketpp/SConstruct                     |  266 +++
 extlibs/websocketpp/changelog.md                   |  234 ++
 .../websocketpp/docs/simple_broadcast_server.cpp   |   52 +
 .../docs/simple_count_server_thread.cpp            |   65 +
 extlibs/websocketpp/examples/CMakeLists.txt        |    6 +
 .../associative_storage/associative_storage.cpp    |   88 +
 .../examples/broadcast_server/SConscript           |   23 +
 .../examples/broadcast_server/broadcast_server.cpp |  156 ++
 .../websocketpp/examples/debug_client/SConscript   |   24 +
 .../examples/debug_client/debug_client.cpp         |  166 ++
 .../examples/debug_server/CMakeLists.txt           |   10 +
 .../websocketpp/examples/debug_server/SConscript   |   23 +
 .../examples/debug_server/debug_server.cpp         |  174 ++
 extlibs/websocketpp/examples/dev/SConscript        |   18 +
 extlibs/websocketpp/examples/dev/main.cpp          |  200 ++
 .../examples/echo_server/CMakeLists.txt            |   10 +
 .../websocketpp/examples/echo_server/SConscript    |   23 +
 .../examples/echo_server/echo_handler.hpp          |   37 +
 .../examples/echo_server/echo_server.cpp           |   58 +
 .../examples/echo_server_both/CMakeLists.txt       |   15 +
 .../examples/echo_server_both/SConscript           |   24 +
 .../examples/echo_server_both/echo_server_both.cpp |   87 +
 .../examples/echo_server_both/server.pem           |   58 +
 .../examples/echo_server_tls/CMakeLists.txt        |   15 +
 .../examples/echo_server_tls/SConscript            |   24 +
 .../examples/echo_server_tls/echo_server_tls.cpp   |   73 +
 .../examples/echo_server_tls/server.pem            |   58 +
 .../examples/enriched_storage/enriched_storage.cpp |   87 +
 .../examples/handler_switch/handler_switch.cpp     |   42 +
 .../examples/iostream_server/SConscript            |   23 +
 .../examples/iostream_server/iostream_server.cpp   |   89 +
 .../examples/print_server/CMakeLists.txt           |   10 +
 .../websocketpp/examples/print_server/SConscript   |   23 +
 .../examples/print_server/print_server.cpp         |   22 +
 .../simple_broadcast_server.cpp                    |   51 +
 .../websocketpp/examples/sip_client/CMakeLists.txt |   11 +
 extlibs/websocketpp/examples/sip_client/README.txt |   22 +
 extlibs/websocketpp/examples/sip_client/SConscript |   23 +
 .../websocketpp/examples/sip_client/sip_client.cpp |   84 +
 .../examples/subprotocol_server/SConscript         |   23 +
 .../subprotocol_server/subprotocol_server.cpp      |   48 +
 .../examples/telemetry_client/CMakeLists.txt       |   10 +
 .../examples/telemetry_client/SConscript           |   23 +
 .../examples/telemetry_client/telemetry_client.cpp |  156 ++
 .../examples/telemetry_server/CMakeLists.txt       |   10 +
 .../examples/telemetry_server/SConscript           |   23 +
 .../examples/telemetry_server/index.html           |   85 +
 .../examples/telemetry_server/telemetry_server.cpp |  204 ++
 .../examples/testee_client/CMakeLists.txt          |   11 +
 .../websocketpp/examples/testee_client/SConscript  |   23 +
 .../examples/testee_client/testee_client.cpp       |   80 +
 .../websocketpp/examples/testee_server/SConscript  |   23 +
 .../examples/testee_server/testee_server.cpp       |  138 ++
 .../examples/utility_client/CMakeLists.txt         |   11 +
 .../websocketpp/examples/utility_client/SConscript |   23 +
 .../examples/utility_client/utility_client.cpp     |  325 +++
 extlibs/websocketpp/readme.md                      |   45 +
 extlibs/websocketpp/roadmap.md                     |   43 +
 extlibs/websocketpp/test/connection/SConscript     |   25 +
 extlibs/websocketpp/test/connection/connection.cpp |  478 +++++
 .../websocketpp/test/connection/connection_tu2.cpp |   62 +
 .../websocketpp/test/connection/connection_tu2.hpp |   51 +
 extlibs/websocketpp/test/endpoint/SConscript       |   24 +
 extlibs/websocketpp/test/endpoint/endpoint.cpp     |  126 ++
 extlibs/websocketpp/test/extension/SConscript      |   27 +
 extlibs/websocketpp/test/extension/extension.cpp   |   37 +
 .../test/extension/permessage_deflate.cpp          |  543 +++++
 extlibs/websocketpp/test/http/SConscript           |   23 +
 extlibs/websocketpp/test/http/parser.cpp           | 1127 ++++++++++
 extlibs/websocketpp/test/http/parser_perf.cpp      |  141 ++
 extlibs/websocketpp/test/logger/SConscript         |   23 +
 extlibs/websocketpp/test/logger/basic.cpp          |   81 +
 extlibs/websocketpp/test/message_buffer/SConscript |   27 +
 extlibs/websocketpp/test/message_buffer/alloc.cpp  |   96 +
 .../websocketpp/test/message_buffer/message.cpp    |   72 +
 extlibs/websocketpp/test/message_buffer/pool.cpp   |  156 ++
 extlibs/websocketpp/test/processors/SConscript     |   47 +
 .../processors/extension_permessage_compress.cpp   |  198 ++
 extlibs/websocketpp/test/processors/hybi00.cpp     |  274 +++
 extlibs/websocketpp/test/processors/hybi07.cpp     |  193 ++
 extlibs/websocketpp/test/processors/hybi08.cpp     |  197 ++
 extlibs/websocketpp/test/processors/hybi13.cpp     |  693 ++++++
 extlibs/websocketpp/test/processors/processor.cpp  |  135 ++
 extlibs/websocketpp/test/random/SConscript         |   27 +
 extlibs/websocketpp/test/random/none.cpp           |   40 +
 extlibs/websocketpp/test/random/random_device.cpp  |   50 +
 extlibs/websocketpp/test/roles/SConscript          |   27 +
 extlibs/websocketpp/test/roles/client.cpp          |  194 ++
 extlibs/websocketpp/test/roles/server.cpp          |  247 +++
 extlibs/websocketpp/test/transport/SConscript      |   24 +
 extlibs/websocketpp/test/transport/asio/SConscript |   28 +
 extlibs/websocketpp/test/transport/asio/base.cpp   |   49 +
 extlibs/websocketpp/test/transport/asio/timers.cpp |  187 ++
 extlibs/websocketpp/test/transport/hybi_util.cpp   |   98 +
 extlibs/websocketpp/test/transport/integration.cpp |  609 ++++++
 .../websocketpp/test/transport/iostream/SConscript |   31 +
 .../websocketpp/test/transport/iostream/base.cpp   |   33 +
 .../test/transport/iostream/connection.cpp         |  575 +++++
 .../test/transport/iostream/endpoint.cpp           |   41 +
 extlibs/websocketpp/test/utility/SConscript        |   40 +
 extlibs/websocketpp/test/utility/close.cpp         |  125 ++
 extlibs/websocketpp/test/utility/error.cpp         |   54 +
 extlibs/websocketpp/test/utility/frame.cpp         |  538 +++++
 extlibs/websocketpp/test/utility/sha1.cpp          |   81 +
 extlibs/websocketpp/test/utility/uri.cpp           |  246 +++
 extlibs/websocketpp/test/utility/utilities.cpp     |   73 +
 .../broadcast_tutorial/broadcast_tutorial.md       |   17 +
 .../tutorials/chat_tutorial/chat_tutorial.md       |   13 +
 .../websocketpp/tutorials/utility_client/step1.cpp |   56 +
 .../websocketpp/tutorials/utility_client/step2.cpp |   61 +
 .../websocketpp/tutorials/utility_client/step3.cpp |   81 +
 .../websocketpp/tutorials/utility_client/step4.cpp |  202 ++
 .../websocketpp/tutorials/utility_client/step5.cpp |  280 +++
 .../websocketpp/tutorials/utility_client/step6.cpp |  335 +++
 .../tutorials/utility_client/utility_client.md     |  856 ++++++++
 extlibs/websocketpp/websocketpp-config.cmake.in    |    7 +
 .../websocketpp/websocketpp-configVersion.cmake.in |   11 +
 extlibs/websocketpp/websocketpp/CMakeLists.txt     |    2 +
 extlibs/websocketpp/websocketpp/base64/base64.hpp  |  178 ++
 extlibs/websocketpp/websocketpp/client.hpp         |   33 +
 extlibs/websocketpp/websocketpp/close.hpp          |  342 +++
 extlibs/websocketpp/websocketpp/common/chrono.hpp  |   55 +
 .../websocketpp/common/connection_hdl.hpp          |   52 +
 extlibs/websocketpp/websocketpp/common/cpp11.hpp   |  150 ++
 .../websocketpp/websocketpp/common/functional.hpp  |  105 +
 extlibs/websocketpp/websocketpp/common/md5.hpp     |  448 ++++
 extlibs/websocketpp/websocketpp/common/memory.hpp  |   86 +
 extlibs/websocketpp/websocketpp/common/network.hpp |  104 +
 .../websocketpp/websocketpp/common/platforms.hpp   |   46 +
 extlibs/websocketpp/websocketpp/common/random.hpp  |   77 +
 extlibs/websocketpp/websocketpp/common/regex.hpp   |   59 +
 extlibs/websocketpp/websocketpp/common/stdint.hpp  |   73 +
 .../websocketpp/common/system_error.hpp            |   82 +
 extlibs/websocketpp/websocketpp/common/thread.hpp  |   76 +
 extlibs/websocketpp/websocketpp/common/time.hpp    |   56 +
 .../websocketpp/websocketpp/concurrency/basic.hpp  |   46 +
 .../websocketpp/websocketpp/concurrency/none.hpp   |   80 +
 extlibs/websocketpp/websocketpp/config/asio.hpp    |   77 +
 .../websocketpp/websocketpp/config/asio_client.hpp |   77 +
 .../websocketpp/websocketpp/config/asio_no_tls.hpp |   73 +
 .../websocketpp/config/asio_no_tls_client.hpp      |   73 +
 .../websocketpp/config/boost_config.hpp            |   72 +
 extlibs/websocketpp/websocketpp/config/core.hpp    |  285 +++
 .../websocketpp/websocketpp/config/core_client.hpp |  294 +++
 extlibs/websocketpp/websocketpp/config/debug.hpp   |  286 +++
 .../websocketpp/websocketpp/config/debug_asio.hpp  |   77 +
 .../websocketpp/config/debug_asio_no_tls.hpp       |   73 +
 .../websocketpp/config/minimal_client.hpp          |   72 +
 .../websocketpp/config/minimal_server.hpp          |  312 +++
 extlibs/websocketpp/websocketpp/connection.hpp     | 1530 +++++++++++++
 .../websocketpp/websocketpp/connection_base.hpp    |   38 +
 extlibs/websocketpp/websocketpp/endpoint.hpp       |  619 ++++++
 extlibs/websocketpp/websocketpp/endpoint_base.hpp  |   38 +
 extlibs/websocketpp/websocketpp/error.hpp          |  272 +++
 .../websocketpp/extensions/extension.hpp           |  102 +
 .../extensions/permessage_deflate/disabled.hpp     |  106 +
 .../extensions/permessage_deflate/enabled.hpp      |  725 +++++++
 extlibs/websocketpp/websocketpp/frame.hpp          |  861 ++++++++
 extlibs/websocketpp/websocketpp/http/constants.hpp |  308 +++
 .../websocketpp/websocketpp/http/impl/parser.hpp   |  196 ++
 .../websocketpp/websocketpp/http/impl/request.hpp  |  191 ++
 .../websocketpp/websocketpp/http/impl/response.hpp |  266 +++
 extlibs/websocketpp/websocketpp/http/parser.hpp    |  615 ++++++
 extlibs/websocketpp/websocketpp/http/request.hpp   |  124 ++
 extlibs/websocketpp/websocketpp/http/response.hpp  |  188 ++
 .../websocketpp/impl/connection_impl.hpp           | 2267 ++++++++++++++++++++
 .../websocketpp/websocketpp/impl/endpoint_impl.hpp |  255 +++
 .../websocketpp/impl/utilities_impl.hpp            |   87 +
 extlibs/websocketpp/websocketpp/logger/basic.hpp   |  169 ++
 extlibs/websocketpp/websocketpp/logger/levels.hpp  |  203 ++
 extlibs/websocketpp/websocketpp/logger/stub.hpp    |  119 +
 extlibs/websocketpp/websocketpp/logger/syslog.hpp  |  146 ++
 .../websocketpp/message_buffer/alloc.hpp           |  105 +
 .../websocketpp/message_buffer/message.hpp         |  340 +++
 .../websocketpp/message_buffer/pool.hpp            |  229 ++
 .../websocketpp/websocketpp/processors/base.hpp    |  299 +++
 .../websocketpp/websocketpp/processors/hybi00.hpp  |  446 ++++
 .../websocketpp/websocketpp/processors/hybi07.hpp  |   78 +
 .../websocketpp/websocketpp/processors/hybi08.hpp  |   83 +
 .../websocketpp/websocketpp/processors/hybi13.hpp  | 1005 +++++++++
 .../websocketpp/processors/processor.hpp           |  392 ++++
 extlibs/websocketpp/websocketpp/random/none.hpp    |   60 +
 .../websocketpp/random/random_device.hpp           |   80 +
 .../websocketpp/roles/client_endpoint.hpp          |  170 ++
 .../websocketpp/roles/server_endpoint.hpp          |  166 ++
 extlibs/websocketpp/websocketpp/server.hpp         |   33 +
 extlibs/websocketpp/websocketpp/sha1/sha1.hpp      |  189 ++
 .../websocketpp/transport/asio/base.hpp            |  251 +++
 .../websocketpp/transport/asio/connection.hpp      | 1162 ++++++++++
 .../websocketpp/transport/asio/endpoint.hpp        | 1094 ++++++++++
 .../websocketpp/transport/asio/security/base.hpp   |  152 ++
 .../websocketpp/transport/asio/security/none.hpp   |  329 +++
 .../websocketpp/transport/asio/security/tls.hpp    |  421 ++++
 .../websocketpp/transport/base/connection.hpp      |  238 ++
 .../websocketpp/transport/base/endpoint.hpp        |   77 +
 .../websocketpp/transport/debug/base.hpp           |  104 +
 .../websocketpp/transport/debug/connection.hpp     |  397 ++++
 .../websocketpp/transport/debug/endpoint.hpp       |  140 ++
 .../websocketpp/transport/iostream/base.hpp        |  121 ++
 .../websocketpp/transport/iostream/connection.hpp  |  661 ++++++
 .../websocketpp/transport/iostream/endpoint.hpp    |  222 ++
 .../websocketpp/transport/stub/base.hpp            |   95 +
 .../websocketpp/transport/stub/connection.hpp      |  272 +++
 .../websocketpp/transport/stub/endpoint.hpp        |  140 ++
 extlibs/websocketpp/websocketpp/uri.hpp            |  354 +++
 extlibs/websocketpp/websocketpp/utf8_validator.hpp |  154 ++
 extlibs/websocketpp/websocketpp/utilities.hpp      |  182 ++
 extlibs/websocketpp/websocketpp/version.hpp        |   60 +
 extlibs/wksxmppxep/prep.sh                         |    0
 extlibs/yaml/prep.sh                               |    0
 java/examples-android/gradlew                      |    0
 java/examples-android/gradlew.bat                  |    0
 java/examples-java/ocflightserver/run.sh           |    0
 java/gradlew                                       |    0
 java/gradlew.bat                                   |    0
 java/iotivity-android/gradlew                      |    0
 java/iotivity-android/run_android_smoketests.py    |    0
 resource/csdk/connectivity/build/tizen/gbsbuild.sh |    0
 resource/csdk/connectivity/inc/cacertprofile.h     |    2 +
 .../connectivity/src/adapter_util/cacertprofile.c  |   43 +
 resource/csdk/include/octypes.h                    |    4 +-
 .../csdk/security/provisioning/sample/makecerts    |    0
 .../security/provisioning/sample/system_test.py    |    0
 .../provisioning/src/ocprovisioningmanager.c       |    0
 .../csdk/stack/samples/tizen/build/gbsbuild.sh     |    0
 .../com.example.app.iotivity/src/App/App.less      |    0
 .../com.example.app.iotivity/src/App/package.json  |    0
 resource/docs/javadocGen.sh                        |    0
 resource/src/OCAccountManager.cpp                  |   18 +-
 .../EnrolleeSample/build/tizen/gbsbuild.sh         |    0
 .../android/NotiConsumerExample/gradlew.bat        |    0
 .../examples/android/AndroidBundle/gradlew         |    0
 .../examples/android/AndroidBundle/gradlew.bat     |    0
 .../examples/android/RCSampleServerApp/gradlew     |    0
 .../examples/android/RCSampleServerApp/gradlew.bat |    0
 tools/darwin/build-ios.sh                          |    0
 tools/darwin/mkfwk_ios.sh                          |    0
 tools/darwin/mkfwk_osx.sh                          |    0
 tools/generate_report.sh                           |    0
 tools/style/astyle-clean-cpp-format.sh             |    0
 tools/style/astyle-cpp-format.sh                   |    0
 tools/vagrant/iotivity-setup.sh                    |    0
 330 files changed, 58162 insertions(+), 15 deletions(-)
 mode change 100755 => 100644 auto_build.py
 create mode 100644 bridging/plugins/zigbee_plugin/Device_Operations/Device_Operations.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Device_Operations/Device_Operations.h
 create mode 100644 bridging/plugins/zigbee_plugin/README
 create mode 100644 bridging/plugins/zigbee_plugin/SConscript
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Device.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Device.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorDimmableLight.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorDimmableLight.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorTemperatureLight.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorTemperatureLight.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_DimmableLight.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_DimmableLight.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ExtendedColorLight.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ExtendedColorLight.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_IASZone.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_IASZone.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_MainsPowerOutlet.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_MainsPowerOutlet.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OccupancySensor.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OccupancySensor.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffLight.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffLight.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffOutput.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffOutput.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_SmartPlug.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_SmartPlug.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_TemperatureSensor.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_TemperatureSensor.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_Thermostat.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_Thermostat.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_WindowCoveringDevice.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_WindowCoveringDevice.h
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Resource.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/Zigbee_Resource.h
 create mode 100644 bridging/plugins/zigbee_plugin/bridge_introspection.dat
 create mode 100644 bridging/plugins/zigbee_plugin/bridge_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/cloud/Zigbee_Cloud.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/cloud/Zigbee_Cloud.h
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_ColorDimmableLight_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_ColorTemperatureLight_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_DimmableLight_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_ExtendedColorLight_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_IASZone_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_MainsPowerOutlet_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_OccupancySensor_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_OnoffLight_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_OnoffOutput_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_SmartPlug_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_TemperatureSensor_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_Thermostat_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/idd/zigbee_WindowCoveringDevice_introspection.json
 create mode 100644 bridging/plugins/zigbee_plugin/virtual_server/SConscript
 create mode 100644 bridging/plugins/zigbee_plugin/virtual_server/Virtual_Server.cpp
 create mode 100644 bridging/plugins/zigbee_plugin/zigbee_oic_svr_db.dat
 create mode 100644 bridging/plugins/zigbee_plugin/zigbee_oic_svr_db.json
 create mode 100644 bridging/plugins/zigbee_plugin/zigbee_oic_virtualsvr_db.dat
 create mode 100644 bridging/plugins/zigbee_plugin/zigbee_oic_virtualsvr_db.json
 mode change 100755 => 100644 build_common/windows/SConscript
 mode change 100755 => 100644 cloud/account/start.sh
 mode change 100755 => 100644 cloud/interface/start.sh
 mode change 100755 => 100644 cloud/messagequeue/start.sh
 mode change 100755 => 100644 cloud/resourcedirectory/start.sh
 mode change 100755 => 100644 extlibs/buildDependencies.sh
 mode change 100755 => 100644 extlibs/gtest/prep.sh
 mode change 100755 => 100644 extlibs/hippomocks/prep.sh
 mode change 100755 => 100644 extlibs/libcoap/SConscript
 mode change 100755 => 100644 extlibs/libstrophe/prep.sh
 mode change 100755 => 100644 extlibs/mbedtls/prep.sh
 mode change 100755 => 100644 extlibs/rapidjson/prep.sh
 mode change 100755 => 100644 extlibs/raxmpp/prep.sh
 create mode 100644 extlibs/socket/sio_client.cpp
 create mode 100644 extlibs/socket/sio_client.h
 create mode 100644 extlibs/socket/sio_client_impl.cpp
 create mode 100644 extlibs/socket/sio_client_impl.h
 create mode 100644 extlibs/socket/sio_message.h
 create mode 100644 extlibs/socket/sio_packet.cpp
 create mode 100644 extlibs/socket/sio_packet.h
 create mode 100644 extlibs/socket/sio_socket.cpp
 create mode 100644 extlibs/socket/sio_socket.h
 mode change 100755 => 100644 extlibs/tinycbor/prep.sh
 create mode 100644 extlibs/websocketpp/.gitattributes
 create mode 100644 extlibs/websocketpp/.gitignore
 create mode 100644 extlibs/websocketpp/.travis.yml
 create mode 100644 extlibs/websocketpp/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/COPYING
 create mode 100644 extlibs/websocketpp/Doxyfile
 create mode 100644 extlibs/websocketpp/SConstruct
 create mode 100644 extlibs/websocketpp/changelog.md
 create mode 100644 extlibs/websocketpp/docs/simple_broadcast_server.cpp
 create mode 100644 extlibs/websocketpp/docs/simple_count_server_thread.cpp
 create mode 100644 extlibs/websocketpp/examples/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/associative_storage/associative_storage.cpp
 create mode 100644 extlibs/websocketpp/examples/broadcast_server/SConscript
 create mode 100644 extlibs/websocketpp/examples/broadcast_server/broadcast_server.cpp
 create mode 100644 extlibs/websocketpp/examples/debug_client/SConscript
 create mode 100644 extlibs/websocketpp/examples/debug_client/debug_client.cpp
 create mode 100644 extlibs/websocketpp/examples/debug_server/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/debug_server/SConscript
 create mode 100644 extlibs/websocketpp/examples/debug_server/debug_server.cpp
 create mode 100644 extlibs/websocketpp/examples/dev/SConscript
 create mode 100644 extlibs/websocketpp/examples/dev/main.cpp
 create mode 100644 extlibs/websocketpp/examples/echo_server/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/echo_server/SConscript
 create mode 100644 extlibs/websocketpp/examples/echo_server/echo_handler.hpp
 create mode 100644 extlibs/websocketpp/examples/echo_server/echo_server.cpp
 create mode 100644 extlibs/websocketpp/examples/echo_server_both/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/echo_server_both/SConscript
 create mode 100644 extlibs/websocketpp/examples/echo_server_both/echo_server_both.cpp
 create mode 100644 extlibs/websocketpp/examples/echo_server_both/server.pem
 create mode 100644 extlibs/websocketpp/examples/echo_server_tls/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/echo_server_tls/SConscript
 create mode 100644 extlibs/websocketpp/examples/echo_server_tls/echo_server_tls.cpp
 create mode 100644 extlibs/websocketpp/examples/echo_server_tls/server.pem
 create mode 100644 extlibs/websocketpp/examples/enriched_storage/enriched_storage.cpp
 create mode 100644 extlibs/websocketpp/examples/handler_switch/handler_switch.cpp
 create mode 100644 extlibs/websocketpp/examples/iostream_server/SConscript
 create mode 100644 extlibs/websocketpp/examples/iostream_server/iostream_server.cpp
 create mode 100644 extlibs/websocketpp/examples/print_server/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/print_server/SConscript
 create mode 100644 extlibs/websocketpp/examples/print_server/print_server.cpp
 create mode 100644 extlibs/websocketpp/examples/simple_broadcast_server/simple_broadcast_server.cpp
 create mode 100644 extlibs/websocketpp/examples/sip_client/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/sip_client/README.txt
 create mode 100644 extlibs/websocketpp/examples/sip_client/SConscript
 create mode 100644 extlibs/websocketpp/examples/sip_client/sip_client.cpp
 create mode 100644 extlibs/websocketpp/examples/subprotocol_server/SConscript
 create mode 100644 extlibs/websocketpp/examples/subprotocol_server/subprotocol_server.cpp
 create mode 100644 extlibs/websocketpp/examples/telemetry_client/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/telemetry_client/SConscript
 create mode 100644 extlibs/websocketpp/examples/telemetry_client/telemetry_client.cpp
 create mode 100644 extlibs/websocketpp/examples/telemetry_server/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/telemetry_server/SConscript
 create mode 100644 extlibs/websocketpp/examples/telemetry_server/index.html
 create mode 100644 extlibs/websocketpp/examples/telemetry_server/telemetry_server.cpp
 create mode 100644 extlibs/websocketpp/examples/testee_client/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/testee_client/SConscript
 create mode 100644 extlibs/websocketpp/examples/testee_client/testee_client.cpp
 create mode 100644 extlibs/websocketpp/examples/testee_server/SConscript
 create mode 100644 extlibs/websocketpp/examples/testee_server/testee_server.cpp
 create mode 100644 extlibs/websocketpp/examples/utility_client/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/examples/utility_client/SConscript
 create mode 100644 extlibs/websocketpp/examples/utility_client/utility_client.cpp
 create mode 100644 extlibs/websocketpp/readme.md
 create mode 100644 extlibs/websocketpp/roadmap.md
 create mode 100644 extlibs/websocketpp/test/connection/SConscript
 create mode 100644 extlibs/websocketpp/test/connection/connection.cpp
 create mode 100644 extlibs/websocketpp/test/connection/connection_tu2.cpp
 create mode 100644 extlibs/websocketpp/test/connection/connection_tu2.hpp
 create mode 100644 extlibs/websocketpp/test/endpoint/SConscript
 create mode 100644 extlibs/websocketpp/test/endpoint/endpoint.cpp
 create mode 100644 extlibs/websocketpp/test/extension/SConscript
 create mode 100644 extlibs/websocketpp/test/extension/extension.cpp
 create mode 100644 extlibs/websocketpp/test/extension/permessage_deflate.cpp
 create mode 100644 extlibs/websocketpp/test/http/SConscript
 create mode 100644 extlibs/websocketpp/test/http/parser.cpp
 create mode 100644 extlibs/websocketpp/test/http/parser_perf.cpp
 create mode 100644 extlibs/websocketpp/test/logger/SConscript
 create mode 100644 extlibs/websocketpp/test/logger/basic.cpp
 create mode 100644 extlibs/websocketpp/test/message_buffer/SConscript
 create mode 100644 extlibs/websocketpp/test/message_buffer/alloc.cpp
 create mode 100644 extlibs/websocketpp/test/message_buffer/message.cpp
 create mode 100644 extlibs/websocketpp/test/message_buffer/pool.cpp
 create mode 100644 extlibs/websocketpp/test/processors/SConscript
 create mode 100644 extlibs/websocketpp/test/processors/extension_permessage_compress.cpp
 create mode 100644 extlibs/websocketpp/test/processors/hybi00.cpp
 create mode 100644 extlibs/websocketpp/test/processors/hybi07.cpp
 create mode 100644 extlibs/websocketpp/test/processors/hybi08.cpp
 create mode 100644 extlibs/websocketpp/test/processors/hybi13.cpp
 create mode 100644 extlibs/websocketpp/test/processors/processor.cpp
 create mode 100644 extlibs/websocketpp/test/random/SConscript
 create mode 100644 extlibs/websocketpp/test/random/none.cpp
 create mode 100644 extlibs/websocketpp/test/random/random_device.cpp
 create mode 100644 extlibs/websocketpp/test/roles/SConscript
 create mode 100644 extlibs/websocketpp/test/roles/client.cpp
 create mode 100644 extlibs/websocketpp/test/roles/server.cpp
 create mode 100644 extlibs/websocketpp/test/transport/SConscript
 create mode 100644 extlibs/websocketpp/test/transport/asio/SConscript
 create mode 100644 extlibs/websocketpp/test/transport/asio/base.cpp
 create mode 100644 extlibs/websocketpp/test/transport/asio/timers.cpp
 create mode 100644 extlibs/websocketpp/test/transport/hybi_util.cpp
 create mode 100644 extlibs/websocketpp/test/transport/integration.cpp
 create mode 100644 extlibs/websocketpp/test/transport/iostream/SConscript
 create mode 100644 extlibs/websocketpp/test/transport/iostream/base.cpp
 create mode 100644 extlibs/websocketpp/test/transport/iostream/connection.cpp
 create mode 100644 extlibs/websocketpp/test/transport/iostream/endpoint.cpp
 create mode 100644 extlibs/websocketpp/test/utility/SConscript
 create mode 100644 extlibs/websocketpp/test/utility/close.cpp
 create mode 100644 extlibs/websocketpp/test/utility/error.cpp
 create mode 100644 extlibs/websocketpp/test/utility/frame.cpp
 create mode 100644 extlibs/websocketpp/test/utility/sha1.cpp
 create mode 100644 extlibs/websocketpp/test/utility/uri.cpp
 create mode 100644 extlibs/websocketpp/test/utility/utilities.cpp
 create mode 100644 extlibs/websocketpp/tutorials/broadcast_tutorial/broadcast_tutorial.md
 create mode 100644 extlibs/websocketpp/tutorials/chat_tutorial/chat_tutorial.md
 create mode 100644 extlibs/websocketpp/tutorials/utility_client/step1.cpp
 create mode 100644 extlibs/websocketpp/tutorials/utility_client/step2.cpp
 create mode 100644 extlibs/websocketpp/tutorials/utility_client/step3.cpp
 create mode 100644 extlibs/websocketpp/tutorials/utility_client/step4.cpp
 create mode 100644 extlibs/websocketpp/tutorials/utility_client/step5.cpp
 create mode 100644 extlibs/websocketpp/tutorials/utility_client/step6.cpp
 create mode 100644 extlibs/websocketpp/tutorials/utility_client/utility_client.md
 create mode 100644 extlibs/websocketpp/websocketpp-config.cmake.in
 create mode 100644 extlibs/websocketpp/websocketpp-configVersion.cmake.in
 create mode 100644 extlibs/websocketpp/websocketpp/CMakeLists.txt
 create mode 100644 extlibs/websocketpp/websocketpp/base64/base64.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/client.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/close.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/chrono.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/connection_hdl.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/cpp11.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/functional.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/md5.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/memory.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/network.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/platforms.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/random.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/regex.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/stdint.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/system_error.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/thread.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/common/time.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/concurrency/basic.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/concurrency/none.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/asio.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/asio_client.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/asio_no_tls.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/asio_no_tls_client.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/boost_config.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/core.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/core_client.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/debug.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/debug_asio.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/debug_asio_no_tls.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/minimal_client.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/config/minimal_server.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/connection.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/connection_base.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/endpoint.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/endpoint_base.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/error.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/extensions/extension.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/extensions/permessage_deflate/disabled.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/extensions/permessage_deflate/enabled.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/frame.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/http/constants.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/http/impl/parser.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/http/impl/request.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/http/impl/response.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/http/parser.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/http/request.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/http/response.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/impl/connection_impl.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/impl/endpoint_impl.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/impl/utilities_impl.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/logger/basic.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/logger/levels.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/logger/stub.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/logger/syslog.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/message_buffer/alloc.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/message_buffer/message.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/message_buffer/pool.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/processors/base.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/processors/hybi00.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/processors/hybi07.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/processors/hybi08.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/processors/hybi13.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/processors/processor.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/random/none.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/random/random_device.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/roles/client_endpoint.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/roles/server_endpoint.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/server.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/sha1/sha1.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/asio/base.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/asio/connection.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/asio/endpoint.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/asio/security/base.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/asio/security/none.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/asio/security/tls.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/base/connection.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/base/endpoint.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/debug/base.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/debug/connection.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/debug/endpoint.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/iostream/base.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/iostream/connection.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/iostream/endpoint.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/stub/base.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/stub/connection.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/transport/stub/endpoint.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/uri.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/utf8_validator.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/utilities.hpp
 create mode 100644 extlibs/websocketpp/websocketpp/version.hpp
 mode change 100755 => 100644 extlibs/wksxmppxep/prep.sh
 mode change 100755 => 100644 extlibs/yaml/prep.sh
 mode change 100755 => 100644 java/examples-android/gradlew
 mode change 100755 => 100644 java/examples-android/gradlew.bat
 mode change 100755 => 100644 java/examples-java/ocflightserver/run.sh
 mode change 100755 => 100644 java/gradlew
 mode change 100755 => 100644 java/gradlew.bat
 mode change 100755 => 100644 java/iotivity-android/gradlew
 mode change 100755 => 100644 java/iotivity-android/run_android_smoketests.py
 mode change 100755 => 100644 resource/csdk/connectivity/build/tizen/gbsbuild.sh
 mode change 100755 => 100644 resource/csdk/security/provisioning/sample/makecerts
 mode change 100755 => 100644 resource/csdk/security/provisioning/sample/system_test.py
 mode change 100755 => 100644 resource/csdk/security/provisioning/src/ocprovisioningmanager.c
 mode change 100755 => 100644 resource/csdk/stack/samples/tizen/build/gbsbuild.sh
 mode change 100755 => 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/App.less
 mode change 100755 => 100644 resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/package.json
 mode change 100755 => 100644 resource/docs/javadocGen.sh
 mode change 100755 => 100644 service/easy-setup/sampleapp/enrollee/tizen-sdb/EnrolleeSample/build/tizen/gbsbuild.sh
 mode change 100755 => 100644 service/notification/examples/android/NotiConsumerExample/gradlew.bat
 mode change 100755 => 100644 service/resource-container/examples/android/AndroidBundle/gradlew
 mode change 100755 => 100644 service/resource-container/examples/android/AndroidBundle/gradlew.bat
 mode change 100755 => 100644 service/resource-container/examples/android/RCSampleServerApp/gradlew
 mode change 100755 => 100644 service/resource-container/examples/android/RCSampleServerApp/gradlew.bat
 mode change 100755 => 100644 tools/darwin/build-ios.sh
 mode change 100755 => 100644 tools/darwin/mkfwk_ios.sh
 mode change 100755 => 100644 tools/darwin/mkfwk_osx.sh
 mode change 100755 => 100644 tools/generate_report.sh
 mode change 100755 => 100644 tools/style/astyle-clean-cpp-format.sh
 mode change 100755 => 100644 tools/style/astyle-cpp-format.sh
 mode change 100755 => 100644 tools/vagrant/iotivity-setup.sh

diff --git a/auto_build.py b/auto_build.py
old mode 100755
new mode 100644
diff --git a/bridging/SConscript b/bridging/SConscript
index 2539e374d..41c2aa5aa 100644
--- a/bridging/SConscript
+++ b/bridging/SConscript
@@ -30,20 +30,23 @@ build_sample = 'ON'
 src_dir = env.get('SRC_DIR')
 
 # rapidjson fetch
-SConscript('#extlibs/rapidjson/SConscript')
+SConscript(os.path.join(env.get('SRC_DIR'), 'extlibs', 'rapidjson', 'SConscript'))
 
-if target_os not in ['android', 'darwin', 'ios', 'tizen', 'msys_nt', 'webos', 'windows']:
+if target_os not in [
+    'android', 'arduino', 'darwin', 'ios', 'tizen', 'msys_nt', 'windows']:
 
-    SConscript('common/SConscript')
+    SConscript(os.path.join('common', 'SConscript'))
 
-    SConscript('mini_plugin_manager/SConscript')
+    SConscript(os.path.join('mini_plugin_manager', 'SConscript'))
 
-    SConscript('mpm_client/SConscript')
+    SConscript(os.path.join('mpm_client', 'SConscript'))
 
-    SConscript('plugins/lifx_plugin/SConscript')
+    SConscript(os.path.join('plugins', 'lifx_plugin', 'SConscript'))
 
-    SConscript('plugins/hue_plugin/SConscript')
+    SConscript(os.path.join('plugins', 'hue_plugin', 'SConscript'))
 
-    SConscript('plugins/nest_plugin/SConscript')
+    SConscript(os.path.join('plugins', 'nest_plugin', 'SConscript'))
 
-    SConscript('plugins/lyric_plugin/SConscript')
+    SConscript(os.path.join('plugins', 'lyric_plugin', 'SConscript'))
+    
+    SConscript(os.path.join('plugins', 'zigbee_plugin', 'SConscript'))
diff --git a/bridging/plugins/zigbee_plugin/Device_Operations/Device_Operations.cpp b/bridging/plugins/zigbee_plugin/Device_Operations/Device_Operations.cpp
new file mode 100644
index 000000000..38cf4e446
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Device_Operations/Device_Operations.cpp
@@ -0,0 +1,787 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Device_Operations/Device_Operations.h"
+#include "../Zigbee_Devices/Zigbee_ColorDimmableLight.h"
+#include "../Zigbee_Devices/Zigbee_ColorTemperatureLight.h"
+#include "../Zigbee_Devices/Zigbee_DimmableLight.h"
+#include "../Zigbee_Devices/Zigbee_ExtendedColorLight.h"
+#include "../Zigbee_Devices/Zigbee_IASZone.h"
+#include "../Zigbee_Devices/Zigbee_MainsPowerOutlet.h"
+#include "../Zigbee_Devices/Zigbee_OccupancySensor.h"
+#include "../Zigbee_Devices/Zigbee_OnoffLight.h"
+#include "../Zigbee_Devices/Zigbee_OnoffOutput.h"
+#include "../Zigbee_Devices/Zigbee_SmartPlug.h"
+#include "../Zigbee_Devices/Zigbee_TemperatureSensor.h"
+#include "../Zigbee_Devices/Zigbee_Thermostat.h"
+#include "../Zigbee_Devices/Zigbee_WindowCoveringDevice.h"
+#include "experimental/ocrandom.h"
+
+using namespace sio;
+using namespace std;
+
+#define EUI64_STRING_LENGTH 16
+#define HEXADECIMAL_BUFFER_LENGTH 8
+#define PUREPAYLOAD_HEADER_LENGTH 8
+#define DATATYPE_START_INDEX_PUREPAYLOAD 6
+#define DATATYPE_LENGTH 2
+
+// mutex lock
+std::mutex _lock;
+
+ZBOperations::ZBOperations()
+{
+
+}
+
+void ZBOperations::bind_events()
+{
+    socket->on("devices",
+            sio::socket::event_listener_aux(
+                    [&](string const& /*name*/, message::ptr const& data, bool /*isAck*/, message::list &/*ack_resp*/)
+                    {
+                        if(this->sockTrans_flag == ZB_DISCOVERY)
+                        {
+                            devicesScanned.clear();
+
+                            uint32_t number_of_discovered_devices = data->get_map()["devices"]->get_vector().size();
+                            for (uint32_t i = 0; i < number_of_discovered_devices; i++)
+                            {
+                                ZigbeeDeviceSharedPtr d;
+
+                                // get and set device type of device
+                                std::string deviceType = data->get_map()["devices"]->get_vector().at(i)->get_map()["deviceType"]->get_string();
+                                if(deviceType == DEVICE_TYPE_ONOFF_LIGHT)
+                                {
+                                    d = std::make_shared< ZigbeeOnoffLight >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_COLOR_TEMPERATURE_LIGHT)
+                                {
+                                    d = std::make_shared< ZigbeeColorTemperatureLight >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_EXTENDED_COLOR_LIGHT)
+                                {
+                                    d = std::make_shared< ZigbeeExtendedColorLight >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_DIMMABLE_LIGHT)
+                                {
+                                    d = std::make_shared< ZigbeeDimmableLight >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_COLOR_DIMMABLE_LIGHT)
+                                {
+                                    d = std::make_shared< ZigbeeColorDimmableLight >();
+                                }
+                                else if(deviceType == DEVICE_TYPE_TEMPERATURE_SENSOR)
+                                {
+                                    d = std::make_shared< ZigbeeTemperatureSensor >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_THERMOSTAT)
+                                {
+                                    d = std::make_shared< ZigbeeThermostat >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_WINDOW_COVERING_DEVICE)
+                                {
+                                    d = std::make_shared< ZigbeeWindowCoveringDevice >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_SMART_PLUG)
+                                {
+                                    d = std::make_shared< ZigbeeSmartPlug >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_MAINS_POWER_OUTLET)
+                                {
+                                    d = std::make_shared< ZigbeeMainsPowerOutlet >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_ONOFF_OUTPUT)
+                                {
+                                    d = std::make_shared< ZigbeeOnoffOutput >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_IAS_ZONE)
+                                {
+                                    d = std::make_shared< ZigbeeIASZone >();
+                                }
+                                else if (deviceType == DEVICE_TYPE_OCCUPANCY_SENSOR)
+                                {
+                                    d = std::make_shared< ZigbeeOccupancySensor >();
+                                }
+                                d->setDeviceType(deviceType);
+
+                                // get and set node id of device
+                                std::string nodeId = data->get_map()["devices"]->get_vector().at(i)->get_map()["nodeId"]->get_string();
+                                d->setNodeId(nodeId);
+
+                                // get and set eui64 of device
+                                std::string eui64 = data->get_map()["devices"]->get_vector().at(i)->get_map()["deviceEndpoint"]->get_map()["eui64"]->get_string();
+                                d->setEui64(eui64.substr(strlen("0x")));
+
+                                devicesScanned.push_back(d);
+                            }
+
+                            this->sockTrans_flag = ZB_NONE;
+                            this->cv_discovery_finished.notify_all();
+                        }
+
+                        else if(this->sockTrans_flag == ZB_PERIODIC_UPDATE)
+                        {
+
+                        }
+                    }));
+
+    socket->on("gatewaylogstream",
+            sio::socket::event_listener_aux(
+                    [&](string const& /*name*/, message::ptr const& data, bool /*isAck*/,message::list /*&ack_resp*/)
+                    {
+                        _lock.lock();
+                        if(this->sockTrans_flag == ZB_GET)
+                        {
+                            std::string output = data->get_string();
+
+                            if(bufferFlag && buffer.find("CommandRelay: Command received from ") == std::string::npos)
+                            {
+
+                                // if "payload[" is not exist in the buffered string, add additional log stream string to the buffer string
+                                buffer += output;
+                            }
+
+                            if(!bufferFlag)
+                            {
+                                if(buffer.length() == 0 && output.find("payload[") != std::string::npos)
+                                {
+                                    buffer.clear();
+                                    buffer = output.substr(output.find("payload["));
+                                    bufferFlag = true;
+                                }
+                                else if(0 < buffer.length())
+                                {
+                                    if(buffer.find("payload[") != std::string::npos)
+                                    {
+                                        buffer = buffer.substr(buffer.find("payload["));
+                                        bufferFlag = true;
+                                    }
+                                    else
+                                    {
+                                        buffer.clear();
+                                    }
+                                }
+                            }
+
+                            if(bufferFlag && buffer.find("CommandRelay: Command received from ") != std::string::npos)
+                            {
+                                std::string eui64Str = buffer.substr(buffer.find("CommandRelay: Command received from ")+strlen("CommandRelay: Command received from "), EUI64_STRING_LENGTH);
+
+                                // in this case, there is full payload (e.g., payload[05 00 00 42 xx xx xx xx xx xx ])
+                                buffer = buffer.substr(buffer.find("["), buffer.find("]")-buffer.find("[")+1);
+                                std::string purePayload = "";
+                                for (uint32_t i = 0; i < buffer.length(); i++)
+                                {
+                                    // parse payload without blank and bracket
+                                    if(buffer[i] != ' ' && buffer[i] != '[' && buffer[i] != ']' && buffer[i] != '\t' && buffer[i] != '\n')
+                                    {
+                                        purePayload += buffer[i];
+                                    }
+                                }
+
+                                if(purePayload.length() < 10)
+                                {
+                                    bufferFlag = false;
+                                }
+                                else
+                                {
+                                    // check cluster id and attribute id
+                                    if(temp_clusterId == BASIC_CLUSTER &&
+                                            (temp_clusterId.substr(2) != purePayload.substr(2, 2) || temp_attributeId.substr(2) != purePayload.substr(0, 2)))
+                                    {
+                                        bufferFlag = false;
+                                    }
+                                    else
+                                    {
+                                        // check data type and get payload length and payload
+                                        std::string dataType = purePayload.substr(DATATYPE_START_INDEX_PUREPAYLOAD,
+                                                DATATYPE_LENGTH);
+                                        if (dataType == ZIGBEE_DATA_TYPE_BOOL || dataType == ZIGBEE_DATA_TYPE_MAP8
+                                                || dataType == ZIGBEE_DATA_TYPE_UNINT8 || dataType == ZIGBEE_DATA_TYPE_ENUM8)
+                                        {
+                                            HEX_result_length = ZIGBEE_DATA_OCTET_1_READ_LENGTH;
+                                            HEX_result[eui64Str] = purePayload.substr(PUREPAYLOAD_HEADER_LENGTH, HEX_result_length);
+                                        }
+                                        else if (dataType == ZIGBEE_DATA_TYPE_MAP16 || dataType == ZIGBEE_DATA_TYPE_UNINT16
+                                                || dataType == ZIGBEE_DATA_TYPE_SNINT16 || dataType == ZIGBEE_DATA_TYPE_ENUM16)
+                                        {
+                                            HEX_result_length = ZIGBEE_DATA_OCTET_2_READ_LENGTH;
+                                            HEX_result[eui64Str] = purePayload.substr(PUREPAYLOAD_HEADER_LENGTH, HEX_result_length);
+                                        }
+                                        else if (dataType == ZIGBEE_DATA_TYPE_EUI64)
+                                       {
+                                           HEX_result_length = ZIGBEE_DATA_OCTET_8_READ_LENGTH;
+                                           HEX_result[eui64Str] = purePayload.substr(PUREPAYLOAD_HEADER_LENGTH, HEX_result_length);
+                                       }
+                                        else if (dataType == ZIGBEE_DATA_TYPE_STRING)
+                                        {
+                                            int readLength;
+                                            int sFactor_FromBytes = 2;
+                                            stringstream str_readLength(purePayload.substr(PUREPAYLOAD_HEADER_LENGTH,
+                                                    ZIGBEE_DATA_TYPE_STRING_LENGTH_INFO_INCLUDED_LENGTH));
+
+                                            str_readLength >> std::hex >> readLength;
+                                            HEX_result_length = readLength * sFactor_FromBytes;
+                                            HEX_result[eui64Str] = purePayload.substr(PUREPAYLOAD_HEADER_LENGTH +
+                                                    ZIGBEE_DATA_TYPE_STRING_LENGTH_INFO_INCLUDED_LENGTH, HEX_result_length);
+                                        }
+
+                                        this->sockTrans_flag = ZB_NONE;
+                                    }
+                                }
+                            }
+                        }
+                        _lock.unlock();
+                    }));
+}
+
+/**
+ * get network security level of this Zigbee network. the value ranges (0x00~0x07)
+ */
+std::string ZBOperations::getNwkSecurityLevel()
+{
+
+    std::string securityLevel;
+    securityLevel.clear();
+
+    socket->on("networkSecurityLevel",
+            sio::socket::event_listener_aux(
+                    [&](string const& /*name*/, message::ptr const& data, bool /*isAck*/,message::list &/*ack_resp*/)
+                    {
+                        string output = data->get_string();
+                        securityLevel = output;
+                    }));
+
+    while (securityLevel.empty())
+    {
+        sleep(1);
+    }
+
+    socket->off("networkSecurityLevel");
+
+    return securityLevel;
+}
+
+/**
+ * sends ZCL command to the gateway
+ */
+void ZBOperations::sendReadCommand(std::string eui64, std::string clusterId,
+        std::string attributeId)
+{
+    _lock.lock();
+
+    if (eui64.length() > EUI64_STRING_LENGTH)
+    {
+        temp_eui64 = eui64.substr(strlen("0x"), EUI64_STRING_LENGTH);
+    }
+    else
+    {
+        temp_eui64 = eui64;
+    }
+
+    temp_endpoint = endpoint;
+    temp_clusterId = clusterId;
+    temp_attributeId = attributeId;
+
+    obj_array->get_vector().clear();
+    //set global direction to 0x0, this means data is from cluster to server
+    obj1->get_map()["command"] = string_message::create("zcl global direction 0x0");
+    //read data from specific cluster ID and attribute ID
+    obj2->get_map()["command"] = string_message::create(
+            "zcl global read " + temp_clusterId + " " + temp_attributeId);
+    //send command to specific eui and endpoint
+    obj3->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + temp_eui64 + "} " + temp_endpoint);
+
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    obj_array->get_vector().push_back(obj3);
+
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+void ZBOperations::sendWriteCommand(std::string eui64, std::string clusterId,
+        std::string attributeId, std::string dataType, std::string dataString)
+{
+    _lock.lock();
+
+    if (eui64.length() > EUI64_STRING_LENGTH)
+    {
+        temp_eui64 = eui64.substr(strlen("0x"), EUI64_STRING_LENGTH);
+    }
+    else
+    {
+        temp_eui64 = eui64;
+    }
+
+    temp_endpoint = endpoint;
+    temp_clusterId = clusterId;
+    temp_attributeId = attributeId;
+    temp_dataType=dataType;
+    temp_dataString=dataString;
+
+    obj_array->get_vector().clear();
+    //set global direction to 0x0, this means data is from cluster to server
+    obj1->get_map()["command"] = string_message::create("zcl global direction 0x1");
+    //read data from specific cluster ID and attribute ID
+    obj2->get_map()["command"] = string_message::create(
+            "zcl global write " + temp_clusterId + " " + temp_attributeId + " " + temp_dataType + " " + temp_dataString);
+    //send command to specific eui and endpoint
+    obj3->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + temp_eui64 + "} " + temp_endpoint);
+
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    obj_array->get_vector().push_back(obj3);
+
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+/**
+ *  get~ operations below get the data from specific cluster and attribute using ZCL command
+ *  @param[in] eui64    IEEE 64-bit address of zigbee device
+ *  @param[in] endpoint logical extension by the application (usually, 1)
+ */
+
+void ZBOperations::initToGet(std::string eui64)
+{
+    buffer.clear();
+    bufferFlag = false;
+    HEX_result[eui64].clear();
+    sockTrans_flag = ZB_GET;
+}
+
+bool ZBOperations::waitForTimeout(std::string eui64)
+{
+    time_t lockTime = time(0);
+
+    while (HEX_result[eui64].empty())
+    {
+        if ((time(0) - lockTime > TIMEOUT_LIMIT) || (sockTrans_flag == ZB_ERROR))
+        {
+            sockTrans_flag = ZB_NONE;
+            return true;
+        }
+    }
+
+    return false;
+}
+
+std::string ZBOperations::getZigbeeAttribute(std::string eui64, std::string cluster, std::string attribute)
+{
+
+    for (uint32_t i = 0; i < RETRIAL_LIMIT; i++)
+    {
+        initToGet(eui64);
+        sendReadCommand(eui64, cluster, attribute);
+        if (!waitForTimeout(eui64))
+        {
+            break;
+        }
+    }
+    return HEX_result[eui64];
+}
+
+/**
+ * generate random uuid using OCGenerateUuid for platform ID
+ */
+std::string ZBOperations::generatePlatformId()
+{
+    char uuidString[MAX_IDENTITY_SIZE] = { };
+    uint8_t uuid[UUID_IDENTITY_SIZE] = { };
+    OCGenerateUuid(uuid);
+    OCConvertUuidToString(uuid, uuidString);
+
+    return uuidString;
+}
+
+std::string ZBOperations::generateProtocolIndependentId()
+{
+    char uuidString[MAX_IDENTITY_SIZE] = { };
+    uint8_t uuid[UUID_IDENTITY_SIZE] = { };
+    OCGenerateUuid(uuid);
+    OCConvertUuidToString(uuid, uuidString);
+
+    return uuidString;
+}
+
+/**
+ * open socket connection to bridge server
+ */
+void ZBOperations::openSocket(std::string bridgeIpAddr, std::string port)
+{
+    connection_listener l(h);
+
+    h.set_open_listener(std::bind(&connection_listener::on_connected, &l));
+    _cond.notify_all();
+    connect_finish = true;
+    h.set_close_listener(std::bind(&connection_listener::on_close, &l, std::placeholders::_1));
+    h.set_fail_listener(std::bind(&connection_listener::on_fail, &l));
+    h.connect("http://" + bridgeIpAddr + ":" + port);
+
+    socket = h.socket();
+    bind_events();
+}
+
+/**
+ * create json object for generating ZCL command
+ */
+void ZBOperations::create_json_object()
+{
+    obj1 = object_message::create();
+    obj2 = object_message::create();
+    obj3 = object_message::create();
+    obj_array = array_message::create();
+}
+
+void ZBOperations::closeSocket()
+{
+    h.sync_close();
+    h.clear_con_listeners();
+}
+
+/**
+ * enable log stream in the zigbee gateway
+ */
+void ZBOperations::logstreamON()
+{
+    _lock.lock();
+    obj1->get_map()["type"] = string_message::create("setwebserverattribute");
+    obj1->get_map()["attribute"] = string_message::create("logStreaming");
+    obj1->get_map()["value"] = bool_message::create(true);
+    _lock.unlock();
+    socket->emit("servermessage", obj1);
+}
+
+/**
+ * request state of the zigbee gateway
+ */
+void ZBOperations::requestGatewayState()
+{
+    _lock.lock();
+    obj1->get_map()["type"] = string_message::create("requestgatewaystate");
+    _lock.unlock();
+    socket->emit("action", obj1);
+}
+
+void ZBOperations::setON(std::string eui64)
+{
+    _lock.lock();
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create("zcl on-off on");
+    obj2->get_map()["command"] = string_message::create(
+                  "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    socket->emit("command", obj_array);
+    _lock.unlock();
+}
+
+void ZBOperations::setOFF(std::string eui64)
+{
+    _lock.lock();
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create("zcl on-off off");
+    obj2->get_map()["command"] = string_message::create(
+                    "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    socket->emit("command", obj_array);
+    _lock.unlock();
+}
+
+void ZBOperations::moveToHueSat(std::string eui64, int hue, int sat, int time)
+{
+    _lock.lock();
+
+    char hue_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(hue_buf, "%x", hue);
+
+    char sat_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(sat_buf, "%x", sat);
+
+    char time_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(time_buf, "%x", time);
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create(
+            "zcl color-control movetohueandsat " + std::string(hue_buf) + " " + std::string(sat_buf)
+                    + " " + std::string(time_buf));
+    obj1->get_map()["postDelayMs"] = int_message::create(0);
+    obj2->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj2->get_map()["postDelayMs"] = int_message::create(0);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+void ZBOperations::moveToLevel(std::string eui64, int level, int time)
+{
+    _lock.lock();
+    char level_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(level_buf, "%x", level);
+
+    char time_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(time_buf, "%x", time);
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create(
+            "zcl level-control o-mv-to-level " + std::string(level_buf) + " "
+                    + std::string(time_buf));
+    obj1->get_map()["postDelayMs"] = int_message::create(0);
+    obj2->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj2->get_map()["postDelayMs"] = int_message::create(0);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+void ZBOperations::moveToColorTemp(std::string eui64, int colorTemp, int time)
+{
+    _lock.lock();
+
+    char colorTemp_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(colorTemp_buf, "%x", colorTemp);
+
+    char time_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(time_buf, "%x", time);
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create(
+            "zcl color-control movetocolortemp " + std::string(colorTemp_buf) + " "
+                    + std::string(time_buf));
+    obj1->get_map()["postDelayMs"] = int_message::create(0);
+    obj2->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj2->get_map()["postDelayMs"] = int_message::create(0);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+void ZBOperations::moveToColor(std::string eui64, int colorX, int colorY, int time)
+{
+    _lock.lock();
+
+    char colorX_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(colorX_buf, "%x", colorX);
+
+    char colorY_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(colorY_buf, "%x", colorY);
+
+    char time_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(time_buf, "%x", time);
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create(
+            "zcl color-control movetocolor " + std::string(colorX_buf) + " "
+                    +std::string(colorY_buf) + " " + std::string(time_buf));
+    obj1->get_map()["postDelayMs"] = int_message::create(0);
+    obj2->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj2->get_map()["postDelayMs"] = int_message::create(0);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+//window covering command
+void ZBOperations::setLiftAccelerationTime(std::string eui64, int Lift_AccelerationTime)
+{
+    char Lift_AccelerationTime_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(Lift_AccelerationTime_buf, "%x", Lift_AccelerationTime);
+
+    std::string clusterId = WINDOW_COVERING_CLUSTER;
+    std::string attributeId =ACCELERATION_TIME_LIFT;
+    std::string dataType = ZIGBEE_DATA_TYPE_UNINT16;
+
+    sendWriteCommand(eui64, clusterId, attributeId, dataType, std::string(Lift_AccelerationTime_buf));
+}
+
+void ZBOperations::setMode(std::string eui64, int mode)
+{
+    char mode_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(mode_buf, "%x", mode);
+
+    std::string clusterId = WINDOW_COVERING_CLUSTER;
+    std::string attributeId =MODE;
+    std::string dataType = ZIGBEE_DATA_TYPE_MAP8;
+
+    sendWriteCommand(eui64, clusterId, attributeId, dataType, std::string(mode_buf));
+}
+
+void ZBOperations::setLiftDecelerationTime(std::string eui64, int Lift_DecelerationTime)
+{
+    char Lift_DecelerationTime_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(Lift_DecelerationTime_buf, "%x", Lift_DecelerationTime);
+
+    std::string clusterId = WINDOW_COVERING_CLUSTER;
+    std::string attributeId = DECELERATION_TIME_LIFT;
+    std::string dataType = ZIGBEE_DATA_TYPE_UNINT16;
+
+    sendWriteCommand(eui64, clusterId, attributeId, dataType, std::string(Lift_DecelerationTime_buf));
+}
+
+void ZBOperations::setLiftVelocity(std::string eui64, int Lift_Velocity)
+{
+    char Lift_Velocity_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(Lift_Velocity_buf, "%x", Lift_Velocity);
+
+    std::string clusterId = WINDOW_COVERING_CLUSTER;
+    std::string attributeId =VELOCITY_LIFT;
+    std::string dataType = ZIGBEE_DATA_TYPE_UNINT16;
+
+    sendWriteCommand(eui64, clusterId, attributeId, dataType, std::string(Lift_Velocity_buf));
+}
+
+void ZBOperations::goToLiftPercentage(std::string eui64, int liftPercentage)
+{
+    _lock.lock();
+
+    char liftPercentage_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(liftPercentage_buf, "%x", liftPercentage);
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create(
+            "zcl window-covering go-to-lift-percentage " + std::string(liftPercentage_buf));
+    obj1->get_map()["postDelayMs"] = int_message::create(0);
+    obj2->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj2->get_map()["postDelayMs"] = int_message::create(0);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+void ZBOperations::goToLiftValue(std::string eui64, int liftValue)
+{
+    _lock.lock();
+
+    char liftValue_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(liftValue_buf, "%x", liftValue);
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create(
+            "zcl window-covering go-to-lift-value " + std::string(liftValue_buf));
+    obj1->get_map()["postDelayMs"] = int_message::create(0);
+    obj2->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj2->get_map()["postDelayMs"] = int_message::create(0);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+void ZBOperations::goToTiltPercentage(std::string eui64, int tiltPercentage)
+{
+    _lock.lock();
+
+    char tiltPercentage_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(tiltPercentage_buf, "%x", tiltPercentage);
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create(
+            "zcl window-covering go-to-tilt-percentage " + std::string(tiltPercentage_buf));
+    obj1->get_map()["postDelayMs"] = int_message::create(0);
+    obj2->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj2->get_map()["postDelayMs"] = int_message::create(0);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+void ZBOperations::goToTiltValue(std::string eui64, int tiltValue)
+{
+    _lock.lock();
+
+    char tiltValue_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(tiltValue_buf, "%x", tiltValue);
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create(
+            "zcl window-covering go-to-tilt-value " + std::string(tiltValue_buf));
+    obj1->get_map()["postDelayMs"] = int_message::create(0);
+    obj2->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj2->get_map()["postDelayMs"] = int_message::create(0);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+void ZBOperations::setPointRaiseLower(std::string eui64, int mode, int amount)
+{
+    _lock.lock();
+
+    char mode_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(mode_buf, "%x", mode);
+
+    char amount_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(amount_buf, "%x", amount);
+
+    obj_array->get_vector().clear();
+    obj1->get_map()["command"] = string_message::create(
+            "zcl tstat set " + std::string(mode_buf) + " "
+                    +std::string(amount_buf));
+    obj1->get_map()["postDelayMs"] = int_message::create(0);
+    obj2->get_map()["command"] = string_message::create(
+            "plugin device-table send {" + eui64 + "} " + endpoint);
+    obj2->get_map()["postDelayMs"] = int_message::create(0);
+    obj_array->get_vector().push_back(obj1);
+    obj_array->get_vector().push_back(obj2);
+    _lock.unlock();
+    socket->emit("command", obj_array);
+}
+
+void ZBOperations::setCurrentZoneSensitivityLevel(std::string eui64, int currentZoneSensitivityLevel)
+{
+    char currentZoneSensitivityLevel_buf[HEXADECIMAL_BUFFER_LENGTH];
+    sprintf(currentZoneSensitivityLevel_buf, "%x", currentZoneSensitivityLevel);
+
+    std::string clusterId = IAS_ZONE_CLUSTER;
+    std::string attributeId = CURRENT_ZONE_SENSITIVITY_LEVEL;
+    std::string dataType = ZIGBEE_DATA_TYPE_UNINT8;
+
+    sendWriteCommand(eui64, clusterId, attributeId, dataType, std::string(currentZoneSensitivityLevel_buf));
+}
+
+// Permit ZigBee devices to join network
+void ZBOperations::permitJoin(int delayMS)
+{
+    _lock.lock();
+    obj1->get_map()["type"] = string_message::create("permitjoinZB3OpenNetworkOnly");
+    obj1->get_map()["delayMS"] = int_message::create(delayMS);
+    _lock.unlock();
+    socket->emit("action", obj1);
+}
diff --git a/bridging/plugins/zigbee_plugin/Device_Operations/Device_Operations.h b/bridging/plugins/zigbee_plugin/Device_Operations/Device_Operations.h
new file mode 100644
index 000000000..1e27b569b
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Device_Operations/Device_Operations.h
@@ -0,0 +1,282 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef ZIGBEEOPERATIONS_H
+#define ZIGBEEOPERATIONS_H
+
+#include <pluginServer.h>
+#include <sio_client.h>
+#include <functional>
+#include <thread>
+#include <mutex>
+#include <condition_variable>
+#include "Zigbee_Device.h"
+#include <time.h>
+
+#include <string>
+#ifdef WIN32
+#include <stdio.h>
+#endif
+
+using namespace std;
+using namespace sio;
+
+const int TIMEOUT_LIMIT = 2;    // timeout limit for get information from web server in gateway
+const int RETRIAL_LIMIT = 2;    // maximum number of trials for get information from web server in gateway
+
+// Cluster IDs
+const std::string BASIC_CLUSTER = "0000";
+const std::string ON_OFF_CLUSTER = "0006";
+const std::string LEVEL_CONTROL_CLUSTER = "0008";
+const std::string COLOR_CONTROL_CLUSTER = "0300";
+const std::string TEMPERATURE_MEASUREMENT_CLUSTER = "0402";
+
+const std::string IAS_ZONE_CLUSTER = "0500";
+const std::string WINDOW_COVERING_CLUSTER = "0102";
+const std::string THERMOSTAT_CLUSTER = "0201";
+const std::string OCCUPANCY_SENSING_CLUSTER = "0406";
+
+// Attribute IDs of specific clusters
+const std::string ON_OFF_VALUE_ATTRIBUTE = "0000";
+const std::string BASIC_DATAMODEL_VERSION_ATTRIBUTE = "0000";
+const std::string BASIC_SOFTWARE_VERSION_ATTRIBUTE = "0001";
+const std::string BASIC_SPEC_VERSION_ATTRIBUTE = "0002";
+const std::string BASIC_HARDWARE_VERSION_ATTRIBUTE = "0003";
+const std::string BASIC_MANUFACTURER_ATTRIBUTE = "0004";
+const std::string BASIC_MODEL_NUMBER_ATTRIBUTE = "0005";
+const std::string BASIC_DATE_OF_MANUFACTURE_ATTRIBUTE = "0006";
+const std::string BASIC_LOCALIZATION_DESCRIPTION_ATTRIBUTE = "0010";
+
+// Attributes of color control cluster
+const std::string CURRENT_HUE_ATTRIBUTE = "0000";
+const std::string CURRENT_SATURATION_ATTRIBUTE = "0001";
+const std::string REMAINING_TIME_ATTRIBUTE = "0002";
+const std::string CURRENT_COLOR_X_ATTRIBUTE = "0003";
+const std::string CURRENT_COLOR_Y_ATTRIBUTE = "0004";
+const std::string COLOR_TEMPERATURE_MIRED_ATTRIBUTE = "0007";
+const std::string COLOR_TEMP_PHYSICAL_MIN_MIRED_ATTRIBUTE = "400b";
+const std::string COLOR_TEMP_PHYSICAL_MAX_MIRED_ATTRIBUTE = "400c";
+
+// Attributes of IAS zone cluster
+const std::string ZONE_STATE_ATTRIBUTE = "0000";
+const std::string ZONE_TYPE_ATTRIBUTE = "0001";
+const std::string ZONE_STATUS_ATTRIBUTE = "0002";
+const std::string IAS_CIE_ADDRESS_ATTRIBUTE = "0010";
+const std::string ZONE_ID_ATTRIBUTE = "0011";
+const std::string NUMBER_OF_ZONES_SENSITIVITY_LEVEL_SUPPORTED_ATTRIBUTE = "0012";
+const std::string CURRENT_ZONE_SENSITIVITY_LEVEL_ATTRIBUTE = "0013";
+
+// Attribute of level control cluster
+const std::string CURRENT_LEVEL_ATTRIBUTE = "0000";
+
+// Attributes of temperature measurement cluster
+const std::string TEMPERATURE_MEASURED_VALUE_ATTRIBUTE = "0000";
+const std::string TEMPERATURE_MIN_MEASURED_VALUE_ATTRIBUTE = "0001";
+const std::string TEMPERATURE_MAX_MEASURED_VALUE_ATTRIBUTE = "0002";
+const std::string TOLERANCE_ATTRIBUTE = "0003";
+
+// Attributes of thermostat cluster
+const std::string LOCAL_TEMPERATURE_INFORMATION_ATTRIBUTE = "0000";
+const std::string OCCUPIED_COOLING_SETPOINT = "0011";
+const std::string OCCUPIED_HEATING_SETPOINT = "0012";
+
+// Attribute of occupancy sensing cluster
+const std::string OCCUPANCY_ATTRIBUTE = "0000";
+
+//on testing Attribute IDs window covering
+const std::string ACCELERATION_TIME_LIFT = "0105";
+const std::string MODE = "0107";
+const std::string DECELERATION_TIME_LIFT = "0106";
+const std::string VELOCITY_LIFT = "0104";
+const std::string WINDOW_COVERING_TYPE = "0000";
+const std::string CONFIG_STATUS = "0007";
+const std::string CURRENT_POSITION_LIFT_PERCENTAGE = "0008";
+const std::string CURRENT_POSITION_LIFT = "0003";
+const std::string INSTALLED_OPEN_LIMIT_LIFT = "0100";
+const std::string INSTALLED_CLOSED_LIMIT_LIFT = "0101";
+const std::string CURRENT_POSITION_TILT_PERCENTAGE = "0009";
+const std::string CURRENT_POSITION_TILT = "0004";
+const std::string INSTALLED_OPEN_LIMIT_TILT = "0102";
+const std::string INSTALLED_CLOSED_LIMIT_TILT = "0103";
+
+//on testing attribute IDs window IAS zone
+const std::string CURRENT_ZONE_SENSITIVITY_LEVEL = "0013";
+const std::string NUMBER_OF_ZONE_SENSITIVITY_LEVEL_SUPPORTED = "0012";
+const std::string ZONE_ID = "0011";
+const std::string ZONE_TYPE = "0001";
+const std::string ZONE_STATE = "0000";
+const std::string IAS_CIE_ADDRESS = "0010";
+const std::string ZONE_STATUS = "0002";
+
+// ZCL data type definition
+const std::string ZIGBEE_DATA_TYPE_BOOL = "10"; // e.g., ONOFF
+const std::string ZIGBEE_DATA_TYPE_MAP8 = "18";
+const std::string ZIGBEE_DATA_TYPE_MAP16 = "19";
+const std::string ZIGBEE_DATA_TYPE_UNINT8 = "20"; // e.g., Software version, Hardware version, Spec Version
+const std::string ZIGBEE_DATA_TYPE_UNINT16 = "21";
+const std::string ZIGBEE_DATA_TYPE_SNINT16 = "29"; // e.g., Temperature sensor
+const std::string ZIGBEE_DATA_TYPE_ENUM8 = "30";
+const std::string ZIGBEE_DATA_TYPE_ENUM16 = "31";
+const std::string ZIGBEE_DATA_TYPE_STRING = "42"; // e.g., Manufacturer name, Model number
+const std::string ZIGBEE_DATA_TYPE_EUI64 = "f0";
+
+// Data length of each data types
+const int ZIGBEE_DATA_OCTET_1_READ_LENGTH = 2;
+const int ZIGBEE_DATA_OCTET_2_READ_LENGTH = 4;
+const int ZIGBEE_DATA_OCTET_8_READ_LENGTH = 16;
+const int ZIGBEE_DATA_TYPE_STRING_LENGTH_INFO_INCLUDED_LENGTH = 2;
+
+// Default endpoint
+const std::string endpoint = "0x1";
+
+typedef enum
+{
+    ZB_DISCOVERY, ZB_PERIODIC_UPDATE, ZB_SET, ZB_GET, ZB_NONE, ZB_ERROR
+} SOCKET_TRANSITION_STATE;
+
+class ZigbeeDevice;
+
+class ZBOperations
+{
+public:
+    std::condition_variable_any _cond;
+    bool connect_finish = false;
+
+    sio::client h;
+    sio::socket::ptr socket;
+    message::ptr obj1;
+    message::ptr obj2;
+    message::ptr obj3;
+    message::ptr obj_array;
+
+    std::string temp_eui64;
+    std::string temp_endpoint;
+
+    std::string temp_clusterId;
+    std::string temp_attributeId;
+
+    std::string temp_dataType;
+    std::string temp_dataString;
+
+    std::map< std::string, std::string > HEX_result;
+    int HEX_result_length;
+
+    bool bufferFlag;
+    std::string buffer;
+
+    int start_time;
+    int end_time;
+
+    SOCKET_TRANSITION_STATE sockTrans_flag;
+
+    std::mutex mutex_discovery, mutex_get;
+    std::condition_variable_any cv_discovery_finished, cv_get_finished;
+    std::vector< std::shared_ptr< ZigbeeDevice > > devicesScanned;
+
+//public:
+    void bind_events();
+    std::string getNwkSecurityLevel();
+    void openSocket(std::string bridgeIpAddr, std::string port);
+    void create_json_object();
+    void closeSocket();
+
+//public:
+    ZBOperations();
+
+    void logstreamON();
+    void requestGatewayState();
+    void setON(std::string eui64);
+    void setOFF(std::string eui64);
+
+    void moveToHueSat(std::string eui64, int hue, int sat, int time);
+    void moveToLevel(std::string eui64, int level, int time);
+    void moveToColorTemp(std::string eui64, int colorTemp, int time);
+    void moveToColor(std::string eui64, int colorX, int colorY, int time);
+    void setPointRaiseLower(std::string eui64, int mode, int amount);
+
+    //window covering command
+    void setLiftAccelerationTime(std::string eui64, int Lift_AccelerationTime);
+    void setMode(std::string eui64, int mode);
+    void setLiftDecelerationTime(std::string eui64, int Lift_DecelerationTime);
+    void setLiftVelocity(std::string eui64, int Lift_Velocity);
+    void goToLiftPercentage(std::string eui64, int liftPercentage);
+    void goToLiftValue(std::string eui64, int liftValue);
+    void goToTiltPercentage(std::string eui64, int tiltPercentage);
+    void goToTiltValue(std::string eui64, int tiltValue);
+
+    //IAS zone command
+    void setCurrentZoneSensitivityLevel(std::string eui64, int currentZoneSensitivityLevel);
+
+    void permitJoin(int delayMS);
+    void getOnOff(std::string eui64);
+    void getMeasuredTemperature(std::string eui64);
+    void getMeasuredMinTemperature(std::string eui64);
+    void getMeasuredMaxTemperature(std::string eui64);
+    void getTolerance(std::string eui64);
+
+    // Initialize internal variables for getting by ZB command via server in gateway
+    void initToGet(std::string eui64);
+
+    // Check the getting time is over or not
+    bool waitForTimeout(std::string eui64);
+
+    // get Zigbee attribute
+    std::string getZigbeeAttribute(std::string eui64, std::string cluster, std::string attribute);
+
+    std::string generatePlatformId(void);
+    std::string generateProtocolIndependentId(void);
+
+    void sendReadCommand(std::string eui64, std::string clusterId,
+            std::string attributeId);
+    //data write need to be tested
+    void sendWriteCommand(std::string eui64, std::string clusterId,
+            std::string attributeId, std::string dataType, std::string dataString);
+};
+typedef std::shared_ptr< ZBOperations > ZBOperationsSharedPtr;
+
+class connection_listener
+{
+    sio::client &handler;
+
+public:
+
+    connection_listener(sio::client& h) :
+            handler(h)
+    {
+    }
+
+    void on_connected()
+    {
+    }
+
+    void on_close(sio::client::close_reason const& reason)
+    {
+        std::cout << "Socket closed: " << reason << std::endl;
+        exit(0);
+    }
+
+    void on_fail()
+    {
+        std::cout << "Socket failed " << std::endl;
+        exit(0);
+    }
+};
+
+#endif
diff --git a/bridging/plugins/zigbee_plugin/README b/bridging/plugins/zigbee_plugin/README
new file mode 100644
index 000000000..48db56bd0
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/README
@@ -0,0 +1,51 @@
+1. General
+	This plugin is tested on SILICON LABS zigbee Wi-Fi/Ethernet gateway (RD-0001-0201, RD-0002-0201).
+	
+2. Setting IP address for the gateway
+	Change the IP address setting according to your gateway network information as follows: 
+		ZIGBEE_GATEWAY_IP = "your gateway ip address (e.g., 192.168.0.18)";  	// Zigbee_Resource.h (line 30) 
+	
+3. Setting network addess for cloud option (if WITH_CLOUD=yes)
+	Change the IP address setting according to network information of cloud server as follows: 	
+		CLOUD_SERVER_IP = "your cloud server ip address (e.g., 192.168.0.66)"	// cloud/Zigbee_Cloud.h (line 19)
+	
+4. Build
+	Build without cloud 
+		$ sudo scons bridging/  
+	Build with cloud:	    
+	    $ sudo scons bridging/ RD_MODE=all SECURED=1 WITH_TCP=yes RELEASE=yes TARGET_TRANSPORT=IP WITH_CLOUD=yes WITH_MQ=PUB,SUB J=2
+	    
+5. How can I start this plugin?
+
+    Use either binary executable 'mpm_sample_client' to load and
+    control this plugin.
+
+    More information on these clients can be found at:
+    <iotivity>/bridging/src/mpm_client/README.
+    
+6. Cloud server setting (WITH_CLOUD=yes):
+		
+	More information on running cloud servers (resource directory, account server, message queue, interface servers) can be found at:
+		<iotivity>/cloud/resourcedirectory/src/README
+		<iotivity>/cloud/account/src/README
+		<iotivity>/cloud/messagequeue/src/README
+		<iotivity>/cloud/interface/src/README
+		
+7. Authcode generation (WITH_CLOUD=yes):
+	To register device, you need 'Auth Code' provided by OAuth 2 provider like Facebook, Google or Github. 
+	IoTivity Cloud project includes 'GitHub' account plugin. To get a 'Auth Code' from 'GitHub' you can make request to below URL:	
+ 	https://github.com/login?return_to=%2Flogin%2Foauth%2Fauthorize%3Fclient_id%3Dea9c18f540323b0213d0%26redirect_uri%3Dhttp%253A%252F%252Fwww.example.com%252Foauth_callback%252F
+ 	
+ 	Once you signed-in, you'll be redirected to other web page include 'Auth Code' in the redirected URL: 	
+ 	http://www.example.com/oauth_callback/?code=a459ed1102a9a18b9ad7
+ 	
+ 	The 'code' part (a459ed1102a9a18b9ad7) in the URI is the 'Auth Code' from 'GitHub'.
+	This code is used to register and sign-in device.
+	Copy this code and paste to "input auth code : " message prompt.
+	
+	This code should be generated each time when each device is registered.  
+
+For proper documentation of this plugin, Mini Plugin
+Manager, the client applications, and other plugins, please
+perform a query on the "Bridging" or "Bridging Project" at
+wiki.iotivity.org.
diff --git a/bridging/plugins/zigbee_plugin/SConscript b/bridging/plugins/zigbee_plugin/SConscript
new file mode 100644
index 000000000..61202edce
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/SConscript
@@ -0,0 +1,132 @@
+#******************************************************************
+#
+# Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#####
+# zigbee Plugin build script
+##
+
+import os
+import os.path
+
+Import('env')
+
+target_os = env.get('TARGET_OS')
+src_dir = env.get('SRC_DIR')
+bridging_path = os.path.join(src_dir, 'bridging')
+
+zigbee_env = env.Clone()
+
+print("Reading zigbee Plugin script")
+def maskFlags(flags):
+    flags = [flags.replace('-Wl,--no-undefined', '') for flags in flags]
+    return flags
+
+
+######################################################################
+# Build flags
+######################################################################
+
+zigbee_env.PrependUnique(CPPPATH=[
+    os.path.join(src_dir, 'resource', 'c_common', 'oic_malloc', 'include'),
+    os.path.join(src_dir, 'resource', 'c_common', 'oic_string', 'include'),
+    os.path.join(src_dir, 'resource', 'c_common'),
+    os.path.join(src_dir, 'resource', 'oc_logger', 'include'),
+    os.path.join(src_dir, 'resource', 'csdk', 'logger', 'include'),
+    os.path.join(src_dir, 'resource', 'csdk', 'include'),
+    os.path.join(src_dir, 'resource', 'csdk', 'stack', 'include'),
+    os.path.join(src_dir, 'resource', 'csdk', 'stack', 'include', 'internal'),
+    os.path.join(src_dir, 'resource', 'csdk', 'security', 'include', 'internal'),
+    os.path.join(src_dir, 'resource', 'csdk', 'security', 'include', 'experimental'),
+    os.path.join(src_dir, 'resource', 'csdk', 'connectivity', 'api'),
+    os.path.join(src_dir, 'resource', 'include'),
+    os.path.join(src_dir, 'extlibs', 'cjson'),
+    os.path.join(src_dir, 'extlibs', 'tinycbor', 'src'),
+    os.path.join(src_dir, 'extlibs', 'rapidjson','rapidjson', 'include'), 						  # added
+    os.path.join(src_dir, 'extlibs', 'websocketpp'),											  # added
+    os.path.join(src_dir, 'extlibs', 'socket'),												      # added
+    os.path.join(src_dir, 'resource', 'csdk','resource-directory','include'),					  # added
+    os.path.join(src_dir, 'resource', 'csdk', 'security', 'provisioning', 'include', 'cloud'), 	  # added
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin','cloud'), 							  # added
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin','local_RD'), 						  # added
+])
+
+zigbee_env.AppendUnique(CPPPATH=[
+    os.path.join(bridging_path, 'include'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin'),    
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin','Zigbee_Devices'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin','Device_Operations'),
+])
+
+compiler = zigbee_env.get('CXX')
+if 'g++' in compiler:
+    zigbee_env.AppendUnique(CXXFLAGS=['-std=c++0x', '-Wall'])
+
+zigbee_env['LINKFLAGS'] = maskFlags(env['LINKFLAGS'])
+zigbee_env.AppendUnique(LINKFLAGS=['-Wl,--allow-shlib-undefined'])
+zigbee_env.AppendUnique(LINKFLAGS=[
+    '-Wl,--whole-archive',
+    zigbee_env.get('BUILD_DIR') + 'libmpmcommon.a', '-Wl,-no-whole-archive'
+])
+
+zigbee_env.AppendUnique(
+LIBS=['resource_directory','oc','m', 'cjson', 'octbstack', 'ocsrm', 'connectivity_abstraction',
+'coap', 'curl','boost_system','boost_date_time','pthread'] 
+)
+
+#added
+#####################################################################
+# Source files and Target(s)
+######################################################################
+zigbee_src = [
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Device_Operations', 'Device_Operations.cpp'),    	   
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_OnoffLight.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_ColorTemperatureLight.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_ExtendedColorLight.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_DimmableLight.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_ColorDimmableLight.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_TemperatureSensor.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_Thermostat.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_WindowCoveringDevice.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_SmartPlug.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_MainsPowerOutlet.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_OnoffOutput.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_IASZone.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Devices', 'Zigbee_OccupancySensor.cpp'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Resource.cpp'),    
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'Zigbee_Device.cpp'),
+	os.path.join(src_dir, 'extlibs', 'socket','sio_client.cpp'),
+	os.path.join(src_dir, 'extlibs', 'socket','sio_socket.cpp'),
+	os.path.join(src_dir, 'extlibs', 'socket','sio_client_impl.cpp'),
+	os.path.join(src_dir, 'extlibs', 'socket','sio_packet.cpp'),
+]
+
+if env.get('WITH_CLOUD') == 1 :
+    zigbee_src += [os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'cloud', 'Zigbee_Cloud.cpp')] # added
+
+cbor_env = zigbee_env.Clone()
+cbor_output_dir = env.get('BUILD_DIR') + '/bridging/mpm_client/'
+cbor = cbor_env.ScanJSON()
+cbor_env.Install(cbor_output_dir, cbor)
+
+zigbee_env.AppendUnique(zigbee_SRC=zigbee_src)
+zigbeelib = zigbee_env.SharedLibrary('zigbeeplugin', zigbee_env.get('zigbee_SRC'))
+zigbee_env.InstallTarget(zigbeelib, 'zigbeeplugin')
+zigbee_env.UserInstallTargetLib(zigbeelib, 'zigbeeplugin')
+
+SConscript(os.path.join(bridging_path, 'plugins', 'zigbee_plugin', 'virtual_server', 'SConscript'),)
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Device.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Device.cpp
new file mode 100644
index 000000000..e0fb65ec6
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Device.cpp
@@ -0,0 +1,1027 @@
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+
+#include "Zigbee_Device.h"
+
+ZigbeeDevice::ZigbeeDevice()
+{
+}
+
+MPMResult ZigbeeDevice::discoverZigbeeDevices(std::vector< ZigbeeDeviceSharedPtr > &devices,
+        ZBOperationsSharedPtr ZBO)
+{
+    ZBO->sockTrans_flag = ZB_DISCOVERY;
+
+    ZBO->requestGatewayState();
+
+    std::unique_lock < mutex > lock(ZBO->mutex_discovery);
+    ZBO->cv_discovery_finished.wait(lock);
+
+    for (uint32_t i = 0; i < ZBO->devicesScanned.size(); ++i)
+    {
+        ZigbeeDeviceSharedPtr device = ZBO->devicesScanned[i];
+        device->setModelNumber(device->getModelNumberByZBC(device, ZBO));
+        device->setName(device->getNameByZBC(device, ZBO));
+        device->setSoftwareVersion(device->getSoftwareVersionByZBC(device, ZBO));
+        device->setManufacturerName(device->getManufacturerNameByZBC(device, ZBO));
+        device->setPlatformId(device->getPlatformIdByZBC(device, ZBO));
+        device->setProtocolIndependentId(device->getProtocolIndependentIdByZBC(device, ZBO));
+        device->setHardwareVersion(device->getHardwareVersionByZBC(device, ZBO));
+
+        device->PrintCoreResource();
+    }
+
+    devices = ZBO->devicesScanned;
+
+    return MPM_RESULT_OK;
+}
+
+std::string ZigbeeDevice::getNameByZBC(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr /*ZBO*/)
+{
+    return device->getModelNumber();
+}
+
+std::string ZigbeeDevice::getSoftwareVersionByZBC(ZigbeeDeviceSharedPtr device,
+        ZBOperationsSharedPtr ZBO)
+{
+    return ZBO->getZigbeeAttribute(device->getEui64(), BASIC_CLUSTER, BASIC_SOFTWARE_VERSION_ATTRIBUTE);
+}
+
+std::string ZigbeeDevice::getManufacturerNameByZBC(ZigbeeDeviceSharedPtr device,
+        ZBOperationsSharedPtr ZBO)
+{
+    return ZBO->getZigbeeAttribute(device->getEui64(), BASIC_CLUSTER, BASIC_MANUFACTURER_ATTRIBUTE);
+}
+
+std::string ZigbeeDevice::getModelNumberByZBC(ZigbeeDeviceSharedPtr device,
+        ZBOperationsSharedPtr ZBO)
+{
+    return ZBO->getZigbeeAttribute(device->getEui64(), BASIC_CLUSTER, BASIC_MODEL_NUMBER_ATTRIBUTE);
+}
+
+std::string ZigbeeDevice::getProtocolIndependentIdByZBC(ZigbeeDeviceSharedPtr /*device*/,
+        ZBOperationsSharedPtr ZBO)
+{
+    return ZBO->generateProtocolIndependentId();
+}
+
+std::string ZigbeeDevice::getPlatformIdByZBC(ZigbeeDeviceSharedPtr, ZBOperationsSharedPtr ZBO)
+{
+    return ZBO->generatePlatformId();
+}
+
+std::string ZigbeeDevice::getHardwareVersionByZBC(ZigbeeDeviceSharedPtr device,
+        ZBOperationsSharedPtr ZBO)
+{
+    return ZBO->getZigbeeAttribute(device->getEui64(), BASIC_CLUSTER, BASIC_HARDWARE_VERSION_ATTRIBUTE);
+}
+
+// get light state by ZB command via server in gateway
+ZigbeeDevice::onoff_light_state ZigbeeDevice::getOnoffLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    ZigbeeDevice::onoff_light_state state;
+
+    // value
+    state.value = ZBO->getZigbeeAttribute(device->getEui64(), ON_OFF_CLUSTER, ON_OFF_VALUE_ATTRIBUTE) == "01" ? true : false;
+
+    return state;
+}
+
+ZigbeeDevice::color_temperature_light_state ZigbeeDevice::getColorTemperatureLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string uri)
+{
+    ZigbeeDevice::color_temperature_light_state state;
+
+    if(uri == BINARY_SWITCH_RELATIVE_URI)
+    {
+        // value
+        state.value = ZBO->getZigbeeAttribute(device->getEui64(), ON_OFF_CLUSTER, ON_OFF_VALUE_ATTRIBUTE) == "01" ? true : false;
+    }
+    else if(uri == DIMMING_RELATIVE_URI)
+    {
+        // dimmingSetting
+        int currentlevel = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), LEVEL_CONTROL_CLUSTER, CURRENT_LEVEL_ATTRIBUTE));
+        state.dimmingSetting = (int)(((double)currentlevel/254.0)*100.0 + 0.5);
+    }
+    else if(uri == COLOR_HS_RELATIVE_URI)
+    {
+        // hue
+        int currenthue = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_HUE_ATTRIBUTE));
+        state.hue = ((double)currenthue/254.0)*360.0;
+
+        // saturation
+        int currentsaturation = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_SATURATION_ATTRIBUTE));
+        state.saturation = currentsaturation;
+    }
+    else if(uri == COLOR_CSC_RELATIVE_URI)
+    {
+        // csc[0]
+        int currentX = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_COLOR_X_ATTRIBUTE));
+        state.csc[0] = (double)(currentX)/65536.0;
+
+        // csc[1]
+        int currentY = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_COLOR_Y_ATTRIBUTE));
+        state.csc[1] = (double)(currentY)/65536.0;
+    }
+    else if(uri == COLOR_CT_RELATIVE_URI)
+    {
+        // ct
+        int colortemperaturemired = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, COLOR_TEMPERATURE_MIRED_ATTRIBUTE));
+        state.ct = colortemperaturemired;
+
+        // range[0]
+        int colorphysicalmin = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, COLOR_TEMP_PHYSICAL_MIN_MIRED_ATTRIBUTE));
+        state.range[0] = colorphysicalmin;
+
+        // range[1]
+        int colorphysicalmax = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, COLOR_TEMP_PHYSICAL_MAX_MIRED_ATTRIBUTE));
+        state.range[0] = colorphysicalmax;
+    }
+
+    return state;
+}
+
+ZigbeeDevice::extended_color_light_state ZigbeeDevice::getExtendedColorLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string uri)
+{
+    ZigbeeDevice::extended_color_light_state state;
+
+    if(uri == BINARY_SWITCH_RELATIVE_URI)
+    {
+        // value
+        state.value = ZBO->getZigbeeAttribute(device->getEui64(), ON_OFF_CLUSTER, ON_OFF_VALUE_ATTRIBUTE) == "01" ? true : false;
+    }
+    else if(uri == DIMMING_RELATIVE_URI)
+    {
+        // dimmingSetting
+        int currentlevel = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), LEVEL_CONTROL_CLUSTER, CURRENT_LEVEL_ATTRIBUTE));
+        state.dimmingSetting = (int)(((double)currentlevel/254.0)*100.0 + 0.5);
+    }
+    else if(uri == COLOR_HS_RELATIVE_URI)
+    {
+        // hue
+        int currenthue = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_HUE_ATTRIBUTE));
+        state.hue = ((double)currenthue/254.0)*360.0;
+
+        // saturation
+        int currentsaturation = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_SATURATION_ATTRIBUTE));
+        state.saturation = currentsaturation;
+    }
+    else if(uri == COLOR_CSC_RELATIVE_URI)
+    {
+        // csc[0]
+        int currentX = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_COLOR_X_ATTRIBUTE));
+        state.csc[0] = (double)(currentX)/65536.0;
+
+        // csc[1]
+        int currentY = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_COLOR_Y_ATTRIBUTE));
+        state.csc[1] = (double)(currentY)/65536.0;
+    }
+    else if(uri == COLOR_CT_RELATIVE_URI)
+    {
+        // ct
+        int colortemperaturemired = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, COLOR_TEMPERATURE_MIRED_ATTRIBUTE));
+        state.ct = colortemperaturemired;
+
+        // range[0]
+        int colorphysicalmin = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, COLOR_TEMP_PHYSICAL_MIN_MIRED_ATTRIBUTE));
+        state.range[0] = colorphysicalmin;
+
+        // range[1]
+        int colorphysicalmax = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, COLOR_TEMP_PHYSICAL_MAX_MIRED_ATTRIBUTE));
+        state.range[0] = colorphysicalmax;
+    }
+
+    return state;
+}
+
+ZigbeeDevice::dimmable_light_state ZigbeeDevice::getDimmableLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string uri)
+{
+    ZigbeeDevice::dimmable_light_state state;
+
+    if(uri == BINARY_SWITCH_RELATIVE_URI)
+    {
+        // value
+        state.value = ZBO->getZigbeeAttribute(device->getEui64(), ON_OFF_CLUSTER, ON_OFF_VALUE_ATTRIBUTE) == "01" ? true : false;
+    }
+    else if(uri == DIMMING_RELATIVE_URI)
+    {
+        // dimmingSetting
+        int currentlevel = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), LEVEL_CONTROL_CLUSTER, CURRENT_LEVEL_ATTRIBUTE));
+        state.dimmingSetting = (int)(((double)currentlevel/254.0)*100.0 + 0.5);
+    }
+
+    return state;
+}
+
+ZigbeeDevice::color_dimmable_light_state ZigbeeDevice::getColorDimmableLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string uri)
+{
+    ZigbeeDevice::color_dimmable_light_state state;
+
+    if(uri == BINARY_SWITCH_RELATIVE_URI)
+    {
+        // value
+        state.value = ZBO->getZigbeeAttribute(device->getEui64(), ON_OFF_CLUSTER, ON_OFF_VALUE_ATTRIBUTE) == "01" ? true : false;
+    }
+    else if(uri == DIMMING_RELATIVE_URI)
+    {
+        // dimmingSetting
+        int currentlevel = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), LEVEL_CONTROL_CLUSTER, CURRENT_LEVEL_ATTRIBUTE));
+        state.dimmingSetting = (int)(((double)currentlevel/254.0)*100.0 + 0.5);
+    }
+    else if(uri == COLOR_HS_RELATIVE_URI)
+    {
+        // hue
+        int currenthue = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_HUE_ATTRIBUTE));
+        state.hue = ((double)currenthue/254.0)*360.0;
+
+        // saturation
+        int currentsaturation = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_SATURATION_ATTRIBUTE));
+        state.saturation = currentsaturation;
+    }
+    else if(uri == COLOR_CSC_RELATIVE_URI)
+    {
+        // csc[0]
+        int currentX = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_COLOR_X_ATTRIBUTE));
+        state.csc[0] = (double)(currentX)/65536.0;
+
+        // csc[1]
+        int currentY = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, CURRENT_COLOR_Y_ATTRIBUTE));
+        state.csc[1] = (double)(currentY)/65536.0;
+    }
+    else if(uri == COLOR_CT_RELATIVE_URI)
+    {
+        // ct
+        int colortemperaturemired = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, COLOR_TEMPERATURE_MIRED_ATTRIBUTE));
+        state.ct = colortemperaturemired;
+
+        // range[0]
+        int colorphysicalmin = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, COLOR_TEMP_PHYSICAL_MIN_MIRED_ATTRIBUTE));
+        state.range[0] = colorphysicalmin;
+
+        // range[1]
+        int colorphysicalmax = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), COLOR_CONTROL_CLUSTER, COLOR_TEMP_PHYSICAL_MAX_MIRED_ATTRIBUTE));
+        state.range[0] = colorphysicalmax;
+    }
+
+    return state;
+}
+
+// get temperature sensor state by ZB command via server in gateway
+ZigbeeDevice::temperature_sensor_state ZigbeeDevice::getTemperatureSensorState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    ZigbeeDevice::temperature_sensor_state state;
+
+    // temperature
+    int measuredValue = getINT16(ZBO->getZigbeeAttribute(device->getEui64(), TEMPERATURE_MEASUREMENT_CLUSTER, TEMPERATURE_MEASURED_VALUE_ATTRIBUTE));
+    state.temperature = (double)(measuredValue)/100.0;
+    state.units = "C";
+
+    // precision
+    int tolerance = getINT16(ZBO->getZigbeeAttribute(device->getEui64(), TEMPERATURE_MEASUREMENT_CLUSTER, TOLERANCE_ATTRIBUTE));
+    state.precision = (double)(tolerance)/100.0;
+
+    // range[0]
+    int minMeasuredValue = getINT16(ZBO->getZigbeeAttribute(device->getEui64(), TEMPERATURE_MEASUREMENT_CLUSTER, TEMPERATURE_MIN_MEASURED_VALUE_ATTRIBUTE));
+    state.range[0] = (double)(minMeasuredValue)/100.0;
+
+    // range[1]
+    int maxMeasuredValue = getINT16(ZBO->getZigbeeAttribute(device->getEui64(), TEMPERATURE_MEASUREMENT_CLUSTER, TEMPERATURE_MAX_MEASURED_VALUE_ATTRIBUTE));
+    state.range[1] = (double)(maxMeasuredValue)/100.0;
+
+    return state;
+}
+
+ZigbeeDevice::thermostat_state ZigbeeDevice::getThermostatState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string cluster)
+{
+    ZigbeeDevice::thermostat_state state;
+
+    if(cluster == "CurrentTemperature")
+    {
+        int localTemperature = getINT16(ZBO->getZigbeeAttribute(device->getEui64(), THERMOSTAT_CLUSTER, LOCAL_TEMPERATURE_INFORMATION_ATTRIBUTE));
+        state.temperature = (double)(localTemperature)/100.0;
+    }
+    else if(cluster == "Cool")
+    {
+        int occupiedCoolingSetPoint = getINT16(ZBO->getZigbeeAttribute(device->getEui64(), THERMOSTAT_CLUSTER, OCCUPIED_COOLING_SETPOINT));
+        state.temperature = (double)(occupiedCoolingSetPoint)/100.0;
+    }
+    else if(cluster == "Heat")
+    {
+        int occupiedHeatingSetPoint = getINT16(ZBO->getZigbeeAttribute(device->getEui64(), THERMOSTAT_CLUSTER, OCCUPIED_HEATING_SETPOINT));
+        state.temperature = (double)(occupiedHeatingSetPoint)/100.0;
+    }
+    state.units = "C";
+
+    return state;
+}
+
+ZigbeeDevice::window_covering_device_state ZigbeeDevice::getWindowCoveringDeviceState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string cluster)
+{
+    ZigbeeDevice::window_covering_device_state state;
+
+    if(cluster == "Configuration")
+    {
+        // windowcoveringtype
+        int windowCoveringType = getENUM8(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, WINDOW_COVERING_TYPE));;
+        switch(windowCoveringType)
+        {
+            case 0: // 0x00
+                state.windowcoveringtype = "Rollershade.";
+                break;
+
+            case 1: // 0x01
+                state.windowcoveringtype = "RollerShade-2 Motor.";
+                break;
+
+            case 2: // 0x02
+                state.windowcoveringtype = "RollerShade-Exterior.";
+                break;
+
+            case 3: // 0x03
+                state.windowcoveringtype = "RollerShade-Exterior-2 Motor.";
+                break;
+
+            case 4: // 0x04
+                state.windowcoveringtype = "Drapery.";
+                break;
+
+            case 5: // 0x05
+                state.windowcoveringtype = "Awning.";
+                break;
+
+            case 6: // 0x06
+                state.windowcoveringtype = "Shutter.";
+                break;
+
+            case 7: // 0x07
+                state.windowcoveringtype = "Tilt Blind - Tilt Only.";
+                break;
+
+            case 8: // 0x08
+                state.windowcoveringtype = "Tilt Blind – Lift and Tilt.";
+                break;
+
+            case 9: // 0x09
+                state.windowcoveringtype = "Projector Screen.";
+                break;
+        }
+
+        // Lift_AccelerationTime
+        int accelerationTime = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, ACCELERATION_TIME_LIFT));
+        state.liftaccelerationtime = accelerationTime;
+
+        // Lift_DecelerationTime
+        int decelerationTime = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, DECELERATION_TIME_LIFT));
+        state.liftdecelerationtime = decelerationTime;
+
+        // Lift_Velocity
+        int velocity = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, VELOCITY_LIFT));
+        state.liftvelocity = velocity;
+
+        // Mode
+        int Mode = getMAP8(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, MODE));
+        state.mode.motordirection = Mode%2 == 1 ? true : false;
+        Mode = Mode >> 1;
+        state.mode.calibration = Mode%2 == 1 ? true : false;
+        Mode = Mode >> 1;
+        state.mode.maintenance = Mode%2 == 1 ? true : false;
+        Mode = Mode >> 1;
+        state.mode.ledfeedback = Mode%2 == 1 ? true : false;
+
+        // configstatus
+        int configStatus = getMAP8(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, CONFIG_STATUS));
+        state.configstatus.operational = configStatus%2 == 1 ? true : false;
+        configStatus = configStatus >> 1;
+        state.configstatus.online = configStatus%2 == 1 ? true : false;
+        configStatus = configStatus >> 1;
+        state.configstatus.rotationdirection = configStatus%2 == 1 ? "reversed" : "normal";
+        configStatus = configStatus >> 1;
+        state.configstatus.controllift = configStatus%2 == 1 ? "closedloop" : "openloop";
+        configStatus = configStatus >> 1;
+        state.configstatus.controltilt = configStatus%2 == 1 ? "closedloop" : "openloop";
+        configStatus = configStatus >> 1;
+        state.configstatus.closedloopliftcontrol = configStatus%2 == 1 ? "encoder" : "timer";
+        configStatus = configStatus >> 1;
+        state.configstatus.closedlooptiltcontrol = configStatus%2 == 1 ? "encoder" : "timer";
+    }
+    else if(cluster == "LiftPercentage")
+    {
+        // openLevel (CurrentPositionLiftPercentage)
+        int currentPositionLiftPercentage = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, CURRENT_POSITION_LIFT_PERCENTAGE));
+        state.openLevel = currentPositionLiftPercentage;
+    }
+    else if(cluster == "LiftPosition")
+    {
+        // openlevel (CurrentPositionLift)
+        int currentPositionLift = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, CURRENT_POSITION_LIFT));
+        state.openLevel = currentPositionLift;
+
+        // range[0] (InstalledClosedLimitLift)
+        int physicalClosedLimitLift = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, INSTALLED_CLOSED_LIMIT_LIFT));
+        state.range[0] = physicalClosedLimitLift;
+
+        // range[1] (InstalledOpenLimitLift)
+        int physicalOpenLimitLift = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, INSTALLED_OPEN_LIMIT_LIFT));
+        state.range[1] = physicalOpenLimitLift;
+    }
+    else if(cluster == "TiltPercentage")
+    {
+        // openLevel (CurrentPositionTiltPercentage)
+        int currentPositionTiltPercentage = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, CURRENT_POSITION_TILT_PERCENTAGE));
+        state.openLevel = currentPositionTiltPercentage;
+    }
+    else if(cluster == "TiltPosition")
+    {
+        // openLevel (CurrentPositionTilt)
+        int currentPositionTilt = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, CURRENT_POSITION_TILT));
+        state.openLevel = currentPositionTilt;
+
+        // range[0] (InstalledClosedLimitTilt)
+        int physicalClosedLimitTilt = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, INSTALLED_CLOSED_LIMIT_TILT));
+        state.range[0] = physicalClosedLimitTilt;
+
+        // range[1] (InstalledOpenLimitTilt)
+        int physicalOpenLimitTilt = getUINT16(ZBO->getZigbeeAttribute(device->getEui64(), WINDOW_COVERING_CLUSTER, INSTALLED_OPEN_LIMIT_TILT));
+        state.range[1] = physicalOpenLimitTilt;
+    }
+
+    return state;
+}
+
+ZigbeeDevice::smart_plug_state ZigbeeDevice::getSmartPlugState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    ZigbeeDevice::smart_plug_state state;
+
+    // value
+    state.value = ZBO->getZigbeeAttribute(device->getEui64(), ON_OFF_CLUSTER, ON_OFF_VALUE_ATTRIBUTE) == "01" ? true : false;
+
+    return state;
+}
+ZigbeeDevice::mains_power_outlet_state ZigbeeDevice::getMainsPowerOutletState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    ZigbeeDevice::mains_power_outlet_state state;
+
+    // value
+    state.value = ZBO->getZigbeeAttribute(device->getEui64(), ON_OFF_CLUSTER, ON_OFF_VALUE_ATTRIBUTE) == "01" ? true : false;
+
+    return state;
+}
+
+ZigbeeDevice::onoff_output_state ZigbeeDevice::getOnoffOutputState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    ZigbeeDevice::onoff_output_state state;
+
+    // value
+    state.value = ZBO->getZigbeeAttribute(device->getEui64(), ON_OFF_CLUSTER, ON_OFF_VALUE_ATTRIBUTE) == "01" ? true : false;
+
+    return state;
+}
+
+ZigbeeDevice::IAS_zone_info_state ZigbeeDevice::getIASZoneState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    ZigbeeDevice::IAS_zone_info_state state;
+
+    // numberofzonesensitivitylevelsupported
+    int numberOfZoneSensitivityLevelsSupported = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), IAS_ZONE_CLUSTER, NUMBER_OF_ZONE_SENSITIVITY_LEVEL_SUPPORTED));
+    state.numzonesensitivitylevel = numberOfZoneSensitivityLevelsSupported;
+
+    // zoneid
+    int zoneID = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), IAS_ZONE_CLUSTER, ZONE_ID));
+    state.zoneid = zoneID;
+
+    // zonetype (DataType in SiliconLabs Gateway Logstream is Enum16 (0x31))
+    int zoneType = getENUM16(ZBO->getZigbeeAttribute(device->getEui64(), IAS_ZONE_CLUSTER, ZONE_TYPE));
+    switch(zoneType)
+    {
+        case 0: // 0x0000
+            state.zonetype = "Standard CIE";
+            break;
+
+        case 13: // 0x000d
+            state.zonetype = "Motion sensor";
+            break;
+
+        case 21: // 0x0015
+            state.zonetype = "Contact switch";
+            break;
+
+        case 40: // 0x0028
+            state.zonetype = "Fire sensor";
+            break;
+
+        case 42: // 0x002a
+            state.zonetype = "Water sensor";
+            break;
+
+        case 43: // 0x002b
+            state.zonetype = "Carbon Monoxide (CO) sensor";
+            break;
+
+        case 44: // 0x002c
+            state.zonetype = "Personal emergency device";
+            break;
+
+        case 45: // 0x002d
+            state.zonetype = "Vibration/Movement sensor";
+            break;
+
+        case 271: // 0x010f
+            state.zonetype = "Remote Control";
+            break;
+
+        case 277: // 0x0115
+            state.zonetype = "Key fob";
+            break;
+
+        case 541: // 0x021d
+            state.zonetype = "Keypad";
+            break;
+
+        case 549: // 0x0225
+            state.zonetype = "Standard Warning Device";
+            break;
+
+        case 550: // 0x0226
+            state.zonetype = "Glass break sensor";
+            break;
+
+        case 553: // 0x0229
+            state.zonetype = "Security repeater";
+            break;
+
+        case 65536: // 0xffff
+            state.zonetype = "Invalid Zone Type";
+            break;
+
+        default:
+            state.zonetype = "";
+            break;
+    }
+
+    // zonestate
+    int zoneState = getENUM8(ZBO->getZigbeeAttribute(device->getEui64(), IAS_ZONE_CLUSTER, ZONE_TYPE));
+    state.zonestate = zoneState%2 == 1 ? true : false;
+
+    // currentzonesensitivitylevel
+    int currentZoneSensitivityLevel = getUINT8(ZBO->getZigbeeAttribute(device->getEui64(), IAS_ZONE_CLUSTER, CURRENT_ZONE_SENSITIVITY_LEVEL));
+    state.currentzonesensitivitylevel = currentZoneSensitivityLevel;
+
+    // IAS_CIE_address
+    state.iascieaddress = ZBO->getZigbeeAttribute(device->getEui64(), IAS_ZONE_CLUSTER, IAS_CIE_ADDRESS);
+
+    // zonestatus
+    int zoneStatus = getMAP16(ZBO->getZigbeeAttribute(device->getEui64(), IAS_ZONE_CLUSTER, ZONE_STATUS));
+    state.zonestatus_bool[0] = zoneStatus%2 == 1 ? true : false;
+    zoneStatus = zoneStatus >> 1;
+    state.zonestatus_bool[1] = zoneStatus%2 == 1 ? true : false;
+    zoneStatus = zoneStatus >> 1;
+    state.zonestatus_bool[2] = zoneStatus%2 == 1 ? true : false;
+    zoneStatus = zoneStatus >> 1;
+    state.zonestatus_bool[3] = zoneStatus%2 == 1 ? true : false;
+    zoneStatus = zoneStatus >> 1;
+    state.zonestatus_bool[4] = zoneStatus%2 == 1 ? true : false;
+    zoneStatus = zoneStatus >> 1;
+    state.zonestatus_bool[5] = zoneStatus%2 == 1 ? true : false;
+    zoneStatus = zoneStatus >> 1;
+    state.zonestatus_bool[6] = zoneStatus%2 == 1 ? true : false;
+    zoneStatus = zoneStatus >> 1;
+    state.zonestatus_bool[7] = zoneStatus%2 == 1 ? true : false;
+    zoneStatus = zoneStatus >> 1;
+    state.zonestatus_bool[8] = zoneStatus%2 == 1 ? true : false;
+    zoneStatus = zoneStatus >> 1;
+    state.zonestatus_bool[9] = zoneStatus%2 == 1 ? true : false;
+
+    // ocf.zonestatus.alarms
+    switch(zoneType)
+    {
+        case 0: // 0x0000
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("system");
+            }
+            break;
+
+        case 13: // 0x000d
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("intrusion");
+            }
+            if(state.zonestatus_bool[1] == true)
+            {
+                state.zonestatus.alarms.push_back("presence");
+            }
+            break;
+
+        case 21: // 0x0015
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("1stportalopenclose");
+            }
+            if(state.zonestatus_bool[1] == true)
+            {
+                state.zonestatus.alarms.push_back("2ndportalopenclose");
+            }
+            break;
+
+        case 40: // 0x0028
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("fire");
+            }
+            break;
+
+        case 42: // 0x002a
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("wateroverflow");
+            }
+            break;
+
+        case 43: // 0x002b
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("CO");
+            }
+            if(state.zonestatus_bool[1] == true)
+            {
+                state.zonestatus.alarms.push_back("cooking");
+            }
+            break;
+
+        case 44: // 0x002c
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("fall");
+            }
+            if(state.zonestatus_bool[1] == true)
+            {
+                state.zonestatus.alarms.push_back("emergencybutton");
+            }
+            break;
+
+        case 45: // 0x002d
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("movement");
+            }
+            if(state.zonestatus_bool[1] == true)
+            {
+                state.zonestatus.alarms.push_back("vibration");
+            }
+            break;
+
+        case 271: // 0x010f
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("panic");
+            }
+            if(state.zonestatus_bool[1] == true)
+            {
+                state.zonestatus.alarms.push_back("emergency");
+            }
+            break;
+
+        case 277: // 0x0115
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("panic");
+            }
+            if(state.zonestatus_bool[1] == true)
+            {
+                state.zonestatus.alarms.push_back("emergency");
+            }
+            break;
+
+        case 541: // 0x021d
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("panic");
+            }
+            if(state.zonestatus_bool[1] == true)
+            {
+                state.zonestatus.alarms.push_back("emergency");
+            }
+            break;
+
+        case 549: // 0x0225
+            if(state.zonestatus_bool[0] == true)
+            {
+                state.zonestatus.alarms.push_back("glassbreak");
+            }
+            break;
+
+        case 550: // 0x0226
+            break;
+
+        case 553: // 0x0229
+            break;
+
+        case 65536: // 0xffff
+            break;
+    }
+
+    // ocf.zonestatus.tamper
+    state.zonestatus.tamper = state.zonestatus_bool[2];
+
+    // ocf.zonestatus.zonestatusreports
+    if(state.zonestatus_bool[4] == false && state.zonestatus_bool[5] == false)
+    {
+        state.zonestatus.zonestatusreports = "none";
+    }
+    else if(state.zonestatus_bool[4] == true && state.zonestatus_bool[5] == false)
+    {
+        state.zonestatus.zonestatusreports = "statuschangeonly";
+    }
+    else if(state.zonestatus_bool[4] == false && state.zonestatus_bool[5] == true)
+    {
+        state.zonestatus.zonestatusreports = "alarmclearonly";
+    }
+    else if(state.zonestatus_bool[4] == true && state.zonestatus_bool[5] == true)
+    {
+        state.zonestatus.zonestatusreports = "statuschangeandalarmclear";
+    }
+
+    // ocf.zonestatus.fault
+    state.zonestatus.fault = state.zonestatus_bool[6];
+
+    // ocf.zonestatus.test
+    state.zonestatus.test = state.zonestatus_bool[8];
+
+    // ocf.zonebattery
+    state.zonebattery.lowbattery = state.zonestatus_bool[3];
+    state.zonebattery.charge = 100;
+    state.zonebattery.defect = state.zonestatus_bool[9];
+
+    // ocf.zonepowersource
+    state.zonepowersource.sourcefault = state.zonestatus_bool[7];
+    state.zonepowersource.powerSources.push_back("AC (Mains) Power");
+    state.zonepowersource.powerSources.push_back("Internal Battery");
+
+    return state;
+}
+
+ZigbeeDevice::occupancy_sensor_state ZigbeeDevice::getOccupancySensorState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    ZigbeeDevice::occupancy_sensor_state state;
+
+    // value
+    int occupancy = getMAP8(ZBO->getZigbeeAttribute(device->getEui64(), OCCUPANCY_SENSING_CLUSTER, OCCUPANCY_ATTRIBUTE));
+    state.value = occupancy%2 == 1 ? true : false;
+
+    return state;
+}
+
+std::string ZigbeeDevice::AsciiToChar(std::string hex_string)
+{
+    if (hex_string.find_first_not_of("0123456789ABCDEFabcdef- ") != std::string::npos)
+        return hex_string;
+
+    std::string tempString;
+    tempString.clear();
+    for (uint32_t i = 0; i < hex_string.length() / 2; i++)
+    {
+        uint32_t hex;
+        stringstream convert(hex_string.substr(2 * i, 2).c_str());
+        convert >> std::hex >> hex;
+        tempString += (char) hex;
+    }
+    return tempString;
+}
+
+int ZigbeeDevice::getUINT8(std::string str)
+{
+    int v;
+    stringstream ss;
+    ss.str(str);
+    ss >> std::hex >> v;
+
+    return v;
+}
+
+int ZigbeeDevice::getUINT16(std::string str)
+{
+    if(str.length() > 0)
+    {
+        int hex1, hex2;
+        stringstream ss1, ss2;
+        ss1.str(str.substr(0, 2));
+        ss1 >> std::hex >> hex1;
+        ss2.str(str.substr(2, 2));
+        ss2 >> std::hex >> hex2;
+        return hex2 * 256 + hex1;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+int ZigbeeDevice::getINT16(std::string str)
+{
+    if(str.length() > 0)
+    {
+        int hex1, hex2;
+        stringstream ss1, ss2;
+        ss1.str(str.substr(0, 2));
+        ss1 >> std::hex >> hex1;
+        ss2.str(str.substr(2, 2));
+        ss2 >> std::hex >> hex2;
+        return hex2 * 256 + hex1;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+int ZigbeeDevice::getMAP8(std::string str)
+{
+    int v;
+    stringstream ss;
+    ss.str(str);
+    ss >> std::hex >> v;
+
+    return v;
+}
+
+
+int ZigbeeDevice::getMAP16(std::string str)
+{
+    if(str.length() > 0)
+    {
+        int hex1, hex2;
+        stringstream ss1, ss2;
+        ss1.str(str.substr(0, 2));
+        ss1 >> std::hex >> hex1;
+        ss2.str(str.substr(2, 2));
+        ss2 >> std::hex >> hex2;
+        return hex2 * 256 + hex1;
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+int ZigbeeDevice::getENUM8(std::string str)
+{
+    int v;
+    stringstream ss;
+    ss.str(str);
+    ss >> std::hex >> v;
+
+    return v;
+}
+
+int ZigbeeDevice::getENUM16(std::string str)
+{
+    if(str.length() > 0)
+    {
+        int hex1, hex2;
+        stringstream ss1, ss2;
+        ss1.str(str.substr(0, 2));
+        ss1 >> std::hex >> hex1;
+        ss2.str(str.substr(2, 2));
+        ss2 >> std::hex >> hex2;
+        return hex2 * 256 + hex1;
+    }
+    else
+    {
+        return 65536;
+    }
+}
+
+void ZigbeeDevice::PrintCoreResource()
+{
+    std::cout << "\n========================= Zigbee device information =========================" << std::endl;
+    std::cout << "name:" << this->m_name << std::endl;
+    std::cout << "software version:" << this->m_software_version << std::endl;
+    std::cout << "model number:" << this->m_model_number << std::endl;
+    std::cout << "manufacturer name:" << this->m_manufacturer_name << std::endl;
+    std::cout << "protocol independent ID:" << this->m_protocol_independent_Id << std::endl;
+    std::cout << "platform ID:" << this->m_platform_Id << std::endl;
+    std::cout << "hardware version:" << this->m_hardware_version << std::endl;
+    std::cout << "=============================================================================" << std::endl;
+}
+
+void ZigbeeDevice::setPid(pid_t pid)
+{
+    this->m_pid = pid;
+}
+
+void ZigbeeDevice::setOwnedState(bool state)
+{
+    this->m_isOwned = state;
+}
+
+void ZigbeeDevice::setEcoSystem(std::string eco_system)
+{
+    this->m_eco_system = eco_system;
+}
+
+void ZigbeeDevice::setDeviceType(std::string deviceType)
+{
+    this->m_deviceType = deviceType;
+}
+
+void ZigbeeDevice::setNodeId(std::string nodeId)
+{
+    this->m_nodeId = nodeId;
+}
+
+void ZigbeeDevice::setEui64(std::string eui64)
+{
+    this->m_eui64 = eui64;
+}
+void ZigbeeDevice::setName(std::string name)
+{
+    this->m_name = AsciiToChar(name);
+}
+
+void ZigbeeDevice::setSoftwareVersion(std::string software_version)
+{
+    this->m_software_version = software_version;
+}
+
+void ZigbeeDevice::setManufacturerName(std::string manufacturer_name)
+{
+    this->m_manufacturer_name = AsciiToChar(manufacturer_name);
+}
+
+void ZigbeeDevice::setModelNumber(std::string model_number)
+{
+    this->m_model_number = AsciiToChar(model_number);
+}
+
+void ZigbeeDevice::setProtocolIndependentId(std::string protocol_independent_Id)
+{
+    this->m_protocol_independent_Id = protocol_independent_Id;
+}
+
+void ZigbeeDevice::setPlatformId(std::string platform_Id)
+{
+    this->m_platform_Id = platform_Id;
+}
+
+void ZigbeeDevice::setHardwareVersion(std::string hardware_version)
+{
+    this->m_hardware_version = hardware_version;
+}
+
+pid_t ZigbeeDevice::getPid()
+{
+    return m_pid;
+}
+
+bool ZigbeeDevice::getOwnedState()
+{
+    return m_isOwned;
+}
+
+std::string ZigbeeDevice::getNodeId()
+{
+    return m_nodeId;
+}
+
+std::string ZigbeeDevice::getDeviceType()
+{
+    return m_deviceType;
+}
+
+std::string ZigbeeDevice::getEui64()
+{
+    return m_eui64;
+}
+
+std::string ZigbeeDevice::getName()
+{
+    return m_name;
+}
+
+std::string ZigbeeDevice::getSoftwareVersion()
+{
+    return m_software_version;
+}
+
+std::string ZigbeeDevice::getManufacturerName()
+{
+    return m_manufacturer_name;
+}
+
+std::string ZigbeeDevice::getModelNumber()
+{
+    return m_model_number;
+}
+
+std::string ZigbeeDevice::getProtocolIndependentId()
+{
+    return m_protocol_independent_Id;
+}
+
+std::string ZigbeeDevice::getPlatformId()
+{
+    return m_platform_Id;
+}
+
+std::string ZigbeeDevice::getHardwareVersion()
+{
+    return m_hardware_version;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Device.h b/bridging/plugins/zigbee_plugin/Zigbee_Device.h
new file mode 100644
index 000000000..7587cde43
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Device.h
@@ -0,0 +1,599 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_OBJECTS_ZIGBEE_DEVICE_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_OBJECTS_ZIGBEE_DEVICE_H_
+
+#include "OCApi.h"
+#include "Device_Operations/Device_Operations.h"
+#include <unistd.h>
+
+// Definition for Zigbee Device Type
+const std::string DEVICE_TYPE_ONOFF_LIGHT = "0x0100"; // oic.d.light
+const std::string DEVICE_TYPE_COLOR_TEMPERATURE_LIGHT = "0x010c"; // oic.d.light
+const std::string DEVICE_TYPE_EXTENDED_COLOR_LIGHT = "0x010d"; // oic.d.light
+const std::string DEVICE_TYPE_DIMMABLE_LIGHT = "0x0101"; // oic.d.light
+const std::string DEVICE_TYPE_COLOR_DIMMABLE_LIGHT = "0x0102"; // oic.d.light
+const std::string DEVICE_TYPE_TEMPERATURE_SENSOR = "0x0302"; // oic.d.sensor
+const std::string DEVICE_TYPE_THERMOSTAT = "0x0301"; // oic.d.thermostat
+const std::string DEVICE_TYPE_WINDOW_COVERING_DEVICE = "0x0202"; // oic.d.blind
+const std::string DEVICE_TYPE_SMART_PLUG = "0x0051"; // oic.d.smartplug
+const std::string DEVICE_TYPE_MAINS_POWER_OUTLET = "0x0009"; // oic.d.smartplug
+const std::string DEVICE_TYPE_ONOFF_OUTPUT = "0x0002"; // oic.d.smartplug
+const std::string DEVICE_TYPE_IAS_ZONE = "0x0402"; // oic.d.sensor
+const std::string DEVICE_TYPE_OCCUPANCY_SENSOR = "0x0107"; // oic.d.sensor
+
+// Definition for OCF Device Type
+const std::string OIC_VIRTUAL_DEVICE = "oic.d.virtual";
+const std::string OIC_LIGHT_DEVICE = "oic.d.light";
+const std::string OIC_SENSOR_DEVICE = "oic.d.sensor";
+const std::string OIC_SMARTPLUG_DEVICE = "oic.d.smartplug";
+const std::string OIC_BLIND_DEVICE = "oic.d.blind";
+const std::string OIC_THERMOSTAT_DEVICE = "oic.d.thermostat";
+
+// Definition for OCF Resource Type
+const std::string OIC_BINARY_SWITCH = "oic.r.switch.binary"; // OCF Resource: Binary Switch, Zigbee Cluster: On/off
+const std::string OIC_DIMMING = "oic.r.light.dimming"; // OCF Resource: Dimming, Zigbee Cluster: Level Control
+const std::string OIC_COLOUR_HUE_AND_SATURATION = "oic.r.colour.hs"; // OCF Resource: Colour Hue and Saturation, Zigbee Cluster: Color Control
+const std::string OIC_COLOUR_SPACE_COORDINATES = "oic.r.colour.csc"; // OCF Resource: Colour Space Coordinates, Zigbee Cluster: Color Control
+const std::string OIC_COLOUR_TEMPERATURE = "oic.r.colour.colourtemperature"; // OCF Resource: Colour Temperature, Zigbee Cluster: Color Control
+const std::string OIC_WINDOWCOVERING = "oic.r.windowcovering"; // OCF Resource: Window Covering, Zigbee Cluster: Window Covering
+const std::string OIC_OPENLEVEL = "oic.r.openlevel"; // OCF Resource: Window Covering, Zigbee Cluster: Window Covering
+const std::string OIC_TEMPERATURE = "oic.r.temperature"; // OCF Resource: Temperature, Zigbee Cluster: Temperature Measurement
+const std::string OIC_IAS_ZONE = "oic.r.ias.zone"; // OCF Resource: IAS Zone, Zigbee Cluster: IAS Zone
+const std::string OIC_IAS_ZONE_INFO = "oic.r.iaszoneinfo"; // OCF Resource: IAS Zone, Zigbee Cluster: IAS Zone
+const std::string OIC_ENERGY_BATTERY = "oic.r.energy.battery";
+const std::string OIC_CONDITIONAL = "oic.r.value.conditional";
+const std::string OIC_POWERSOURCE = "oic.r.powersource";
+const std::string OIC_PRESENCE_SENSOR = "oic.r.sensor.presence"; // OCF Resource: Presence Sensor, Zigbee Cluster: Occupancy Sensing
+
+// relative uri
+const std::string BINARY_SWITCH_RELATIVE_URI = "/switch";
+const std::string DIMMING_RELATIVE_URI = "/brightness";
+const std::string COLOR_HS_RELATIVE_URI = "/color_hs";
+const std::string COLOR_CSC_RELATIVE_URI = "/color_csc";
+const std::string COLOR_CT_RELATIVE_URI = "/color_ct";
+const std::string WINDOW_COVERING_RELATIVE_URI = "/windowcovering";
+const std::string OPENLEVEL_RELATIVE_URI = "/openlevel";
+const std::string TEMPERATURE_RELATIVE_URI = "/temperature";
+const std::string IAS_ZONE_RELATIVE_URI = "/iaszone";
+const std::string IAS_ZONE_INFO_RELATIVE_URI = "/iaszoneinfo";
+const std::string BATTERY_RELATIVE_URI = "/battery";
+const std::string POWERSOURCE_RELATIVE_URI = "/powersource";
+const std::string PRESENCE_SENSOR_RELATIVE_URI = "/presence";
+
+class ZBOperations;
+
+class ZigbeeDevice
+{
+public:
+    std::string OCFDeviceType;
+    std::vector< std::string > resourceUris;
+    std::map< std::string, std::vector< std::string > > childResourceUris;
+    std::map< std::string, std::vector< std::string > > resourceTypes;
+    std::map< std::string, std::vector< std::string > > interfaces;
+
+    uint32_t getNumberOfAdditionalResources()   {return resourceUris.size();}
+
+private:
+    pid_t m_pid;  // process ID for virtual server
+    bool m_isOwned;   // owned state for virtual server
+    std::string m_eco_system; // eco_system information for virtual server
+
+    /* Member variables for a Zigbee device */
+    std::string m_nodeId;
+    std::string m_deviceType;
+    std::string m_eui64;
+
+    std::string m_name;
+    std::string m_software_version;
+    std::string m_manufacturer_name;
+    std::string m_model_number;
+    std::string m_protocol_independent_Id;
+    std::string m_localized_names;
+    std::string m_platform_Id;
+    std::string m_hardware_version;
+
+public:
+    ZigbeeDevice();
+
+    /*
+     * Discover all Zigbee devices connected to gateway
+     */
+    MPMResult static discoverZigbeeDevices(std::vector< std::shared_ptr< ZigbeeDevice > > &devices,
+            std::shared_ptr< ZBOperations > ZBO);
+
+    /*
+     * Setters of member variables
+     */
+    void setPid(pid_t pid);
+    void setOwnedState(bool state);
+    void setEcoSystem(std::string eco_system);
+
+    void setNodeId(std::string nodeId);
+    void setDeviceType(std::string deviceType);
+    void setEui64(std::string eui64);
+    void setName(std::string name);
+    void setSoftwareVersion(std::string software_version);
+    void setManufacturerName(std::string manufacturer_name);
+    void setModelNumber(std::string model_number);
+    void setProtocolIndependentId(std::string protocol_independent_Id);
+    void setPlatformId(std::string platform_Id);
+    void setHardwareVersion(std::string hardware_version);
+
+    /*
+     * Getters of member variables
+     */
+    pid_t getPid();
+    bool getOwnedState();
+    std::string getNodeId();
+    std::string getDeviceType();
+    std::string getEui64();
+    std::string getName();
+    std::string getSoftwareVersion();
+    std::string getManufacturerName();
+    std::string getModelNumber();
+    std::string getProtocolIndependentId();
+    std::string getPlatformId();
+    std::string getHardwareVersion();
+
+    /*
+     * Getters of member variables by ZB command via server in gateway
+     */
+    std::string getNameByZBC(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations >);
+    std::string getSoftwareVersionByZBC(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations >);
+    std::string getManufacturerNameByZBC(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations >);
+    std::string getModelNumberByZBC(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations >);
+    std::string getProtocolIndependentIdByZBC(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations >);
+    std::string getPlatformIdByZBC(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations >);
+    std::string getHardwareVersionByZBC(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations >);
+
+    std::string AsciiToChar(std::string hex_string);
+    int getUINT8(std::string str);
+    int getUINT16(std::string str);
+    int getINT16(std::string str);
+    int getMAP8(std::string str);
+    int getMAP16(std::string str);
+    int getENUM8(std::string str);
+    int getENUM16(std::string str);
+    void PrintCoreResource(void);
+
+    /*
+     * state structure for onoff light
+     */
+    typedef struct onoff_light_state_t
+    {
+        // oic.r.switch.binary
+        bool value;
+    } onoff_light_state;
+
+    /*
+     * state structure for color temperature light
+     */
+    typedef struct color_temperature_light_state_t
+    {
+        // oic.r.switch.binary
+        bool value;
+
+        // oic.r.light.dimming
+        int dimmingSetting;
+
+        // oic.r.colour.hs
+        double hue;
+        int saturation;
+
+        // oic.r.colour.csc
+        double csc[2];
+
+        // oic.r.colour.colourtemperature
+        int ct;
+        int range[2];
+    } color_temperature_light_state;
+
+    /*
+     * state structure for extended color light
+     */
+    typedef struct extended_color_light_state_t
+    {
+        // oic.r.switch.binary
+        bool value;
+
+        // oic.r.light.dimming
+        int dimmingSetting;
+
+        // oic.r.colour.hs
+        double hue;
+        int saturation;
+
+        // oic.r.colour.csc
+        double csc[2];
+
+        // oic.r.colour.colourtemperature
+        int ct;
+        int range[2];
+    } extended_color_light_state;
+
+    /*
+     * state structure for dimmable light
+     */
+    typedef struct dimmable_light_state_t
+    {
+        // oic.r.switch.binary
+        bool value;
+
+        // oic.r.light.dimming
+        int dimmingSetting;
+    } dimmable_light_state;
+
+    /*
+     * state structure for color dimmable light
+     */
+    typedef struct color_dimmable_light_state_t
+    {
+        // oic.r.switch.binary
+        bool value;
+
+        // oic.r.light.dimming
+        int dimmingSetting;
+
+        // oic.r.colour.hs
+        double hue;
+        int saturation;
+
+        // oic.r.colour.csc
+        double csc[2];
+
+        // oic.r.colour.colourtemperature
+        int ct;
+        int range[2];
+    } color_dimmable_light_state;
+
+    /*
+     * state structure for temperature sensor
+     */
+    typedef struct temperature_sensor_state_t
+    {
+        // oic.r.temperature
+        double temperature;
+        std::string units;
+        double precision;
+        double range[2];
+    } temperature_sensor_state;
+
+    /*
+     * state structure for thermostat
+     */
+    typedef struct thermostat_state_t
+    {
+        double temperature;
+        std::string units;
+    } thermostat_state;
+
+    /*
+     * state structure for window covering device
+     */
+    typedef struct window_covering_device_state_t
+    {
+        std::string windowcoveringtype;
+        int liftaccelerationtime;
+        int liftdecelerationtime;
+        int liftvelocity;
+
+        struct Mode
+        {
+            bool calibration;
+            bool ledfeedback;
+            bool maintenance;
+            bool motordirection;
+        };
+        Mode mode;
+
+        struct Configstatus
+        {
+            std::string controllift;
+            std::string controltilt;
+            std::string closedloopliftcontrol;
+            std::string closedlooptiltcontrol;
+            bool online;
+            bool operational;
+            std::string rotationdirection;
+        };
+        Configstatus configstatus;
+
+        int openLevel;
+        int range[2];
+
+    } window_covering_device_state;
+
+    /*
+     * state structure for smart plug
+     */
+    typedef struct smart_plug_state_t
+    {
+        // oic.r.switch.binary
+        bool value;
+    } smart_plug_state;
+
+    /*
+     * state structure for mains power outlet
+     */
+    typedef struct mains_power_outlet_state_t
+    {
+        // oic.r.switch.binary
+        bool value;
+    } mains_power_outlet_state;
+
+    /*
+     * state structure for onoff output
+     */
+    typedef struct onoff_output_state_t
+    {
+        // oic.r.switch.binary
+        bool value;
+    } onoff_output_state;
+
+    typedef struct battery_state_t
+    {
+        int charge;
+        bool lowbattery;
+        bool defect;
+    } battery_state;
+
+    typedef struct powersource_state_t
+    {
+        std::vector< std::string > powerSources;
+        bool sourcefault;
+    } powersource_state;
+    /*
+     * state structure for IAS zone info
+     */
+    typedef struct IAS_zone_info_state_t
+    {
+        struct ZoneStatus
+        {
+            std::vector< std::string > alarms;
+            std::string zonestatusreports;
+            bool tamper;
+            bool test;
+            bool fault;
+        };
+
+        // oic.r.ias.zone
+        bool zonestate;
+        bool zonestatus_bool[10];
+        ZoneStatus zonestatus;
+        battery_state zonebattery;
+        powersource_state zonepowersource;
+        int numzonesensitivitylevel;
+        int zoneid;
+        std::string iascieaddress;
+        std::string zonetype;
+        int currentzonesensitivitylevel;
+    } IAS_zone_info_state;
+
+
+    /*
+     * state structure for occupancy sensor
+     */
+    typedef struct occupancy_sensor_state_t
+    {
+        // oic.r.presence
+        bool value;   // (To OCF) value = false if occupancy == xxxxxxx0 (8 bitmap), value = true if occupancy == xxxxxxx1 (8 bitmap)
+
+    } occupancy_sensor_state;
+
+    virtual void setState(onoff_light_state) {}
+    virtual void setState(color_temperature_light_state) {}
+    virtual void setState(extended_color_light_state) {}
+    virtual void setState(dimmable_light_state) {}
+    virtual void setState(color_dimmable_light_state) {}
+    virtual void setState(temperature_sensor_state) {}
+    virtual void setState(thermostat_state) {}
+    virtual void setState(window_covering_device_state) {}
+    virtual void setState(smart_plug_state) {}
+    virtual void setState(mains_power_outlet_state) {}
+    virtual void setState(onoff_output_state) {}
+    virtual void setState(IAS_zone_info_state) {}
+    virtual void setState(occupancy_sensor_state) {}
+
+    /*
+     * Virtual member functions for getting state of devices (e.g., light state or temperature sensor state)
+     * These virtual functions will be overloaded in child class (e.g., Zigbee_Light class or Zigbee_TemperatureSensor class)
+     */
+    virtual onoff_light_state getOnoffLightState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >);
+    virtual color_temperature_light_state getColorTemperatureLightState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >, std::string);
+    virtual extended_color_light_state getExtendedColorLightState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >, std::string);
+    virtual dimmable_light_state getDimmableLightState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >, std::string);
+    virtual color_dimmable_light_state getColorDimmableLightState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >, std::string);
+    virtual temperature_sensor_state getTemperatureSensorState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >);
+    virtual thermostat_state getThermostatState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations > , std::string );
+    virtual window_covering_device_state getWindowCoveringDeviceState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >, std::string );
+    virtual smart_plug_state getSmartPlugState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >);
+    virtual mains_power_outlet_state getMainsPowerOutletState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >);
+    virtual onoff_output_state getOnoffOutputState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >);
+    virtual IAS_zone_info_state getIASZoneState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >);
+    virtual occupancy_sensor_state getOccupancySensorState(std::shared_ptr< ZigbeeDevice >, std::shared_ptr< ZBOperations >);
+
+public:
+    template <typename T1, typename T2>
+    void OCFToZigbee(const std::string uri, const std::string property, T1 before, T2 *after)
+    {
+        if (this->getDeviceType() == DEVICE_TYPE_ONOFF_LIGHT ||
+                this->getDeviceType() == DEVICE_TYPE_COLOR_TEMPERATURE_LIGHT ||
+                this->getDeviceType() == DEVICE_TYPE_EXTENDED_COLOR_LIGHT ||
+                this->getDeviceType() == DEVICE_TYPE_DIMMABLE_LIGHT ||
+                this->getDeviceType() == DEVICE_TYPE_COLOR_DIMMABLE_LIGHT)
+        {
+            if(uri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                if(property == "value")
+                {
+                    *after = before;
+                }
+            }
+            else if(uri == DIMMING_RELATIVE_URI)
+            {
+                if(property == "dimmingSetting")
+                {
+                    *after = (before*254)/100;
+                }
+            }
+            else if(uri == COLOR_HS_RELATIVE_URI)
+            {
+                if(property == "hue")
+                {
+                    *after = (before/360)*254;
+                }
+                else if(property == "saturation")
+                {
+                    *after = before;
+                }
+            }
+            else if(uri == COLOR_CSC_RELATIVE_URI)
+            {
+                if(property == "csc")
+                {
+                    *after = before*65536;
+                }
+            }
+            else if(uri == COLOR_CT_RELATIVE_URI)
+            {
+                if(property == "ct")
+                {
+                    *after = before;
+                }
+                else if(property == "range")
+                {
+                    // nothing to do in case of OCF -> Zigbee translation
+                }
+            }
+        }
+        else if (this->getDeviceType() == DEVICE_TYPE_TEMPERATURE_SENSOR ||
+                this->getDeviceType() == DEVICE_TYPE_OCCUPANCY_SENSOR)
+        {
+            // nothing to do in case of OCF -> Zigbee translation
+        }
+        else if (this->getDeviceType() == DEVICE_TYPE_THERMOSTAT)
+        {
+            if(uri == TEMPERATURE_RELATIVE_URI + "_info")
+            {
+                // nothing to do in case of OCF -> Zigbee translation
+            }
+            else if(uri == TEMPERATURE_RELATIVE_URI + "_hot" ||
+                    uri == TEMPERATURE_RELATIVE_URI + "_cool")
+            {
+                if(property == "temperature")
+                {
+                    *after = before*100.0;
+                }
+            }
+        }
+        else if (this->getDeviceType() == DEVICE_TYPE_WINDOW_COVERING_DEVICE)
+        {
+            if(uri == WINDOW_COVERING_RELATIVE_URI)
+            {
+                if(property == "liftaccelerationtime" ||
+                        property == "liftdecelerationtime" ||
+                        property == "liftvelocity")
+                {
+                    *after = before;
+                }
+                else if(property == "mode")
+                {
+                    // OCFToZigbeeBitmapMasking() call
+                }
+            }
+            else if(uri == OPENLEVEL_RELATIVE_URI + "/liftpercent" ||
+                    uri == OPENLEVEL_RELATIVE_URI + "/liftposition" ||
+                    uri == OPENLEVEL_RELATIVE_URI + "/tiltpercent" ||
+                    uri == OPENLEVEL_RELATIVE_URI + "/tiltdegree")
+            {
+                if(property == "openLevel")
+                {
+                    *after = before;
+                }
+            }
+        }
+        else if (this->getDeviceType() == DEVICE_TYPE_SMART_PLUG ||
+                this->getDeviceType() == DEVICE_TYPE_MAINS_POWER_OUTLET ||
+                this->getDeviceType() == DEVICE_TYPE_ONOFF_OUTPUT)
+        {
+            if(uri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                if(property == "value")
+                {
+                    *after = before;
+                }
+            }
+        }
+        else if (this->getDeviceType() == DEVICE_TYPE_IAS_ZONE)
+        {
+            if(uri == IAS_ZONE_INFO_RELATIVE_URI)
+            {
+                if(property == "currentzonesensitivitylevel")
+                {
+                    *after = before;
+                }
+            }
+        }
+    }
+
+    int pow(int base, size_t expo)
+    {
+        int result = 1;
+        if(expo == 0)
+        {
+            return result;
+        }
+        else
+        {
+            for (size_t i = 0 ; i < expo ; ++i)
+            {
+                result *= base;
+            }
+        }
+        return result;
+    }
+
+    void OCFToZigbeeBitmapMasking(const std::string uri, const std::string property, bool *array, size_t arraySize, int *bitmap)
+    {
+        if (this->getDeviceType() == DEVICE_TYPE_WINDOW_COVERING_DEVICE)
+        {
+            if(uri == WINDOW_COVERING_RELATIVE_URI)
+            {
+                if(property == "mode")
+                {
+                    for (size_t i = 0; i < arraySize; ++i)
+                    {
+                        if(array[i])
+                        {
+                            *bitmap += pow(2, i);
+                        }
+                    }
+                }
+            }
+        }
+    }
+};
+typedef std::shared_ptr< ZigbeeDevice > ZigbeeDeviceSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_OBJECTS_ZIGBEE_DEVICE_H_ */
+
+
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorDimmableLight.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorDimmableLight.cpp
new file mode 100644
index 000000000..71318798d
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorDimmableLight.cpp
@@ -0,0 +1,90 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_ColorDimmableLight.h"
+
+ZigbeeColorDimmableLight::ZigbeeColorDimmableLight()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_LIGHT_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(BINARY_SWITCH_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_BINARY_SWITCH);
+        resourceTypes[BINARY_SWITCH_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[BINARY_SWITCH_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(DIMMING_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_DIMMING);
+        resourceTypes[DIMMING_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[DIMMING_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(COLOR_HS_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_COLOUR_HUE_AND_SATURATION);
+        resourceTypes[COLOR_HS_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[COLOR_HS_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(COLOR_CSC_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_COLOUR_SPACE_COORDINATES);
+        resourceTypes[COLOR_CSC_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[COLOR_CSC_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(COLOR_CT_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_COLOUR_TEMPERATURE);
+        resourceTypes[COLOR_CT_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[COLOR_CT_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeColorDimmableLight::setState(color_dimmable_light_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::color_dimmable_light_state ZigbeeColorDimmableLight::getColorDimmableLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string uri)
+{
+    m_state = ZigbeeDevice::getColorDimmableLightState(device, ZBO, uri);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorDimmableLight.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorDimmableLight.h
new file mode 100644
index 000000000..62d882093
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorDimmableLight.h
@@ -0,0 +1,38 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_COLORDIMMABLELIGHT_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_COLORDIMMABLELIGHT_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeColorDimmableLight: public ZigbeeDevice
+{
+public:
+    ZigbeeColorDimmableLight();
+
+    color_dimmable_light_state m_state;
+
+    virtual void setState(color_dimmable_light_state state);
+    virtual color_dimmable_light_state getColorDimmableLightState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > , std::string );
+};
+typedef std::shared_ptr< ZigbeeColorDimmableLight > ZigbeeColorDimmableLightSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_COLORDIMMABLELIGHT_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorTemperatureLight.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorTemperatureLight.cpp
new file mode 100644
index 000000000..c62acd218
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorTemperatureLight.cpp
@@ -0,0 +1,90 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_ColorTemperatureLight.h"
+
+ZigbeeColorTemperatureLight::ZigbeeColorTemperatureLight()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_LIGHT_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(BINARY_SWITCH_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_BINARY_SWITCH);
+        resourceTypes[BINARY_SWITCH_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[BINARY_SWITCH_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(DIMMING_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_DIMMING);
+        resourceTypes[DIMMING_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[DIMMING_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(COLOR_HS_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_COLOUR_HUE_AND_SATURATION);
+        resourceTypes[COLOR_HS_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[COLOR_HS_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(COLOR_CSC_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_COLOUR_SPACE_COORDINATES);
+        resourceTypes[COLOR_CSC_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[COLOR_CSC_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(COLOR_CT_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_COLOUR_TEMPERATURE);
+        resourceTypes[COLOR_CT_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[COLOR_CT_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeColorTemperatureLight::setState(color_temperature_light_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::color_temperature_light_state ZigbeeColorTemperatureLight::getColorTemperatureLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string uri)
+{
+    m_state = ZigbeeDevice::getColorTemperatureLightState(device, ZBO, uri);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorTemperatureLight.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorTemperatureLight.h
new file mode 100644
index 000000000..e33c7cb14
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ColorTemperatureLight.h
@@ -0,0 +1,39 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_COLORTEMPERATURELIGHT_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_COLORTEMPERATURELIGHT_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeColorTemperatureLight: public ZigbeeDevice
+{
+public:
+    ZigbeeColorTemperatureLight();
+
+    color_temperature_light_state m_state;
+
+    virtual void setState(color_temperature_light_state state);
+    virtual color_temperature_light_state getColorTemperatureLightState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > , std::string );
+};
+typedef std::shared_ptr< ZigbeeColorTemperatureLight > ZigbeeColorTemperatureLightSharedPtr;
+
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_COLORTEMPERATURELIGHT_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_DimmableLight.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_DimmableLight.cpp
new file mode 100644
index 000000000..7e2a89b54
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_DimmableLight.cpp
@@ -0,0 +1,60 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_DimmableLight.h"
+
+ZigbeeDimmableLight::ZigbeeDimmableLight()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_LIGHT_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(BINARY_SWITCH_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_BINARY_SWITCH);
+        resourceTypes[BINARY_SWITCH_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[BINARY_SWITCH_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(DIMMING_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_DIMMING);
+        resourceTypes[DIMMING_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[DIMMING_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeDimmableLight::setState(dimmable_light_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::dimmable_light_state ZigbeeDimmableLight::getDimmableLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string uri)
+{
+    m_state = ZigbeeDevice::getDimmableLightState(device, ZBO, uri);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_DimmableLight.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_DimmableLight.h
new file mode 100644
index 000000000..91636f71d
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_DimmableLight.h
@@ -0,0 +1,38 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_DIMMABLELIGHT_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_DIMMABLELIGHT_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeDimmableLight: public ZigbeeDevice
+{
+public:
+    ZigbeeDimmableLight();
+
+    dimmable_light_state m_state;
+
+    virtual void setState(dimmable_light_state state);
+    virtual dimmable_light_state getDimmableLightState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > , std::string );
+};
+typedef std::shared_ptr< ZigbeeDimmableLight > ZigbeeDimmableLightSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_DIMMABLELIGHT_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ExtendedColorLight.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ExtendedColorLight.cpp
new file mode 100644
index 000000000..d161c6294
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ExtendedColorLight.cpp
@@ -0,0 +1,90 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_ExtendedColorLight.h"
+
+ZigbeeExtendedColorLight::ZigbeeExtendedColorLight()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_LIGHT_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(BINARY_SWITCH_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_BINARY_SWITCH);
+        resourceTypes[BINARY_SWITCH_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[BINARY_SWITCH_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(DIMMING_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_DIMMING);
+        resourceTypes[DIMMING_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[DIMMING_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(COLOR_HS_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_COLOUR_HUE_AND_SATURATION);
+        resourceTypes[COLOR_HS_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[COLOR_HS_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(COLOR_CSC_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_COLOUR_SPACE_COORDINATES);
+        resourceTypes[COLOR_CSC_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[COLOR_CSC_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(COLOR_CT_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_COLOUR_TEMPERATURE);
+        resourceTypes[COLOR_CT_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[COLOR_CT_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeExtendedColorLight::setState(extended_color_light_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::extended_color_light_state ZigbeeExtendedColorLight::getExtendedColorLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string uri)
+{
+    m_state = ZigbeeDevice::getExtendedColorLightState(device, ZBO, uri);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ExtendedColorLight.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ExtendedColorLight.h
new file mode 100644
index 000000000..4d0b7f6a5
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_ExtendedColorLight.h
@@ -0,0 +1,38 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_EXTENDEDCOLORLIGHT_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_EXTENDEDCOLORLIGHT_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeExtendedColorLight: public ZigbeeDevice
+{
+public:
+    ZigbeeExtendedColorLight();
+
+    extended_color_light_state m_state;
+
+    virtual void setState(extended_color_light_state state);
+    virtual extended_color_light_state getExtendedColorLightState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > , std::string );
+};
+typedef std::shared_ptr< ZigbeeExtendedColorLight > ZigbeeExtendedColorLightSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_EXTENDEDCOLORLIGHT_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_IASZone.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_IASZone.cpp
new file mode 100644
index 000000000..3e786b1ab
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_IASZone.cpp
@@ -0,0 +1,80 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#include "../Zigbee_Devices/Zigbee_IASZone.h"
+
+ZigbeeIASZone::ZigbeeIASZone()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_SENSOR_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(IAS_ZONE_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_IAS_ZONE);
+        resourceTypes[IAS_ZONE_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_LL);
+        iface.push_back(OC_RSRVD_INTERFACE_BATCH);
+        interfaces[IAS_ZONE_RELATIVE_URI] = iface;
+    }
+    childResourceUris[IAS_ZONE_RELATIVE_URI].push_back(IAS_ZONE_INFO_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_IAS_ZONE_INFO);
+        resourceTypes[IAS_ZONE_INFO_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_READ_WRITE);
+        interfaces[IAS_ZONE_INFO_RELATIVE_URI] = iface;
+    }
+    childResourceUris[IAS_ZONE_RELATIVE_URI].push_back(BATTERY_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_ENERGY_BATTERY);
+        resourceTypes[BATTERY_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_READ_WRITE);
+        interfaces[BATTERY_RELATIVE_URI] = iface;
+    }
+    childResourceUris[IAS_ZONE_RELATIVE_URI].push_back(POWERSOURCE_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_POWERSOURCE);
+        resourceTypes[POWERSOURCE_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_READ);
+        interfaces[POWERSOURCE_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeIASZone::setState(IAS_zone_info_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::IAS_zone_info_state ZigbeeIASZone::getIASZoneState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    m_state = ZigbeeDevice::getIASZoneState(device, ZBO);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_IASZone.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_IASZone.h
new file mode 100644
index 000000000..82672a6b3
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_IASZone.h
@@ -0,0 +1,40 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_IASZONE_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_IASZONE_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeIASZone: public ZigbeeDevice
+{
+public:
+    ZigbeeIASZone();
+
+    IAS_zone_info_state m_state;
+    battery_state m_battery_state;
+    powersource_state m_powersource_state;
+
+    virtual void setState(IAS_zone_info_state state);
+    virtual IAS_zone_info_state getIASZoneState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > );
+};
+typedef std::shared_ptr< ZigbeeIASZone > ZigbeeIASZoneSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_IASZONE_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_MainsPowerOutlet.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_MainsPowerOutlet.cpp
new file mode 100644
index 000000000..706b314d4
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_MainsPowerOutlet.cpp
@@ -0,0 +1,49 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#include "../Zigbee_Devices/Zigbee_MainsPowerOutlet.h"
+
+ZigbeeMainsPowerOutlet::ZigbeeMainsPowerOutlet()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_SMARTPLUG_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(BINARY_SWITCH_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_BINARY_SWITCH);
+        resourceTypes[BINARY_SWITCH_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[BINARY_SWITCH_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeMainsPowerOutlet::setState(mains_power_outlet_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::mains_power_outlet_state ZigbeeMainsPowerOutlet::getMainsPowerOutletState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    m_state = ZigbeeDevice::getMainsPowerOutletState(device, ZBO);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_MainsPowerOutlet.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_MainsPowerOutlet.h
new file mode 100644
index 000000000..01b09e184
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_MainsPowerOutlet.h
@@ -0,0 +1,38 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_MAINSPOWEROUTLET_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_MAINSPOWEROUTLET_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeMainsPowerOutlet: public ZigbeeDevice
+{
+public:
+    ZigbeeMainsPowerOutlet();
+
+    mains_power_outlet_state m_state;
+
+    virtual void setState(mains_power_outlet_state state);
+    virtual mains_power_outlet_state getMainsPowerOutletState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > );
+};
+typedef std::shared_ptr< ZigbeeMainsPowerOutlet > ZigbeeMainsPowerOutletSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_MAINSPOWEROUTLET_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OccupancySensor.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OccupancySensor.cpp
new file mode 100644
index 000000000..33a376d01
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OccupancySensor.cpp
@@ -0,0 +1,49 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#include "../Zigbee_Devices/Zigbee_OccupancySensor.h"
+
+ZigbeeOccupancySensor::ZigbeeOccupancySensor()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_SENSOR_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(PRESENCE_SENSOR_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_PRESENCE_SENSOR);
+        resourceTypes[PRESENCE_SENSOR_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_SENSOR);
+        interfaces[PRESENCE_SENSOR_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeOccupancySensor::setState(occupancy_sensor_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::occupancy_sensor_state ZigbeeOccupancySensor::getOccupancySensorState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    m_state = ZigbeeDevice::getOccupancySensorState(device, ZBO);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OccupancySensor.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OccupancySensor.h
new file mode 100644
index 000000000..afd6c524c
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OccupancySensor.h
@@ -0,0 +1,38 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_OCCUPANCYSENSOR_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_OCCUPANCYSENSOR_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeOccupancySensor: public ZigbeeDevice
+{
+public:
+    ZigbeeOccupancySensor();
+
+    occupancy_sensor_state m_state;
+
+    virtual void setState(occupancy_sensor_state state);
+    virtual occupancy_sensor_state getOccupancySensorState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > );
+};
+typedef std::shared_ptr< ZigbeeOccupancySensor > ZigbeeOccupancySensorSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_OCCUPANCYSENSOR_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffLight.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffLight.cpp
new file mode 100644
index 000000000..5ceaa401e
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffLight.cpp
@@ -0,0 +1,50 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_OnoffLight.h"
+
+ZigbeeOnoffLight::ZigbeeOnoffLight()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_LIGHT_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(BINARY_SWITCH_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_BINARY_SWITCH);
+        resourceTypes[BINARY_SWITCH_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[BINARY_SWITCH_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeOnoffLight::setState(onoff_light_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::onoff_light_state ZigbeeOnoffLight::getOnoffLightState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    m_state = ZigbeeDevice::getOnoffLightState(device, ZBO);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffLight.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffLight.h
new file mode 100644
index 000000000..15f86d2a2
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffLight.h
@@ -0,0 +1,39 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_ONOFFLIGHT_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_ONOFFLIGHT_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeOnoffLight: public ZigbeeDevice
+{
+public:
+    ZigbeeOnoffLight();
+
+    onoff_light_state m_state;
+
+    virtual void setState(onoff_light_state state);
+    virtual onoff_light_state getOnoffLightState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > );
+};
+typedef std::shared_ptr< ZigbeeOnoffLight > ZigbeeOnoffLightSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_STUB_PLUGIN_ZIGBEE_OBJECTS_ZIGBEE_LIGHT_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffOutput.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffOutput.cpp
new file mode 100644
index 000000000..8099cfa24
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffOutput.cpp
@@ -0,0 +1,50 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_OnoffOutput.h"
+
+ZigbeeOnoffOutput::ZigbeeOnoffOutput()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_SMARTPLUG_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(BINARY_SWITCH_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_BINARY_SWITCH);
+        resourceTypes[BINARY_SWITCH_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[BINARY_SWITCH_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeOnoffOutput::setState(onoff_output_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::onoff_output_state ZigbeeOnoffOutput::getOnoffOutputState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    m_state = ZigbeeDevice::getOnoffOutputState(device, ZBO);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffOutput.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffOutput.h
new file mode 100644
index 000000000..9a60c4729
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_OnoffOutput.h
@@ -0,0 +1,37 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_ONOFFOUTPUT_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_ONOFFOUTPUT_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeOnoffOutput: public ZigbeeDevice
+{
+public:
+    ZigbeeOnoffOutput();
+
+    onoff_output_state m_state;
+
+    virtual void setState(onoff_output_state state);
+    virtual onoff_output_state getOnoffOutputState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > );
+};
+typedef std::shared_ptr< ZigbeeOnoffOutput > ZigbeeOnoffOutputSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_ONOFFOUTPUT_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_SmartPlug.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_SmartPlug.cpp
new file mode 100644
index 000000000..a3ac89d42
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_SmartPlug.cpp
@@ -0,0 +1,50 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_SmartPlug.h"
+
+ZigbeeSmartPlug::ZigbeeSmartPlug()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_SMARTPLUG_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(BINARY_SWITCH_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_BINARY_SWITCH);
+        resourceTypes[BINARY_SWITCH_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[BINARY_SWITCH_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeSmartPlug::setState(smart_plug_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::smart_plug_state ZigbeeSmartPlug::getSmartPlugState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    m_state = ZigbeeDevice::getSmartPlugState(device, ZBO);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_SmartPlug.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_SmartPlug.h
new file mode 100644
index 000000000..fee7866bc
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_SmartPlug.h
@@ -0,0 +1,38 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_SMARTPLUG_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_SMARTPLUG_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeSmartPlug: public ZigbeeDevice
+{
+public:
+    ZigbeeSmartPlug();
+
+    smart_plug_state m_state;
+
+    virtual void setState(smart_plug_state state);
+    virtual smart_plug_state getSmartPlugState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > );
+};
+typedef std::shared_ptr< ZigbeeSmartPlug > ZigbeeSmartPlugSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_SMARTPLUG_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_TemperatureSensor.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_TemperatureSensor.cpp
new file mode 100644
index 000000000..59f8a0488
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_TemperatureSensor.cpp
@@ -0,0 +1,51 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_TemperatureSensor.h"
+
+ZigbeeTemperatureSensor::ZigbeeTemperatureSensor()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_SENSOR_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(TEMPERATURE_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_TEMPERATURE);
+        resourceTypes[TEMPERATURE_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        iface.push_back(OC_RSRVD_INTERFACE_SENSOR);
+        interfaces[TEMPERATURE_RELATIVE_URI] = iface;
+    }
+}
+
+void ZigbeeTemperatureSensor::setState(temperature_sensor_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::temperature_sensor_state ZigbeeTemperatureSensor::getTemperatureSensorState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO)
+{
+    m_state = ZigbeeDevice::getTemperatureSensorState(device, ZBO);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_TemperatureSensor.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_TemperatureSensor.h
new file mode 100644
index 000000000..9729ab217
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_TemperatureSensor.h
@@ -0,0 +1,38 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_OBJECTS_ZIGBEE_TEMPERATURE_SENSOR_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_OBJECTS_ZIGBEE_TEMPERATURE_SENSOR_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeTemperatureSensor: public ZigbeeDevice
+{
+public:
+    ZigbeeTemperatureSensor();
+
+    temperature_sensor_state m_state;
+
+    virtual void setState(temperature_sensor_state state);
+    virtual temperature_sensor_state getTemperatureSensorState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > );
+};
+typedef std::shared_ptr< ZigbeeTemperatureSensor > ZigbeeTemperatureSensorSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_OBJECTS_ZIGBEE_TEMPERATURE_SENSOR_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_Thermostat.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_Thermostat.cpp
new file mode 100644
index 000000000..6299c4876
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_Thermostat.cpp
@@ -0,0 +1,73 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_Thermostat.h"
+
+ZigbeeThermostat::ZigbeeThermostat()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_THERMOSTAT_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(TEMPERATURE_RELATIVE_URI + "_info");
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_TEMPERATURE);
+        resourceTypes[TEMPERATURE_RELATIVE_URI + "_info"] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        iface.push_back(OC_RSRVD_INTERFACE_SENSOR);
+        interfaces[TEMPERATURE_RELATIVE_URI + "_info"] = iface;
+    }
+    resourceUris.push_back(TEMPERATURE_RELATIVE_URI + "_hot");
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_TEMPERATURE);
+        resourceTypes[TEMPERATURE_RELATIVE_URI + "_hot"] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        iface.push_back(OC_RSRVD_INTERFACE_SENSOR);
+        interfaces[TEMPERATURE_RELATIVE_URI + "_hot"] = iface;
+    }
+    resourceUris.push_back(TEMPERATURE_RELATIVE_URI + "_cool");
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_TEMPERATURE);
+        resourceTypes[TEMPERATURE_RELATIVE_URI + "_cool"] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        iface.push_back(OC_RSRVD_INTERFACE_SENSOR);
+        interfaces[TEMPERATURE_RELATIVE_URI + "_cool"] = iface;
+    }
+}
+
+void ZigbeeThermostat::setState(thermostat_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::thermostat_state ZigbeeThermostat::getThermostatState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string cluster)
+{
+    m_state = ZigbeeDevice::getThermostatState(device, ZBO, cluster);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_Thermostat.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_Thermostat.h
new file mode 100644
index 000000000..23e6bf5b7
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_Thermostat.h
@@ -0,0 +1,38 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_THERMOSTAT_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_THERMOSTAT_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeThermostat: public ZigbeeDevice
+{
+public:
+    ZigbeeThermostat();
+
+    thermostat_state m_state;
+
+    virtual void setState(thermostat_state state);
+    virtual thermostat_state getThermostatState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > , std::string );
+};
+typedef std::shared_ptr< ZigbeeThermostat > ZigbeeThermostatSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_THERMOSTAT_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_WindowCoveringDevice.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_WindowCoveringDevice.cpp
new file mode 100644
index 000000000..78fd60e23
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_WindowCoveringDevice.cpp
@@ -0,0 +1,90 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "../Zigbee_Devices/Zigbee_WindowCoveringDevice.h"
+
+ZigbeeWindowCoveringDevice::ZigbeeWindowCoveringDevice()
+{
+    // set OCF device type
+    OCFDeviceType = OIC_BLIND_DEVICE;
+
+    // set OCF resource uri(s) and its corresponding resource type(s) and interface(s)
+    resourceUris.push_back(WINDOW_COVERING_RELATIVE_URI);
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_WINDOWCOVERING);
+        resourceTypes[WINDOW_COVERING_RELATIVE_URI] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_READ_WRITE);
+        interfaces[WINDOW_COVERING_RELATIVE_URI] = iface;
+    }
+    resourceUris.push_back(OPENLEVEL_RELATIVE_URI + "_liftpercent");
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_OPENLEVEL);
+        resourceTypes[OPENLEVEL_RELATIVE_URI + "_liftpercent"] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[OPENLEVEL_RELATIVE_URI + "_liftpercent"] = iface;
+    }
+    resourceUris.push_back(OPENLEVEL_RELATIVE_URI + "_liftposition");
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_OPENLEVEL);
+        resourceTypes[OPENLEVEL_RELATIVE_URI + "_liftposition"] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[OPENLEVEL_RELATIVE_URI + "_liftposition"] = iface;
+    }
+    resourceUris.push_back(OPENLEVEL_RELATIVE_URI + "_tiltpercent");
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_OPENLEVEL);
+        resourceTypes[OPENLEVEL_RELATIVE_URI + "_tiltpercent"] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[OPENLEVEL_RELATIVE_URI + "_tiltpercent"] = iface;
+    }
+    resourceUris.push_back(OPENLEVEL_RELATIVE_URI + "_tiltdegree");
+    {
+        std::vector< std::string > rt;
+        rt.push_back(OIC_OPENLEVEL);
+        resourceTypes[OPENLEVEL_RELATIVE_URI + "_tiltdegree"] = rt;
+
+        std::vector< std::string > iface;
+        iface.push_back(OC_RSRVD_INTERFACE_ACTUATOR);
+        interfaces[OPENLEVEL_RELATIVE_URI + "_tiltdegree"] = iface;
+    }
+}
+
+void ZigbeeWindowCoveringDevice::setState(window_covering_device_state state)
+{
+    m_state = state;
+}
+
+ZigbeeDevice::window_covering_device_state ZigbeeWindowCoveringDevice::getWindowCoveringDeviceState(ZigbeeDeviceSharedPtr device, ZBOperationsSharedPtr ZBO, std::string cluster)
+{
+    m_state = ZigbeeDevice::getWindowCoveringDeviceState(device, ZBO, cluster);
+    return m_state;
+}
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_WindowCoveringDevice.h b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_WindowCoveringDevice.h
new file mode 100644
index 000000000..bf86b73c2
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Devices/Zigbee_WindowCoveringDevice.h
@@ -0,0 +1,38 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_WINDOWCOVERINGDEVICE_H_
+#define BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_WINDOWCOVERINGDEVICE_H_
+
+#include "Zigbee_Device.h"
+
+class ZigbeeWindowCoveringDevice: public ZigbeeDevice
+{
+public:
+    ZigbeeWindowCoveringDevice();
+
+    window_covering_device_state m_state;
+
+    virtual void setState(window_covering_device_state state);
+    virtual window_covering_device_state getWindowCoveringDeviceState(std::shared_ptr< ZigbeeDevice > , std::shared_ptr< ZBOperations > ,std::string );
+};
+typedef std::shared_ptr< ZigbeeWindowCoveringDevice > ZigbeeWindowCoveringDeviceSharedPtr;
+
+#endif /* BRIDGING_PLUGINS_ZIGBEE_PLUGIN_ZIGBEE_DEVICES_ZIGBEE_WINDOWCOVERINGDEVICE_H_ */
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Resource.cpp b/bridging/plugins/zigbee_plugin/Zigbee_Resource.cpp
new file mode 100644
index 000000000..8d4c01dc5
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Resource.cpp
@@ -0,0 +1,984 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include <stdio.h>
+#include <string.h>
+#include <string>
+#include <fstream>
+#include <iostream>
+#include <map>
+#include <memory>
+#include <set>
+#include <mutex>
+#include <assert.h>
+#include <pluginServer.h>
+#include "OCPlatform.h"
+#include "OCApi.h"
+#include "ocstack.h"
+#include "ocpayload.h"
+#include "ocresource.h"
+#include "ocresourcehandler.h"
+#include "oic_malloc.h"
+#include "oic_string.h"
+#include "ConcurrentIotivityUtils.h"
+#include "experimental/logger.h"
+#include "experimental/payload_logging.h"
+#include <sio_client.h>
+#include <functional>
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <thread>
+#include <signal.h>
+#include <unistd.h>
+#include <condition_variable>
+#include "Zigbee_Resource.h"
+#include "cloudresource.h"
+#include "Zigbee_Cloud.h"
+#include "deviceonboardingstate.h"
+#include "securevirtualresourcetypes.h"
+
+using namespace OC::Bridging;
+using namespace std;
+using namespace sio;
+
+#define TAG "ZIGBEE_PLUGIN"
+#define CTX_DEVICE_NAME         "OCF_Zigbee_Translator"
+#define CTX_DEVICE_TYPE         "oic.d.bridge"
+#define BM                  3
+#define ECO_SYSTEM "ZIGBEE"
+
+/*******************************************************************************
+ * global data goes here
+ ******************************************************************************/
+MPMPluginCtx *g_plugin_ctx = NULL;
+ZBOperationsSharedPtr ZBO;
+
+// This map is used to store the information of discovered zigbee devices.
+std::map< std::string, ZigbeeDeviceSharedPtr > g_discoveredDevicesMap;
+// This map is used to store the information of zigbee devices which are discovered and added by plugin.
+std::map< std::string, ZigbeeDeviceSharedPtr > addedDevices;
+std::vector< vodentry > g_vods;
+
+FILE *sec_file(const char *path, const char *mode)
+{
+    std::string filename;
+
+    if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    {
+        filename = std::string("zigbee_") + path;
+    }
+    else if (0 == strcmp(path, OC_INTROSPECTION_FILE_NAME))
+    {
+        filename = "bridge_introspection.dat";
+    }
+    return fopen(filename.c_str(), mode);
+}
+
+MPMResult pluginCreate(MPMPluginCtx **pluginSpecificCtx)
+{
+    if (g_plugin_ctx != NULL)
+    {
+        OIC_LOG(ERROR, TAG, "Plugin is already created.");
+
+        return MPM_RESULT_ALREADY_CREATED;
+    }
+    /* allocate a context structure for the plugin */
+    MPMPluginCtx *ctx = (MPMPluginCtx *) calloc(1, sizeof(MPMPluginCtx));
+
+    /* initialize the plugin context */
+    if (ctx == NULL)
+    {
+        OIC_LOG(ERROR, TAG, "Allocation of plugin context failed");
+        return MPM_RESULT_INTERNAL_ERROR;
+    }
+
+    *pluginSpecificCtx = ctx;
+    g_plugin_ctx = ctx;
+
+    ctx->device_name = CTX_DEVICE_NAME;
+    ctx->resource_type = CTX_DEVICE_TYPE;
+    ctx->open = sec_file;
+
+    // bind the resource type and interface of "/oic/d"
+    OCResourceHandle resourceHandle = OCGetResourceHandleAtUri(OC_RSRVD_DEVICE_URI);
+    OCBindResourceTypeToResource(resourceHandle, OIC_VIRTUAL_DEVICE.c_str());
+    OCBindResourceInterfaceToResource(resourceHandle, LINK_INTERFACE.c_str());
+
+    return MPM_RESULT_OK;
+}
+
+#ifdef SECURED
+void *shmaddr;
+void writeOwnedStateOnSharedMemory(bool state)
+{
+    char buf[1024];
+    strcpy(buf, (char *)shmaddr);
+    std::string strBuf = buf;
+
+    char pidBuf[8];
+    sprintf(pidBuf, "%d\t", getpid());
+    std::string pidStr = pidBuf;
+    std::string ownedState = state == true ? "T" : "F";
+    if(strBuf.find(pidStr) != std::string::npos)
+    {
+        strBuf.replace(strBuf.find(pidStr) + pidStr.length(), 1, ownedState);
+        strcpy((char *)shmaddr, strBuf.c_str());
+    }
+}
+
+void shm_listener()
+{
+    char buf[1024];
+    std::string strBuf;
+    OicSecDostype_t dos;
+    bool oldStateSelf=false;
+    while(1)
+    {
+        GetDos(&dos);
+//        std::cout << "Bridge's onboarding state: " << dos.state  << std::endl;
+
+        if(dos.state == DOS_RFPRO || dos.state == DOS_RFNOP)
+        {
+            writeOwnedStateOnSharedMemory(true);
+            std::cout << "Bridge's ownership status: Owned " << std::endl;
+            if(!oldStateSelf){
+                std::cout << "cloud!!"<<std::endl;
+                /*WITH_CLOUD option*/
+
+            #if WITH_CLOUD
+                condition_variable g_callbackLock;
+                std::mutex blocker;
+                std::unique_lock<std::mutex> lock(blocker);
+
+                // make coapcloudconf resource
+                InitCloudResource();
+                // Cloud settings - cloud sign up & sign in
+                Cloud_Settings cloud;
+
+                OCStackResult OC_res;
+                ResourceHandles resourceHandles;
+
+                resourceHandles.push_back(FindResourceByUri(OC_RSRVD_DEVICE_URI));
+
+                OC_res = cloud.publishResource(resourceHandles);
+
+                std::cout << " result: " << OC_res << std::endl;
+
+            #endif
+
+                oldStateSelf=true;
+            }
+        }
+        else
+        {
+            if(oldStateSelf) {
+                /*WITH_CLOUD option*/
+            #if WITH_CLOUD
+                DeInitCloudResource();
+            #endif
+                oldStateSelf=false;
+            }
+        }
+        strcpy(buf, (char *)shmaddr);
+        strBuf = buf;
+
+        // parse owned state of vods
+        while(1)
+        {
+            size_t tabIndex = strBuf.find("\t");
+            if(tabIndex != std::string::npos)
+            {
+                pid_t vodPid = std::stoi(strBuf.substr(0, tabIndex));
+                strBuf = strBuf.substr(tabIndex+1);
+                tabIndex = strBuf.find("\t");
+
+                bool ownedState = strBuf.substr(0, tabIndex) == "T" ? true : false;
+                strBuf = strBuf.substr(tabIndex+1);
+
+                for(auto it = addedDevices.begin(); it != addedDevices.end(); it++)
+                {
+                    ZigbeeDeviceSharedPtr device = it->second;
+                    if(device->getPid() == vodPid)
+                    {
+                        device->setOwnedState(ownedState);
+                    }
+                }
+
+                if(strBuf.length() < 2)
+                {
+                    break;
+                }
+            }
+            else
+            {
+                break;
+            }
+        }
+
+        sleep(3);
+    }
+}
+
+void createSharedMemoryForOwnedState()
+{
+    // create shared memory
+    int shm_size = 1024; // bytes
+    key_t key = ftok("shmfile_ownedstate", 1);;
+    int shmid = shmget(key, shm_size, IPC_CREAT|0666);
+    shmaddr = shmat(shmid, NULL, 0);
+
+    // initialize shared memory
+    char buf[1024];
+    strcpy(buf, (char *)shmaddr);
+    std::string strBuf = buf;
+
+    OicSecDostype_t dos;
+    GetDos(&dos);
+    if(dos.state == DOS_RFPRO || dos.state == DOS_RFNOP)
+    {
+        sprintf(buf, "%d\t%s\t", getpid(), "T");
+    }
+    else
+    {
+        sprintf(buf, "%d\t%s\t", getpid(), "F");
+    }
+
+    if(strBuf.find("\t") == std::string::npos) // for initial execution
+    {
+        strcpy((char *)shmaddr, buf);
+    }
+    else // for reconnection
+    {
+        pid_t vodPid = std::stoi(strBuf.substr(0, strBuf.find("\t")));
+        if(vodPid != getpid())
+        {
+            std::string newBuf = buf;
+            newBuf += strBuf.substr(strBuf.find("\t")+3);
+            strcpy((char *)shmaddr, newBuf.c_str());
+        }
+    }
+    // start listener for shared memory
+    std::thread t(shm_listener);
+    t.detach();
+}
+#endif
+
+MPMResult pluginStart(MPMPluginCtx *ctx)
+{
+
+    if (ctx->started)
+    {
+        OIC_LOG(INFO, TAG, "Plugin is already started.");
+        return MPM_RESULT_ALREADY_STARTED;
+    }
+
+    /* initialize settings to communicate (send zigbee command or receive status messages) Zigbee bridging gateway */
+    ZBO = std::make_shared< ZBOperations >();
+
+    ZBO->openSocket(ZIGBEE_GATEWAY_IP, ZIGBEE_GATEWAY_PORT);
+
+    ZBO->create_json_object();
+    ZBO->logstreamON();
+
+    ctx->stay_in_process_loop = true;
+    OIC_LOG(INFO, TAG, "pluginStart called!");
+
+    // generate vodlist resource
+    if (createVodListResource() != OC_STACK_OK)
+    {
+         OIC_LOG(ERROR, TAG, "Vodlist Resource creation was failed...");
+         return MPM_RESULT_INTERNAL_ERROR;
+    }
+
+    OCResourceHandle vodlistHandle = FindResourceByUri(VODLIST_URI);
+    OCBindResourceInterfaceToResource(vodlistHandle, OC_RSRVD_INTERFACE_READ);
+
+#ifdef SECURED
+    // create shared memory
+    createSharedMemoryForOwnedState();
+#endif
+
+    return MPM_RESULT_OK;
+}
+
+MPMResult pluginScan(MPMPluginCtx *, MPMPipeMessage *)
+{
+    std::vector< ZigbeeDeviceSharedPtr > devicesScanned;
+
+    /* discover new zigbee devices in the network and add them in the map */
+    MPMResult result = ZigbeeDevice::discoverZigbeeDevices(devicesScanned, ZBO);
+
+    /* iterate for every discovered device in the map */
+    for (uint32_t i = 0; i < devicesScanned.size(); ++i)
+    {
+        ZigbeeDeviceSharedPtr device = devicesScanned[i];
+
+        std::string nodeId = device->getNodeId();
+        std::cout << "[pluginScan]found ZigBee device's node ID = " << nodeId << std::endl;
+
+        if (g_discoveredDevicesMap.find(nodeId) != g_discoveredDevicesMap.end())
+        {
+            OIC_LOG_V(INFO, TAG, "Already found %s. Ignoring", nodeId.c_str());
+            continue;
+        }
+
+        g_discoveredDevicesMap[nodeId] = device;
+        MPMSendResponse(nodeId.c_str(), nodeId.size(), MPM_SCAN);
+    }
+    if (result != MPM_RESULT_OK)
+    {
+        OIC_LOG_V(ERROR, TAG, "Failed to fetch resources with error (%d)", result);
+        return MPM_RESULT_INTERNAL_ERROR;
+    }
+
+    return MPM_RESULT_OK;
+}
+
+MPMResult pluginAdd(MPMPluginCtx *, MPMPipeMessage *message)
+{
+    if (message->payloadSize <= 0 && message->payload == NULL)
+    {
+        OIC_LOG(ERROR, TAG, "No payload received, failed to add device");
+        return MPM_RESULT_INTERNAL_ERROR;
+    }
+
+    MPMResourceList *list = NULL;
+    MPMResult result = MPM_RESULT_INTERNAL_ERROR;
+
+    std::string nodeId = reinterpret_cast< const char* >(message->payload);
+
+    if (addedDevices.find(nodeId) != addedDevices.end())
+    {
+        OIC_LOG_V(ERROR, TAG, "%s already added", nodeId.c_str());
+        return MPM_RESULT_ALREADY_CREATED;
+    }
+    if (g_discoveredDevicesMap.find(nodeId) == g_discoveredDevicesMap.end())
+    {
+        OIC_LOG_V(ERROR, TAG, "%s was NOT discovered in a scan", nodeId.c_str());
+        std::cout << nodeId.c_str() << "was NOT discovered in a scan" << std::endl;
+        return result;
+    }
+
+    addedDevices[nodeId] = g_discoveredDevicesMap[nodeId];
+
+    uint8_t *buff = (uint8_t *) OICCalloc(1, MPM_MAX_METADATA_LEN);
+    if (buff == NULL)
+    {
+        OIC_LOG_V(ERROR, TAG, "Calloc failed %s", strerror(errno));
+        return MPM_RESULT_OUT_OF_MEMORY;
+    }
+    size_t size = MPM_MAX_METADATA_LEN;
+
+    ZigbeeDeviceSharedPtr device = addedDevices[nodeId];
+    ZBDeviceDetails deviceDetails;
+    MPMDeviceSpecificData deviceConfiguration;
+
+    memset(&deviceDetails, 0, sizeof(ZBDeviceDetails));
+    memset(&deviceConfiguration, 0, sizeof(MPMDeviceSpecificData));
+
+    /* create resources: zigbee device resource, core (platform, device, and configuration info.) resources */
+    std::cout << "createVirtualServer in pluginAdd" << std::endl;
+    createVirtualServer(nodeId);
+
+    OICStrcpy(deviceDetails.summary_info.nodeId, MPM_MAX_LENGTH_32, (device->getNodeId()).c_str());
+    OICStrcpy(deviceDetails.summary_info.deviceType, MPM_MAX_LENGTH_64,
+            (device->getDeviceType()).c_str());
+    OICStrcpy(deviceDetails.summary_info.eui64, MPM_MAX_UNIQUE_ID_LEN,
+            (device->getEui64()).c_str());
+    deviceDetails.summary_info.pid = device->getPid();
+    OICStrcpy(deviceDetails.summary_info.name, MPM_MAX_LENGTH_64, (device->getName()).c_str());
+    OICStrcpy(deviceDetails.summary_info.eco_system, MPM_MAX_LENGTH_64, (std::string(ECO_SYSTEM)).c_str());
+    OICStrcpy(deviceDetails.summary_info.di, MAX_IDENTITY_SIZE, (device->getProtocolIndependentId().c_str()));
+
+    /* make a vodentry and save to g_vods */
+    vodentry ve;
+    ve.n = deviceDetails.summary_info.name;
+    ve.di = deviceDetails.summary_info.di;
+    ve.econame = deviceDetails.summary_info.eco_system;
+    g_vods.push_back(ve);
+
+    deviceDetails.device_info.deviceName = device->getName();
+    deviceDetails.device_info.manufacturerName = device->getManufacturerName();
+
+    /* create and form metadata for RECONNECT */
+    createMetaData(nodeId, device, list);
+
+    OICStrcpy(deviceConfiguration.devName, MPM_MAX_LENGTH_64,
+            deviceDetails.device_info.deviceName.c_str());
+    OICStrcpy(deviceConfiguration.devType, MPM_MAX_LENGTH_64,
+            deviceDetails.summary_info.deviceType);
+    OICStrcpy(deviceConfiguration.manufacturerName, MPM_MAX_LENGTH_256,
+            deviceDetails.device_info.manufacturerName.c_str());
+
+    MPMFormMetaData(list, &deviceConfiguration, buff, size, &(deviceDetails.summary_info),
+            sizeof(deviceDetails.summary_info));
+
+    MPMAddResponse response;
+    memset(&response, 0, sizeof(MPMAddResponse));
+    OICStrcpy(response.uri, MPM_MAX_URI_LEN, nodeId.c_str());
+    memcpy(response.metadata, buff, MPM_MAX_METADATA_LEN);
+    size_t response_size = sizeof(MPMAddResponse);
+
+    MPMSendResponse(&response, response_size, MPM_ADD);
+    OICFree(buff);
+
+    return MPM_RESULT_OK;
+}
+
+MPMResult pluginRemove(MPMPluginCtx *, MPMPipeMessage *message)
+{
+    if (message->payloadSize <= 0 && message->payload == NULL)
+    {
+        OIC_LOG(ERROR, TAG, "No payload received, failed to remove device");
+        return MPM_RESULT_INTERNAL_ERROR;
+    }
+    std::string nodeId = reinterpret_cast< const char * >(message->payload);
+    OIC_LOG_V(DEBUG, TAG, "device nodeId to be removed - %s ", nodeId.c_str());
+
+    if (addedDevices.find(nodeId) == addedDevices.end())
+    {
+        OIC_LOG(ERROR, TAG, "Device to be removed is not added yet");
+        return MPM_RESULT_NOT_PRESENT;
+    }
+
+    ZigbeeDeviceSharedPtr device = addedDevices[nodeId];
+
+    /* delete existing resources */
+    deleteVirtualServer(device->getPid());
+
+    /* delete vodentry from g_vods */
+    for (std::vector< vodentry >::size_type i = 0 ; i < g_vods.size() ; )
+    {
+        if(g_vods[i].di == device->getProtocolIndependentId())
+        {
+            g_vods.erase(g_vods.begin() + i);
+        }
+        else
+        {
+            i++;
+        }
+    }
+
+    addedDevices.erase(nodeId);
+
+    MPMSendResponse(nodeId.c_str(), nodeId.size(), MPM_REMOVE);
+    return MPM_RESULT_OK;
+
+    OIC_LOG(INFO, TAG,
+            "Remove called! Remove iotivity resources here based on what the client says");
+    return MPM_RESULT_OK;
+}
+
+MPMResult pluginReconnect(MPMPluginCtx *, MPMPipeMessage *message)
+{
+    if (message->payloadSize <= 0 && message->payload == NULL)
+    {
+        OIC_LOG(ERROR, TAG, "No paylaod received, failed to reconnect");
+        return MPM_RESULT_INTERNAL_ERROR;
+    }
+
+    MPMResourceList *list = NULL, *temp = NULL;
+    void *pluginSpecificDetails = NULL;
+
+    MPMParseMetaData(message->payload, MPM_MAX_METADATA_LEN, &list, &pluginSpecificDetails);
+
+    ZBSummaryInfo *zbSummary = (ZBSummaryInfo *) pluginSpecificDetails;
+
+    ZigbeeDeviceSharedPtr device = std::make_shared< ZigbeeDevice >();;
+
+    // get nodeId, deviceType, eui64, uri from reconnect DB
+    device->setNodeId(std::string(zbSummary->nodeId));
+    device->setDeviceType(std::string(zbSummary->deviceType));
+    device->setEui64(std::string(zbSummary->eui64));
+    device->setPid(zbSummary->pid);
+    device->setName(std::string(zbSummary->name));
+    device->setEcoSystem(std::string(ECO_SYSTEM));
+    device->setProtocolIndependentId(std::string(zbSummary->di));
+
+    // make a vodentry and save to g_vods
+    vodentry ve;
+    ve.n = zbSummary->name;
+    ve.di = zbSummary->di;
+    ve.econame = zbSummary->eco_system;
+    g_vods.push_back(ve);
+
+    // get information of core resources by ZB command
+    getCoreResourceInfo(device);
+
+    std::string nodeId = device->getNodeId();
+
+    /* create resources based on meta data */
+    g_discoveredDevicesMap[nodeId] = device;
+    addedDevices[nodeId] = g_discoveredDevicesMap[nodeId];
+
+    while (list)
+    {
+        temp = list;
+        list = list->next;
+        OICFree(temp);
+    }
+
+    free(zbSummary);
+
+    return MPM_RESULT_OK;
+}
+
+MPMResult pluginStop(MPMPluginCtx *pluginSpecificCtx)
+{
+    MPMPluginCtx *ctx = pluginSpecificCtx;
+
+    if (NULL != ctx && g_plugin_ctx != NULL)
+    {
+        // clear global members
+        addedDevices.clear();
+        g_discoveredDevicesMap.clear();
+        g_vods.clear();
+//        shmdt(shmaddr);
+
+        if (ctx->started)
+        {
+            ctx->stay_in_process_loop = false;
+            pthread_join(ctx->thread_handle, NULL);
+            ctx->started = false;
+        }
+    }
+
+    return MPM_RESULT_OK;
+}
+
+MPMResult pluginDestroy(MPMPluginCtx *ctx)
+{
+    MPMResult result = MPM_RESULT_INTERNAL_ERROR;
+
+    if (ctx != NULL && g_plugin_ctx != NULL)
+    {
+        result = MPM_RESULT_OK;
+        if (ctx->started == true)
+        {
+            result = pluginStop(ctx);
+        }
+
+        /* freeing the resource allocated in create */
+        OICFree(ctx);
+        g_plugin_ctx = NULL;
+    }
+
+    ZBO->closeSocket();
+
+    OIC_LOG_V(INFO, TAG, "Plugin destroy's return value:%d", result);
+
+    return (result);
+}
+
+void setArgValue(char **arg, std::string value)
+{
+    *arg = new char[value.size() + 1];
+    strcpy(*arg, value.c_str());
+}
+
+MPMResult createVirtualServer(std::string nodeId)
+{
+    ZigbeeDeviceSharedPtr device = addedDevices[nodeId];
+
+    // execute json to cbor
+    pid_t pid = fork();
+    if (pid < 0)
+    {
+        std::cout << "fork error" << std::endl;
+        exit(0);
+    }
+    if (pid == 0)
+    {
+        // get json2cbor path
+        char buf[128];
+        std::string path(getcwd(buf, 128));
+        std::string json2cbor_path = path.substr(0, path.find("/bridging/")).append(
+                JSON2CBOR_RELATIVE_PATH).append(JSON2CBOR);
+
+        std::string src_svrDB_json_path = path.substr(0, path.find("/out/")).append(
+                ZIGBEE_PLUGIN_RELATIVE_PATH).append("zigbee_oic_virtualsvr_db.json");
+        std::string des_svrDB_cbor_path = path.substr(0, path.find("/bridging/")).append(
+                MPM_CLIENT_RELATIVE_PATH).append("zigbee_oic_virtualsvr_db_").append(nodeId).append(".dat");
+        execl(json2cbor_path.c_str(), JSON2CBOR.c_str(), src_svrDB_json_path.c_str(),
+                des_svrDB_cbor_path.c_str(), NULL);
+    }
+
+    pid = fork();
+    if (pid < 0)
+    {
+        std::cout << "fork error" << std::endl;
+        exit(0);
+    }
+    if (pid == 0)
+    {
+        // get json2cbor path
+        char buf[128];
+        std::string path(getcwd(buf, 128));
+        std::string json2cbor_path = path.substr(0, path.find("/bridging/")).append(
+                JSON2CBOR_RELATIVE_PATH).append(JSON2CBOR);
+
+        std::string src_introspection_json_path = path.substr(0, path.find("/out/")).append(
+                               ZIGBEE_PLUGIN_RELATIVE_PATH).append(IDD_RELATIVE_PATH);
+        if(device->getDeviceType() == DEVICE_TYPE_ONOFF_LIGHT)
+        {
+            src_introspection_json_path.append("zigbee_OnoffLight_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_COLOR_TEMPERATURE_LIGHT)
+        {
+            src_introspection_json_path.append("zigbee_ColorTepmeratureLight_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_EXTENDED_COLOR_LIGHT)
+        {
+            src_introspection_json_path.append("zigbee_ExtendedColorLight_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_DIMMABLE_LIGHT)
+        {
+            src_introspection_json_path.append("zigbee_DimmableLight_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_COLOR_DIMMABLE_LIGHT)
+        {
+            src_introspection_json_path.append("zigbee_ColorDimmableLight_introspection.json");
+        }
+        else if(device->getDeviceType() == DEVICE_TYPE_TEMPERATURE_SENSOR)
+        {
+            src_introspection_json_path.append("zigbee_TemperatureSensor_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_THERMOSTAT)
+        {
+            src_introspection_json_path.append("zigbee_Thermostat_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_WINDOW_COVERING_DEVICE)
+        {
+            src_introspection_json_path.append("zigbee_WindowCoveringDevice_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_SMART_PLUG)
+        {
+            src_introspection_json_path.append("zigbee_SmartPlug_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_MAINS_POWER_OUTLET)
+        {
+            src_introspection_json_path.append("zigbee_MainsPowerOutlet_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_ONOFF_OUTPUT)
+        {
+            src_introspection_json_path.append("zigbee_OnoffOutput_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_IAS_ZONE)
+        {
+            src_introspection_json_path.append("zigbee_IASZone_introspection.json");
+        }
+        else if (device->getDeviceType() == DEVICE_TYPE_OCCUPANCY_SENSOR)
+        {
+            src_introspection_json_path.append("zigbee_OccupancySensor_introspection.json");
+        }
+
+        std::string des_introspection_cbor_path = path.substr(0, path.find("/bridging/")).append(
+                   MPM_CLIENT_RELATIVE_PATH).append("virtualsvr_introspection_").append(nodeId).append(".dat");
+        execl(json2cbor_path.c_str(), JSON2CBOR.c_str(), src_introspection_json_path.c_str(),
+                   des_introspection_cbor_path.c_str(), NULL);
+    }
+
+    sleep(2);
+
+    // execute virtual server
+    if (pid != 0)
+    {
+        pid = fork();
+        if (pid < 0)
+        {
+            std::cout << "fork error" << std::endl;
+            exit(0);
+        }
+        if (pid == 0)
+        {
+            // get virtual server path
+            char buf[128];
+            std::string path(getcwd(buf, 128));
+            path = path.substr(0, path.find("/bridging/")).append(VIRTUAL_SERVER_RELATIVE_PATH).append(
+                            VIRTUAL_SERVER);
+
+            // array of args for executing the virtual server
+            char *argv[12];
+            argv[0] = (char *) VIRTUAL_SERVER.c_str();
+            setArgValue(&argv[1], device->getNodeId());
+            setArgValue(&argv[2], device->getDeviceType());
+            setArgValue(&argv[3], device->getEui64());
+            setArgValue(&argv[4], device->getName());
+            setArgValue(&argv[5], device->getSoftwareVersion());
+            setArgValue(&argv[6], device->getManufacturerName());
+            setArgValue(&argv[7], device->getModelNumber());
+            setArgValue(&argv[8], device->getProtocolIndependentId());
+            setArgValue(&argv[9], device->getPlatformId());
+            setArgValue(&argv[10], device->getHardwareVersion());
+            argv[11] = NULL;
+
+            // execute virtual server with argv
+            execv(path.c_str(), argv);
+        }
+        else
+        {
+            std::cout << "child process pid = " << pid << std::endl;
+            device->setPid(pid); // here, pid is the pid for child process
+        }
+    }
+
+    return MPM_RESULT_OK;
+}
+
+#ifdef SECURED
+void deleteOwnedStateOnSharedMemory(pid_t pid)
+{
+    char buf[1024];
+    strcpy(buf, (char *)shmaddr);
+    std::string strBuf = buf;
+    std::string newBuf = "";
+
+    while(1)
+    {
+        if(strBuf.find("\t") == std::string::npos)
+        {
+            break;
+        }
+
+        if(std::stoi(strBuf.substr(0, strBuf.find("\t"))) != pid)
+        {
+            newBuf += strBuf.substr(0, strBuf.find("\t"));
+            newBuf += "\t";
+            strBuf = strBuf.substr(strBuf.find("\t")+1);
+            newBuf += strBuf.substr(0, 2);
+            strBuf = strBuf.substr(2);
+        }
+        else
+        {
+            strBuf = strBuf.substr(strBuf.find("\t")+3);
+        }
+    }
+
+    strcpy((char *)shmaddr, newBuf.c_str());
+}
+#endif
+
+MPMResult deleteVirtualServer(pid_t pid)
+{
+#ifdef SECURED
+    deleteOwnedStateOnSharedMemory(pid);
+#endif
+    kill(pid, SIGUSR1);
+    sleep(2);
+
+    return MPM_RESULT_OK;
+}
+
+
+MPMResult createPayloadForMetaData(MPMResourceList **list, const std::string &configURI,
+        const std::string rt, const std::string res_if)
+{
+    MPMResourceList *temp = (MPMResourceList *) OICCalloc(1, sizeof(MPMResourceList));
+    if (temp == NULL)
+    {
+        OIC_LOG_V(ERROR, TAG, "Calloc failed for createPayloadForMetaData %s", strerror(errno));
+        return MPM_RESULT_OUT_OF_MEMORY;
+    }
+
+    OICStrcpy(temp->rt, MPM_MAX_LENGTH_64, rt.c_str());
+    OICStrcpy(temp->href, MPM_MAX_URI_LEN, configURI.c_str());
+    OICStrcpy(temp->interfaces, MPM_MAX_LENGTH_64, res_if.c_str());
+    temp->bitmap = BM;
+
+    temp->next = *list;
+    *list = temp;
+    return MPM_RESULT_OK;
+}
+
+MPMResult createMetaData(const std::string &nodeId, ZigbeeDeviceSharedPtr device,
+        MPMResourceList *list)
+{
+    MPMResult result = MPM_RESULT_INTERNAL_ERROR;
+
+    for (uint32_t i = 0 ; i < device->resourceUris.size(); ++i)
+    {
+        std::vector< std::string > rt = device->resourceTypes[device->resourceUris[i]];
+        std::vector< std::string > iface = device->interfaces[device->resourceUris[i]];
+
+        for (uint32_t j = 0 ; j < rt.size(); ++j)
+        {
+            for (uint32_t k = 0 ; k < iface.size(); ++k)
+            {
+                result = createPayloadForMetaData(&list, nodeId + device->resourceUris[i],
+                        rt[j], iface[k]);
+
+                if (result != MPM_RESULT_OK)
+                {
+                    OIC_LOG_V(ERROR, TAG, " Failed creating device resource payload for metadata");
+                    return result;
+                }
+            }
+        }
+    }
+
+    result = createPayloadForMetaData(&list, nodeId + OC_RSRVD_DEVICE_URI,
+            OC_RSRVD_RESOURCE_TYPE_DEVICE, OC_RSRVD_INTERFACE_DEFAULT);
+    if (result != MPM_RESULT_OK)
+    {
+        OIC_LOG_V(ERROR, TAG, " Failed creating device info. core resource payload for metadata");
+        return result;
+    }
+
+    result = createPayloadForMetaData(&list, nodeId + OC_RSRVD_PLATFORM_URI,
+            OC_RSRVD_RESOURCE_TYPE_PLATFORM, OC_RSRVD_INTERFACE_DEFAULT);
+    if (result != MPM_RESULT_OK)
+    {
+        OIC_LOG_V(ERROR, TAG, " Failed creating platform info. core resource payload for metadata");
+        return result;
+    }
+
+    result = createPayloadForMetaData(&list, nodeId + CONFIGURATION_URI,
+            OC_RSRVD_RESOURCE_TYPE_CONFIGURATION, OC_RSRVD_INTERFACE_DEFAULT);
+    if (result != MPM_RESULT_OK)
+    {
+        OIC_LOG_V(ERROR, TAG,
+                " Failed creating configuration info. core resource payload for metadata");
+        return result;
+    }
+    return result;
+}
+
+void getCoreResourceInfo(ZigbeeDeviceSharedPtr device)
+{
+    device->setModelNumber(device->getModelNumberByZBC(device, ZBO));
+    device->setName(device->getNameByZBC(device, ZBO));
+    device->setSoftwareVersion(device->getSoftwareVersionByZBC(device, ZBO));
+    device->setManufacturerName(device->getManufacturerNameByZBC(device, ZBO));
+    device->setPlatformId(device->getPlatformIdByZBC(device, ZBO));
+    device->setProtocolIndependentId(device->getProtocolIndependentIdByZBC(device, ZBO));
+    device->setHardwareVersion(device->getHardwareVersionByZBC(device, ZBO));
+}
+
+bool isSecureEnvironmentSet()
+{
+    char *non_secure_env = getenv("NONSECURE");
+
+    if (non_secure_env && !strcmp(non_secure_env, "true"))
+    {
+        OIC_LOG_V(INFO, TAG, "Creating NON SECURE resources");
+        return false;
+    } OIC_LOG_V(INFO, TAG, "Creating SECURE resources");
+    return true;
+}
+
+bool isOwned(std::string di)
+{
+#ifndef SECURED
+    return true;
+#endif
+
+    bool ownedState = false;
+
+    for(auto it = addedDevices.begin(); it != addedDevices.end(); it++)
+    {
+        ZigbeeDeviceSharedPtr device = it->second;
+        if(device->getProtocolIndependentId() == di)
+        {
+            ownedState = device->getOwnedState();
+            break;
+        }
+    }
+
+    return ownedState;
+}
+
+OCRepresentation getVodlistRepresentation()
+{
+    OCRepresentation rep;
+
+    std::vector< OCRepresentation > vods;
+    for (std::vector< vodentry >::size_type i = 0 ; i < g_vods.size() ; ++i)
+    {
+        if(isOwned(g_vods[i].di))
+        {
+            OCRepresentation vodRep;
+            vodRep.setValue("n", g_vods[i].n);
+            vodRep.setValue("di", g_vods[i].di);
+            vodRep.setValue("econame", g_vods[i].econame);
+            vods.push_back(vodRep);
+        }
+    }
+
+    rep.setValue("vods", vods);
+
+    return rep;
+}
+
+OCEntityHandlerResult vodlistEntityHandler(std::shared_ptr< OCResourceRequest > request)
+    {
+        OCEntityHandlerResult ehResult = OC_EH_ERROR;
+        if (request)
+        {
+            // Get the request type and request flag
+            std::string requestType = request->getRequestType();
+            int requestFlag = request->getRequestHandlerFlag();
+
+            if (requestFlag & RequestHandlerFlag::RequestFlag)
+            {
+                auto pResponse = std::make_shared< OCResourceResponse >();
+                pResponse->setRequestHandle(request->getRequestHandle());
+                pResponse->setResourceHandle(request->getResourceHandle());
+
+                // If the request type is GET
+                if (requestType == "GET")
+                {
+                    pResponse->setResponseResult(OC_EH_OK);
+                    pResponse->setResourceRepresentation(getVodlistRepresentation());
+                    if (OC_STACK_OK == OCPlatform::sendResponse(pResponse))
+                    {
+                        ehResult = OC_EH_OK;
+                    }
+                }
+            }
+        }
+        else
+        {
+            std::cout << "Request invalid" << std::endl;
+        }
+
+        return ehResult;
+}
+
+OCStackResult createVodListResource()
+{
+    // generate configuration resource
+    uint8_t resourceProperties = OC_DISCOVERABLE;
+    if (isSecureEnvironmentSet())
+    {
+        resourceProperties |= OC_SECURE;
+    }
+
+    // This will internally create and register the resource.
+    OCResourceHandle handle;
+    std::string vodlistUri = VODLIST_URI;
+
+    OCStackResult result = OCPlatform::registerResource(
+            handle, vodlistUri, OIC_VODLIST,
+            DEFAULT_INTERFACE, vodlistEntityHandler, resourceProperties);
+
+    return result;
+}
+
diff --git a/bridging/plugins/zigbee_plugin/Zigbee_Resource.h b/bridging/plugins/zigbee_plugin/Zigbee_Resource.h
new file mode 100644
index 000000000..40d900216
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/Zigbee_Resource.h
@@ -0,0 +1,150 @@
+//******************************************************************
+//
+// Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "Zigbee_Device.h"
+
+#ifndef _ZIGBEE_RESOURCE_H
+#define _ZIGBEE_RESOURCE_H
+
+/* pre-configured Network address of Bridging device */
+// change the IP address according to network information ZIGBEE GATEWAY
+static const std::string ZIGBEE_GATEWAY_IP = "192.168.0.18";
+// This port number is pre-fixed in the SILICON LABS zigbee Wi-Fi/Ethernet gateway (RD-0001-0201, RD-0002-0201)
+static const std::string ZIGBEE_GATEWAY_PORT = "9010";
+
+static std::string ZIGBEE_PLUGIN_RELATIVE_PATH = "/bridging/plugins/zigbee_plugin/";
+static std::string MPM_CLIENT_RELATIVE_PATH = "/bridging/mpm_client/";
+static std::string IDD_RELATIVE_PATH = "idd/";
+
+// path for json2cbor
+static std::string JSON2CBOR = "json2cbor";
+static std::string JSON2CBOR_RELATIVE_PATH = "/resource/csdk/security/tool/";
+
+// path for virtual server
+static std::string VIRTUAL_SERVER = "virtualserver";
+static std::string VIRTUAL_SERVER_RELATIVE_PATH = "/bridging/plugins/zigbee_plugin/virtual_server/";
+
+// To represent configuration resource
+#define CONFIGURATION_URI      "/con"
+#define OC_RSRVD_RESOURCE_TYPE_CONFIGURATION "oic.wk.con"
+#define OIC_RSRC_PSTAT_URI  "/oic/sec/pstat"
+#define OIC_RSRC_SP_URI     "/oic/sec/sp"
+#define OIC_RSRC_ACL2_URI   "/oic/sec/acl2"
+#define OIC_RSRC_CRED_URI   "/oic/sec/cred"
+#define OIC_RSRC_CRL_URI    "/oic/sec/crl"
+#define OIC_RSRC_CSR_URI    "/oic/sec/csr"
+#define OIC_RSRC_ROLES_URI  "/oic/sec/roles"
+#define OIC_RSRC_DOXM_URI   "/oic/sec/doxm"
+
+// To represent vodlist resource
+#define VODLIST_URI     "/vodlist"
+#define OIC_VODLIST     "oic.r.vodlist"
+
+// Structure used in Put_request to get the appropriate attribute Values
+typedef struct
+{
+    std::string deviceName;
+    std::string specVersion;
+    std::string deviceId;
+    std::string protocolIndependentId;
+    std::string dataModelVersion;
+    std::string localizedDescription;
+    std::string softwareVersion;
+    std::string manufacturerName;
+    std::string modelNumber;
+} ZBDeviceInfo;
+
+typedef struct
+{
+    std::string platformId;
+    std::string manufacturerName;
+    std::string manufacturerUrl;
+    std::string modelNumber;
+    std::string dateOfManufacture;
+    std::string platformVersion;
+    std::string operatingSystemVersion;
+    std::string hardwareVersion;
+    std::string firmwareVersion;
+    std::string supportUrl;
+    std::string systemTime;
+    std::string vendorId;
+} ZBPlatformInfo;
+
+typedef struct
+{
+    std::string deviceName;
+    std::string location;
+    std::string locationName;
+    std::string currency;
+    std::string region;
+    std::string localizedNames;
+    std::string defaultLanguage;
+
+} ZBConfigInfo;
+
+typedef struct
+{
+    char nodeId[MPM_MAX_LENGTH_32];
+    char deviceType[MPM_MAX_LENGTH_64];
+    char eui64[MPM_MAX_UNIQUE_ID_LEN];
+    pid_t pid;
+    char name[MPM_MAX_LENGTH_64];
+    char eco_system[MPM_MAX_LENGTH_64];
+    char di[MAX_IDENTITY_SIZE];
+} ZBSummaryInfo;
+
+typedef struct
+{
+    ZBDeviceInfo device_info;
+    ZBPlatformInfo platform_info;
+    ZBConfigInfo config_info;
+    ZBSummaryInfo summary_info;
+} ZBDeviceDetails;
+
+typedef struct
+{
+    std::string n;
+    std::string di;
+    std::string econame;
+} vodentry;
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+OCStackResult createVodListResource();
+
+MPMResult createVirtualServer(std::string nodeId);
+
+MPMResult deleteVirtualServer(pid_t pid);
+
+MPMResult createPayloadForMetaData(MPMResourceList **list, const std::string &configURI,
+        const std::string rt, const std::string res_if);
+
+MPMResult createMetaData(const std::string &uri, ZigbeeDeviceSharedPtr device,
+        MPMResourceList *list);
+
+void getCoreResourceInfo(ZigbeeDeviceSharedPtr device);
+
+void createSharedMemoryForOwnedState();
+void writeOwnedStateOnSharedMemory(bool state);
+void deleteOwnedStateOnSharedMemory(pid_t pid);
+
+#endif
diff --git a/bridging/plugins/zigbee_plugin/bridge_introspection.dat b/bridging/plugins/zigbee_plugin/bridge_introspection.dat
new file mode 100644
index 0000000000000000000000000000000000000000..dc6abdf90a6900b29eeca14a00582ed760de53db
GIT binary patch
literal 154
zcmZvT!41P83;<Wj1eA6oWDK|^*uqY#PSa5sjU-Z^eV*=aWPOL6vBSgpNG<U|BdgeP
z75gkdyCkZZckD{s(tdZ|`I!|8uBhKw%w!herrX65L@GhBGrm2Q+bq&KZt&Nk1S>k`
MD`KKX*L2c60F^RB)&Kwi

literal 0
HcmV?d00001

diff --git a/bridging/plugins/zigbee_plugin/bridge_introspection.json b/bridging/plugins/zigbee_plugin/bridge_introspection.json
new file mode 100644
index 000000000..5fb534925
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/bridge_introspection.json
@@ -0,0 +1,15 @@
+{
+  "swagger" : "2.0",
+  "info" : {
+    "title" : "empty swagger file",
+    "version" : "v1.0.0"
+  },
+  "schemes" : ["http"],
+  "consumes" : ["application/json"],
+  "produces" : ["application/json"],
+  "paths" : {
+    
+  },
+  "definitions" : {
+  }
+}
\ No newline at end of file
diff --git a/bridging/plugins/zigbee_plugin/cloud/Zigbee_Cloud.cpp b/bridging/plugins/zigbee_plugin/cloud/Zigbee_Cloud.cpp
new file mode 100644
index 000000000..d4655d23b
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/cloud/Zigbee_Cloud.cpp
@@ -0,0 +1,132 @@
+#include "Zigbee_Cloud.h"
+#include <sstream>
+
+condition_variable g_callbackLock;
+string g_accesstoken="";
+string g_uid="";
+
+Cloud_Settings::Cloud_Settings()
+{
+
+    std::mutex blocker;
+    std::unique_lock < std::mutex > lock(blocker);
+    std::string CLOUD_SERVER_IP="";
+    std::string CLOUD_SERVER_PORT="";    // multicast port
+    std::string AUTH_PROVIDER="";
+    g_authcode="";
+    std::string input_string;
+    stringstream ss;
+
+    /*ex)cloud server ip : 192.168.0.66, port : 5683(iotivity cloud), github, 3db50c8a8ee2de081f6f
+    input: 192.168.0.66 5683 github 3db50c8a8ee2de081f6f*/
+    cout << "input cloud \"server_IP server_port auth_provider authcode\"" << endl;
+    cin>>CLOUD_SERVER_IP;
+    cin>>CLOUD_SERVER_PORT;
+    cin>>AUTH_PROVIDER;
+    cin>>g_authcode;
+
+    g_host = "coap+tcp://";
+    g_host += CLOUD_SERVER_IP + ":" + CLOUD_SERVER_PORT;
+
+    // construct account manager for cloud
+    accountMgr = OCPlatform::constructAccountManagerObject(g_host, CT_ADAPTER_TCP);
+    // cloud sign up (auth by github)
+    accountMgr->signUp(AUTH_PROVIDER, g_authcode, &handleLoginoutCB);
+    g_callbackLock.wait(lock);
+    cout << "signUp Done" << endl;
+
+    // cloud sign in (with uid & accesstoken)
+    if(g_accesstoken!=""){
+        accountMgr->signIn(g_uid, g_accesstoken, &handleLoginoutCB);
+        g_callbackLock.wait(lock);
+        cout << "signIn Done" << endl;
+    }
+    else {
+        cout << "unsuccessful sign up!" << endl;
+    }
+
+}
+
+// publish resource to resource directory in cloud
+OCStackResult Cloud_Settings::publishResource(ResourceHandles resourceHandles)
+{
+    OCStackResult OC_res = RDClient::Instance().publishResourceToRD(g_host,
+            OCConnectivityType::CT_ADAPTER_TCP, resourceHandles, &onPublish);
+
+    return OC_res;
+}
+
+// publish callback function(called by publishResource) - get result code
+void onPublish(const OCRepresentation &, const int &eCode)
+{
+    cout << "Publish resource response received, code: " << eCode << endl;
+
+    g_callbackLock.notify_all();
+}
+
+// print Representation - JSON Format
+void printRepresentation(OCRepresentation rep)
+{
+    for (auto itr = rep.begin(); itr != rep.end(); ++itr)
+    {
+        cout << "\t" << itr->attrname() << ":\t" << itr->getValueToString() << endl;
+        if (itr->type() == AttributeType::Vector)
+        {
+            switch (itr->base_type())
+            {
+                case AttributeType::OCRepresentation:
+                    for (auto itr2 : (*itr).getValue< vector< OCRepresentation > >())
+                    {
+                        printRepresentation(itr2);
+                    }
+                    break;
+
+                case AttributeType::Integer:
+                    for (auto itr2 : (*itr).getValue< vector< int > >())
+                    {
+                        cout << "\t\t" << itr2 << endl;
+                    }
+                    break;
+
+                case AttributeType::String:
+                    for (auto itr2 : (*itr).getValue< vector< string > >())
+                    {
+                        cout << "\t\t" << itr2 << endl;
+                    }
+                    break;
+
+                default:
+                    cout << "Unhandled base type " << itr->base_type() << endl;
+                    break;
+            }
+        }
+        else if (itr->type() == AttributeType::OCRepresentation)
+        {
+            printRepresentation((*itr).getValue< OCRepresentation >());
+        }
+    }
+}
+
+/*
+ handle Cloud Login & Logout information(called by accountMgr -> signUp/signIn)
+ get accesstoken & uid from result representation.
+ */
+void handleLoginoutCB(const HeaderOptions &, const OCRepresentation &rep, const int ecode)
+{
+    cout << "Auth response received code: " << ecode << endl;
+
+    if (rep.getPayload() != NULL)
+    {
+        printRepresentation(rep);
+    }
+
+    if (ecode == 4)
+    {
+        g_accesstoken = rep.getValueToString("accesstoken");
+
+        if (g_uid.empty())
+            g_uid = rep.getValueToString("uid");
+    }
+
+    g_callbackLock.notify_all();
+}
diff --git a/bridging/plugins/zigbee_plugin/cloud/Zigbee_Cloud.h b/bridging/plugins/zigbee_plugin/cloud/Zigbee_Cloud.h
new file mode 100644
index 000000000..4344ed8b9
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/cloud/Zigbee_Cloud.h
@@ -0,0 +1,34 @@
+#ifndef ZIGBEE_CLOUD_H
+#define ZIGBEE_CLOUD_H
+
+#include<iostream>
+#include<string>
+#include "OCRepresentation.h"
+#include "OCApi.h"
+#include "RDClient.h"
+#include "OCAccountManager.h"
+#include "OCPlatform.h"
+
+#include <condition_variable>
+
+using namespace OC;
+using namespace std;
+
+/* pre-configured cloud network information */
+// change the IP address according to cloud network information
+
+class Cloud_Settings
+{
+public:
+    string g_host;
+    string g_authcode;
+    OCAccountManager::Ptr accountMgr;
+    Cloud_Settings();
+    OCStackResult publishResource(ResourceHandles resourceHandles);
+};
+
+void handleLoginoutCB(const HeaderOptions &, const OCRepresentation &rep, const int ecode);
+void onPublish(const OCRepresentation &, const int &ecode);
+void printRepresentation(OCRepresentation rep);
+
+#endif
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_ColorDimmableLight_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_ColorDimmableLight_introspection.json
new file mode 100644
index 000000000..0c6ebe088
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_ColorDimmableLight_introspection.json
@@ -0,0 +1,872 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": { 
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/switch": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+               }
+            }
+          }
+        },
+        
+        "/brightness": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+
+               }
+            }
+          }
+        },
+
+	"/color_hs": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Color_HS"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_HS"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_HS"
+                  }
+
+               }
+            }
+          }
+        },
+        
+	"/color_csc": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CSC"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CSC"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CSC"
+                  }
+
+               }
+            }
+          }
+        },
+
+        
+        "/color_ct": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CT"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CT"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CT"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+
+"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+        "BinarySwitch": {
+           "type": "object",
+           "required": [
+             "value"
+           ],
+           "properties":  {
+               "value": {
+                  "type": "boolean",
+                  "description": "Status of the switch"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.switch.binary" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+         "Brightness": {
+           "type": "object",
+           "required": [
+             "dimmingSetting"
+           ],
+           "properties":  {
+                "dimmingSetting" :
+                  {
+                    "description": "Current dimming value",
+                    "type": "integer"
+                  },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.light.dimming" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+       
+	"Color_HS": {
+           "type": "object",
+           "required": [
+             "hue","saturation"
+           ],
+           "properties":  {
+             "hue" :
+                      {
+                "description": "Hue angle as defined by the CIECAM02 model definition",
+                "maximum": 360.0,
+                "minimum": 0.0,
+                "type": "number"
+              },
+      
+              "saturation" :
+                      {
+                "description": "Saturation as defined by the CIECAM02 model definition",
+                "maximum": 32767,
+                "minimum": 0,
+                "type": "integer"
+              },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.colour.hs" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+	"Color_CSC": {
+           "type": "object",
+           "required": [
+             "csc"
+           ],
+           "properties":  {
+               "csc" :
+                        {
+                  "description": "X and Y coordinates of the colour in CIE colour space",
+                  "items": {
+                    "maximum": 1,
+                    "minimum": 0,
+                    "type": "number"
+                  },
+                  "maxItems": 2,
+                  "minItems": 2,
+                  "type": "array"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.colour.csc" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+
+        
+        "Color_CT": {
+           "type": "object",
+           "required": [
+             "ct"
+           ],
+           "properties":  {
+                "ct" :
+                {
+                  "description": "Mired colour temperature",
+                  "minimum": 0,
+                  "type": "integer"
+                },                
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.colour.colourtemperature" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+}
+
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_ColorTemperatureLight_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_ColorTemperatureLight_introspection.json
new file mode 100644
index 000000000..0c6ebe088
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_ColorTemperatureLight_introspection.json
@@ -0,0 +1,872 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": { 
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/switch": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+               }
+            }
+          }
+        },
+        
+        "/brightness": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+
+               }
+            }
+          }
+        },
+
+	"/color_hs": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Color_HS"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_HS"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_HS"
+                  }
+
+               }
+            }
+          }
+        },
+        
+	"/color_csc": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CSC"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CSC"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CSC"
+                  }
+
+               }
+            }
+          }
+        },
+
+        
+        "/color_ct": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CT"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CT"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CT"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+
+"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+        "BinarySwitch": {
+           "type": "object",
+           "required": [
+             "value"
+           ],
+           "properties":  {
+               "value": {
+                  "type": "boolean",
+                  "description": "Status of the switch"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.switch.binary" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+         "Brightness": {
+           "type": "object",
+           "required": [
+             "dimmingSetting"
+           ],
+           "properties":  {
+                "dimmingSetting" :
+                  {
+                    "description": "Current dimming value",
+                    "type": "integer"
+                  },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.light.dimming" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+       
+	"Color_HS": {
+           "type": "object",
+           "required": [
+             "hue","saturation"
+           ],
+           "properties":  {
+             "hue" :
+                      {
+                "description": "Hue angle as defined by the CIECAM02 model definition",
+                "maximum": 360.0,
+                "minimum": 0.0,
+                "type": "number"
+              },
+      
+              "saturation" :
+                      {
+                "description": "Saturation as defined by the CIECAM02 model definition",
+                "maximum": 32767,
+                "minimum": 0,
+                "type": "integer"
+              },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.colour.hs" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+	"Color_CSC": {
+           "type": "object",
+           "required": [
+             "csc"
+           ],
+           "properties":  {
+               "csc" :
+                        {
+                  "description": "X and Y coordinates of the colour in CIE colour space",
+                  "items": {
+                    "maximum": 1,
+                    "minimum": 0,
+                    "type": "number"
+                  },
+                  "maxItems": 2,
+                  "minItems": 2,
+                  "type": "array"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.colour.csc" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+
+        
+        "Color_CT": {
+           "type": "object",
+           "required": [
+             "ct"
+           ],
+           "properties":  {
+                "ct" :
+                {
+                  "description": "Mired colour temperature",
+                  "minimum": 0,
+                  "type": "integer"
+                },                
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.colour.colourtemperature" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+}
+
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_DimmableLight_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_DimmableLight_introspection.json
new file mode 100644
index 000000000..100ab77f6
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_DimmableLight_introspection.json
@@ -0,0 +1,562 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": {
+
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/switch": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+               }
+            }
+          }
+        },
+        
+        "/brightness": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+	"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+        "BinarySwitch": {
+           "type": "object",
+           "required": [
+             "value"
+           ],
+           "properties":  {
+               "value": {
+                  "type": "boolean",
+                  "description": "Status of the switch"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.switch.binary" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+         "Brightness": {
+           "type": "object",
+           "required": [
+             "dimmingSetting"
+           ],
+           "properties":  {
+                "dimmingSetting" :
+                  {
+                    "description": "Current dimming value",               	  
+                    "type": "integer"
+                  },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.light.dimming" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+}
+
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_ExtendedColorLight_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_ExtendedColorLight_introspection.json
new file mode 100644
index 000000000..0c6ebe088
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_ExtendedColorLight_introspection.json
@@ -0,0 +1,872 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": { 
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/switch": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+               }
+            }
+          }
+        },
+        
+        "/brightness": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Brightness"
+                  }
+
+               }
+            }
+          }
+        },
+
+	"/color_hs": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Color_HS"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_HS"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_HS"
+                  }
+
+               }
+            }
+          }
+        },
+        
+	"/color_csc": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CSC"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CSC"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CSC"
+                  }
+
+               }
+            }
+          }
+        },
+
+        
+        "/color_ct": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CT"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CT"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+              
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Color_CT"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+
+"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+        "BinarySwitch": {
+           "type": "object",
+           "required": [
+             "value"
+           ],
+           "properties":  {
+               "value": {
+                  "type": "boolean",
+                  "description": "Status of the switch"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.switch.binary" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+         "Brightness": {
+           "type": "object",
+           "required": [
+             "dimmingSetting"
+           ],
+           "properties":  {
+                "dimmingSetting" :
+                  {
+                    "description": "Current dimming value",
+                    "type": "integer"
+                  },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.light.dimming" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+       
+	"Color_HS": {
+           "type": "object",
+           "required": [
+             "hue","saturation"
+           ],
+           "properties":  {
+             "hue" :
+                      {
+                "description": "Hue angle as defined by the CIECAM02 model definition",
+                "maximum": 360.0,
+                "minimum": 0.0,
+                "type": "number"
+              },
+      
+              "saturation" :
+                      {
+                "description": "Saturation as defined by the CIECAM02 model definition",
+                "maximum": 32767,
+                "minimum": 0,
+                "type": "integer"
+              },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.colour.hs" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+	"Color_CSC": {
+           "type": "object",
+           "required": [
+             "csc"
+           ],
+           "properties":  {
+               "csc" :
+                        {
+                  "description": "X and Y coordinates of the colour in CIE colour space",
+                  "items": {
+                    "maximum": 1,
+                    "minimum": 0,
+                    "type": "number"
+                  },
+                  "maxItems": 2,
+                  "minItems": 2,
+                  "type": "array"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.colour.csc" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        },
+
+        
+        "Color_CT": {
+           "type": "object",
+           "required": [
+             "ct"
+           ],
+           "properties":  {
+                "ct" :
+                {
+                  "description": "Mired colour temperature",
+                  "minimum": 0,
+                  "type": "integer"
+                },                
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.colour.colourtemperature" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+}
+
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_IASZone_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_IASZone_introspection.json
new file mode 100644
index 000000000..6232357ad
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_IASZone_introspection.json
@@ -0,0 +1,214 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "IASZone",
+    "version": "OCF2.x",
+    "license": {
+      "name": "copyright 2018 Open Connectivity Foundation, Inc. All rights reserved.",
+      "x-description": "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n        1.  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n        2.  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE Open Connectivity Foundation, INC. \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE OR WARRANTIES OF NON-INFRINGEMENT, ARE DISCLAIMED.\n        IN NO EVENT SHALL THE Open Connectivity Foundation, INC. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n        HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
+    }
+  },
+  "schemes": ["http"],
+  "consumes": ["application/json"],
+  "produces": ["application/json"],
+  "paths": {
+    "/IASZoneResURI" : {
+      "get": {
+        "description": "This resource describes an Intruder Alert System (IAS) Zone.\nZone Type provides the information about the type of device/alarm.\nZone Status provides an array which has 10 items representing various status information(e.g., battery status, mode, alarm (Up to two), supervision of IAS network, etc.\nA device implementing this resource can be enrolled to IAS Control and Indicator Equipment (CIE).\nIAS CIE can allocate ID for the device and update this resource of the device.\nThis resource may provide multiple sensitivity levels (>2).\nNumberofZoneSensitivityLevelSupported provides the number of the levels.\nA specific level can be selected as currentzonesensitivityLevel.\nRetrieves the current IASZone Properties",
+        "parameters": [
+          {"$ref": "#/parameters/interface-all"}
+        ],
+        "responses": {
+            "200": {
+              "description" : "",
+              "x-example":
+                {
+                  "rt": ["oic.r.iaszone"],
+                  "zonetype": "motionsensor",
+                  "zonestatus": {
+                    "alarms": ["presence"],
+                    "tamper": false,
+                    "zonestatusreports": "statuschangeonly",
+                    "fault": false,
+                    "test": false
+                  },
+                  "zonebattery": {
+                    "charge": 70,
+                    "defect": false
+                  },
+                  "zonepowersource": {
+                    "powerSources": ["AC (Mains) Power"],
+                    "sourcefault": false
+                  },
+                  "iascieaddress": "ACDE9F56A3FE6B98",
+                  "zonestate": true,
+                  "zoneid": 64,
+                  "numzonesensitivitylevel": 3,
+                  "currentzonesensitivitylevel": 2
+                },
+              "schema": { "$ref": "#/definitions/IASZone" }
+            }
+        }
+      },
+      "post": {
+        "description": "Sets the current sensitivity level of the IASZone.\n",
+        "parameters": [
+          {"$ref": "#/parameters/interface-all"},
+          {
+            "name": "body",
+            "in": "body",
+            "required": true,
+            "schema": { "$ref": "#/definitions/IASZone-Update" },
+            "x-example":
+              {
+                "currentzonesensitivitylevel": 3
+              }
+          }
+        ],
+        "responses": {
+            "200": {
+              "description" : "Success path response code\n"
+            }
+        }
+      }
+    }
+  },
+  "parameters": {
+    "interface-all" : {
+      "in" : "query",
+      "name" : "if",
+      "type" : "string",
+      "enum" : ["oic.if.rw", "oic.if.baseline"]
+    }
+  },
+  "definitions": {
+    "IASZone" : {
+      "properties": {
+        "rt" : {
+          "description": "Resource Type",
+          "items": {
+            "maxLength": 64,
+            "type": "string",
+            "enum": ["oic.r.iaszone"]
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+        "zonestate" : {
+          "description": "The IAS zone state. True = enrolled, False = not enrolled.",
+          "readOnly": true,
+          "type": "boolean"
+        },
+        "zonestatus" : {
+          "description": "Set of alarm indicators.",
+          "properties": {
+            "alarms": {
+              "type": "array",
+              "description": "Array of alarms. The alarms exposed are dependent on the zonetype.",
+              "readOnly": true,
+              "minItems": 1,
+              "maxItems": 2,
+              "items": {
+                "type": "string",
+                "enum": ["system","intrusion","presence","1stportalopenclose","2ndportalopenclose","fire","wateroverflow","CO","cooking","fall","emergencybutton","movement","vibration","panic","emergency","glassbreak"]
+              }
+            },
+            "zonestatusreports": {
+              "description": "Controls the generation of status indications",
+              "type": "string",
+              "enum": ["none","statuschangeonly","alarmclearonly","statuschangeandalarmclear"]
+            },
+            "tamper": {
+              "description": "Tamper status. True = tampered, False = not tampered.",
+              "readOnly": true,
+              "type": "boolean"
+            },
+            "test": {
+              "description": "Test mode indicator. True = sensor is in test mode, False = sensor is in operational mode",
+              "readOnly": true,
+              "type": "boolean"
+            },
+            "fault": {
+              "description": "Fault indicator. True = fault detected, False = no fault detected",
+              "readOnly": true,
+              "type": "boolean"
+            }
+          },
+          "readOnly": true,
+          "type": "object"
+        },
+        "zonebattery": {
+          "$ref": "https://openconnectivityfoundation.github.io/IoTDataModels/BatteryResURI.swagger.json#/definitions/Battery"
+        },
+        "zonepowersource": {
+          "$ref": "https://openconnectivityfoundation.github.io/IoTDataModels/PowerSourcesResourceURI.swagger.json#/definitions/powerSourceSchema"
+        },
+        "n" : {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "numzonesensitivitylevel" : {
+          "description": "Number of supported zone sensitivity levels",
+          "minimum": 2,
+          "readOnly": true,
+          "type": "integer"
+        },
+        "zoneid" : {
+          "description": "ID allocated by the IAS CIE",
+          "readOnly": true,
+          "type": "integer"
+        },
+        "iascieaddress" : {
+          "description": "EUI-64 Address of the enrolled IAS Control and Indicating Equipment (CIE)",
+          "readOnly": true,
+          "type": "string"
+        },
+        "zonetype" :  {
+          "description": "IAS zone type. See OCF Device Specification for set of valid values.",
+          "readOnly": true,
+          "type": "string"
+        },
+        "currentzonesensitivitylevel" : {
+          "description": "Current zone sensitivity level",
+          "minimum": 0,
+          "type": "integer"
+        },
+        "id" : {
+          "description": "Instance ID of this specific resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "if" : {
+          "description": "The interface set supported by this resource",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.rw"
+            ],
+            "type": "string"
+          },
+          "minItems": 2,
+		      "maxItems": 2,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+	  "required": ["zonetype", "zonestate", "zonestatus", "zoneid", "iascieaddress"]
+    },
+    "IASZone-Update" : {
+      "properties": {
+        "currentzonesensitivitylevel" : {
+          "description": "Current zone sensitivity level, Client can only set 1 or higher.",
+          "minimum": 1,
+          "type": "integer"
+        }
+      },
+	  "required": ["currentzonesensitivitylevel"]
+    }
+  }
+}
+
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_MainsPowerOutlet_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_MainsPowerOutlet_introspection.json
new file mode 100644
index 000000000..f48e16298
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_MainsPowerOutlet_introspection.json
@@ -0,0 +1,465 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": {
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/switch": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+	"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+        "BinarySwitch": {
+           "type": "object",
+           "required": [
+             "value"
+           ],
+           "properties":  {
+               "value": {
+                  "type": "boolean",
+                  "description": "Status of the switch"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.switch.binary" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_OccupancySensor_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_OccupancySensor_introspection.json
new file mode 100644
index 000000000..3c1695d04
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_OccupancySensor_introspection.json
@@ -0,0 +1,468 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": {
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/presence": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Presence"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": ["oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Presence"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Presence"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+	"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+        "Presence": {
+           "type": "object",
+           "required": [
+             "value"
+           ],
+           "properties":  {
+                "value" :
+                        {
+                  "description": "true = sensed, false = not sensed.",
+                  "readOnly": true,
+                  "type": "boolean"
+                },
+
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.sensor.presence" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.s"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_OnoffLight_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_OnoffLight_introspection.json
new file mode 100644
index 000000000..f48e16298
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_OnoffLight_introspection.json
@@ -0,0 +1,465 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": {
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/switch": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+	"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+        "BinarySwitch": {
+           "type": "object",
+           "required": [
+             "value"
+           ],
+           "properties":  {
+               "value": {
+                  "type": "boolean",
+                  "description": "Status of the switch"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.switch.binary" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_OnoffOutput_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_OnoffOutput_introspection.json
new file mode 100644
index 000000000..f48e16298
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_OnoffOutput_introspection.json
@@ -0,0 +1,465 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": {
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/switch": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+	"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+        "BinarySwitch": {
+           "type": "object",
+           "required": [
+             "value"
+           ],
+           "properties":  {
+               "value": {
+                  "type": "boolean",
+                  "description": "Status of the switch"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.switch.binary" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_SmartPlug_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_SmartPlug_introspection.json
new file mode 100644
index 000000000..c462f0e63
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_SmartPlug_introspection.json
@@ -0,0 +1,466 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": {
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/switch": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/BinarySwitch"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+	"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+
+        "BinarySwitch": {
+           "type": "object",
+           "required": [
+             "value"
+           ],
+           "properties":  {
+               "value": {
+                  "type": "boolean",
+                  "description": "Status of the switch"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.switch.binary" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_TemperatureSensor_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_TemperatureSensor_introspection.json
new file mode 100644
index 000000000..7bcfeb4d2
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_TemperatureSensor_introspection.json
@@ -0,0 +1,506 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": {
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/temperature": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+
+	"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+        "Temperature": {
+           "type": "object",
+           "required": [
+             "temperature"
+           ],
+           "properties":  {
+                "temperature" :
+                        {
+                  "description": "Current temperature setting or measurement",
+                  "type": "number"
+                },
+        
+                "precision" :
+                        {
+                  "description": "Accuracy granularity of the exposed value",
+                  "readOnly": true,
+                  "type": "number"
+                },
+                "units" :
+                        {
+                  "description": "Units for the temperature value",
+                  "enum": [
+                    "C",
+                    "F",
+                    "K"
+                  ],
+                  "readOnly": true,
+                  "type": "string"
+                },
+        
+                "range" :
+                        {
+                  "description": "The valid range for the value Property",
+                  "items": {
+                    "anyOf": [
+                      {
+                        "type": "number"
+                      },
+                      {
+                        "type": "integer"
+                      }
+                    ]
+                  },
+                  "maxItems": 2,
+                  "minItems": 2,
+                  "readOnly": true,
+                  "type": "array"
+                },
+
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.temperature" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a",
+                            "oic.if.s"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_Thermostat_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_Thermostat_introspection.json
new file mode 100644
index 000000000..d1ecb54ad
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_Thermostat_introspection.json
@@ -0,0 +1,591 @@
+{
+    "swagger": "2.0",
+    "info": {
+      "title": "OCF Dev Kit",
+      "version": "1.0"
+    },
+    "schemes": [
+        "http"
+    ],
+    "consumes": [
+        "application/json"
+    ],
+    "produces": [
+        "application/json"
+    ],
+    "paths": {
+	"/oic/d": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Device"
+		    }
+		  }
+		}
+	      }
+	    },
+
+	"/oic/p": 
+	{
+      "get": 
+	  {
+        "description": "",
+        "parameters": [
+          {
+             "enum": [
+		"oic.if.baseline",
+		"oic.if.r"
+	      ],
+	      "in": "query",
+	      "name": "if",
+	      "type": "string"
+	  }
+        ],
+        "responses": 
+		{
+          "200": 
+		  {
+            "description": "",
+            "schema": 
+			{
+              "$ref": "#/definitions/Platform"
+		    }
+		  }
+		}
+	      }
+	    },
+	
+		
+	"/con": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+               }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Configuration"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.rw","oic.if.baseline" ],
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": false,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/ConfigurationUpdate"
+                  }
+
+               }
+            }
+          }
+        },
+       "/temperature_info": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+
+               }
+            }
+          }
+        },
+        "/temperature_hot": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+
+               }
+            }
+          }
+        },
+        "/temperature_cool": {
+          "get": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                  "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+               }
+            }
+
+           },
+
+          "post": {
+            "parameters": [
+               {
+                 "name": "if",
+                 "in": "query",
+                 "description": "",
+                 "enum": [ "oic.if.a","oic.if.baseline","oic.if.s" ],
+
+                 "type": "string"
+                },
+                {
+                  "name": "body",
+                  "in": "body",
+                  "required": true,
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+                }
+            ],
+            "responses": {
+              "200" : {
+                  "description" : "",
+                   "schema" :
+                  {
+                    "$ref": "#/definitions/Temperature"
+                  }
+
+               }
+            }
+          }
+        }
+    },
+    "definitions":
+    {
+	"Device": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"n": {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"icv": {
+          "description": "The version of the OIC Server",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmno": {
+          "description": "Model number as designated by manufacturer",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"sv": {
+          "description": "Software version.",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+	"dmv": {
+          "description": "Spec versions of the Resource and Device Specifications to which this device data model is implemented",
+          "maxLength": 256,
+          "readOnly": true,
+          "type": "string"
+        },
+	"di": {
+		"allOf": [
+		{
+			"description": "Format pattern according to IETF RFC 4122.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        }, 
+	"piid": {
+		"allOf": [
+		{
+			"description": "Protocol independent unique identifier for device that is immutable.",
+			"pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+			"type": "string"
+		},
+		{
+			"description": "Unique identifier for device",
+			"readOnly": true
+		}
+		]
+        },            
+        "rt": {
+          "default": [
+            "oic.wk.d", "oic.d.light", "oic.d.virtual"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "n", "di", "icv", "dmv", "piid"
+      ],
+      "type": "object"
+    },	
+	
+    "Platform": {
+      "properties": {
+        "if": {
+          "description": "",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.r"
+            ],
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+	"mnhw": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmn": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "mnmo": {
+          "description": "",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "pi": {
+          "allOf": [
+            {
+              "description": "",
+              "pattern": "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$",
+              "type": "string"
+            },
+            {
+              "description": "",
+              "readOnly": true
+            }
+          ]
+        },
+        "rt": {
+          "default": [
+            "oic.wk.p"
+          ],
+          "description": "",
+          "items": {
+            "maxLength": 64,
+            "type": "string"
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": [
+        "pi",
+        "mnmn"
+      ],
+      "type": "object"
+    },
+	"Configuration": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "readOnly": true,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+	"ConfigurationUpdate": {
+           "type": "object",
+           "required": [
+             "n"
+           ],
+           "properties":  {
+               "n": {
+		  "type": "string",
+		  "maxLength": 64,
+		  "description": "The name of device"
+		},
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.wk.con"]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.rw"
+                        ]
+                    }
+                }
+            }
+        },
+
+
+        "Temperature": {
+           "type": "object",
+           "required": [
+             "temperature"
+           ],
+           "properties":  {
+                "temperature" :
+                        {
+                  "description": "Current temperature setting or measurement",
+                  "type": "number"
+                },
+                "units" :
+                        {
+                  "description": "Units for the temperature value",
+                  "enum": [
+                    "C",
+                    "F",
+                    "K"
+                  ],
+                  "readOnly": true,
+                  "type": "string"
+                },
+                "rt": {
+                  "type": "array",
+                  "items" : [
+                    {
+                      "type" : "string",
+                      "maxLength": 64
+                    }
+                  ],
+                  "minItems" : 1,
+                  "description": "Resource Type",
+                  "readOnly" : true,
+                  "default" : [ "oic.r.temperature" ]
+                },
+                "if": {
+                    "type": "array",
+                    "description": "The interface set supported by this resource",
+                    "readOnly" : true,
+                    "items": {
+                        "type": "string",
+                        "enum": [
+                            "oic.if.baseline",
+                            "oic.if.a",
+                            "oic.if.s"
+                        ]
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/bridging/plugins/zigbee_plugin/idd/zigbee_WindowCoveringDevice_introspection.json b/bridging/plugins/zigbee_plugin/idd/zigbee_WindowCoveringDevice_introspection.json
new file mode 100644
index 000000000..0a2be55b3
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/idd/zigbee_WindowCoveringDevice_introspection.json
@@ -0,0 +1,260 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Window Covering",
+    "version": "OCF2.x",
+    "license": {
+      "name": "copyright 2018 Open Connectivity Foundation, Inc. All rights reserved.",
+      "x-description": "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n        1.  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n        2.  Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n        THIS SOFTWARE IS PROVIDED BY THE Open Connectivity Foundation, INC. \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE OR WARRANTIES OF NON-INFRINGEMENT, ARE DISCLAIMED.\n        IN NO EVENT SHALL THE Open Connectivity Foundation, INC. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n        HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
+    }
+  },
+  "schemes": ["http"],
+  "consumes": ["application/json"],
+  "produces": ["application/json"],
+  "paths": {
+    "/WindowCoveringResURI" : {
+      "get": {
+        "description": "This resource describes the information of a window covering, i.e., type, configuration status, and mode.\nVelocity associated with lifting the window covering can be changed by updating Lift_Velocity(cm/sec).\nRamp up/down times to reaching the velocity setting can be changed by updating Lift_Acceleration Time/Lift_Deceleration Time (0.1sec).\nRetrieves the current Window Covering Properties",
+        "parameters": [
+          {"$ref": "#/parameters/interface-all"}
+        ],
+        "responses": {
+            "200": {
+              "description" : "",
+              "x-example":
+                {
+                  "rt": ["oic.r.windowcovering"],
+                  "windowcoveringtype": "shutter",
+                  "configstatus": {
+                    "operational": true,
+                    "online": true,
+                    "rotationdirection": "normal",
+                    "controllift": "closedloop",
+                    "controltilt": "closedloop",
+                    "closedloopliftcontrol": "encoder",
+                    "closedlooptiltcontrol": "encoder"
+                  },
+                  "mode": {
+                    "motordirection": false,
+                    "calibration": false,
+                    "maintenance": false,
+                    "ledfeedback": true
+                  },
+                  "liftvelocity": 5,
+                  "liftaccelerationtime": 200,
+                  "liftdecelerationtime": 200
+                },
+              "schema": { "$ref": "#/definitions/WindowCovering" }
+            }
+        }
+      },
+      "post": {
+        "description": "Update window covering settings.\n",
+        "parameters": [
+          {"$ref": "#/parameters/interface-all"},
+          {
+            "name": "body",
+            "in": "body",
+            "required": true,
+            "schema": { "$ref": "#/definitions/WindowCovering-Update" },
+            "x-example":
+              {
+                "mode": {
+                  "motordirection": true,
+                  "calibration": false,
+                  "maintenance": false,
+                  "ledfeedback": true
+                },
+                "liftvelocity": 10,
+                "liftaccelerationtime": 500,
+                "liftdecelerationtime": 500
+              }
+          }
+        ],
+        "responses": {
+            "200": {
+              "description" : "Success path response code\n"
+            }
+        }
+      }
+    }
+  },
+  "parameters": {
+    "interface-all" : {
+      "in" : "query",
+      "name" : "if",
+      "type" : "string",
+      "enum" : ["oic.if.rw", "oic.if.baseline"]
+    }
+  },
+  "definitions": {
+    "WindowCovering" : {
+      "properties": {
+        "rt" : {
+          "description": "Resource Type",
+          "items": {
+            "maxLength": 64,
+            "type": "string",
+            "enum": ["oic.r.windowcovering"]
+          },
+          "minItems": 1,
+          "readOnly": true,
+          "type": "array"
+        },
+        "windowcoveringtype" : {
+          "description": "Window covering type. See OCF Device Specification for set of valid values.",
+          "readOnly": true,
+          "type": "string"
+        },
+        "liftvelocity" : {
+          "description": "Velocity in cm/sec associated with lifting the covering",
+          "type": "integer"
+        },
+        "configstatus" : {
+          "description": "Set of config status indicators.",
+          "properties": {
+            "controllift": {
+              "description": "Closed loop control allows for intermediate settings, open loop supports only up or down",
+              "readOnly": true,
+              "type": "string",
+              "enum": ["closedloop","openloop"]
+            },
+            "controltilt": {
+              "description": "Closed loop control allows for intermediate settings, open loop supports only tilted or not tilted",
+              "readOnly": true,
+              "type": "string",
+              "enum": ["closedloop","openloop"]
+            },
+            "closedloopliftcontrol": {
+              "description": "Encoder or timer controlled",
+              "readOnly": true,
+              "type": "string",
+              "enum": ["encoder","timer"]
+            },
+            "closedlooptiltcontrol": {
+              "description": "Encoder or timer controlled",
+              "readOnly": true,
+              "type": "string",
+              "enum": ["encoder","timer"]
+            },
+            "online": {
+              "description": "True = online, False = not online",
+              "readOnly": true,
+              "type": "boolean"
+            },
+            "operational": {
+              "description": "True = operational, False = not operational",
+              "readOnly": true,
+              "type": "boolean"
+            },
+            "rotationdirection": {
+              "description": "Identifies if the direction of rotation has been reversed to match physical installation.",
+              "readOnly": true,
+              "type": "string",
+              "enum": ["normal","reversed"]
+            }
+          },
+          "readOnly": true,
+          "type": "object"
+        },
+        "n" : {
+          "description": "Friendly name of the resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "liftaccelerationtime" : {
+          "description": "Ramp up time to reach lift velocity (ms)",
+          "type": "integer"
+        },
+        "liftdecelerationtime" : {
+          "description": "Ramp down time from the velocity setting (ms)",
+          "type": "integer"
+        },
+        "mode" : {
+          "description": "Set of operational modes.",
+          "properties": {
+            "calibration": {
+              "description": "True = calibration mode, False = normal mode",
+              "type": "boolean"
+            },
+            "ledfeedback": {
+              "description": "True = feedback enabled, False = LEDs are off",
+              "type": "boolean"
+            },
+            "maintenance": {
+              "description": "True = maintenance mode, False = normal mode",
+              "type": "boolean"
+            },
+            "motordirection": {
+              "description": "True = direction reversed, False = direction normal",
+              "type": "boolean"
+            }
+          },
+          "type": "object"
+        },
+        "id" : {
+          "description": "Instance ID of this specific resource",
+          "maxLength": 64,
+          "readOnly": true,
+          "type": "string"
+        },
+        "if" : {
+          "description": "The interface set supported by this resource",
+          "items": {
+            "enum": [
+              "oic.if.baseline",
+              "oic.if.rw"
+            ],
+            "type": "string"
+          },
+          "minItems": 2,
+		      "maxItems": 2,
+          "readOnly": true,
+          "type": "array"
+        }
+      },
+      "required": ["windowcoveringtype", "configstatus", "mode"]
+    },
+    "WindowCovering-Update" : {
+      "properties": {
+        "liftaccelerationtime" : {
+          "description": "Ramp up time to reach lift velocity (ms)",
+          "type": "integer"
+        },
+        "liftdecelerationtime" : {
+          "description": "Ramp down time from the velocity setting (ms)",
+          "type": "integer"
+        },
+        "liftvelocity" : {
+          "description": "Velocity in cm/sec associated with lifting the covering",
+          "type": "integer"
+        },
+        "mode" : {
+          "description": "Set of operational modes.",
+          "properties": {
+            "calibration": {
+              "description": "True = calibration mode, False = normal mode",
+              "type": "boolean"
+            },
+            "ledfeedback": {
+              "description": "True = feedback enabled, False = LEDs are off",
+              "type": "boolean"
+            },
+            "maintenance": {
+              "description": "True = maintenance mode, False = normal mode",
+              "type": "boolean"
+            },
+            "motordirection": {
+              "description": "True = direction reversed, False = direction normal",
+              "type": "boolean"
+            }
+          },
+          "type": "object"
+        }
+      },
+      "required": ["mode"]
+    }
+  }
+}
+
diff --git a/bridging/plugins/zigbee_plugin/virtual_server/SConscript b/bridging/plugins/zigbee_plugin/virtual_server/SConscript
new file mode 100644
index 000000000..234bd6f73
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/virtual_server/SConscript
@@ -0,0 +1,118 @@
+#******************************************************************
+#
+# Copyright 2017 Intel Mobile Communications GmbH All Rights Reserved.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#####
+# zigbee Plugin build script
+##
+
+import os
+import os.path
+
+Import('env')
+
+target_os = env.get('TARGET_OS')
+src_dir = env.get('SRC_DIR')
+bridging_path = os.path.join(src_dir, 'bridging')
+zigbee_env = env.Clone()
+
+print("Reading zigbee Plugin VIRTUAL SERVER script")
+
+def maskFlags(flags):
+    flags = [flags.replace('-Wl,--no-undefined', '') for flags in flags]
+    return flags
+
+
+######################################################################
+# Build flags
+######################################################################
+
+zigbee_env.PrependUnique(CPPPATH=[
+	os.path.join(src_dir, 'resource', 'c_common', 'oic_malloc', 'include'),
+    os.path.join(src_dir, 'resource', 'c_common', 'oic_malloc', 'include'),
+    os.path.join(src_dir, 'resource', 'c_common', 'oic_string', 'include'),
+    os.path.join(src_dir, 'resource', 'c_common'),
+    os.path.join(src_dir, 'resource', 'oc_logger', 'include'),
+    os.path.join(src_dir, 'resource', 'csdk', 'logger', 'include'),
+    os.path.join(src_dir, 'resource', 'csdk', 'include'),
+    os.path.join(src_dir, 'resource', 'csdk', 'stack', 'include'),
+    os.path.join(src_dir, 'resource', 'csdk', 'stack', 'include', 'internal'),
+    os.path.join(src_dir, 'resource', 'csdk', 'security', 'include', 'internal'),
+    os.path.join(src_dir, 'resource', 'csdk', 'security', 'include', 'experimental'),
+    os.path.join(src_dir, 'resource', 'csdk', 'connectivity', 'api'),
+    os.path.join(src_dir, 'resource', 'include'),
+    os.path.join(src_dir, 'extlibs', 'cjson'),
+    os.path.join(src_dir, 'extlibs', 'tinycbor', 'src'),
+    os.path.join(src_dir, 'extlibs', 'rapidjson','rapidjson', 'include'), 		 #### added
+    os.path.join(src_dir, 'extlibs', 'websocketpp'),							 #### added
+    os.path.join(src_dir, 'extlibs', 'socket'),									 #### added
+    os.path.join(src_dir, 'resource', 'csdk', 'resource-directory', 'include'),  #### added
+    os.path.join(src_dir, 'resource', 'csdk', 'security', 'provisioning', 'include', 'cloud'),      #added
+])
+
+zigbee_env.AppendUnique(CPPPATH=[	
+    os.path.join(bridging_path, 'include'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin'),    
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin','Zigbee_Devices'),
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin','virtual_server'),    
+    os.path.join(bridging_path, 'plugins', 'zigbee_plugin','cloud'),
+])
+
+if 'g++' in zigbee_env.get('CXX'):
+    zigbee_env.AppendUnique(
+        CXXFLAGS=['-std=c++0x', '-Wall', '-Wextra', '-Werror'])
+        
+zigbee_env['CC']= zigbee_env['CXX']
+        
+if target_os in ['msys_nt', 'windows']:
+    zigbee_env.PrependUnique(LIBS=[
+        'mswsock',
+        'ws2_32',
+        'iphlpapi',
+        'ole32'
+    ])
+else:
+    zigbee_env.PrependUnique(LIBS=['oc_logger'])
+
+if zigbee_env.get('SECURED') == '1':
+    zigbee_env.AppendUnique(LIBS=[
+        'mbedtls',
+        'mbedx509',
+        'mbedcrypto'
+    ])
+    if target_os in ['msys_nt', 'windows']:
+        zigbee_env.AppendUnique(LIBS=['advapi32'])
+
+zigbee_env['LINKFLAGS'] = maskFlags(env['LINKFLAGS'])
+zigbee_env.AppendUnique(LINKFLAGS=['-Wl,--allow-shlib-undefined'])
+zigbee_env.AppendUnique(LINKFLAGS=[
+    '-Wl,--whole-archive',
+    zigbee_env.get('BUILD_DIR') + 'libmpmcommon.a', '-Wl,-no-whole-archive'
+])
+
+zigbee_env.AppendUnique(
+LIBS=['resource_directory','oc', 'm', 'octbstack', 'ocsrm', 'connectivity_abstraction', 'coap', 'curl','boost_system','boost_date_time','pthread'] 
+)
+
+zigbee_env.AppendUnique(LIBS=['minipluginmanager'])
+zigbee_env.AppendUnique(LIBS=['mpmcommon'])
+zigbee_env.AppendUnique(LIBS=['zigbeeplugin'])
+
+build_dir = env.get('BUILD_DIR') + '/bridging/plugins/zigbee_plugin/virtual_server/'
+
+virtualserver = zigbee_env.Program(build_dir + 'virtualserver', ['Virtual_Server.cpp'])
diff --git a/bridging/plugins/zigbee_plugin/virtual_server/Virtual_Server.cpp b/bridging/plugins/zigbee_plugin/virtual_server/Virtual_Server.cpp
new file mode 100644
index 000000000..3673b555e
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/virtual_server/Virtual_Server.cpp
@@ -0,0 +1,2127 @@
+//******************************************************************
+//
+// Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+///
+/// This sample provides steps to define an interface for a resource
+/// (properties and methods) and host this resource on the server.
+///
+#include "iotivity_config.h"
+
+#include <functional>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_PTHREAD_H
+#include <pthread.h>
+#endif
+#include <sys/types.h>
+#include <signal.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <unistd.h>
+#include <mutex>
+#include <condition_variable>
+#include "oic_malloc.h"
+#include "OCPlatform.h"
+#include "OCApi.h"
+#include "ocstack.h"
+#include "ocpayload.h"
+#include "ocresource.h"
+#include "ocresourcehandler.h"
+#include "ConcurrentIotivityUtils.h"
+#include "Zigbee_Resource.h"
+#include "Zigbee_Device.h"
+#include "../Zigbee_Devices/Zigbee_OnoffLight.h"
+#include "../Zigbee_Devices/Zigbee_ColorTemperatureLight.h"
+#include "../Zigbee_Devices/Zigbee_ExtendedColorLight.h"
+#include "../Zigbee_Devices/Zigbee_DimmableLight.h"
+#include "../Zigbee_Devices/Zigbee_ColorDimmableLight.h"
+#include "../Zigbee_Devices/Zigbee_TemperatureSensor.h"
+#include "../Zigbee_Devices/Zigbee_Thermostat.h"
+#include "../Zigbee_Devices/Zigbee_WindowCoveringDevice.h"
+#include "../Zigbee_Devices/Zigbee_SmartPlug.h"
+#include "../Zigbee_Devices/Zigbee_MainsPowerOutlet.h"
+#include "../Zigbee_Devices/Zigbee_OnoffOutput.h"
+#include "../Zigbee_Devices/Zigbee_IASZone.h"
+#include "../Zigbee_Devices/Zigbee_OccupancySensor.h"
+#include "cloudresource.h"
+#include "Zigbee_Cloud.h"
+#include "doxmresource.h"
+#include "srmutility.h"
+#include "oic_string.h"
+#include "deviceonboardingstate.h"
+#include "securevirtualresourcetypes.h"
+
+#ifdef HAVE_WINDOWS_H
+#include <windows.h>
+#endif
+
+#define TAG "VIRTUAL_SERVER"
+
+/** Name of device. in Configuration resource */
+#define OC_RSRVD_LOCALIZED_NAMES        "ln"
+
+using namespace OC::Bridging;
+using namespace std;
+namespace PH = std::placeholders;
+
+char VIRTUALSVR_DB_FILE_NAME[128];
+char INTROSPECTION_DATA_FILE_NAME[128];
+
+int gObservation = 0;
+void * ChangeRepresentation(void *param);
+
+#define OBSERVE_NOTIFICATION_INTERVAL 1
+
+ZBOperationsSharedPtr ZBO;
+
+class VirtualServer
+{
+
+public:
+    std::vector< std::string > m_uri;
+    ZigbeeDeviceSharedPtr m_device;
+    ResourceHandles m_resourceHandles;
+    std::map< std::string, ObservationIds > m_interestedObserverMap;
+
+public:
+    /// Constructor
+    VirtualServer(char* argv[])
+{
+        /*
+         * make device instance according to (Zigbee) device type
+         */
+        if (std::string(argv[2]) == DEVICE_TYPE_ONOFF_LIGHT)
+        {
+            m_device = std::make_shared< ZigbeeOnoffLight >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_COLOR_TEMPERATURE_LIGHT)
+        {
+            m_device = std::make_shared< ZigbeeColorTemperatureLight >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_EXTENDED_COLOR_LIGHT)
+        {
+            m_device = std::make_shared< ZigbeeExtendedColorLight >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_DIMMABLE_LIGHT)
+        {
+            m_device = std::make_shared< ZigbeeDimmableLight >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_COLOR_DIMMABLE_LIGHT)
+        {
+            m_device = std::make_shared< ZigbeeColorDimmableLight >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_TEMPERATURE_SENSOR)
+        {
+            m_device = std::make_shared< ZigbeeTemperatureSensor >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_THERMOSTAT)
+        {
+            m_device = std::make_shared< ZigbeeThermostat >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_WINDOW_COVERING_DEVICE)
+        {
+            m_device = std::make_shared< ZigbeeWindowCoveringDevice >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_SMART_PLUG)
+        {
+            m_device = std::make_shared< ZigbeeSmartPlug >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_MAINS_POWER_OUTLET)
+        {
+            m_device = std::make_shared< ZigbeeMainsPowerOutlet >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_ONOFF_OUTPUT)
+        {
+            m_device = std::make_shared< ZigbeeOnoffOutput >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_IAS_ZONE)
+        {
+            m_device = std::make_shared< ZigbeeIASZone >();
+        }
+        else if (std::string(argv[2]) == DEVICE_TYPE_OCCUPANCY_SENSOR)
+        {
+            m_device = std::make_shared< ZigbeeOccupancySensor >();
+        }
+
+        /*
+         * set uri(s) and device information
+         */
+        for (uint32_t i = 0 ; i < m_device->resourceUris.size(); ++i)
+        {
+            m_uri.push_back(m_device->resourceUris[i]);
+
+            for (uint32_t j = 0 ; j < (m_device->childResourceUris[m_device->resourceUris[i]]).size(); ++j)
+            {
+                m_uri.push_back((m_device->childResourceUris[m_device->resourceUris[i]])[j]);
+            }
+        }
+
+        m_device->setNodeId(std::string(argv[1]));
+        m_device->setDeviceType(std::string(argv[2]));
+        m_device->setEui64(std::string(argv[3]));
+        m_device->setName(std::string(argv[4]));
+        m_device->setSoftwareVersion(std::string(argv[5]));
+        m_device->setManufacturerName(std::string(argv[6]));
+        m_device->setModelNumber(std::string(argv[7]));
+        m_device->setProtocolIndependentId(std::string(argv[8]));
+        m_device->setPlatformId(std::string(argv[9]));
+        m_device->setHardwareVersion(std::string(argv[10]));
+}
+
+    void setDeviceInfoParams(OCDeviceInfo &device_info)
+    {
+        device_info.deviceName = (char *) (m_device->getName().c_str());
+
+        if (!device_info.deviceName || device_info.deviceName[0] == '\0')
+        {
+            OIC_LOG(ERROR, "VIRTUAL SERVER", "Assigning temporary name since device name is NULL");
+            device_info.deviceName = (char *) "temporary name";
+        }
+
+        device_info.types = NULL;
+        device_info.dataModelVersions = NULL;
+        device_info.specVersion = NULL;
+
+        char uuidString[MAX_IDENTITY_SIZE];
+        OICStrcpy(uuidString, MAX_IDENTITY_SIZE, m_device->getProtocolIndependentId().c_str());
+        OicUuid_t uuid;
+        if (OC_STACK_OK != ConvertStrToUuid(uuidString, &uuid))
+        {
+            std::cout << "Convert String to UUID" << std::endl;
+        }
+        if (OC_STACK_OK != SetDoxmDeviceID(&uuid))
+        {
+            std::cout << "Can't change deviceID" << std::endl;
+        }
+    }
+
+    OCStackResult setDeviceInfo(void)
+    {
+        OCStackResult result = OC_STACK_ERROR;
+
+        if (m_device->getName().length() > 0)
+        {
+            result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME,
+                    m_device->getName());
+            if (result != OC_STACK_OK)
+            {
+                std::cout << "Failed to set device name" << std::endl;
+                return result;
+            }
+        }
+
+        if (m_device->getSoftwareVersion().length() > 0)
+        {
+            result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_SOFTWARE_VERSION,
+                    m_device->getSoftwareVersion());
+            if (result != OC_STACK_OK)
+            {
+                std::cout << "Failed to set software version" << std::endl;
+                return result;
+            }
+        }
+
+        if (m_device->getModelNumber().length() > 0)
+        {
+            result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_MODEL_NUM,
+                    m_device->getModelNumber());
+            if (result != OC_STACK_OK)
+            {
+                std::cout << "Failed to set device model versions" << std::endl;
+                return result;
+            }
+        }
+
+        if (m_device->getProtocolIndependentId().length() > 0)
+        {
+            result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_PROTOCOL_INDEPENDENT_ID,
+                    m_device->getProtocolIndependentId());
+            if (result != OC_STACK_OK)
+            {
+                std::cout << "Failed to set piid" << std::endl;
+                return result;
+            }
+        }
+
+        return OC_STACK_OK;
+    }
+
+    OCStackResult setPlatformInfo(void)
+    {
+        OCStackResult result = OC_STACK_ERROR;
+
+        if (m_device->getPlatformId().length() > 0)
+        {
+            result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_PLATFORM_ID,
+                    m_device->getPlatformId());
+            if (result != OC_STACK_OK)
+            {
+                std::cout << "Failed to set " << OC_RSRVD_PLATFORM_ID << std::endl;
+                return result;
+            }
+        }
+
+        if (m_device->getManufacturerName().length() > 0)
+        {
+            result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MFG_NAME,
+                    m_device->getManufacturerName());
+            if (result != OC_STACK_OK)
+            {
+                std::cout << "Failed to set " << OC_RSRVD_MFG_NAME << std::endl;
+                return result;
+            }
+        }
+
+        if (m_device->getModelNumber().length() > 0)
+        {
+            result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MODEL_NUM,
+                    m_device->getModelNumber());
+            if (result != OC_STACK_OK)
+            {
+                std::cout << "Failed to set " << OC_RSRVD_MODEL_NUM << std::endl;
+                return result;
+            }
+        }
+
+        if (m_device->getHardwareVersion().length() > 0)
+        {
+            result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_HARDWARE_VERSION,
+                    m_device->getHardwareVersion());
+            if (result != OC_STACK_OK)
+            {
+                std::cout << "Failed to set " << OC_RSRVD_HARDWARE_VERSION << std::endl;
+                return result;
+            }
+
+        }
+
+        return result;
+    }
+
+    bool isSecureEnvironmentSet()
+    {
+        char *non_secure_env = getenv("NONSECURE");
+
+        if (non_secure_env && !strcmp(non_secure_env, "true"))
+        {
+            OIC_LOG_V(INFO, TAG, "Creating NON SECURE resources");
+            return false;
+        } OIC_LOG_V(INFO, TAG, "Creating SECURE resources");
+        return true;
+    }
+
+    /// This function internally calls registerResource API.
+    OCStackResult createResources(void)
+    {
+        uint8_t deviceResourceProperties = OC_OBSERVABLE | OC_DISCOVERABLE;
+        uint8_t configResourceProperties = OC_DISCOVERABLE;
+        if (isSecureEnvironmentSet())
+        {
+            deviceResourceProperties |= OC_SECURE;
+            configResourceProperties |= OC_SECURE;
+        }
+
+        OCStackResult result = OC_STACK_ERROR;
+
+        // This will internally create and register the resource.
+        EntityHandler cb = std::bind(&VirtualServer::entityHandler, this, PH::_1);
+
+        // add device specific OCF device type to /oic/d
+        addType(std::string(OC_RSRVD_DEVICE_URI), m_device->OCFDeviceType);
+
+        // add OCF virtual device type (oic.d.virtual) to /oic/d
+        addType(std::string(OC_RSRVD_DEVICE_URI), OIC_VIRTUAL_DEVICE);
+
+        // add read interface (oic.if.r) to /oic/p
+        addInterface(std::string(OC_RSRVD_PLATFORM_URI), std::string(OC_RSRVD_INTERFACE_READ));
+
+        /*
+         * create configuration resource (/con)
+         */
+        std::string configUri = CONFIGURATION_URI;
+        OCResourceHandle configHandle;
+        result = OCPlatform::registerResource(
+                configHandle, configUri, OC_RSRVD_RESOURCE_TYPE_CONFIGURATION,
+                DEFAULT_INTERFACE, cb, configResourceProperties);
+        if (OC_STACK_OK != result)
+        {
+            std::cout << "Configuration Resource creation was unsuccessful." << std::endl;
+        }
+
+        addInterface(std::string(CONFIGURATION_URI), std::string(OC_RSRVD_INTERFACE_READ_WRITE));
+
+        /*
+         * create device specific resource(s) according to device type
+         */
+        for (uint32_t i = 0 ; i < m_device->resourceUris.size(); ++i)
+        {
+            std::vector< std::string > rt = m_device->resourceTypes[m_device->resourceUris[i]];
+            std::vector< std::string > iface = m_device->interfaces[m_device->resourceUris[i]];
+
+            OCResourceHandle handle;
+            result = OCPlatform::registerResource(handle, m_device->resourceUris[i], rt[0],
+                    DEFAULT_INTERFACE, cb, deviceResourceProperties);
+            m_resourceHandles.push_back(handle);
+
+            // add resource type(s)
+            for (uint32_t j = 1 ; j < rt.size(); ++j)
+            {
+                addType(m_device->resourceUris[i], rt[j]);
+            }
+
+            // add interface(s)
+            for (uint32_t j = 0 ; j < iface.size(); ++j)
+            {
+                addInterface(m_device->resourceUris[i], iface[j]);
+            }
+
+            if (OC_STACK_OK != result)
+            {
+                std::cout << "Resource creation was unsuccessful." << std::endl;
+            }
+
+            // create child resources if exist
+            std::vector< std::string > childResourceUris = m_device->childResourceUris[m_device->resourceUris[i]];
+            for (uint32_t j = 0 ; j < childResourceUris.size(); ++j)
+            {
+                std::vector< std::string > rt = m_device->resourceTypes[childResourceUris[j]];
+                std::vector< std::string > iface = m_device->interfaces[childResourceUris[j]];
+
+                OCResourceHandle childHandle;
+                result = OCPlatform::registerResource(childHandle, childResourceUris[j], rt[0],
+                        DEFAULT_INTERFACE, cb, deviceResourceProperties);
+                m_resourceHandles.push_back(childHandle);
+
+                // add resource type(s)
+                for (uint32_t k = 1 ; k < rt.size(); ++k)
+                {
+                    addType(childResourceUris[j], rt[k]);
+                }
+
+                // add interface(s)
+                for (uint32_t k = 0 ; k < iface.size(); ++k)
+                {
+                    addInterface(childResourceUris[j], iface[k]);
+                }
+
+                if (OC_STACK_OK != result)
+                {
+                    std::cout << "Resource creation was unsuccessful." << std::endl;
+                }
+
+                OCBindResource(handle, childHandle);
+            }
+        }
+
+        return result;
+    }
+
+    void addType(const std::string& uri, const std::string& type) const
+    {
+        OCResourceHandle resourceHandle = OCGetResourceHandleAtUri(uri.c_str());
+        OCBindResourceTypeToResource(resourceHandle, type.c_str());
+    }
+
+    void addInterface(const std::string& uri, const std::string& iface) const
+    {
+        OCResourceHandle resourceHandle = OCGetResourceHandleAtUri(uri.c_str());
+        OCBindResourceInterfaceToResource(resourceHandle, iface.c_str());
+    }
+
+    OCResourceHandle getHandle(const uint32_t index)
+    {
+        return m_resourceHandles[index];
+    }
+
+    OCRepresentation getRepresentation(std::string targetUri)
+    {
+        // parse query if any
+        std::string query;
+        if(targetUri.find("?") != std::string::npos)
+        {
+            query = targetUri.substr(targetUri.find("?"));
+            targetUri = targetUri.substr(0, targetUri.find("?"));
+        }
+
+        OCRepresentation rep;
+        if(m_device->getDeviceType() == DEVICE_TYPE_ONOFF_LIGHT)
+        {
+            ZigbeeDevice::onoff_light_state state;
+            state = m_device->getOnoffLightState(m_device, ZBO);
+            if (targetUri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                rep.setValue("value", state.value);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_COLOR_TEMPERATURE_LIGHT)
+        {
+            ZigbeeDevice::color_temperature_light_state state;
+            if (targetUri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                state = m_device->getColorTemperatureLightState(m_device, ZBO, targetUri);
+                rep.setValue("value", state.value);
+            }
+            else if(targetUri == DIMMING_RELATIVE_URI)
+            {
+                state = m_device->getColorTemperatureLightState(m_device, ZBO, targetUri);
+                rep.setValue("dimmingSetting", state.dimmingSetting);
+            }
+            else if(targetUri == COLOR_HS_RELATIVE_URI)
+            {
+                state = m_device->getColorTemperatureLightState(m_device, ZBO, targetUri);
+                rep.setValue("hue", state.hue);
+                rep.setValue("saturation", state.saturation);
+            }
+            else if(targetUri == COLOR_CSC_RELATIVE_URI)
+            {
+                state = m_device->getColorTemperatureLightState(m_device, ZBO, targetUri);
+                std::vector<double> cscVector;
+                for (uint32_t i = 0 ; i < 2; ++i)
+                {
+                    cscVector.push_back(state.csc[i]);
+                }
+                rep.setValue("csc", cscVector);
+            }
+            else if(targetUri == COLOR_CT_RELATIVE_URI)
+            {
+                state = m_device->getColorTemperatureLightState(m_device, ZBO, targetUri);
+                rep.setValue("ct", state.ct);
+                std::vector<int> rangeVector;
+                for (uint32_t i = 0 ; i < 2; ++i)
+                {
+                    rangeVector.push_back(state.range[i]);
+                }
+                rep.setValue("range", rangeVector);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_EXTENDED_COLOR_LIGHT)
+        {
+            ZigbeeDevice::extended_color_light_state state;
+            if (targetUri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                state = m_device->getExtendedColorLightState(m_device, ZBO, targetUri);
+                rep.setValue("value", state.value);
+            }
+            else if(targetUri == DIMMING_RELATIVE_URI)
+            {
+                state = m_device->getExtendedColorLightState(m_device, ZBO, targetUri);
+                rep.setValue("dimmingSetting", state.dimmingSetting);
+            }
+            else if(targetUri == COLOR_HS_RELATIVE_URI)
+            {
+                state = m_device->getExtendedColorLightState(m_device, ZBO, targetUri);
+                rep.setValue("hue", state.hue);
+                rep.setValue("saturation", state.saturation);
+            }
+            else if(targetUri == COLOR_CSC_RELATIVE_URI)
+            {
+                state = m_device->getExtendedColorLightState(m_device, ZBO, targetUri);
+                std::vector<double> cscVector;
+                for (uint32_t i = 0 ; i < 2; ++i)
+                {
+                    cscVector.push_back(state.csc[i]);
+                }
+                rep.setValue("csc", cscVector);
+            }
+            else if(targetUri == COLOR_CT_RELATIVE_URI)
+            {
+                state = m_device->getExtendedColorLightState(m_device, ZBO, targetUri);
+                rep.setValue("ct", state.ct);
+                std::vector<int> rangeVector;
+                for (uint32_t i = 0 ; i < 2; ++i)
+                {
+                    rangeVector.push_back(state.range[i]);
+                }
+                rep.setValue("range", rangeVector);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_DIMMABLE_LIGHT)
+        {
+            ZigbeeDevice::dimmable_light_state state;
+            if (targetUri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                state = m_device->getDimmableLightState(m_device, ZBO, targetUri);
+                rep.setValue("value", state.value);
+            }
+            else if(targetUri == DIMMING_RELATIVE_URI)
+            {
+                state = m_device->getDimmableLightState(m_device, ZBO, targetUri);
+                rep.setValue("dimmingSetting", state.dimmingSetting);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_COLOR_DIMMABLE_LIGHT)
+        {
+            ZigbeeDevice::color_dimmable_light_state state;
+            if (targetUri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                state = m_device->getColorDimmableLightState(m_device, ZBO, targetUri);
+                rep.setValue("value", state.value);
+            }
+            else if(targetUri == DIMMING_RELATIVE_URI)
+            {
+                state = m_device->getColorDimmableLightState(m_device, ZBO, targetUri);
+                rep.setValue("dimmingSetting", state.dimmingSetting);
+            }
+            else if(targetUri == COLOR_HS_RELATIVE_URI)
+            {
+                state = m_device->getColorDimmableLightState(m_device, ZBO, targetUri);
+                rep.setValue("hue", state.hue);
+                rep.setValue("saturation", state.saturation);
+            }
+            else if(targetUri == COLOR_CSC_RELATIVE_URI)
+            {
+                std::vector<double> cscVector;
+                state = m_device->getColorDimmableLightState(m_device, ZBO, targetUri);
+                for (uint32_t i = 0 ; i < 2; ++i)
+                {
+                    cscVector.push_back(state.csc[i]);
+                }
+                rep.setValue("csc", cscVector);
+            }
+            else if(targetUri == COLOR_CT_RELATIVE_URI)
+            {
+                state = m_device->getColorDimmableLightState(m_device, ZBO, targetUri);
+                rep.setValue("ct", state.ct);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_TEMPERATURE_SENSOR)
+        {
+            ZigbeeDevice::temperature_sensor_state state;
+            state = m_device->getTemperatureSensorState(m_device, ZBO);
+            if(targetUri == TEMPERATURE_RELATIVE_URI)
+            {
+                rep.setValue("temperature", state.temperature);
+                rep.setValue("units", state.units);
+                rep.setValue("precision", state.precision);
+
+                std::vector<double> rangeVector;
+                for (uint32_t i = 0 ; i < 2; ++i)
+                {
+                    rangeVector.push_back(state.range[i]);
+                }
+                rep.setValue("range", rangeVector);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_THERMOSTAT)
+        {
+            ZigbeeDevice::thermostat_state state;
+            if(targetUri == TEMPERATURE_RELATIVE_URI + "_info")
+            {
+                state = m_device->getThermostatState(m_device, ZBO, "CurrentTemperature");
+                rep.setValue("temperature", state.temperature);
+                rep.setValue("units", state.units);
+            }
+            else if(targetUri == TEMPERATURE_RELATIVE_URI + "_hot")
+            {
+                state = m_device->getThermostatState(m_device, ZBO, "Heat");
+                rep.setValue("temperature", state.temperature);
+                rep.setValue("units", state.units);
+            }
+            else if(targetUri == TEMPERATURE_RELATIVE_URI + "_cool")
+            {
+                state = m_device->getThermostatState(m_device, ZBO, "Cool");
+                rep.setValue("temperature", state.temperature);
+                rep.setValue("units", state.units);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_WINDOW_COVERING_DEVICE)
+        {
+            ZigbeeDevice::window_covering_device_state state;
+            if(targetUri == WINDOW_COVERING_RELATIVE_URI)
+            {
+                state = m_device->getWindowCoveringDeviceState(m_device, ZBO, "Configuration");
+                rep.setValue("windowcoveringtype", state.windowcoveringtype);
+                rep.setValue("liftvelocity", state.liftvelocity);
+                rep.setValue("liftaccelerationtime", state.liftaccelerationtime);
+                rep.setValue("liftdecelerationtime", state.liftdecelerationtime);
+
+                OCRepresentation modeRep;
+                modeRep.setValue("mode.calibration", state.mode.calibration);
+                modeRep.setValue("mode.ledfeedback", state.mode.ledfeedback);
+                modeRep.setValue("mode.maintenance", state.mode.maintenance);
+                modeRep.setValue("mode.motordirection", state.mode.motordirection);
+                rep.setValue("mode", modeRep);
+
+                OCRepresentation configstatusRep;
+                configstatusRep.setValue("configstatus.controllift", state.configstatus.controllift);
+                configstatusRep.setValue("configstatus.controltilt", state.configstatus.controltilt);
+                configstatusRep.setValue("configstatus.closedloopliftcontrol", state.configstatus.closedloopliftcontrol);
+                configstatusRep.setValue("configstatus.closedlooptiltcontrol", state.configstatus.closedlooptiltcontrol);
+                configstatusRep.setValue("configstatus.online", state.configstatus.online);
+                configstatusRep.setValue("configstatus.operational", state.configstatus.operational);
+                configstatusRep.setValue("configstatus.otationdirection", state.configstatus.rotationdirection);
+                rep.setValue("configstatus", configstatusRep);
+            }
+            else if(targetUri == OPENLEVEL_RELATIVE_URI + "_liftpercent")
+            {
+                state = m_device->getWindowCoveringDeviceState(m_device, ZBO, "LiftPercentage");
+                rep.setValue("openLevel", state.openLevel);
+            }
+            else if(targetUri == OPENLEVEL_RELATIVE_URI + "_liftposition")
+            {
+                state = m_device->getWindowCoveringDeviceState(m_device, ZBO, "LiftPosition");
+                rep.setValue("openLevel", state.openLevel);
+
+                std::vector<int> rangeVector;
+                for (uint32_t i = 0 ; i < 2; ++i)
+                {
+                    rangeVector.push_back(state.range[i]);
+                }
+                rep.setValue("range", rangeVector);
+            }
+            else if(targetUri == OPENLEVEL_RELATIVE_URI + "_tiltpercent")
+            {
+                state = m_device->getWindowCoveringDeviceState(m_device, ZBO, "TiltPercentage");
+                rep.setValue("openLevel", state.openLevel);
+            }
+            else if(targetUri == OPENLEVEL_RELATIVE_URI + "_tiltdegree")
+            {
+                state = m_device->getWindowCoveringDeviceState(m_device, ZBO, "TiltPosition");
+                rep.setValue("openLevel", state.openLevel);
+
+                std::vector<int> rangeVector;
+                for (uint32_t i = 0 ; i < 2; ++i)
+                {
+                    rangeVector.push_back(state.range[i]);
+                }
+                rep.setValue("range", rangeVector);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_SMART_PLUG)
+        {
+            ZigbeeDevice::smart_plug_state state;
+            state = m_device->getSmartPlugState(m_device, ZBO);
+            if (targetUri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                rep.setValue("value", state.value);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_MAINS_POWER_OUTLET)
+        {
+            ZigbeeDevice::mains_power_outlet_state state;
+            state = m_device->getMainsPowerOutletState(m_device, ZBO);
+            if (targetUri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                rep.setValue("value", state.value);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_ONOFF_OUTPUT)
+        {
+            ZigbeeDevice::onoff_output_state state;
+            state = m_device->getOnoffOutputState(m_device, ZBO);
+            if (targetUri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                rep.setValue("value", state.value);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_IAS_ZONE)
+        {
+            if(targetUri == IAS_ZONE_RELATIVE_URI)
+            {
+                if(query.find(OC_RSRVD_INTERFACE_DEFAULT) != std::string::npos)
+                {
+                    std::vector < OCRepresentation > linksReps;
+
+                    // iaszoneinfo
+                    OCRepresentation iaszoneinfoRep;
+                    iaszoneinfoRep.setUri(IAS_ZONE_INFO_RELATIVE_URI);
+
+                    std::vector < std::string > resourceTypes;
+                    for (uint32_t i = 0 ; i < m_device->resourceTypes[IAS_ZONE_INFO_RELATIVE_URI].size(); ++i)
+                    {
+                        resourceTypes.push_back((m_device->resourceTypes[IAS_ZONE_INFO_RELATIVE_URI])[i]);
+                    }
+                    iaszoneinfoRep.setResourceTypes(resourceTypes);
+
+                    std::vector < std::string > ifaces;
+                    ifaces.push_back(std::string(DEFAULT_INTERFACE));
+                    for (uint32_t i = 0 ; i < m_device->interfaces[IAS_ZONE_INFO_RELATIVE_URI].size(); ++i)
+                    {
+                        ifaces.push_back((m_device->interfaces[IAS_ZONE_INFO_RELATIVE_URI])[i]);
+                    }
+                    iaszoneinfoRep.setResourceInterfaces(ifaces);
+                    linksReps.push_back(iaszoneinfoRep);
+
+                    // battery
+                    OCRepresentation batteryRep;
+                    batteryRep.setUri(BATTERY_RELATIVE_URI);
+
+                    resourceTypes.clear();
+                    for (uint32_t i = 0 ; i < m_device->resourceTypes[BATTERY_RELATIVE_URI].size(); ++i)
+                    {
+                        resourceTypes.push_back((m_device->resourceTypes[BATTERY_RELATIVE_URI])[i]);
+                    }
+                    batteryRep.setResourceTypes(resourceTypes);
+
+                    ifaces.clear();
+                    ifaces.push_back(std::string(DEFAULT_INTERFACE));
+                    for (uint32_t i = 0 ; i < m_device->interfaces[BATTERY_RELATIVE_URI].size(); ++i)
+                    {
+                        ifaces.push_back((m_device->interfaces[BATTERY_RELATIVE_URI])[i]);
+                    }
+                    batteryRep.setResourceInterfaces(ifaces);
+                    linksReps.push_back(batteryRep);
+
+                    // powersource
+                    OCRepresentation powersourceRep;
+                    powersourceRep.setUri(POWERSOURCE_RELATIVE_URI);
+
+                    resourceTypes.clear();
+                    for (uint32_t i = 0 ; i < m_device->resourceTypes[POWERSOURCE_RELATIVE_URI].size(); ++i)
+                    {
+                        resourceTypes.push_back((m_device->resourceTypes[POWERSOURCE_RELATIVE_URI])[i]);
+                    }
+                    powersourceRep.setResourceTypes(resourceTypes);
+
+                    ifaces.clear();
+                    ifaces.push_back(std::string(DEFAULT_INTERFACE));
+                    for (uint32_t i = 0 ; i < m_device->interfaces[POWERSOURCE_RELATIVE_URI].size(); ++i)
+                    {
+                        ifaces.push_back((m_device->interfaces[POWERSOURCE_RELATIVE_URI])[i]);
+                    }
+                    powersourceRep.setResourceInterfaces(ifaces);
+                    linksReps.push_back(powersourceRep);
+
+                    rep.setValue("links", linksReps);
+                }
+                else if(query.find(OC_RSRVD_INTERFACE_LL) != std::string::npos)
+                {
+                    // iaszoneinfo
+                    OCRepresentation iaszoneinfoRep;
+                    iaszoneinfoRep.setUri(IAS_ZONE_INFO_RELATIVE_URI);
+
+                    std::vector < std::string > resourceTypes;
+                    for (uint32_t i = 0 ; i < m_device->resourceTypes[IAS_ZONE_INFO_RELATIVE_URI].size(); ++i)
+                    {
+                        resourceTypes.push_back((m_device->resourceTypes[IAS_ZONE_INFO_RELATIVE_URI])[i]);
+                    }
+                    iaszoneinfoRep.setResourceTypes(resourceTypes);
+
+                    std::vector < std::string > ifaces;
+                    ifaces.push_back(std::string(DEFAULT_INTERFACE));
+                    for (uint32_t i = 0 ; i < m_device->interfaces[IAS_ZONE_INFO_RELATIVE_URI].size(); ++i)
+                    {
+                        ifaces.push_back((m_device->interfaces[IAS_ZONE_INFO_RELATIVE_URI])[i]);
+                    }
+                    iaszoneinfoRep.setResourceInterfaces(ifaces);
+
+                    // battery
+                    OCRepresentation batteryRep;
+                    batteryRep.setUri(BATTERY_RELATIVE_URI);
+
+                    resourceTypes.clear();
+                    for (uint32_t i = 0 ; i < m_device->resourceTypes[BATTERY_RELATIVE_URI].size(); ++i)
+                    {
+                        resourceTypes.push_back((m_device->resourceTypes[BATTERY_RELATIVE_URI])[i]);
+                    }
+                    batteryRep.setResourceTypes(resourceTypes);
+
+                    ifaces.clear();
+                    ifaces.push_back(std::string(DEFAULT_INTERFACE));
+                    for (uint32_t i = 0 ; i < m_device->interfaces[BATTERY_RELATIVE_URI].size(); ++i)
+                    {
+                        ifaces.push_back((m_device->interfaces[BATTERY_RELATIVE_URI])[i]);
+                    }
+                    batteryRep.setResourceInterfaces(ifaces);
+                    iaszoneinfoRep.addChild(batteryRep);
+
+                    // powersource
+                    OCRepresentation powersourceRep;
+                    powersourceRep.setUri(POWERSOURCE_RELATIVE_URI);
+
+                    resourceTypes.clear();
+                    for (uint32_t i = 0 ; i < m_device->resourceTypes[POWERSOURCE_RELATIVE_URI].size(); ++i)
+                    {
+                        resourceTypes.push_back((m_device->resourceTypes[POWERSOURCE_RELATIVE_URI])[i]);
+                    }
+                    powersourceRep.setResourceTypes(resourceTypes);
+
+                    ifaces.clear();
+                    ifaces.push_back(std::string(DEFAULT_INTERFACE));
+                    for (uint32_t i = 0 ; i < m_device->interfaces[POWERSOURCE_RELATIVE_URI].size(); ++i)
+                    {
+                        ifaces.push_back((m_device->interfaces[POWERSOURCE_RELATIVE_URI])[i]);
+                    }
+                    powersourceRep.setResourceInterfaces(ifaces);
+                    iaszoneinfoRep.addChild(powersourceRep);
+
+                    return iaszoneinfoRep;
+                }
+                else if(query.find(OC_RSRVD_INTERFACE_BATCH) != std::string::npos)
+                {
+                    OCRepresentation iaszoneinfoRep = getRepresentation(IAS_ZONE_INFO_RELATIVE_URI);
+                    iaszoneinfoRep.setUri(IAS_ZONE_INFO_RELATIVE_URI);
+
+                    OCRepresentation batteryRep = getRepresentation(BATTERY_RELATIVE_URI);
+                    batteryRep.setUri(BATTERY_RELATIVE_URI);
+                    iaszoneinfoRep.addChild(batteryRep);
+
+                    OCRepresentation powersourceRep = getRepresentation(POWERSOURCE_RELATIVE_URI);
+                    powersourceRep.setUri(POWERSOURCE_RELATIVE_URI);
+                    iaszoneinfoRep.addChild(powersourceRep);
+
+                    return iaszoneinfoRep;
+                }
+            }
+            else if(targetUri == IAS_ZONE_INFO_RELATIVE_URI)
+            {
+                ZigbeeDevice::IAS_zone_info_state state;
+                state = m_device->getIASZoneState(m_device, ZBO);
+
+                rep.setValue("zonetype", state.zonetype);
+
+                OCRepresentation zonestatusRep;
+                std::vector< std::string > alarms;
+                for (uint32_t i = 0 ; i < state.zonestatus.alarms.size(); ++i)
+                {
+                    alarms.push_back(state.zonestatus.alarms[i]);
+                }
+                zonestatusRep.setValue("zonestatus.alarms", alarms);
+                zonestatusRep.setValue("zonestatus.zonestatusreports", state.zonestatus.zonestatusreports);
+                zonestatusRep.setValue("zonestatus.tamper", state.zonestatus.tamper);
+                zonestatusRep.setValue("zonestatus.test", state.zonestatus.test);
+                zonestatusRep.setValue("zonestatus.fault", state.zonestatus.fault);
+                rep.setValue("zonestatus", zonestatusRep);
+
+                std::vector< bool > zonestatus;
+                for (uint32_t i = 0 ; i < 10; ++i)
+                {
+                    zonestatus.push_back(state.zonestatus_bool[i]);
+                }
+                rep.setValue("zonestatus(bool)", zonestatus);
+
+                rep.setValue("iascieaddress", state.iascieaddress);
+                rep.setValue("zonestate", state.zonestate);
+                rep.setValue("zoneid", state.zoneid);
+                rep.setValue("numzonesensitivitylevel", state.numzonesensitivitylevel);
+                rep.setValue("currentzonesensitivitylevel", state.currentzonesensitivitylevel);
+
+            }
+            else if(targetUri == BATTERY_RELATIVE_URI)
+            {
+                ZigbeeDevice::IAS_zone_info_state state;
+                state = m_device->getIASZoneState(m_device, ZBO);
+
+                rep.setValue("charge", state.zonebattery.charge);
+                rep.setValue("lowbattery", state.zonebattery.lowbattery);
+                rep.setValue("defect", state.zonebattery.defect);
+            }
+            else if(targetUri == POWERSOURCE_RELATIVE_URI)
+            {
+                ZigbeeDevice::IAS_zone_info_state state;
+                state = m_device->getIASZoneState(m_device, ZBO);
+
+                std::vector< std::string > powerSources;
+                for (uint32_t i = 0 ; i < state.zonepowersource.powerSources.size(); ++i)
+                {
+                    powerSources.push_back(state.zonepowersource.powerSources[i]);
+                }
+                rep.setValue("powerSources", powerSources);
+                rep.setValue("sourcefault", state.zonepowersource.powerSources);
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_OCCUPANCY_SENSOR)
+        {
+            ZigbeeDevice::occupancy_sensor_state state;
+            state = m_device->getOccupancySensorState(m_device, ZBO);
+            if (targetUri == PRESENCE_SENSOR_RELATIVE_URI)
+            {
+                rep.setValue("value", state.value);
+            }
+        }
+
+        if (strcmp(targetUri.c_str(), CONFIGURATION_URI))  // targetUri != /con
+        {
+            // set resource type(s) and interface(s) of the target resource to OCRepresentation
+            std::vector < std::string > resourceTypes;
+            for (uint32_t i = 0 ; i < m_device->resourceTypes[targetUri].size(); ++i)
+            {
+                resourceTypes.push_back((m_device->resourceTypes[targetUri])[i]);
+            }
+            rep.setResourceTypes(resourceTypes);
+
+            std::vector < std::string > ifaces;
+            ifaces.push_back(std::string(DEFAULT_INTERFACE));
+            for (uint32_t i = 0 ; i < m_device->interfaces[targetUri].size(); ++i)
+            {
+                ifaces.push_back((m_device->interfaces[targetUri])[i]);
+            }
+            rep.setResourceInterfaces(ifaces);
+        }
+        else // targetUri == /con
+        {
+            rep.setValue(std::string(OC_RSRVD_DEVICE_NAME), m_device->getName());
+
+            std::vector < std::string > resourceTypes;
+            resourceTypes.push_back(OC_RSRVD_RESOURCE_TYPE_CONFIGURATION);
+            rep.setResourceTypes(resourceTypes);
+
+            std::vector < std::string > ifaces;
+            ifaces.push_back(std::string(DEFAULT_INTERFACE));
+            ifaces.push_back(std::string(OC_RSRVD_INTERFACE_READ_WRITE));
+            rep.setResourceInterfaces(ifaces);
+        }
+
+        return rep;
+    }
+
+    OCEntityHandlerResult putRepresentation(std::string uri, OCRepresentation& rep)
+    {
+        // parse query if any
+        std::string query;
+        if(uri.find("?") != std::string::npos)
+        {
+            query = uri.substr(uri.find("?"));
+            uri = uri.substr(0, uri.find("?"));
+        }
+
+        OCEntityHandlerResult result = OC_EH_NOT_ACCEPTABLE;
+        OCRepPayload* payload = rep.getPayload();
+
+        if (m_device->getDeviceType() == DEVICE_TYPE_ONOFF_LIGHT ||
+                m_device->getDeviceType() == DEVICE_TYPE_COLOR_TEMPERATURE_LIGHT ||
+                m_device->getDeviceType() == DEVICE_TYPE_EXTENDED_COLOR_LIGHT ||
+                m_device->getDeviceType() == DEVICE_TYPE_DIMMABLE_LIGHT ||
+                m_device->getDeviceType() == DEVICE_TYPE_COLOR_DIMMABLE_LIGHT)
+        {
+            if(uri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                bool value;
+                if(rep.getValue("value", value))
+                {
+                    if (value == false)
+                    {
+                        ZBO->setOFF(m_device->getEui64());
+                    }
+                    else if (value == true)
+                    {
+                        ZBO->setON(m_device->getEui64());
+                    }
+                    result = OC_EH_OK;
+                }
+            }
+            else if(uri == DIMMING_RELATIVE_URI)
+            {
+                int dimmingSetting;
+                if(rep.getValue("dimmingSetting", dimmingSetting))
+                {
+                    m_device->OCFToZigbee(uri, "dimmingSetting", dimmingSetting, &dimmingSetting);
+                    ZBO->moveToLevel(m_device->getEui64(), dimmingSetting, 0);
+                    result = OC_EH_OK;
+                }
+            }
+            else if(uri == COLOR_HS_RELATIVE_URI)
+            {
+                double hue = 0.0;
+                int saturation = 0;
+                int numberOfUpdatedProperties = 0;
+                if(rep.getValue("hue", hue))
+                {
+                    if(hue < 0 || 360 < hue)
+                    {
+                        return OC_EH_BAD_REQ;
+                    }
+                    m_device->OCFToZigbee(uri, "hue", hue, &hue);
+                    ZBO->moveToHueSat(m_device->getEui64(), (int)hue, saturation, 0);
+                    numberOfUpdatedProperties++;
+                    result = OC_EH_OK;
+                }
+                if(rep.getValue("saturation", saturation))
+                {
+                    m_device->OCFToZigbee(uri, "saturation", saturation, &saturation);
+                    ZBO->moveToHueSat(m_device->getEui64(), (int)hue, saturation, 0);
+                    numberOfUpdatedProperties++;
+                    result = OC_EH_OK;
+                }
+
+                if(numberOfUpdatedProperties < 2)
+                {
+                    result = OC_EH_BAD_REQ;
+                }
+            }
+            else if(uri == COLOR_CSC_RELATIVE_URI)
+            {
+                size_t csc_dimensions[MAX_REP_ARRAY_DEPTH] = {2, 0, 0};
+                double *csc = NULL;
+                int colorx, colory;
+                if(OCRepPayloadGetDoubleArray(payload, "csc", &csc, csc_dimensions))
+                {
+                    if(csc[0] < 0.0 || 1.0 < csc[0])
+                    {
+                        return OC_EH_BAD_REQ;
+                    }
+                    if(csc[1] < 0.0 || 1.0 < csc[1])
+                    {
+                        return OC_EH_BAD_REQ;
+                    }
+                    m_device->OCFToZigbee(uri, "csc", csc[0], &colorx);
+                    m_device->OCFToZigbee(uri, "csc", csc[1], &colory);
+                    ZBO->moveToColor(m_device->getEui64(), colorx, colory, 0);
+                    result = OC_EH_OK;
+                }
+                OICFree(csc);
+            }
+            else if(uri == COLOR_CT_RELATIVE_URI)
+            {
+                int ct;
+                if(rep.getValue("ct", ct))
+                {
+                    if(ct < 0)
+                    {
+                        return OC_EH_BAD_REQ;
+                    }
+                    m_device->OCFToZigbee(uri, "ct", ct, &ct);
+                    ZBO->moveToColorTemp(m_device->getEui64(), ct, 0);
+                    result = OC_EH_OK;
+                }
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_TEMPERATURE_SENSOR ||
+                m_device->getDeviceType() == DEVICE_TYPE_OCCUPANCY_SENSOR)
+        {
+            // nothing to do in case of OCF -> Zigbee translation
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_THERMOSTAT)
+        {
+            if(uri == TEMPERATURE_RELATIVE_URI + "_info")
+            {
+                // nothing to do in case of OCF -> Zigbee translation
+            }
+            else if(uri == TEMPERATURE_RELATIVE_URI + "_hot")
+            {
+                double temperature;
+                if(rep.getValue("temperature", temperature))
+                {
+                    m_device->OCFToZigbee(uri, "temperature", temperature, &temperature);
+                    ZBO->setPointRaiseLower(m_device->getEui64(), 0x00, temperature);
+                    result = OC_EH_OK;
+                }
+            }
+            else if(uri == TEMPERATURE_RELATIVE_URI + "_cool")
+            {
+                double temperature;
+                if(rep.getValue("temperature", temperature))
+                {
+                    m_device->OCFToZigbee(uri, "temperature", temperature, &temperature);
+                    ZBO->setPointRaiseLower(m_device->getEui64(), 0x01, temperature);
+                    result = OC_EH_OK;
+                }
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_WINDOW_COVERING_DEVICE)
+        {
+            if(uri == WINDOW_COVERING_RELATIVE_URI)
+            {
+                int liftaccelerationtime;
+                if(rep.getValue("liftaccelerationtime", liftaccelerationtime))
+                {
+                    m_device->OCFToZigbee(uri, "liftaccelerationtime", liftaccelerationtime, &liftaccelerationtime);
+                    ZBO->setLiftAccelerationTime(m_device->getEui64(), liftaccelerationtime);
+                    result = OC_EH_OK;
+                }
+
+                int liftdecelerationtime;
+                if(rep.getValue("liftdecelerationtime", liftdecelerationtime))
+                {
+                    m_device->OCFToZigbee(uri, "liftdecelerationtime", liftdecelerationtime, &liftdecelerationtime);
+                    ZBO->setLiftDecelerationTime(m_device->getEui64(), liftdecelerationtime);
+                    result = OC_EH_OK;
+                }
+
+                int liftvelocity;
+                if(rep.getValue("liftvelocity", liftvelocity))
+                {
+                    m_device->OCFToZigbee(uri, "liftvelocity", liftvelocity, &liftvelocity);
+                    ZBO->setLiftVelocity(m_device->getEui64(), liftvelocity);
+                    result = OC_EH_OK;
+                }
+
+                OCRepresentation modeRep;
+                if(rep.getValue("mode", modeRep))
+                {
+                    bool mode[4] = {false, false, false, false};
+                    rep.getValue("mode.calibration", mode[0]);
+                    rep.getValue("mode.ledfeedback", mode[1]);
+                    rep.getValue("mode.maintenance", mode[2]);
+                    rep.getValue("mode.motordirection", mode[3]);
+
+                    int Mode = 0;
+                    m_device->OCFToZigbeeBitmapMasking(uri, "mode", mode, 4, &Mode);
+                    ZBO->setMode(m_device->getEui64(), Mode);
+                    result = OC_EH_OK;
+
+                    OICFree(mode);
+                }
+            }
+            else if(uri == OPENLEVEL_RELATIVE_URI + "_liftpercent")
+            {
+                int openLevel;
+                if(rep.getValue("openLevel", openLevel))
+                {
+                    m_device->OCFToZigbee(uri, "openLevel", openLevel, &openLevel);
+                    ZBO->goToLiftPercentage(m_device->getEui64(), openLevel);
+                    result = OC_EH_OK;
+                }
+            }
+            else if(uri == OPENLEVEL_RELATIVE_URI + "_liftposition")
+            {
+                int openLevel;
+                if(rep.getValue("openLevel", openLevel))
+                {
+                    m_device->OCFToZigbee(uri, "openLevel", openLevel, &openLevel);
+                    ZBO->goToLiftValue(m_device->getEui64(), openLevel);
+                    result = OC_EH_OK;
+                }
+            }
+            else if(uri == OPENLEVEL_RELATIVE_URI + "_tiltpercent")
+            {
+                int openLevel;
+                if(rep.getValue("openLevel", openLevel))
+                {
+                    m_device->OCFToZigbee(uri, "openLevel", openLevel, &openLevel);
+                    ZBO->goToTiltPercentage(m_device->getEui64(), openLevel);
+                    result = OC_EH_OK;
+                }
+            }
+            else if(uri == OPENLEVEL_RELATIVE_URI + "_tiltdegree")
+            {
+                int openLevel;
+                if(rep.getValue("openLevel", openLevel))
+                {
+                    m_device->OCFToZigbee(uri, "openLevel", openLevel, &openLevel);
+                    ZBO->goToTiltValue(m_device->getEui64(), openLevel);
+                    result = OC_EH_OK;
+                }
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_SMART_PLUG ||
+                m_device->getDeviceType() == DEVICE_TYPE_MAINS_POWER_OUTLET ||
+                m_device->getDeviceType() == DEVICE_TYPE_ONOFF_OUTPUT)
+        {
+            if(uri == BINARY_SWITCH_RELATIVE_URI)
+            {
+                bool value;
+                if(rep.getValue("value", value))
+                {
+                    if (value == false)
+                    {
+                        ZBO->setOFF(m_device->getEui64());
+                    }
+                    else if (value == true)
+                    {
+                        ZBO->setON(m_device->getEui64());
+                    }
+                    result = OC_EH_OK;
+                }
+            }
+        }
+        else if (m_device->getDeviceType() == DEVICE_TYPE_IAS_ZONE)
+        {
+            if(uri == IAS_ZONE_RELATIVE_URI)
+            {
+                if(query.find(OC_RSRVD_INTERFACE_BATCH) != std::string::npos)
+                {
+                    putRepresentation(IAS_ZONE_INFO_RELATIVE_URI, rep);
+                }
+            }
+            else if(uri == IAS_ZONE_INFO_RELATIVE_URI)
+            {
+                int currentzonesensitivitylevel;
+                if(rep.getValue("currentzonesensitivitylevel", currentzonesensitivitylevel))
+                {
+                    m_device->OCFToZigbee(uri, "currentzonesensitivitylevel", currentzonesensitivitylevel, &currentzonesensitivitylevel);
+                    ZBO->setCurrentZoneSensitivityLevel(m_device->getEui64(), currentzonesensitivitylevel);
+                    result = OC_EH_OK;
+                }
+            }
+        }
+        if (uri == CONFIGURATION_URI)  // targetUri == /con
+        {
+            char *deviceName = NULL;
+            if(OCRepPayloadGetPropString(payload, OC_RSRVD_DEVICE_NAME, &deviceName))
+            {
+                m_device->setName(std::string(deviceName));
+                OCStackResult res;
+                res = OCPlatform::setPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME,
+                        m_device->getName());
+                if (res != OC_STACK_OK)
+                {
+                    std::cout << "Failed to set device name" << std::endl;
+                }
+                else
+                {
+                    result = OC_EH_OK;
+                }
+            }
+        }
+
+        return result;
+    }
+
+    bool isObservedResource(std::string uri)
+    {
+        if(m_interestedObserverMap[uri].size() > 0)
+        {
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+    }
+
+private:
+    OCEntityHandlerResult entityHandler(std::shared_ptr< OCResourceRequest > request)
+    {
+        OCEntityHandlerResult ehResult = OC_EH_ERROR;
+        if (request)
+        {
+            // Get the request type and request flag
+            std::string requestType = request->getRequestType();
+            int requestFlag = request->getRequestHandlerFlag();
+            std::string requestUri = request->getResourceUri();
+
+            // Check for query params (if any) and add them to the request uri
+            QueryParamsMap queries = request->getQueryParameters();
+            for (auto it : queries)
+            {
+                requestUri += "?";
+                requestUri += it.first;
+                requestUri += "=";
+                requestUri += it.second;
+            }
+
+            if (requestFlag & RequestHandlerFlag::RequestFlag)
+            {
+                auto pResponse = std::make_shared< OCResourceResponse >();
+                pResponse->setRequestHandle(request->getRequestHandle());
+                pResponse->setResourceHandle(request->getResourceHandle());
+
+                // If the request type is GET
+                if (requestType == "GET")
+                {
+                    ObservationInfo observationInfo = request->getObservationInfo();
+                    if ((requestFlag & RequestHandlerFlag::ObserverFlag) && (ObserveAction::ObserveUnregister == observationInfo.action))
+                    {
+                        // do nothing in case of unregister observation
+                    }
+                    else
+                    {
+                        pResponse->setResponseResult(OC_EH_OK);
+                        pResponse->setResourceRepresentation(getRepresentation(requestUri));
+                        if (OC_STACK_OK == OCPlatform::sendResponse(pResponse))
+                        {
+                            ehResult = OC_EH_OK;
+                        }
+                    }
+                }
+                else if (requestType == "PUT" || requestType == "POST")
+                {
+                    OCRepresentation rep = request->getResourceRepresentation();
+                    OCEntityHandlerResult result = putRepresentation(requestUri, rep);
+                    pResponse->setResponseResult(result);
+                    pResponse->setResourceRepresentation(rep);
+                    if (OC_STACK_OK == OCPlatform::sendResponse(pResponse))
+                    {
+                        ehResult = OC_EH_OK;
+                    }
+                }
+            }
+            if (requestFlag & RequestHandlerFlag::ObserverFlag)
+            {
+                ObservationInfo observationInfo = request->getObservationInfo();
+                if (ObserveAction::ObserveRegister == observationInfo.action)
+                {
+                    m_interestedObserverMap[request->getResourceUri()].push_back(observationInfo.obsId);
+                }
+                else if (ObserveAction::ObserveUnregister == observationInfo.action)
+                {
+
+                    m_interestedObserverMap[request->getResourceUri()].erase(
+                            std::remove(m_interestedObserverMap[request->getResourceUri()].begin(), m_interestedObserverMap[request->getResourceUri()].end(),
+                                    observationInfo.obsId), m_interestedObserverMap[request->getResourceUri()].end());
+
+                    auto pResponse = std::make_shared< OCResourceResponse >();
+                    pResponse->setRequestHandle(request->getRequestHandle());
+                    pResponse->setResourceHandle(request->getResourceHandle());
+                    pResponse->setResponseResult(OC_EH_OK);
+                    if (OC_STACK_OK == OCPlatform::sendResponse(pResponse))
+                    {
+                        ehResult = OC_EH_OK;
+                    }
+                }
+
+#if defined(_WIN32)
+                DWORD threadId = 0;
+                HANDLE threadHandle = INVALID_HANDLE_VALUE;
+#else
+                pthread_t threadId;
+#endif
+                static int startedThread = 0;
+
+                // Observation happens on a different thread in ChangeRepresentation function.
+                // If we have not created the thread already, we will create one here.
+                if (!startedThread)
+                {
+#if defined(_WIN32)
+                    threadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ChangeRepresentation, (void*)this, 0, &threadId);
+#else
+                    pthread_create(&threadId, NULL, ChangeRepresentation, (void *) this);
+#endif
+                    startedThread = 1;
+                }
+                ehResult = OC_EH_OK;
+            }
+        }
+        else
+        {
+            std::cout << "Request invalid" << std::endl;
+        }
+
+        return ehResult;
+    }
+};
+
+void notify(OCRepresentation rep, OCResourceHandle resHandle, ObservationIds observers)
+{
+    std::shared_ptr<OCResourceResponse> resourceResponse = {   std::make_shared<OCResourceResponse>()};
+    resourceResponse->setResourceRepresentation(rep);
+
+    OCStackResult result = OCPlatform::notifyListOfObservers(resHandle, observers, resourceResponse);
+
+    if (OC_STACK_NO_OBSERVERS == result)
+    {
+        cout << "No More observers, stopping notifications" << endl;
+    }
+
+    gObservation = 0;
+}
+
+void* ChangeRepresentation(void* param)
+{
+    VirtualServer* virtualServer = (VirtualServer *) param;
+
+    // This function continuously monitors for the changes
+    OCRepresentation oldRep, newRep;
+    OCRepPayload *oldPayload[5], *newPayload;
+    for (uint32_t i = 0 ; i < 5 ; ++i)
+    {
+        oldPayload[i] = OCRepPayloadCreate();  // empty payload
+    }
+
+    // DEVICE_TYPE_ONOFF_LIGHT, DEVICE_TYPE_COLOR_TEMPERATURE_LIGHT, DEVICE_TYPE_EXTENDED_COLOR_LIGHT, DEVICE_TYPE_DIMMABLE_LIGHT, DEVICE_TYPE_COLOR_DIMMABLE_LIGHT
+    // DEVICE_TYPE_SMART_PLUG, DEVICE_TYPE_MAINS_POWER_OUTLET, DEVICE_TYPE_ONOFF_OUTPUT, DEVICE_TYPE_OCCUPANCY_SENSOR
+    bool oldValue, newValue;
+    int64_t oldDimmingSetting, newDimmingSetting;
+    double oldHue, newHue;
+    int64_t oldSat, newSat, oldCt, newCt;
+    double *oldCsc, *newCsc;
+
+    // DEVICE_TYPE_TEMPERATURE_SENSOR
+    double oldTemperature, newTemperature;
+
+    // DEVICE_TYPE_THERMOSTAT
+    double oldTemperatureInfo, newTemperatureInfo, oldTemperatureHot, newTemperatureHot, oldTemperatureCool, newTemperatureCool;
+
+    // DEVICE_TYPE_WINDOW_COVERING_DEVICE
+    int64_t oldLift_AccelerationTime, newLift_AccelerationTime, oldLift_DecelerationTime, newLift_DecelerationTime, oldLift_Velocity, newLift_Velocity;
+    bool oldMode[4] = {false, false, false, false}, newMode[4] = {false, false, false, false};
+    char *oldControlLift, *newControlLift, *oldControlTift, *newControlTift, *oldClosedLoopLiftControl, *newClosedLoopLiftControl, *oldClosedLoopTiftControl, *newClosedLoopTiftControl, *oldRotationDirection, *newRotationDirection;
+    bool oldOnline, newOnline, oldOperational, newOperational;
+    int64_t oldOpenLevelLiftPercent, newOpenLevelLiftPercent, oldOpenLevelLiftPosition, newOpenLevelLiftPosition, oldOpenLevelTiltPercent, newOpenLevelTiltPercent,  oldOpenLevelTiltPosition, newOpenLevelTiltPosition;
+
+    // DEVICE_TYPE_IAS_ZONE
+    int64_t oldCurrentZoneSensitivityLevel, newCurrentZoneSensitivityLevel;
+    bool oldZoneState, newZoneState, *oldZoneStatus, *newZoneStatus;
+
+    while (1)
+    {
+        if (virtualServer->m_device->getDeviceType() == DEVICE_TYPE_ONOFF_LIGHT ||
+                virtualServer->m_device->getDeviceType() == DEVICE_TYPE_COLOR_TEMPERATURE_LIGHT ||
+                virtualServer->m_device->getDeviceType() == DEVICE_TYPE_EXTENDED_COLOR_LIGHT ||
+                virtualServer->m_device->getDeviceType() == DEVICE_TYPE_DIMMABLE_LIGHT ||
+                virtualServer->m_device->getDeviceType() == DEVICE_TYPE_COLOR_DIMMABLE_LIGHT)
+        {
+            for (uint32_t i = 0 ; i < virtualServer->m_uri.size(); ++i)
+            {
+                newRep = virtualServer->getRepresentation(virtualServer->m_uri[i]);
+                newPayload = newRep.getPayload();
+                if (virtualServer->m_uri[i] == BINARY_SWITCH_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropBool(oldPayload[i], "value", &oldValue);
+                    OCRepPayloadGetPropBool(newPayload, "value", &newValue);
+                    gObservation = oldValue != newValue ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == DIMMING_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropInt(oldPayload[i], "dimmingSetting", &oldDimmingSetting);
+                    OCRepPayloadGetPropInt(newPayload, "dimmingSetting", &newDimmingSetting);
+                    gObservation = oldDimmingSetting != newDimmingSetting ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == COLOR_HS_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropDouble(oldPayload[i], "hue", &oldHue);
+                    OCRepPayloadGetPropDouble(newPayload, "hue", &newHue);
+                    gObservation = oldHue != newHue ? 1 : 0;
+
+                    OCRepPayloadGetPropInt(oldPayload[i], "saturation", &oldSat);
+                    OCRepPayloadGetPropInt(newPayload, "saturation", &newSat);
+                    gObservation = (gObservation || oldSat != newSat) ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == COLOR_CSC_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    size_t csc_dimensions[MAX_REP_ARRAY_DEPTH] = {2, 0, 0};
+                    OCRepPayloadGetDoubleArray(oldPayload[i], "csc", &oldCsc, csc_dimensions);
+                    OCRepPayloadGetDoubleArray(newPayload, "csc", &newCsc, csc_dimensions);
+                    gObservation = oldCsc[0] != newCsc[0] ? 1 : 0;
+                    gObservation = (gObservation || oldCsc[1] != newCsc[1]) ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == COLOR_CT_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropInt(oldPayload[i], "ct", &oldCt);
+                    OCRepPayloadGetPropInt(newPayload, "ct", &newCt);
+                    gObservation = oldCt != newCt ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+
+                if(gObservation)
+                {
+                    notify(newRep, virtualServer->getHandle(i), virtualServer->m_interestedObserverMap[virtualServer->m_uri[i]]);
+                }
+            }
+        }
+        else if (virtualServer->m_device->getDeviceType() == DEVICE_TYPE_TEMPERATURE_SENSOR)
+        {
+            for (uint32_t i = 0 ; i < virtualServer->m_uri.size(); ++i)
+            {
+                sleep(OBSERVE_NOTIFICATION_INTERVAL);
+
+                newRep = virtualServer->getRepresentation(virtualServer->m_uri[i]);
+                newPayload = newRep.getPayload();
+                if (virtualServer->m_uri[i] == TEMPERATURE_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropDouble(oldPayload[i], "temperature", &oldTemperature);
+                    OCRepPayloadGetPropDouble(newPayload, "temperature", &newTemperature);
+                    gObservation = oldTemperature != newTemperature ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+
+                if(gObservation)
+                {
+                    notify(newRep, virtualServer->getHandle(i), virtualServer->m_interestedObserverMap[virtualServer->m_uri[i]]);
+                }
+            }
+        }
+        else if (virtualServer->m_device->getDeviceType() == DEVICE_TYPE_THERMOSTAT)
+        {
+            for (uint32_t i = 0 ; i < virtualServer->m_uri.size(); ++i)
+            {
+                sleep(OBSERVE_NOTIFICATION_INTERVAL);
+
+                newRep = virtualServer->getRepresentation(virtualServer->m_uri[i]);
+                newPayload = newRep.getPayload();
+                if (virtualServer->m_uri[i] == TEMPERATURE_RELATIVE_URI + "_info" && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropDouble(oldPayload[i], "temperature", &oldTemperatureInfo);
+                    OCRepPayloadGetPropDouble(newPayload, "temperature", &newTemperatureInfo);
+                    gObservation = oldTemperatureInfo != newTemperatureInfo ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == TEMPERATURE_RELATIVE_URI + "_hot" && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropDouble(oldPayload[i], "temperature", &oldTemperatureHot);
+                    OCRepPayloadGetPropDouble(newPayload, "temperature", &newTemperatureHot);
+                    gObservation = oldTemperatureHot != newTemperatureHot ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == TEMPERATURE_RELATIVE_URI + "_cool" && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropDouble(oldPayload[i], "temperature", &oldTemperatureCool);
+                    OCRepPayloadGetPropDouble(newPayload, "temperature", &newTemperatureCool);
+                    gObservation = oldTemperatureCool != newTemperatureCool ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+
+                if(gObservation)
+                {
+                    notify(newRep, virtualServer->getHandle(i), virtualServer->m_interestedObserverMap[virtualServer->m_uri[i]]);
+                }
+            }
+        }
+        else if (virtualServer->m_device->getDeviceType() == DEVICE_TYPE_WINDOW_COVERING_DEVICE)
+        {
+            for (uint32_t i = 0 ; i < virtualServer->m_uri.size(); ++i)
+            {
+                sleep(OBSERVE_NOTIFICATION_INTERVAL);
+
+                newRep = virtualServer->getRepresentation(virtualServer->m_uri[i]);
+                newPayload = newRep.getPayload();
+                if (virtualServer->m_uri[i] == WINDOW_COVERING_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropInt(oldPayload[i], "liftaccelerationtime", &oldLift_AccelerationTime);
+                    OCRepPayloadGetPropInt(newPayload, "liftaccelerationtime", &newLift_AccelerationTime);
+                    gObservation = oldLift_AccelerationTime != newLift_AccelerationTime ? 1 : 0;
+
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropInt(oldPayload[i], "liftdecelerationtime", &oldLift_DecelerationTime);
+                        OCRepPayloadGetPropInt(newPayload, "liftdecelerationtime", &newLift_DecelerationTime);
+                        gObservation = oldLift_DecelerationTime != newLift_DecelerationTime ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropInt(oldPayload[i], "liftvelocity", &oldLift_Velocity);
+                        OCRepPayloadGetPropInt(newPayload, "liftvelocity", &newLift_Velocity);
+                        gObservation = oldLift_Velocity != newLift_Velocity ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropBool(oldPayload[i], "mode.calibration", &(oldMode[0]));
+                        OCRepPayloadGetPropBool(oldPayload[i], "mode.ledfeedback", &(oldMode[1]));
+                        OCRepPayloadGetPropBool(oldPayload[i], "mode.maintenance", &(oldMode[2]));
+                        OCRepPayloadGetPropBool(oldPayload[i], "mode.motordirection", &(oldMode[3]));
+
+                        OCRepPayloadGetPropBool(newPayload, "mode.calibration", &(newMode[0]));
+                        OCRepPayloadGetPropBool(newPayload, "mode.ledfeedback", &(newMode[1]));
+                        OCRepPayloadGetPropBool(newPayload, "mode.maintenance", &(newMode[2]));
+                        OCRepPayloadGetPropBool(newPayload, "mode.motordirection", &(newMode[3]));
+
+                        gObservation = oldMode[0] != newMode[0] ? 1 : 0;
+                        gObservation = (gObservation || oldMode[1] != newMode[1]) ? 1 : 0;
+                        gObservation = (gObservation || oldMode[2] != newMode[2]) ? 1 : 0;
+                        gObservation = (gObservation || oldMode[3] != newMode[3]) ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropString(oldPayload[i], "configstatus.controllift", &oldControlLift);
+                        OCRepPayloadGetPropString(newPayload, "configstatus.controllift", &newControlLift);
+                        gObservation = strcmp(oldControlLift, newControlLift) ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropString(oldPayload[i], "configstatus.controltilt", &oldControlTift);
+                        OCRepPayloadGetPropString(newPayload, "configstatus.controltilt", &newControlTift);
+                        gObservation = strcmp(oldControlTift, newControlTift) ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropString(oldPayload[i], "configstatus.closedloopliftcontrol", &oldClosedLoopLiftControl);
+                        OCRepPayloadGetPropString(newPayload, "configstatus.closedloopliftcontrol", &newClosedLoopLiftControl);
+                        gObservation = strcmp(oldClosedLoopLiftControl, newClosedLoopLiftControl) ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropString(oldPayload[i], "configstatus.closedlooptiltcontrol", &oldClosedLoopTiftControl);
+                        OCRepPayloadGetPropString(newPayload, "configstatus.closedlooptiltcontrol", &newClosedLoopTiftControl);
+                        gObservation = strcmp(oldClosedLoopTiftControl, newClosedLoopTiftControl) ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropBool(oldPayload[i], "configstatus.online", &oldOnline);
+                        OCRepPayloadGetPropBool(newPayload, "configstatus.online", &newOnline);
+                        gObservation = oldOnline != newOnline ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropBool(oldPayload[i], "configstatus.operational", &oldOperational);
+                        OCRepPayloadGetPropBool(newPayload, "configstatus.operational", &newOperational);
+                        gObservation = oldOperational != newOperational ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropString(oldPayload[i], "configstatus.rotationdirection", &oldRotationDirection);
+                        OCRepPayloadGetPropString(newPayload, "configstatus.rotationdirection", &newRotationDirection);
+                        gObservation = strcmp(oldRotationDirection, newRotationDirection) ? 1 : 0;
+                    }
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == OPENLEVEL_RELATIVE_URI + "_liftpercent" && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropInt(oldPayload[i], "openLevel", &oldOpenLevelLiftPercent);
+                    OCRepPayloadGetPropInt(newPayload, "openLevel", &newOpenLevelLiftPercent);
+                    gObservation = oldOpenLevelLiftPercent != newOpenLevelLiftPercent ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == OPENLEVEL_RELATIVE_URI + "_liftposition" && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropInt(oldPayload[i], "openLevel", &oldOpenLevelLiftPosition);
+                    OCRepPayloadGetPropInt(newPayload, "openLevel", &newOpenLevelLiftPosition);
+                    gObservation = oldOpenLevelLiftPosition != newOpenLevelLiftPosition ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == OPENLEVEL_RELATIVE_URI + "_tiltpercent" && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropInt(oldPayload[i], "openLevel", &oldOpenLevelTiltPercent);
+                    OCRepPayloadGetPropInt(newPayload, "openLevel", &newOpenLevelTiltPercent);
+                    gObservation = oldOpenLevelTiltPercent != newOpenLevelTiltPercent ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                else if(virtualServer->m_uri[i] == OPENLEVEL_RELATIVE_URI + "_tiltdegree" && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropInt(oldPayload[i], "openLevel", &oldOpenLevelTiltPosition);
+                    OCRepPayloadGetPropInt(newPayload, "openLevel", &newOpenLevelTiltPosition);
+                    gObservation = oldOpenLevelTiltPosition != newOpenLevelTiltPosition ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+
+                if(gObservation)
+                {
+                    notify(newRep, virtualServer->getHandle(i), virtualServer->m_interestedObserverMap[virtualServer->m_uri[i]]);
+                }
+            }
+        }
+        else if (virtualServer->m_device->getDeviceType() == DEVICE_TYPE_SMART_PLUG ||
+                virtualServer->m_device->getDeviceType() == DEVICE_TYPE_MAINS_POWER_OUTLET ||
+                virtualServer->m_device->getDeviceType() == DEVICE_TYPE_ONOFF_OUTPUT)
+        {
+            for (uint32_t i = 0 ; i < virtualServer->m_uri.size(); ++i)
+            {
+                sleep(OBSERVE_NOTIFICATION_INTERVAL);
+
+                newRep = virtualServer->getRepresentation(virtualServer->m_uri[i]);
+                newPayload = newRep.getPayload();
+                if (virtualServer->m_uri[i] == BINARY_SWITCH_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropBool(oldPayload[i], "value", &oldValue);
+                    OCRepPayloadGetPropBool(newPayload, "value", &newValue);
+                    gObservation = oldValue != newValue ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                if(gObservation)
+                {
+                    notify(newRep, virtualServer->getHandle(i), virtualServer->m_interestedObserverMap[virtualServer->m_uri[i]]);
+                }
+            }
+        }
+        else if (virtualServer->m_device->getDeviceType() == DEVICE_TYPE_IAS_ZONE)
+        {
+            for (uint32_t i = 0 ; i < virtualServer->m_uri.size(); ++i)
+            {
+                sleep(OBSERVE_NOTIFICATION_INTERVAL);
+
+                newRep = virtualServer->getRepresentation(virtualServer->m_uri[i]);
+                newPayload = newRep.getPayload();
+                if (virtualServer->m_uri[i] == IAS_ZONE_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropInt(oldPayload[i], "currentzonesensitivitylevel", &oldCurrentZoneSensitivityLevel);
+                    OCRepPayloadGetPropInt(newPayload, "currentzonesensitivitylevel", &newCurrentZoneSensitivityLevel);
+                    gObservation = oldCurrentZoneSensitivityLevel != newCurrentZoneSensitivityLevel ? 1 : 0;
+                    oldPayload[i] = newPayload;
+
+                    if(!gObservation)
+                    {
+                        OCRepPayloadGetPropBool(oldPayload[i], "zonestate", &oldZoneState);
+                        OCRepPayloadGetPropBool(newPayload, "zonestate", &newZoneState);
+                        gObservation = oldZoneState != newZoneState ? 1 : 0;
+                    }
+                    if(!gObservation)
+                    {
+                        size_t mode_dimensions[MAX_REP_ARRAY_DEPTH] = {10, 0, 0};
+                        OCRepPayloadGetBoolArray(oldPayload[i], "zonestatus(bool)", &oldZoneStatus, mode_dimensions);
+                        OCRepPayloadGetBoolArray(newPayload, "zonestatus(bool)", &newZoneStatus, mode_dimensions);
+                        gObservation = oldZoneStatus[0] != newZoneStatus[0] ? 1 : 0;
+                        gObservation = (gObservation || oldZoneStatus[1] != newZoneStatus[1]) ? 1 : 0;
+                        gObservation = (gObservation || oldZoneStatus[2] != newZoneStatus[1]) ? 1 : 0;
+                        gObservation = (gObservation || oldZoneStatus[3] != newZoneStatus[1]) ? 1 : 0;
+                        gObservation = (gObservation || oldZoneStatus[4] != newZoneStatus[1]) ? 1 : 0;
+                        gObservation = (gObservation || oldZoneStatus[5] != newZoneStatus[1]) ? 1 : 0;
+                        gObservation = (gObservation || oldZoneStatus[6] != newZoneStatus[1]) ? 1 : 0;
+                        gObservation = (gObservation || oldZoneStatus[7] != newZoneStatus[1]) ? 1 : 0;
+                        gObservation = (gObservation || oldZoneStatus[8] != newZoneStatus[1]) ? 1 : 0;
+                        gObservation = (gObservation || oldZoneStatus[9] != newZoneStatus[1]) ? 1 : 0;
+                    }
+                    oldPayload[i] = newPayload;
+                }
+                if(gObservation)
+                {
+                    notify(newRep, virtualServer->getHandle(i), virtualServer->m_interestedObserverMap[virtualServer->m_uri[i]]);
+                }
+            }
+        }
+        else if (virtualServer->m_device->getDeviceType() == DEVICE_TYPE_OCCUPANCY_SENSOR)
+        {
+            for (uint32_t i = 0 ; i < virtualServer->m_uri.size(); ++i)
+            {
+                sleep(OBSERVE_NOTIFICATION_INTERVAL);
+
+                newRep = virtualServer->getRepresentation(virtualServer->m_uri[i]);
+                newPayload = newRep.getPayload();
+                if (virtualServer->m_uri[i] == BINARY_SWITCH_RELATIVE_URI && virtualServer->isObservedResource(virtualServer->m_uri[i]))
+                {
+                    OCRepPayloadGetPropBool(oldPayload[i], "value", &oldValue);
+                    OCRepPayloadGetPropBool(newPayload, "value", &newValue);
+                    gObservation = oldValue != newValue ? 1 : 0;
+                    oldPayload[i] = newPayload;
+                }
+                if(gObservation)
+                {
+                    notify(newRep, virtualServer->getHandle(i), virtualServer->m_interestedObserverMap[virtualServer->m_uri[i]]);
+                }
+            }
+        }
+        sleep(OBSERVE_NOTIFICATION_INTERVAL);
+    }
+
+    return NULL;
+}
+
+void addResourceToResourceHandle(ResourceHandles* resourceHandles, const char* uri)
+{
+    if(FindResourceByUri(uri))
+    {
+        resourceHandles->push_back(FindResourceByUri(uri));
+    }
+}
+
+void handleSignal(int signum)
+{
+    if (signum == SIGUSR1)
+    {
+        exit(EXIT_SUCCESS);
+    }
+}
+#ifdef SECURED
+OCStackResult setResourcesToIndiscoverable()
+{
+    uint8_t numResources = 0;
+    OCGetNumberOfResources(&numResources);
+
+    OCStackResult result = OC_STACK_OK;
+
+    for (uint8_t i = 0; i < numResources; i++)
+    {
+        OCResourceHandle resHandle = OCGetResourceHandle(i);
+        if (resHandle)
+        {
+            result = OCClearResourceProperties(resHandle, OC_DISCOVERABLE);
+            if (result != OC_STACK_OK)
+            {
+                OIC_LOG_V(ERROR, TAG, "Failed to clear OC_DISCOVERABLE (%d)", result);
+                return OC_STACK_ERROR;
+            }
+        }
+    }
+    return result;
+}
+
+OCStackResult setResourcesToDiscoverable()
+{
+    uint8_t numResources = 0;
+    OCGetNumberOfResources(&numResources);
+
+    OCStackResult result = OC_STACK_OK;
+
+    for (uint8_t i = 0; i < numResources; i++)
+    {
+        OCResourceHandle resHandle = OCGetResourceHandle(i);
+        if (resHandle)
+        {
+            result = OCSetResourceProperties(resHandle, OC_DISCOVERABLE);
+            if (result != OC_STACK_OK)
+            {
+                OIC_LOG_V(ERROR, TAG, "Failed to set OC_DISCOVERABLE (%d)", result);
+                return OC_STACK_ERROR;
+            }
+        }
+    }
+    return result;
+}
+#endif
+
+static FILE* client_open(const char* path, const char* mode)
+{
+    char const * filename = path;
+    if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    {
+        filename = VIRTUALSVR_DB_FILE_NAME;
+    }
+    else if (0 == strcmp(path, OC_INTROSPECTION_FILE_NAME))
+    {
+        filename = INTROSPECTION_DATA_FILE_NAME;
+    }
+    return fopen(filename, mode);
+}
+
+#ifdef SECURED
+void *shmaddr;
+void writeOwnedStateOnSharedMemory(bool state)
+{
+    char buf[1024];
+    strcpy(buf, (char *)shmaddr);
+    std::string strBuf = buf;
+
+    char pidBuf[8];
+    sprintf(pidBuf, "%d\t", getpid());
+    std::string pidStr = pidBuf;
+    std::string ownedState = state == true ? "T" : "F";
+    if(strBuf.find(pidStr) != std::string::npos)
+    {
+        strBuf.replace(strBuf.find(pidStr) + pidStr.length(), 1, ownedState);
+        strcpy((char *)shmaddr, strBuf.c_str());
+    }
+    else
+    {
+        sprintf(buf, "%s%d\t%s\t", buf, getpid(), ownedState.c_str());
+        strcpy((char *)shmaddr, buf);
+    }
+}
+
+bool readBridgeOwnedState()
+{
+    char buf[1024];
+    strcpy(buf, (char *)shmaddr);
+    std::string strBuf = buf;
+
+    size_t tabIndex = strBuf.find("\t");
+    pid_t pid = std::stoi(strBuf.substr(0, tabIndex));
+    strBuf = strBuf.substr(tabIndex+1);
+    tabIndex = strBuf.find("\t");
+
+    if(pid == getppid())
+        return strBuf.substr(0, tabIndex) == "T" ? true : false;
+    else
+        return false;
+}
+
+void shm_listener(VirtualServer vs)
+{
+    writeOwnedStateOnSharedMemory(false);
+    bool oldState = false;
+    bool oldSelfState=false;
+    OicSecDostype_t dos;
+    if(vs.m_device==NULL){
+        std::cout<<"vs resourceURis is NULL!"<<std::endl;
+    }
+    // Initial checking Bridge's onboarding state
+    if(oldState == false)
+    {
+        // Disable discovery property
+        if (OC_STACK_OK !=setResourcesToIndiscoverable())
+        {
+            std::cout << "Failed setting resource properties to indiscoverable." << std::endl;
+        }
+    }
+
+    while(1)
+    {
+        sleep(3);
+        bool curState = readBridgeOwnedState();
+
+        GetDos(&dos);
+//        std::cout << "VoD's onboarding state: " << dos.state  << std::endl;
+
+        if(dos.state == DOS_RFPRO || dos.state == DOS_RFNOP)
+        {
+            writeOwnedStateOnSharedMemory(true);
+            std::cout << "VoD's ownership status: Owned " << std::endl;
+            if(!oldSelfState)
+            {
+        /*WITH_CLOUD option*/
+        #if WITH_CLOUD
+                std::mutex blocker;
+                std::condition_variable cv;
+                std::unique_lock < std::mutex > lock(blocker);
+
+                // make coapcloudconf resource
+                InitCloudResource();
+                // Cloud settings - cloud sign up & sign in
+                Cloud_Settings cloud;
+
+                OCStackResult OC_res;
+                ResourceHandles cloud_resourceHandles;
+
+                // publish resource to cloud
+                for (uint32_t i = 0 ; i < vs.m_device->resourceUris.size(); ++i)
+                {
+                    addResourceToResourceHandle(&cloud_resourceHandles, vs.m_device->resourceUris[i].c_str());
+                }
+                addResourceToResourceHandle(&cloud_resourceHandles, CONFIGURATION_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OIC_RSRC_PSTAT_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OIC_RSRC_SP_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OIC_RSRC_ACL2_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OIC_RSRC_CRED_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OIC_RSRC_CRL_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OIC_RSRC_CSR_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OIC_RSRC_ROLES_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OC_RSRVD_INTROSPECTION_URI_PATH);
+                addResourceToResourceHandle(&cloud_resourceHandles, OC_RSRVD_DEVICE_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OC_RSRVD_PLATFORM_URI);
+                addResourceToResourceHandle(&cloud_resourceHandles, OIC_RSRC_DOXM_URI);
+
+                OC_res = cloud.publishResource(cloud_resourceHandles);
+
+                cout << " result: " << OC_res << " Waiting Publish user resource response from cloud" << endl;
+
+                cv.wait(lock);
+        #endif
+                oldSelfState=true;
+            }
+
+        }
+        else
+        {
+            if(oldSelfState){
+                /*WITH_CLOUD option*/
+            #if WITH_CLOUD
+                //DeInitCloudResource();
+            #endif
+                oldSelfState=false;
+            }
+        }
+
+        if(oldState != curState)
+        {
+            std::cout << "Bridge's onboarding state transition! " << std::endl;
+            // Bridge's ownership state transition: Unowned -> Owned
+            if(curState)
+            {
+                oldState = curState;
+
+                GetDos(&dos);
+                // VoD's onboarding state transition: RESET -> RFOTM
+                if(dos.state == DOS_RESET)
+                {
+                    SetDosState(DOS_RFOTM);
+                    std::cout << "VoD's onboarding state transition: RESET -> RFOTM " << std::endl;
+                }
+
+                // Enable discovery property
+                if (OC_STACK_OK !=setResourcesToDiscoverable())
+                {
+                    std::cout << "Failed setting resource properties to discoverable." << std::endl;
+                }
+            }
+            // Bridge's ownership state transition: Owned -> Unowned
+            else
+            {
+                // Disable discovery property
+                if (OC_STACK_OK !=setResourcesToIndiscoverable())
+                {
+                    std::cout << "Failed setting resource properties to indiscoverable." << std::endl;
+                }
+                // VoD's onboarding state: Maintain the current state
+            }
+        }
+    }
+}
+
+void *getSharedMemoryForOwnedState()
+{
+    key_t key = ftok("shmfile_ownedstate", 1);
+    int shmid = shmget(key, 1024, 0);
+
+    return shmat(shmid, NULL, 0);
+}
+#endif
+
+int main(int /*argc*/, char* argv[])
+{
+    // set the name of introspection data file
+    std::string introspection_cbor_path = std::string("virtualsvr_introspection_").append(argv[1]).append(".dat");
+    strcpy(INTROSPECTION_DATA_FILE_NAME, introspection_cbor_path.c_str());
+
+#ifdef SECURED
+    // set the name of SVR file
+    std::string svrDB_cbor_path = std::string("zigbee_oic_virtualsvr_db_").append(argv[1]).append(".dat");
+    strcpy(VIRTUALSVR_DB_FILE_NAME, svrDB_cbor_path.c_str());
+#endif
+
+    OCPersistentStorage ps
+    { client_open, fread, fwrite, fclose, unlink };
+
+    // Create PlatformConfig object
+    PlatformConfig cfg
+    { ServiceType::InProc, ModeType::Both, &ps };
+
+    cfg.transportType = static_cast< OCTransportAdapter >(
+            OCTransportAdapter::OC_DEFAULT_ADAPTER
+            | OCTransportAdapter::OC_ADAPTER_IP | OCTransportAdapter::OC_ADAPTER_TCP);
+    cfg.QoS = QualityOfService::LowQos;
+
+    OCPlatform::Configure(cfg);
+    OC_VERIFY(OCPlatform::start() == OC_STACK_OK);
+
+    ZBO = std::make_shared< ZBOperations >();
+    ZBO->openSocket(ZIGBEE_GATEWAY_IP, ZIGBEE_GATEWAY_PORT);
+    ZBO->create_json_object();
+
+    try
+    {
+        VirtualServer vs(argv);
+        OCDeviceInfo device_info =
+        { NULL, NULL, NULL, NULL };
+        vs.setDeviceInfoParams(device_info);
+
+        if (OCSetDeviceInfo(device_info) != OC_STACK_OK)
+        {
+            OIC_LOG(ERROR, "VIRTUAL SERVER", "Device Registration failed!");
+        }
+
+        if (OC_STACK_OK != vs.setDeviceInfo())
+        {
+            std::cout << "Failed device registration (/oic/d)." << std::endl;
+        }
+
+        if (OC_STACK_OK != vs.setPlatformInfo())
+        {
+            std::cout << "Failed platform registration (/oic/p)." << std::endl;
+        }
+
+        if (OC_STACK_OK != vs.createResources())
+        {
+            std::cout << "Failed creating resources." << std::endl;
+        }
+
+#ifdef SECURED
+        // get shared memory address
+        shmaddr = getSharedMemoryForOwnedState();
+        // start listener for shared memory
+        std::thread t(shm_listener,vs);
+        t.detach();
+#endif
+
+        signal(SIGUSR1, handleSignal);
+
+        std::mutex blocker;
+        std::condition_variable cv;
+        std::unique_lock < std::mutex > lock(blocker);
+
+        // A condition variable will free the mutex it is given, then do a non-
+        // intensive block until 'notify' is called on it.  In this case, since we
+        // don't ever call cv.notify, this should be a non-processor intensive version
+        // of while(true);
+        std::cout << "Waiting" << std::endl;
+        cv.wait(lock, []
+                       {   return false;});
+    }
+    catch (OCException &e)
+    {
+        std::cout << "OCException in main : " << e.what() << endl;
+    }
+
+    OC_VERIFY(OCPlatform::stop() == OC_STACK_OK);
+
+    return 0;
+}
diff --git a/bridging/plugins/zigbee_plugin/zigbee_oic_svr_db.dat b/bridging/plugins/zigbee_plugin/zigbee_oic_svr_db.dat
new file mode 100644
index 0000000000000000000000000000000000000000..54ec6beea6cfc1d2df602818eb1f3afaab33f070
GIT binary patch
literal 1149
zcmchVJ5Iwu5J2+-iH3rXo(?5Oxk4)1NJydF&p2LV@2qy#`IHfYdjzH76gdSqNgw<J
z8MGjh0v8_5Se|)rcDI6w<i2~kndVWE8$NG<2~e^<rHscQ+&U7dwObm9nMU0g2{5ZH
z5N1{Yt=2NK5Jmwi5#-g_fK3&VLVZ!U>iAk^F6s-rH142QU0*8?)l)?kmQ=Etm?m#-
zR;4;n+F2x%3+LojarU(s7`9B1$%bL4HthMZJcj>_b>hSFZ0oV|P0MW&h(O{Zt!mTi
zT;-b21?xA|&ujHl-;AHtf1Od@B>hQYF#)PDXoSp+63pZXbvOpP8{d{l*G;6@;#`Bx
zG9?#RH}%sm;<wkwH*Vc3&M)r34)W_i<SJZYk*aXO89|~nfFZ}+Wd157(hH+DGdrmW
z&5nz-!(H0qnD#iOy`!c-RMX2LzVWg+ipkry2()U2MS!FwNVqd7Y~?PNFjE5lZk^;m
R9Jr{X-0IC1=svam{vG~Ct26)r

literal 0
HcmV?d00001

diff --git a/bridging/plugins/zigbee_plugin/zigbee_oic_svr_db.json b/bridging/plugins/zigbee_plugin/zigbee_oic_svr_db.json
new file mode 100644
index 000000000..7ab91823d
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/zigbee_oic_svr_db.json
@@ -0,0 +1,93 @@
+{
+    "acl": {
+        "aclist2": [
+            {
+                "aceid": 1,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/res" }
+                ],
+                "permission": 18
+            },
+            {
+                "aceid": 2,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/res" }
+                ],
+                "permission": 18
+            },
+            {
+                "aceid": 3,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/con"},
+		    { "href": "/introspection" },
+		    { "href": "/introspection/payload"}
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 4,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/con"},
+                    { "href": "/introspection" },
+		    { "href": "/introspection/payload"}
+                ],
+                "permission": 2
+            },	
+            {
+                "aceid": 5,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/sec/doxm" },
+                    { "href": "/oic/rd" },
+		    { "wc": "-" }
+                ],
+                "permission": 14
+            },
+            {
+                "aceid": 6,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/sec/doxm" },   
+                    { "href": "/oic/rd" },
+		    { "href": "/oic/sec/roles" },
+		    { "href": "CoapCloudConfResURI"},
+		    { "wc": "+" }
+                ],
+                "permission": 14
+            }            
+        ],
+        "rowneruuid": "00000000-0000-0000-0000-000000000000",
+	"rt": ["oic.r.acl"],
+	"if": ["oic.if.baseline"]
+    },
+    "pstat": {
+        "dos": { "s": 1, "p": false },
+        "isop": false,
+        "cm": 2,
+        "tm": 0,
+        "om": 4,
+        "sm": 4,
+        "rowneruuid": "00000000-0000-0000-0000-000000000000",
+	"rt": ["oic.r.pstat"],
+	"if": ["oic.if.baseline"]
+    },
+    "doxm": {
+        "oxms": [0],
+        "oxmsel": 0,
+        "sct": 9,
+        "owned": false,
+        "deviceuuid": "00000000-0000-0000-0000-000000000000",
+        "devowneruuid": "00000000-0000-0000-0000-000000000000",
+        "rowneruuid": "00000000-0000-0000-0000-000000000000",
+	"rt": ["oic.r.doxm"],
+	"if": ["oic.if.baseline"]
+    }
+}
diff --git a/bridging/plugins/zigbee_plugin/zigbee_oic_virtualsvr_db.dat b/bridging/plugins/zigbee_plugin/zigbee_oic_virtualsvr_db.dat
new file mode 100644
index 0000000000000000000000000000000000000000..9adebfc80ae0cf58537f13be6927f4d1b179611b
GIT binary patch
literal 2017
zcmeHI!H&}~5Zx_hfeQyN`~Wx92JJ8O#C0X4<y1NLq;cwajK^uV2M!fNaO4+?_QF@}
zSL~nkzBsYBq$?w_D<N?phgkFM@q6<;POdoP>ix;b%Y`2$xzn$gz&J>8yr3qpfV*wU
zQERt0P%({q!WA$pEf6-A18ugVv`~~8N}hSNGGJ>-BvHSJTa8j%HLjd+yEg7#TRlo`
zl~DC1s499@Vi=eZEc+P(o>4^99^queq5))8fOICcvq;7}<4X+S>JZEfTPtK@V8tj}
zF;3}ESn;pwf1J{v@c&aVrrvuh@S+Zw$b3I-^Om#8z@X>Rppz6q!l2K;C(wIRiwbDS
z+P5mrkeQjnM$AwbXF%`H-u8N4C-gi?=}8p)Ezm47YNg|4h?ZGy<)U;ND9Vt&c!hRe
z#<+?xCmvF67x;VEi^Z&!T42j@1y<@sKvx+W&<a+d=1LaM-#HFCrnGk_k>s#ff2BI9
z4pW;!YBwohVF3cC${f_5h`Gi_=)(}2OI=`CY7X!cqp-u}95LQ0kx91q$M|muXbyw3
zco}=+Y3eKzz48An{^D6w7F!LrX{5M#^(H=(ZoKoloy)D;RQ~5MwNw9#In8CU!7h}=
zG-m`#Y5+ryx%2i17f9b39Wk>LlF;mOULWVK9_3h%bE?M=VqXUKo+L#tx{uTO^;I{}
p=BVffP)Ghwx@XW;D|VHDmE`c}RV$xxPoo}GTXeRQo+|C;<|l&F61xBZ

literal 0
HcmV?d00001

diff --git a/bridging/plugins/zigbee_plugin/zigbee_oic_virtualsvr_db.json b/bridging/plugins/zigbee_plugin/zigbee_oic_virtualsvr_db.json
new file mode 100644
index 000000000..39f315a3c
--- /dev/null
+++ b/bridging/plugins/zigbee_plugin/zigbee_oic_virtualsvr_db.json
@@ -0,0 +1,143 @@
+{
+    "acl": {
+        "aclist2": [
+	    {
+                "aceid": 1,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/res" }
+                ],
+                "permission": 18
+            },
+            {
+                "aceid": 2,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/res" }
+                ],
+                "permission": 18
+            },
+            {
+                "aceid": 3,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/sp" },
+                    { "href": "/oic/sec/csr" },
+                    { "href": "/oic/sec/crl" },
+		    { "href": "/introspection" },
+		    { "href": "/introspection/payload"}
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 4,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/d" },
+                    { "href": "/oic/p" },
+                    { "href": "/oic/sec/sp" },
+                    { "href": "/oic/sec/csr" },
+                    { "href": "/oic/sec/crl" },
+    		    { "href": "/introspection" },
+		    { "href": "/introspection/payload"}
+                ],
+                "permission": 2
+            },
+            {
+                "aceid": 5,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/oic/sec/doxm" },
+                    { "href": "/con" },
+		    { "wc": "-" }
+                ],
+                "permission": 14
+            },
+            {
+                "aceid": 6,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/oic/sec/doxm" },
+		    { "href": "/oic/sec/roles" },
+                    { "href": "/con" },
+		    { "href": "CoapCloudConfResURI"},
+		    { "wc": "+" }
+                ],
+                "permission": 14
+            },
+	    {
+                "aceid": 7,
+                "subject": { "conntype": "anon-clear" },
+                "resources": [
+                    { "href": "/switch" },
+                    { "href": "/brightness" },
+                    { "href": "/color_hs" },
+                    { "href": "/color_csc" },
+                    { "href": "/color_ct" },
+                    { "href": "/windowcovering" },
+                    { "href": "/openlevel_liftpercent" },
+                    { "href": "/openlevel_liftposition" },
+                    { "href": "/openlevel_tiltpercent" },
+                    { "href": "/openlevel_tiltdegree" },
+                    { "href": "/temperature" },
+                    { "href": "/temperature_info" },
+                    { "href": "/temperature_hot" },
+                    { "href": "/temperature_cool" },
+                    { "href": "/ias" },
+                    { "href": "/presence" }
+                ],
+                "permission": 23
+            },
+	    {
+                "aceid": 8,
+                "subject": { "conntype": "auth-crypt" },
+                "resources": [
+                    { "href": "/switch" },
+                    { "href": "/brightness" },
+                    { "href": "/color_hs" },
+                    { "href": "/color_csc" },
+                    { "href": "/color_ct" },
+                    { "href": "/windowcovering" },
+                    { "href": "/openlevel_liftpercent" },
+                    { "href": "/openlevel_liftposition" },
+                    { "href": "/openlevel_tiltpercent" },
+                    { "href": "/openlevel_tiltdegree" },
+                    { "href": "/temperature" },
+                    { "href": "/temperature_info" },
+                    { "href": "/temperature_hot" },
+                    { "href": "/temperature_cool" },
+                    { "href": "/ias" },
+                    { "href": "/presence" }
+                ],
+                "permission": 23
+            }
+        ],
+        "rowneruuid": "00000000-0000-0000-0000-000000000000",
+	"rt": ["oic.r.acl"],
+	"if": ["oic.if.baseline"]
+    },
+    "pstat": {
+        "dos": { "s": 0, "p": false },
+        "isop": false,
+        "cm": 1,
+        "tm": 2,
+        "om": 4,
+        "sm": 4,
+        "rowneruuid": "00000000-0000-0000-0000-000000000000",
+	"rt": ["oic.r.pstat"],
+	"if": ["oic.if.baseline"]
+    },
+    "doxm": {
+        "oxms": [0],
+        "oxmsel": 0,
+        "sct": 9,
+        "owned": false,
+        "devowneruuid": "00000000-0000-0000-0000-000000000000",
+        "rowneruuid": "00000000-0000-0000-0000-000000000000",
+	"rt": ["oic.r.doxm"],
+	"if": ["oic.if.baseline"]
+    }
+}
+
diff --git a/build_common/windows/SConscript b/build_common/windows/SConscript
old mode 100755
new mode 100644
diff --git a/cloud/account/start.sh b/cloud/account/start.sh
old mode 100755
new mode 100644
diff --git a/cloud/interface/start.sh b/cloud/interface/start.sh
old mode 100755
new mode 100644
diff --git a/cloud/messagequeue/start.sh b/cloud/messagequeue/start.sh
old mode 100755
new mode 100644
diff --git a/cloud/resourcedirectory/start.sh b/cloud/resourcedirectory/start.sh
old mode 100755
new mode 100644
diff --git a/extlibs/buildDependencies.sh b/extlibs/buildDependencies.sh
old mode 100755
new mode 100644
diff --git a/extlibs/gtest/prep.sh b/extlibs/gtest/prep.sh
old mode 100755
new mode 100644
diff --git a/extlibs/hippomocks/prep.sh b/extlibs/hippomocks/prep.sh
old mode 100755
new mode 100644
diff --git a/extlibs/libcoap/SConscript b/extlibs/libcoap/SConscript
old mode 100755
new mode 100644
diff --git a/extlibs/libstrophe/prep.sh b/extlibs/libstrophe/prep.sh
old mode 100755
new mode 100644
diff --git a/extlibs/mbedtls/prep.sh b/extlibs/mbedtls/prep.sh
old mode 100755
new mode 100644
diff --git a/extlibs/rapidjson/prep.sh b/extlibs/rapidjson/prep.sh
old mode 100755
new mode 100644
diff --git a/extlibs/raxmpp/prep.sh b/extlibs/raxmpp/prep.sh
old mode 100755
new mode 100644
diff --git a/extlibs/socket/sio_client.cpp b/extlibs/socket/sio_client.cpp
new file mode 100644
index 000000000..3eaa4a040
--- /dev/null
+++ b/extlibs/socket/sio_client.cpp
@@ -0,0 +1,128 @@
+//
+//  sio_client.h
+//
+//  Created by Melo Yao on 3/25/15.
+//
+
+#include "sio_client.h"
+#include "sio_client_impl.h"
+
+using namespace websocketpp;
+using boost::posix_time::milliseconds;
+using std::stringstream;
+
+namespace sio
+{
+    client::client():
+        m_impl(new client_impl())
+    {
+    }
+    
+    client::~client()
+    {
+        delete m_impl;
+    }
+    
+    void client::set_open_listener(con_listener const& l)
+    {
+        m_impl->set_open_listener(l);
+    }
+    
+    void client::set_fail_listener(con_listener const& l)
+    {
+        m_impl->set_fail_listener(l);
+    }
+    
+    void client::set_close_listener(close_listener const& l)
+    {
+        m_impl->set_close_listener(l);
+    }
+    
+    void client::set_socket_open_listener(socket_listener const& l)
+    {
+        m_impl->set_socket_open_listener(l);
+    }
+    
+    void client::set_reconnect_listener(reconnect_listener const& l)
+    {
+        m_impl->set_reconnect_listener(l);
+    }
+
+    void client::set_reconnecting_listener(con_listener const& l)
+    {
+        m_impl->set_reconnecting_listener(l);
+    }
+
+    void client::set_socket_close_listener(socket_listener const& l)
+    {
+        m_impl->set_socket_close_listener(l);
+    }
+    
+    void client::clear_con_listeners()
+    {
+        m_impl->clear_con_listeners();
+    }
+    
+    void client::clear_socket_listeners()
+    {
+        m_impl->clear_socket_listeners();
+    }
+
+    void client::connect(const std::string& uri)
+    {
+        m_impl->connect(uri, {}, {});
+    }
+
+    void client::connect(const std::string& uri, const std::map<string,string>& query)
+    {
+        m_impl->connect(uri, query, {});
+    }
+
+    void client::connect(const std::string& uri, const std::map<std::string,std::string>& query,
+                         const std::map<std::string,std::string>& http_extra_headers)
+    {
+        m_impl->connect(uri, query, http_extra_headers);
+    }
+    
+    socket::ptr const& client::socket(const std::string& nsp)
+    {
+        return m_impl->socket(nsp);
+    }
+    
+    // Closes the connection
+    void client::close()
+    {
+        m_impl->close();
+    }
+    
+    void client::sync_close()
+    {
+        m_impl->sync_close();
+    }
+    
+    bool client::opened() const
+    {
+        return m_impl->opened();
+    }
+    
+    std::string const& client::get_sessionid() const
+    {
+        return m_impl->get_sessionid();
+    }
+
+    void client::set_reconnect_attempts(int attempts)
+    {
+        m_impl->set_reconnect_attempts(attempts);
+    }
+
+    void client::set_reconnect_delay(unsigned millis)
+    {
+        m_impl->set_reconnect_delay(millis);
+    }
+
+    void client::set_reconnect_delay_max(unsigned millis)
+    {
+        m_impl->set_reconnect_delay_max(millis);
+    }
+    
+}
diff --git a/extlibs/socket/sio_client.h b/extlibs/socket/sio_client.h
new file mode 100644
index 000000000..77be0a2d1
--- /dev/null
+++ b/extlibs/socket/sio_client.h
@@ -0,0 +1,92 @@
+//
+//  sio_client.h
+//
+//  Created by Melo Yao on 3/25/15.
+//
+
+#ifndef SIO_CLIENT_H
+#define SIO_CLIENT_H
+#include <string>
+#include <functional>
+#include "sio_message.h"
+#include "sio_socket.h"
+
+namespace sio
+{
+    class client_impl;
+    
+    class client {
+    public:
+        enum close_reason
+        {
+            close_reason_normal,
+            close_reason_drop
+        };
+        
+        typedef std::function<void(void)> con_listener;
+        
+        typedef std::function<void(close_reason const& reason)> close_listener;
+
+        typedef std::function<void(unsigned, unsigned)> reconnect_listener;
+        
+        typedef std::function<void(std::string const& nsp)> socket_listener;
+        
+        client();
+        ~client();
+        
+        //set listeners and event bindings.
+        void set_open_listener(con_listener const& l);
+        
+        void set_fail_listener(con_listener const& l);
+        
+        void set_reconnecting_listener(con_listener const& l);
+
+        void set_reconnect_listener(reconnect_listener const& l);
+
+        void set_close_listener(close_listener const& l);
+        
+        void set_socket_open_listener(socket_listener const& l);
+        
+        void set_socket_close_listener(socket_listener const& l);
+        
+        void clear_con_listeners();
+        
+        void clear_socket_listeners();
+        
+        // Client Functions - such as send, etc.
+        void connect(const std::string& uri);
+
+        void connect(const std::string& uri, const std::map<std::string,std::string>& query);
+
+        void connect(const std::string& uri, const std::map<std::string,std::string>& query,
+                     const std::map<std::string,std::string>& http_extra_headers);
+
+        void set_reconnect_attempts(int attempts);
+
+        void set_reconnect_delay(unsigned millis);
+
+        void set_reconnect_delay_max(unsigned millis);
+        
+        sio::socket::ptr const& socket(const std::string& nsp = "");
+        
+        // Closes the connection
+        void close();
+        
+        void sync_close();
+        
+        bool opened() const;
+        
+        std::string const& get_sessionid() const;
+        
+    private:
+        //disable copy constructor and assign operator.
+        client(client const&){}
+        void operator=(client const&){}
+        
+        client_impl* m_impl;
+    };
+    
+}
+
+
+#endif // __SIO_CLIENT__H__
diff --git a/extlibs/socket/sio_client_impl.cpp b/extlibs/socket/sio_client_impl.cpp
new file mode 100644
index 000000000..e8da085ea
--- /dev/null
+++ b/extlibs/socket/sio_client_impl.cpp
@@ -0,0 +1,601 @@
+//
+//  sio_client_impl.cpp
+//  SioChatDemo
+//
+//  Created by Melo Yao on 4/3/15.
+//  Copyright (c) 2015 Melo Yao. All rights reserved.
+//
+
+#include "sio_client_impl.h"
+#include <sstream>
+#include <boost/date_time/posix_time/posix_time.hpp>
+#include <mutex>
+#include <cmath>
+// Comment this out to disable handshake logging to stdout
+#if DEBUG || _DEBUG
+#define LOG(x) std::cout << x
+#else
+#define LOG(x)
+#endif
+
+using boost::posix_time::milliseconds;
+using namespace std;
+
+namespace sio
+{
+    /*************************public:*************************/
+    client_impl::client_impl() :
+        m_ping_interval(0),
+        m_ping_timeout(0),
+        m_network_thread(),
+        m_con_state(con_closed),
+        m_reconn_delay(5000),
+        m_reconn_delay_max(25000),
+        m_reconn_attempts(0xFFFFFFFF),
+        m_reconn_made(0)
+    {
+        using websocketpp::log::alevel;
+#ifndef DEBUG
+        m_client.clear_access_channels(alevel::all);
+        m_client.set_access_channels(alevel::connect|alevel::disconnect|alevel::app);
+#endif
+        // Initialize the Asio transport policy
+        m_client.init_asio();
+
+        // Bind the clients we are using
+        using websocketpp::lib::placeholders::_1;
+        using websocketpp::lib::placeholders::_2;
+        m_client.set_open_handler(lib::bind(&client_impl::on_open,this,_1));
+        m_client.set_close_handler(lib::bind(&client_impl::on_close,this,_1));
+        m_client.set_fail_handler(lib::bind(&client_impl::on_fail,this,_1));
+        m_client.set_message_handler(lib::bind(&client_impl::on_message,this,_1,_2));
+#if SIO_TLS
+        m_client.set_tls_init_handler(lib::bind(&client_impl::on_tls_init,this,_1));
+#endif
+        m_packet_mgr.set_decode_callback(lib::bind(&client_impl::on_decode,this,_1));
+
+        m_packet_mgr.set_encode_callback(lib::bind(&client_impl::on_encode,this,_1,_2));
+    }
+    
+    client_impl::~client_impl()
+    {
+        this->sockets_invoke_void(&sio::socket::on_close);
+        sync_close();
+    }
+    
+    void client_impl::connect(const string& uri, const map<string,string>& query, const map<string, string>& headers)
+    {
+        if(m_reconn_timer)
+        {
+            m_reconn_timer->cancel();
+            m_reconn_timer.reset();
+        }
+        if(m_network_thread)
+        {
+            if(m_con_state == con_closing||m_con_state == con_closed)
+            {
+                //if client is closing, join to wait.
+                //if client is closed, still need to join,
+                //but in closed case,join will return immediately.
+                m_network_thread->join();
+                m_network_thread.reset();//defensive
+            }
+            else
+            {
+                //if we are connected, do nothing.
+                return;
+            }
+        }
+        m_con_state = con_opening;
+        m_base_url = uri;
+        m_reconn_made = 0;
+
+        string query_str;
+        for(map<string,string>::const_iterator it=query.begin();it!=query.end();++it){
+            query_str.append("&");
+            query_str.append(it->first);
+            query_str.append("=");
+            string query_str_value=encode_query_string(it->second);
+            query_str.append(query_str_value);
+        }
+        m_query_string=move(query_str);
+
+        m_http_headers = headers;
+
+        this->reset_states();
+        m_client.get_io_service().dispatch(lib::bind(&client_impl::connect_impl,this,uri,m_query_string));
+        m_network_thread.reset(new thread(lib::bind(&client_impl::run_loop,this)));//uri lifecycle?
+
+    }
+
+    socket::ptr const& client_impl::socket(string const& nsp)
+    {
+        lock_guard<mutex> guard(m_socket_mutex);
+        string aux;
+        if(nsp == "")
+        {
+            aux = "/";
+        }
+        else if( nsp[0] != '/')
+        {
+            aux.append("/",1);
+            aux.append(nsp);
+        }
+        else
+        {
+            aux = nsp;
+        }
+
+        auto it = m_sockets.find(aux);
+        if(it!= m_sockets.end())
+        {
+            return it->second;
+        }
+        else
+        {
+            pair<const string, socket::ptr> p(aux,shared_ptr<sio::socket>(new sio::socket(this,aux)));
+            return (m_sockets.insert(p).first)->second;
+        }
+    }
+
+    void client_impl::close()
+    {
+        m_con_state = con_closing;
+        this->sockets_invoke_void(&sio::socket::close);
+        m_client.get_io_service().dispatch(lib::bind(&client_impl::close_impl, this,close::status::normal,"End by user"));
+    }
+
+    void client_impl::sync_close()
+    {
+        m_con_state = con_closing;
+        this->sockets_invoke_void(&sio::socket::close);
+        m_client.get_io_service().dispatch(lib::bind(&client_impl::close_impl, this,close::status::normal,"End by user"));
+        if(m_network_thread)
+        {
+            m_network_thread->join();
+            m_network_thread.reset();
+        }
+    }
+
+    /*************************protected:*************************/
+    void client_impl::send(packet& p)
+    {
+        m_packet_mgr.encode(p);
+    }
+
+    void client_impl::remove_socket(string const& nsp)
+    {
+        lock_guard<mutex> guard(m_socket_mutex);
+        auto it = m_sockets.find(nsp);
+        if(it!= m_sockets.end())
+        {
+            m_sockets.erase(it);
+        }
+    }
+
+    boost::asio::io_service& client_impl::get_io_service()
+    {
+        return m_client.get_io_service();
+    }
+
+    void client_impl::on_socket_closed(string const& nsp)
+    {
+        if(m_socket_close_listener)m_socket_close_listener(nsp);
+    }
+
+    void client_impl::on_socket_opened(string const& nsp)
+    {
+        if(m_socket_open_listener)m_socket_open_listener(nsp);
+    }
+
+    /*************************private:*************************/
+    void client_impl::run_loop()
+    {
+
+        m_client.run();
+        m_client.reset();
+        m_client.get_alog().write(websocketpp::log::alevel::devel,
+                                  "run loop end");
+    }
+
+    void client_impl::connect_impl(const string& uri, const string& queryString)
+    {
+        do{
+            websocketpp::uri uo(uri);
+            ostringstream ss;
+#if SIO_TLS
+            ss<<"wss://";
+#else
+            ss<<"ws://";
+#endif
+            const std::string host(uo.get_host());
+            // As per RFC2732, literal IPv6 address should be enclosed in "[" and "]".
+            if(host.find(':')!=std::string::npos){
+                ss<<"["<<uo.get_host()<<"]";
+            } else {
+                ss<<uo.get_host();
+            }
+            ss<<":"<<uo.get_port()<<"/socket.io/?EIO=4&transport=websocket";
+            if(m_sid.size()>0){
+                ss<<"&sid="<<m_sid;
+            }
+            ss<<"&t="<<time(NULL)<<queryString;
+            lib::error_code ec;
+            client_type::connection_ptr con = m_client.get_connection(ss.str(), ec);
+            if (ec) {
+                m_client.get_alog().write(websocketpp::log::alevel::app,
+                                          "Get Connection Error: "+ec.message());
+                break;
+            }
+
+            for( auto&& header: m_http_headers ) {
+                con->replace_header(header.first, header.second);
+            }
+
+            m_client.connect(con);
+            return;
+        }
+        while(0);
+        if(m_fail_listener)
+        {
+            m_fail_listener();
+        }
+    }
+
+    void client_impl::close_impl(close::status::value const& code,string const& reason)
+    {
+        LOG("Close by reason:"<<reason << endl);
+        if(m_reconn_timer)
+        {
+            m_reconn_timer->cancel();
+            m_reconn_timer.reset();
+        }
+        if (m_con.expired())
+        {
+            cerr << "Error: No active session" << endl;
+        }
+        else
+        {
+            lib::error_code ec;
+            m_client.close(m_con, code, reason, ec);
+        }
+    }
+
+    void client_impl::send_impl(shared_ptr<const string> const& payload_ptr,frame::opcode::value opcode)
+    {
+        if(m_con_state == con_opened)
+        {
+            lib::error_code ec;
+            m_client.send(m_con,*payload_ptr,opcode,ec);
+            if(ec)
+            {
+                cerr<<"Send failed,reason:"<< ec.message()<<endl;
+            }
+        }
+    }
+
+    void client_impl::ping(const boost::system::error_code& ec)
+    {
+        if(ec || m_con.expired())
+        {
+            if (ec != boost::asio::error::operation_aborted)
+                LOG("ping exit,con is expired?"<<m_con.expired()<<",ec:"<<ec.message()<<endl){};
+            return;
+        }
+        packet p(packet::frame_ping);
+        m_packet_mgr.encode(p, [&](bool /*isBin*/,shared_ptr<const string> payload)
+        {
+            lib::error_code ec;
+            this->m_client.send(this->m_con, *payload, frame::opcode::text, ec);
+        });
+        if(m_ping_timer)
+        {
+            boost::system::error_code e_code;
+            m_ping_timer->expires_from_now(milliseconds(m_ping_interval), e_code);
+            m_ping_timer->async_wait(lib::bind(&client_impl::ping,this,lib::placeholders::_1));
+        }
+        if(!m_ping_timeout_timer)
+        {
+            m_ping_timeout_timer.reset(new boost::asio::deadline_timer(m_client.get_io_service()));
+            boost::system::error_code timeout_ec;
+            m_ping_timeout_timer->expires_from_now(milliseconds(m_ping_timeout), timeout_ec);
+            m_ping_timeout_timer->async_wait(lib::bind(&client_impl::timeout_pong, this,lib::placeholders::_1));
+        }
+    }
+
+    void client_impl::timeout_pong(const boost::system::error_code &ec)
+    {
+        if(ec)
+        {
+            return;
+        }
+        LOG("Pong timeout"<<endl);
+        m_client.get_io_service().dispatch(lib::bind(&client_impl::close_impl, this,close::status::policy_violation,"Pong timeout"));
+    }
+
+    void client_impl::timeout_reconnect(boost::system::error_code const& ec)
+    {
+        if(ec)
+        {
+            return;
+        }
+        if(m_con_state == con_closed)
+        {
+            m_con_state = con_opening;
+            m_reconn_made++;
+            this->reset_states();
+            LOG("Reconnecting..."<<endl);
+            if(m_reconnecting_listener) m_reconnecting_listener();
+            m_client.get_io_service().dispatch(lib::bind(&client_impl::connect_impl,this,m_base_url,m_query_string));
+        }
+    }
+
+    unsigned client_impl::next_delay() const
+    {
+        //no jitter, fixed power root.
+        unsigned reconn_made = min<unsigned>(m_reconn_made,32);//protect the pow result to be too big.
+        return static_cast<unsigned>(min<double>(m_reconn_delay * pow(1.5,reconn_made),m_reconn_delay_max));
+    }
+
+    socket::ptr client_impl::get_socket_locked(string const& nsp)
+    {
+        lock_guard<mutex> guard(m_socket_mutex);
+        auto it = m_sockets.find(nsp);
+        if(it != m_sockets.end())
+        {
+            return it->second;
+        }
+        else
+        {
+            return socket::ptr();
+        }
+    }
+
+    void client_impl::sockets_invoke_void(void (sio::socket::*fn)(void))
+    {
+        map<const string,socket::ptr> socks;
+        {
+            lock_guard<mutex> guard(m_socket_mutex);
+            socks.insert(m_sockets.begin(),m_sockets.end());
+        }
+        for (auto it = socks.begin(); it!=socks.end(); ++it) {
+            ((*(it->second)).*fn)();
+        }
+    }
+
+    void client_impl::on_fail(connection_hdl)
+    {
+        m_con.reset();
+        m_con_state = con_closed;
+        this->sockets_invoke_void(&sio::socket::on_disconnect);
+        LOG("Connection failed." << endl);
+        if(m_reconn_made<m_reconn_attempts)
+        {
+            LOG("Reconnect for attempt:"<<m_reconn_made<<endl);
+            unsigned delay = this->next_delay();
+            if(m_reconnect_listener) m_reconnect_listener(m_reconn_made,delay);
+            m_reconn_timer.reset(new boost::asio::deadline_timer(m_client.get_io_service()));
+            boost::system::error_code ec;
+            m_reconn_timer->expires_from_now(milliseconds(delay), ec);
+            m_reconn_timer->async_wait(lib::bind(&client_impl::timeout_reconnect,this,lib::placeholders::_1));
+        }
+        else
+        {
+            if(m_fail_listener)m_fail_listener();
+        }
+    }
+    
+    void client_impl::on_open(connection_hdl con)
+    {
+        LOG("Connected." << endl);
+        m_con_state = con_opened;
+        m_con = con;
+        m_reconn_made = 0;
+        this->sockets_invoke_void(&sio::socket::on_open);
+        this->socket("");
+        if(m_open_listener)m_open_listener();
+    }
+    
+    void client_impl::on_close(connection_hdl con)
+    {
+        LOG("Client Disconnected." << endl);
+        con_state m_con_state_was = m_con_state;
+        m_con_state = con_closed;
+        lib::error_code ec;
+        close::status::value code = close::status::normal;
+        client_type::connection_ptr conn_ptr  = m_client.get_con_from_hdl(con, ec);
+        if (ec) {
+            LOG("OnClose get conn failed"<<ec<<endl);
+        }
+        else
+        {
+            code = conn_ptr->get_local_close_code();
+        }
+        
+        m_con.reset();
+        this->clear_timers();
+        client::close_reason reason;
+
+        // If we initiated the close, no matter what the close status was,
+        // we'll consider it a normal close. (When using TLS, we can
+        // sometimes get a TLS Short Read error when closing.)
+        if(code == close::status::normal || m_con_state_was == con_closing)
+        {
+            this->sockets_invoke_void(&sio::socket::on_disconnect);
+            reason = client::close_reason_normal;
+        }
+        else
+        {
+            this->sockets_invoke_void(&sio::socket::on_disconnect);
+            if(m_reconn_made<m_reconn_attempts)
+            {
+                LOG("Reconnect for attempt:"<<m_reconn_made<<endl);
+                unsigned delay = this->next_delay();
+                if(m_reconnect_listener) m_reconnect_listener(m_reconn_made,delay);
+                m_reconn_timer.reset(new boost::asio::deadline_timer(m_client.get_io_service()));
+                boost::system::error_code ec;
+                m_reconn_timer->expires_from_now(milliseconds(delay), ec);
+                m_reconn_timer->async_wait(lib::bind(&client_impl::timeout_reconnect,this,lib::placeholders::_1));
+                return;
+            }
+            reason = client::close_reason_drop;
+        }
+        
+        if(m_close_listener)
+        {
+            m_close_listener(reason);
+        }
+    }
+    
+    void client_impl::on_message(connection_hdl, client_type::message_ptr msg)
+    {
+        if (m_ping_timeout_timer) {
+            boost::system::error_code ec;
+            m_ping_timeout_timer->expires_from_now(milliseconds(m_ping_timeout),ec);
+            m_ping_timeout_timer->async_wait(lib::bind(&client_impl::timeout_pong, this,lib::placeholders::_1));
+        }
+        // Parse the incoming message according to socket.IO rules
+        m_packet_mgr.put_payload(msg->get_payload());
+    }
+    
+    void client_impl::on_handshake(message::ptr const& message)
+    {
+        if(message && message->get_flag() == message::flag_object)
+        {
+            const object_message* obj_ptr =static_cast<object_message*>(message.get());
+            const map<string,message::ptr>* values = &(obj_ptr->get_map());
+            auto it = values->find("sid");
+            if (it!= values->end()) {
+                m_sid = static_pointer_cast<string_message>(it->second)->get_string();
+            }
+            else
+            {
+                goto failed;
+            }
+            it = values->find("pingInterval");
+            if (it!= values->end()&&it->second->get_flag() == message::flag_integer) {
+                m_ping_interval = (unsigned)static_pointer_cast<int_message>(it->second)->get_int();
+            }
+            else
+            {
+                m_ping_interval = 25000;
+            }
+            it = values->find("pingTimeout");
+
+            if (it!=values->end()&&it->second->get_flag() == message::flag_integer) {
+                m_ping_timeout = (unsigned) static_pointer_cast<int_message>(it->second)->get_int();
+            }
+            else
+            {
+                m_ping_timeout = 60000;
+            }
+
+            m_ping_timer.reset(new boost::asio::deadline_timer(m_client.get_io_service()));
+            boost::system::error_code ec;
+            m_ping_timer->expires_from_now(milliseconds(m_ping_interval), ec);
+            if(ec)LOG("ec:"<<ec.message()<<endl){};
+            m_ping_timer->async_wait(lib::bind(&client_impl::ping,this,lib::placeholders::_1));
+            LOG("On handshake,sid:"<<m_sid<<",ping interval:"<<m_ping_interval<<",ping timeout"<<m_ping_timeout<<endl);
+            return;
+        }
+failed:
+        //just close it.
+        m_client.get_io_service().dispatch(lib::bind(&client_impl::close_impl, this,close::status::policy_violation,"Handshake error"));
+    }
+
+    void client_impl::on_pong()
+    {
+        if(m_ping_timeout_timer)
+        {
+            m_ping_timeout_timer->cancel();
+            m_ping_timeout_timer.reset();
+        }
+    }
+
+    void client_impl::on_decode(packet const& p)
+    {
+        switch(p.get_frame())
+        {
+        case packet::frame_message:
+        {
+            socket::ptr so_ptr = get_socket_locked(p.get_nsp());
+            if(so_ptr)so_ptr->on_message_packet(p);
+            break;
+        }
+        case packet::frame_open:
+            this->on_handshake(p.get_message());
+            break;
+        case packet::frame_close:
+            //FIXME how to deal?
+            this->close_impl(close::status::abnormal_close, "End by server");
+            break;
+        case packet::frame_pong:
+            this->on_pong();
+            break;
+
+        default:
+            break;
+        }
+    }
+    
+    void client_impl::on_encode(bool isBinary,shared_ptr<const string> const& payload)
+    {
+        LOG("encoded payload length:"<<payload->length()<<endl);
+        m_client.get_io_service().dispatch(lib::bind(&client_impl::send_impl,this,payload,isBinary?frame::opcode::binary:frame::opcode::text));
+    }
+    
+    void client_impl::clear_timers()
+    {
+        LOG("clear timers"<<endl);
+        boost::system::error_code ec;
+        if(m_ping_timeout_timer)
+        {
+            m_ping_timeout_timer->cancel(ec);
+            m_ping_timeout_timer.reset();
+        }
+        if(m_ping_timer)
+        {
+            m_ping_timer->cancel(ec);
+            m_ping_timer.reset();
+        }
+    }
+    
+    void client_impl::reset_states()
+    {
+        m_client.reset();
+        m_sid.clear();
+        m_packet_mgr.reset();
+    }
+    
+#if SIO_TLS
+    client_impl::context_ptr client_impl::on_tls_init(connection_hdl conn)
+    {
+        context_ptr ctx = context_ptr(new  boost::asio::ssl::context(boost::asio::ssl::context::tlsv1));
+        boost::system::error_code ec;
+        ctx->set_options(boost::asio::ssl::context::default_workarounds |
+                             boost::asio::ssl::context::no_sslv2 |
+                             boost::asio::ssl::context::single_dh_use,ec);
+        if(ec)
+        {
+            cerr<<"Init tls failed,reason:"<< ec.message()<<endl;
+        }
+        
+        return ctx;
+    }
+#endif
+
+    std::string client_impl::encode_query_string(const std::string &query){
+        ostringstream ss;
+        ss << std::hex;
+        // Percent-encode (RFC3986) non-alphanumeric characters.
+        for(const char c : query){
+            if((c >= 'a' && c <= 'z') || (c>= 'A' && c<= 'Z') || (c >= '0' && c<= '9')){
+                ss << c;
+            } else {
+                ss << '%' << std::uppercase << std::setw(2) << int((unsigned char) c) << std::nouppercase;
+            }
+        }
+        ss << std::dec;
+        return ss.str();
+    }
+}
diff --git a/extlibs/socket/sio_client_impl.h b/extlibs/socket/sio_client_impl.h
new file mode 100644
index 000000000..042608e06
--- /dev/null
+++ b/extlibs/socket/sio_client_impl.h
@@ -0,0 +1,232 @@
+#ifndef SIO_CLIENT_IMPL_H
+#define SIO_CLIENT_IMPL_H
+
+#include <cstdint>
+#ifdef _WIN32
+#define _WEBSOCKETPP_CPP11_THREAD_
+#define BOOST_ALL_NO_LIB
+//#define _WEBSOCKETPP_CPP11_RANDOM_DEVICE_
+#define _WEBSOCKETPP_NO_CPP11_FUNCTIONAL_
+#define INTIALIZER(__TYPE__)
+#else
+#define _WEBSOCKETPP_CPP11_STL_ 1
+#define INTIALIZER(__TYPE__) (__TYPE__)
+#endif
+#include <websocketpp/client.hpp>
+#if _DEBUG || DEBUG
+#if SIO_TLS
+#include <websocketpp/config/debug_asio.hpp>
+typedef websocketpp::config::debug_asio_tls client_config;
+#else
+#include <websocketpp/config/debug_asio_no_tls.hpp>
+typedef websocketpp::config::debug_asio client_config;
+#endif //SIO_TLS
+#else
+#if SIO_TLS
+#include <websocketpp/config/asio_client.hpp>
+typedef websocketpp::config::asio_tls_client client_config;
+#else
+#include <websocketpp/config/asio_no_tls_client.hpp>
+typedef websocketpp::config::asio_client client_config;
+#endif //SIO_TLS
+#endif //DEBUG
+#include <boost/asio/deadline_timer.hpp>
+
+#include <memory>
+#include <map>
+#include <thread>
+#include "sio_client.h"
+#include "sio_packet.h"
+
+namespace sio
+{
+    using namespace websocketpp;
+    
+    typedef websocketpp::client<client_config> client_type;
+    
+    class client_impl {
+        
+    protected:
+        enum con_state
+        {
+            con_opening,
+            con_opened,
+            con_closing,
+            con_closed
+        };
+        
+        client_impl();
+        
+        ~client_impl();
+        
+        //set listeners and event bindings.
+#define SYNTHESIS_SETTER(__TYPE__,__FIELD__) \
+    void set_##__FIELD__(__TYPE__ const& l) \
+        { m_##__FIELD__ = l;}
+        
+        SYNTHESIS_SETTER(client::con_listener,open_listener)
+        
+        SYNTHESIS_SETTER(client::con_listener,fail_listener)
+
+        SYNTHESIS_SETTER(client::reconnect_listener,reconnect_listener)
+
+        SYNTHESIS_SETTER(client::con_listener,reconnecting_listener)
+        
+        SYNTHESIS_SETTER(client::close_listener,close_listener)
+        
+        SYNTHESIS_SETTER(client::socket_listener,socket_open_listener)
+        
+        SYNTHESIS_SETTER(client::socket_listener,socket_close_listener)
+        
+#undef SYNTHESIS_SETTER
+        
+        
+        void clear_con_listeners()
+        {
+            m_open_listener = nullptr;
+            m_close_listener = nullptr;
+            m_fail_listener = nullptr;
+            m_reconnect_listener = nullptr;
+            m_reconnecting_listener = nullptr;
+        }
+        
+        void clear_socket_listeners()
+        {
+            m_socket_open_listener = nullptr;
+            m_socket_close_listener = nullptr;
+        }
+        
+        // Client Functions - such as send, etc.
+        void connect(const std::string& uri, const std::map<std::string, std::string>& queryString,
+                     const std::map<std::string, std::string>& httpExtraHeaders);
+        
+        sio::socket::ptr const& socket(const std::string& nsp);
+        
+        // Closes the connection
+        void close();
+        
+        void sync_close();
+        
+        bool opened() const { return m_con_state == con_opened; }
+        
+        std::string const& get_sessionid() const { return m_sid; }
+
+        void set_reconnect_attempts(unsigned attempts) {m_reconn_attempts = attempts;}
+
+        void set_reconnect_delay(unsigned millis) {m_reconn_delay = millis;if(m_reconn_delay_max<millis) m_reconn_delay_max = millis;}
+
+        void set_reconnect_delay_max(unsigned millis) {m_reconn_delay_max = millis;if(m_reconn_delay>millis) m_reconn_delay = millis;}
+        
+    protected:
+        void send(packet& p);
+        
+        void remove_socket(std::string const& nsp);
+        
+        boost::asio::io_service& get_io_service();
+        
+        void on_socket_closed(std::string const& nsp);
+        
+        void on_socket_opened(std::string const& nsp);
+        
+    private:
+        void run_loop();
+
+        void connect_impl(const std::string& uri, const std::string& query);
+
+        void close_impl(close::status::value const& code,std::string const& reason);
+        
+        void send_impl(std::shared_ptr<const std::string> const&  payload_ptr,frame::opcode::value opcode);
+        
+        void ping(const boost::system::error_code& ec);
+        
+        void timeout_pong(const boost::system::error_code& ec);
+
+        void timeout_reconnect(boost::system::error_code const& ec);
+
+        unsigned next_delay() const;
+
+        socket::ptr get_socket_locked(std::string const& nsp);
+        
+        void sockets_invoke_void(void (sio::socket::*fn)(void));
+        
+        void on_decode(packet const& pack);
+        void on_encode(bool isBinary,shared_ptr<const string> const& payload);
+        
+        //websocket callbacks
+        void on_fail(connection_hdl con);
+
+        void on_open(connection_hdl con);
+
+        void on_close(connection_hdl con);
+
+        void on_message(connection_hdl con, client_type::message_ptr msg);
+
+        //socketio callbacks
+        void on_handshake(message::ptr const& message);
+
+        void on_pong();
+
+        void reset_states();
+
+        void clear_timers();
+        
+        #if SIO_TLS
+        typedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;
+        
+        context_ptr on_tls_init(connection_hdl con);
+        #endif
+        
+        // Percent encode query string
+        std::string encode_query_string(const std::string &query);
+
+        // Connection pointer for client functions.
+        connection_hdl m_con;
+        client_type m_client;
+        // Socket.IO server settings
+        std::string m_sid;
+        std::string m_base_url;
+        std::string m_query_string;
+        std::map<std::string, std::string> m_http_headers;
+
+        unsigned int m_ping_interval;
+        unsigned int m_ping_timeout;
+        
+        std::unique_ptr<std::thread> m_network_thread;
+        
+        packet_manager m_packet_mgr;
+        
+        std::unique_ptr<boost::asio::deadline_timer> m_ping_timer;
+        
+        std::unique_ptr<boost::asio::deadline_timer> m_ping_timeout_timer;
+
+        std::unique_ptr<boost::asio::deadline_timer> m_reconn_timer;
+        
+        con_state m_con_state;
+        
+        client::con_listener m_open_listener;
+        client::con_listener m_fail_listener;
+        client::con_listener m_reconnecting_listener;
+        client::reconnect_listener m_reconnect_listener;
+        client::close_listener m_close_listener;
+        
+        client::socket_listener m_socket_open_listener;
+        client::socket_listener m_socket_close_listener;
+        
+        std::map<const std::string,socket::ptr> m_sockets;
+        
+        std::mutex m_socket_mutex;
+
+        unsigned m_reconn_delay;
+
+        unsigned m_reconn_delay_max;
+
+        unsigned m_reconn_attempts;
+
+        unsigned m_reconn_made;
+        
+        friend class sio::client;
+        friend class sio::socket;
+    };
+}
+#endif // SIO_CLIENT_IMPL_H
+
diff --git a/extlibs/socket/sio_message.h b/extlibs/socket/sio_message.h
new file mode 100644
index 000000000..6ad0d9b9f
--- /dev/null
+++ b/extlibs/socket/sio_message.h
@@ -0,0 +1,569 @@
+//
+//  sio_message.h
+//
+//  Created by Melo Yao on 3/25/15.
+//
+
+#ifndef __SIO_MESSAGE_H__
+#define __SIO_MESSAGE_H__
+#include <string>
+#include <memory>
+#include <vector>
+#include <map>
+#include <cassert>
+#include <type_traits>
+namespace sio
+{
+    class message
+    {
+    public:
+        enum flag
+        {
+            flag_integer,
+            flag_double,
+            flag_string,
+            flag_binary,
+            flag_array,
+            flag_object,
+            flag_boolean,
+            flag_null
+        };
+
+        virtual ~message(){};
+
+        class list;
+
+        flag get_flag() const
+        {
+            return _flag;
+        }
+
+        typedef std::shared_ptr<message> ptr;
+
+        virtual bool get_bool() const
+        {
+            assert(false);
+            return false;
+        }
+
+        virtual int64_t get_int() const
+        {
+            assert(false);
+            return 0;
+        }
+
+        virtual double get_double() const
+        {
+            assert(false);
+            return 0;
+        }
+
+        virtual std::string const& get_string() const
+        {
+            assert(false);
+            static std::string s_empty_string;
+            s_empty_string.clear();
+            return s_empty_string;
+        }
+
+        virtual std::shared_ptr<const std::string> const& get_binary() const
+        {
+            assert(false);
+            static std::shared_ptr<const std::string> s_empty_binary;
+            s_empty_binary = nullptr;
+            return s_empty_binary;
+        }
+
+        virtual const std::vector<ptr>& get_vector() const
+        {
+            assert(false);
+            static std::vector<ptr> s_empty_vector;
+            s_empty_vector.clear();
+            return s_empty_vector;
+        }
+
+        virtual std::vector<ptr>& get_vector()
+        {
+            assert(false);
+            static std::vector<ptr> s_empty_vector;
+            s_empty_vector.clear();
+            return s_empty_vector;
+        }
+
+        virtual const std::map<std::string,message::ptr>& get_map() const
+        {
+            assert(false);
+            static std::map<std::string,message::ptr> s_empty_map;
+            s_empty_map.clear();
+            return s_empty_map;
+        }
+
+        virtual std::map<std::string,message::ptr>& get_map()
+        {
+            assert(false);
+            static std::map<std::string,message::ptr> s_empty_map;
+            s_empty_map.clear();
+            return s_empty_map;
+        }
+    private:
+        flag _flag;
+
+    protected:
+        message(flag f):_flag(f){}
+    };
+
+    class null_message : public message
+    {
+    protected:
+        null_message()
+            :message(flag_null)
+        {
+        }
+
+    public:
+        static message::ptr create()
+        {
+            return ptr(new null_message());
+        }
+    };
+
+    class bool_message : public message
+    {
+        bool _v;
+
+    protected:
+        bool_message(bool v)
+            :message(flag_boolean),_v(v)
+        {
+        }
+
+    public:
+        static message::ptr create(bool v)
+        {
+            return ptr(new bool_message(v));
+        }
+
+        bool get_bool() const
+        {
+            return _v;
+        }
+    };
+
+    class int_message : public message
+    {
+        int64_t _v;
+    protected:
+        int_message(int64_t v)
+            :message(flag_integer),_v(v)
+        {
+        }
+
+    public:
+        static message::ptr create(int64_t v)
+        {
+            return ptr(new int_message(v));
+        }
+
+        int64_t get_int() const
+        {
+            return _v;
+        }
+
+        double get_double() const//add double accessor for integer.
+        {
+            return static_cast<double>(_v);
+        }
+    };
+
+    class double_message : public message
+    {
+        double _v;
+        double_message(double v)
+            :message(flag_double),_v(v)
+        {
+        }
+
+    public:
+        static message::ptr create(double v)
+        {
+            return ptr(new double_message(v));
+        }
+
+        double get_double() const
+        {
+            return _v;
+        }
+    };
+
+    class string_message : public message
+    {
+        std::string _v;
+        string_message(std::string const& v)
+            :message(flag_string),_v(v)
+        {
+        }
+
+        string_message(std::string&& v)
+            :message(flag_string),_v(move(v))
+        {
+        }
+    public:
+        static message::ptr create(std::string const& v)
+        {
+            return ptr(new string_message(v));
+        }
+
+        static message::ptr create(std::string&& v)
+        {
+            return ptr(new string_message(move(v)));
+        }
+
+        std::string const& get_string() const
+        {
+            return _v;
+        }
+    };
+
+    class binary_message : public message
+    {
+        std::shared_ptr<const std::string> _v;
+        binary_message(std::shared_ptr<const std::string> const& v)
+            :message(flag_binary),_v(v)
+        {
+        }
+    public:
+        static message::ptr create(std::shared_ptr<const std::string> const& v)
+        {
+            return ptr(new binary_message(v));
+        }
+
+        std::shared_ptr<const std::string> const& get_binary() const
+        {
+            return _v;
+        }
+    };
+
+    class array_message : public message
+    {
+        std::vector<message::ptr> _v;
+        array_message():message(flag_array)
+        {
+        }
+
+    public:
+        static message::ptr create()
+        {
+            return ptr(new array_message());
+        }
+
+        void push(message::ptr const& message)
+        {
+            if(message)
+                _v.push_back(message);
+        }
+
+        void push(const std::string& text)
+        {
+            _v.push_back(string_message::create(text));
+        }
+
+        void push(std::string&& text)
+        {
+            _v.push_back(string_message::create(move(text)));
+        }
+
+        void push(std::shared_ptr<std::string> const& binary)
+        {
+            if(binary)
+                _v.push_back(binary_message::create(binary));
+        }
+
+        void push(std::shared_ptr<const std::string> const& binary)
+        {
+            if(binary)
+                _v.push_back(binary_message::create(binary));
+        }
+
+        void insert(size_t pos,message::ptr const& message)
+        {
+            _v.insert(_v.begin()+pos, message);
+        }
+
+        void insert(size_t pos,const std::string& text)
+        {
+            _v.insert(_v.begin()+pos, string_message::create(text));
+        }
+
+        void insert(size_t pos,std::string&& text)
+        {
+            _v.insert(_v.begin()+pos, string_message::create(move(text)));
+        }
+
+        void insert(size_t pos,std::shared_ptr<std::string> const& binary)
+        {
+            if(binary)
+                _v.insert(_v.begin()+pos, binary_message::create(binary));
+        }
+
+        void insert(size_t pos,std::shared_ptr<const std::string> const& binary)
+        {
+            if(binary)
+                _v.insert(_v.begin()+pos, binary_message::create(binary));
+        }
+
+        size_t size() const
+        {
+            return _v.size();
+        }
+
+        const message::ptr& at(size_t i) const
+        {
+            return _v[i];
+        }
+
+        const message::ptr& operator[] (size_t i) const
+        {
+            return _v[i];
+        }
+
+        std::vector<ptr>& get_vector()
+        {
+            return _v;
+        }
+
+        const std::vector<ptr>& get_vector() const
+        {
+            return _v;
+        }
+    };
+
+    class object_message : public message
+    {
+        std::map<std::string,message::ptr> _v;
+        object_message() : message(flag_object)
+        {
+        }
+    public:
+        static message::ptr create()
+        {
+            return ptr(new object_message());
+        }
+
+        void insert(const std::string & key,message::ptr const& message)
+        {
+            _v[key] = message;
+        }
+
+        void insert(const std::string & key,const std::string& text)
+        {
+            _v[key] = string_message::create(text);
+        }
+
+        void insert(const std::string & key,std::string&& text)
+        {
+            _v[key] = string_message::create(move(text));
+        }
+
+        void insert(const std::string & key,std::shared_ptr<std::string> const& binary)
+        {
+            if(binary)
+                _v[key] = binary_message::create(binary);
+        }
+
+        void insert(const std::string & key,std::shared_ptr<const std::string> const& binary)
+        {
+            if(binary)
+                _v[key] = binary_message::create(binary);
+        }
+
+        bool has(const std::string & key)
+        {
+            return _v.find(key) != _v.end();
+        }
+
+        const message::ptr& at(const std::string & key) const
+        {
+            static std::shared_ptr<message> not_found;
+
+            std::map<std::string,message::ptr>::const_iterator it = _v.find(key);
+            if (it != _v.cend()) return it->second;
+            return not_found;
+        }
+
+        const message::ptr& operator[] (const std::string & key) const
+        {
+            return at(key);
+        }
+
+        bool has(const std::string & key) const
+        {
+            return _v.find(key) != _v.end();
+        }
+
+        std::map<std::string,message::ptr>& get_map()
+        {
+            return _v;
+        }
+
+        const std::map<std::string,message::ptr>& get_map() const
+        {
+            return _v;
+        }
+    };
+
+    class message::list
+    {
+    public:
+        list()
+        {
+        }
+
+        list(std::nullptr_t)
+        {
+        }
+
+        list(message::list&& rhs):
+            m_vector(std::move(rhs.m_vector))
+        {
+
+        }
+
+        list & operator= (const message::list && rhs)
+        {
+            m_vector = std::move(rhs.m_vector);
+            return *this;
+        }
+
+        template <typename T>
+        list(T&& content,
+            typename std::enable_if<std::is_same<std::vector<message::ptr>,typename std::remove_reference<T>::type>::value>::type* = 0):
+            m_vector(std::forward<T>(content))
+        {
+        }
+
+        list(message::list const& rhs):
+            m_vector(rhs.m_vector)
+        {
+
+        }
+
+        list(message::ptr const& message)
+        {
+            if(message)
+                m_vector.push_back(message);
+
+        }
+
+        list(const std::string& text)
+        {
+            m_vector.push_back(string_message::create(text));
+        }
+
+        list(std::string&& text)
+        {
+            m_vector.push_back(string_message::create(move(text)));
+        }
+
+        list(std::shared_ptr<std::string> const& binary)
+        {
+            if(binary)
+                m_vector.push_back(binary_message::create(binary));
+        }
+
+        list(std::shared_ptr<const std::string> const& binary)
+        {
+            if(binary)
+                m_vector.push_back(binary_message::create(binary));
+        }
+
+        void push(message::ptr const& message)
+        {
+            if(message)
+                m_vector.push_back(message);
+        }
+
+        void push(const std::string& text)
+        {
+            m_vector.push_back(string_message::create(text));
+        }
+
+        void push(std::string&& text)
+        {
+            m_vector.push_back(string_message::create(move(text)));
+        }
+
+        void push(std::shared_ptr<std::string> const& binary)
+        {
+            if(binary)
+                m_vector.push_back(binary_message::create(binary));
+        }
+
+        void push(std::shared_ptr<const std::string> const& binary)
+        {
+            if(binary)
+                m_vector.push_back(binary_message::create(binary));
+        }
+
+        void insert(size_t pos,message::ptr const& message)
+        {
+            m_vector.insert(m_vector.begin()+pos, message);
+        }
+
+        void insert(size_t pos,const std::string& text)
+        {
+            m_vector.insert(m_vector.begin()+pos, string_message::create(text));
+        }
+
+        void insert(size_t pos,std::string&& text)
+        {
+            m_vector.insert(m_vector.begin()+pos, string_message::create(move(text)));
+        }
+
+        void insert(size_t pos,std::shared_ptr<std::string> const& binary)
+        {
+            if(binary)
+                m_vector.insert(m_vector.begin()+pos, binary_message::create(binary));
+        }
+
+        void insert(size_t pos,std::shared_ptr<const std::string> const& binary)
+        {
+            if(binary)
+                m_vector.insert(m_vector.begin()+pos, binary_message::create(binary));
+        }
+
+        size_t size() const
+        {
+            return m_vector.size();
+        }
+
+        const message::ptr& at(size_t i) const
+        {
+            return m_vector[i];
+        }
+
+        const message::ptr& operator[] (size_t i) const
+        {
+            return m_vector[i];
+        }
+
+        message::ptr to_array_message(std::string const& event_name) const
+        {
+            message::ptr arr = array_message::create();
+            arr->get_vector().push_back(string_message::create(event_name));
+            arr->get_vector().insert(arr->get_vector().end(),m_vector.begin(),m_vector.end());
+            return arr;
+        }
+
+        message::ptr to_array_message() const
+        {
+            message::ptr arr = array_message::create();
+            arr->get_vector().insert(arr->get_vector().end(),m_vector.begin(),m_vector.end());
+            return arr;
+        }
+
+    private:
+        std::vector<message::ptr> m_vector;
+    };
+}
+
+#endif
diff --git a/extlibs/socket/sio_packet.cpp b/extlibs/socket/sio_packet.cpp
new file mode 100644
index 000000000..a2d13b5ec
--- /dev/null
+++ b/extlibs/socket/sio_packet.cpp
@@ -0,0 +1,517 @@
+//
+//  sio_packet.cpp
+//
+//  Created by Melo Yao on 3/22/15.
+//
+
+#include "sio_packet.h"
+#include <rapidjson/document.h>
+#include <rapidjson/encodedstream.h>
+#include <rapidjson/writer.h>
+#include <cassert>
+#include <boost/lexical_cast.hpp>
+
+#define kBIN_PLACE_HOLDER "_placeholder"
+
+namespace sio
+{
+    using namespace rapidjson;
+    using namespace std;
+    void accept_message(message const& msg,Value& val, Document& doc,vector<shared_ptr<const string> >& buffers);
+
+	void accept_bool_message(bool_message const& msg, Value& val)
+	{
+		val.SetBool(msg.get_bool());
+	}
+
+	void accept_null_message(Value& val)
+	{
+		val.SetNull();
+	}
+
+    void accept_int_message(int_message const& msg, Value& val)
+    {
+        val.SetInt64(msg.get_int());
+    }
+
+    void accept_double_message(double_message const& msg, Value& val)
+    {
+        val.SetDouble(msg.get_double());
+    }
+
+    void accept_string_message(string_message const& msg, Value& val)
+    {
+        val.SetString(msg.get_string().data(),(SizeType) msg.get_string().length());
+    }
+
+
+    void accept_binary_message(binary_message const& msg,Value& val,Document& doc,vector<shared_ptr<const string> >& buffers)
+    {
+        val.SetObject();
+        Value boolVal;
+        boolVal.SetBool(true);
+        val.AddMember(kBIN_PLACE_HOLDER, boolVal, doc.GetAllocator());
+        Value numVal;
+        numVal.SetInt((int)buffers.size());
+        val.AddMember("num", numVal, doc.GetAllocator());
+        //FIXME can not avoid binary copy here.
+        shared_ptr<string> write_buffer = make_shared<string>();
+        write_buffer->reserve(msg.get_binary()->size()+1);
+        char frame_char = packet::frame_message;
+        write_buffer->append(&frame_char,1);
+        write_buffer->append(*(msg.get_binary()));
+        buffers.push_back(write_buffer);
+    }
+
+    void accept_array_message(array_message const& msg,Value& val,Document& doc,vector<shared_ptr<const string> >& buffers)
+    {
+        val.SetArray();
+        for (vector<message::ptr>::const_iterator it = msg.get_vector().begin(); it!=msg.get_vector().end(); ++it) {
+            Value child;
+            accept_message(*(*it), child, doc,buffers);
+            val.PushBack(child, doc.GetAllocator());
+        }
+    }
+
+    void accept_object_message(object_message const& msg,Value& val,Document& doc,vector<shared_ptr<const string> >& buffers)
+    {
+        val.SetObject();
+        for (map<string,message::ptr>::const_iterator it = msg.get_map().begin(); it!= msg.get_map().end(); ++it) {
+            Value nameVal;
+            nameVal.SetString(it->first.data(), (SizeType)it->first.length(), doc.GetAllocator());
+            Value valueVal;
+            accept_message(*(it->second), valueVal, doc,buffers);
+            val.AddMember(nameVal, valueVal, doc.GetAllocator());
+        }
+    }
+
+    void accept_message(message const& msg,Value& val, Document& doc,vector<shared_ptr<const string> >& buffers)
+    {
+        const message* msg_ptr = &msg;
+        switch(msg.get_flag())
+        {
+        case message::flag_integer:
+        {
+            accept_int_message(*(static_cast<const int_message*>(msg_ptr)), val);
+            break;
+        }
+        case message::flag_double:
+        {
+            accept_double_message(*(static_cast<const double_message*>(msg_ptr)), val);
+            break;
+        }
+        case message::flag_string:
+        {
+            accept_string_message(*(static_cast<const string_message*>(msg_ptr)), val);
+            break;
+        }
+		case message::flag_boolean:
+		{
+			accept_bool_message(*(static_cast<const bool_message*>(msg_ptr)), val);
+			break;
+		}
+		case message::flag_null:
+		{
+			accept_null_message(val);
+			break;
+		}
+        case message::flag_binary:
+        {
+            accept_binary_message(*(static_cast<const binary_message*>(msg_ptr)), val,doc,buffers);
+            break;
+        }
+        case message::flag_array:
+        {
+            accept_array_message(*(static_cast<const array_message*>(msg_ptr)), val,doc,buffers);
+            break;
+        }
+        case message::flag_object:
+        {
+            accept_object_message(*(static_cast<const object_message*>(msg_ptr)), val,doc,buffers);
+            break;
+        }
+        default:
+            break;
+        }
+    }
+
+    message::ptr from_json(Value const& value, vector<shared_ptr<const string> > const& buffers)
+    {
+        if(value.IsInt64())
+        {
+            return int_message::create(value.GetInt64());
+        }
+        else if(value.IsDouble())
+        {
+            return double_message::create(value.GetDouble());
+        }
+        else if(value.IsString())
+        {
+            string str(value.GetString(),value.GetStringLength());
+            return string_message::create(str);
+        }
+        else if(value.IsArray())
+        {
+            message::ptr ptr = array_message::create();
+            for (SizeType i = 0; i< value.Size(); ++i) {
+                static_cast<array_message*>(ptr.get())->get_vector().push_back(from_json(value[i],buffers));
+            }
+            return ptr;
+        }
+        else if(value.IsObject())
+        {
+            //binary placeholder
+            auto mem_it = value.FindMember(kBIN_PLACE_HOLDER);
+            if (mem_it!=value.MemberEnd() && mem_it->value.GetBool()) {
+
+                int num = value["num"].GetInt();
+                if(num >= 0 && num < static_cast<int>(buffers.size()))
+                {
+                    return binary_message::create(buffers[num]);
+                }
+                return message::ptr();
+            }
+            //real object message.
+            message::ptr ptr = object_message::create();
+            for (auto it = value.MemberBegin();it!=value.MemberEnd();++it)
+            {
+                if(it->name.IsString())
+                {
+                    string key(it->name.GetString(),it->name.GetStringLength());
+                    static_cast<object_message*>(ptr.get())->get_map()[key] = from_json(it->value,buffers);
+                }
+            }
+            return ptr;
+        }
+		else if(value.IsBool())
+		{
+			return bool_message::create(value.GetBool());
+		}
+		else if(value.IsNull())
+		{
+			return null_message::create();
+		}
+        return message::ptr();
+    }
+
+    packet::packet(string const& nsp,message::ptr const& msg,int pack_id, bool isAck):
+        _frame(frame_message),
+        _type((isAck?type_ack : type_event) | type_undetermined),
+        _nsp(nsp),
+        _pack_id(pack_id),
+        _message(msg),
+        _pending_buffers(0)
+    {
+        assert((!isAck
+                || (isAck&&pack_id>=0)));
+    }
+
+    packet::packet(type type,string const& nsp, message::ptr const& msg):
+        _frame(frame_message),
+        _type(type),
+        _nsp(nsp),
+        _pack_id(-1),
+        _message(msg),
+        _pending_buffers(0)
+    {
+
+    }
+
+    packet::packet(packet::frame_type frame):
+        _frame(frame),
+        _type(type_undetermined),
+        _pack_id(-1),
+        _pending_buffers(0)
+    {
+
+    }
+
+    packet::packet():
+        _type(type_undetermined),
+        _pack_id(-1),
+        _pending_buffers(0)
+    {
+
+    }
+
+
+    bool packet::is_binary_message(string const& payload_ptr)
+    {
+        return payload_ptr.size()>0 && payload_ptr[0] == frame_message;
+    }
+
+    bool packet::is_text_message(string const& payload_ptr)
+    {
+        return payload_ptr.size()>0 && payload_ptr[0] == (frame_message + '0');
+    }
+
+    bool packet::is_message(string const& payload_ptr)
+    {
+        return is_binary_message(payload_ptr) || is_text_message(payload_ptr);
+    }
+
+    bool packet::parse_buffer(const string &buf_payload)
+    {
+        if (_pending_buffers > 0) {
+            assert(is_binary_message(buf_payload));//this is ensured by outside.
+            _buffers.push_back(std::make_shared<string>(buf_payload.data()+1,buf_payload.size()-1));
+            _pending_buffers--;
+            if (_pending_buffers == 0) {
+
+                Document doc;
+                doc.Parse<0>(_buffers.front()->data());
+                _buffers.erase(_buffers.begin());
+                _message = from_json(doc, _buffers);
+                _buffers.clear();
+                return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    bool packet::parse(const string& payload_ptr)
+    {
+        assert(!is_binary_message(payload_ptr)); //this is ensured by outside
+        _frame = (packet::frame_type) (payload_ptr[0] - '0');
+        _message.reset();
+        _pack_id = -1;
+        _buffers.clear();
+        _pending_buffers = 0;
+        size_t pos = 1;
+        if (_frame == frame_message) {
+            _type = (packet::type)(payload_ptr[pos] - '0');
+            if(_type < type_min || _type > type_max)
+            {
+                return false;
+            }
+            pos++;
+            if (_type == type_binary_event || _type == type_binary_ack) {
+                size_t score_pos = payload_ptr.find('-');
+                _pending_buffers = boost::lexical_cast<unsigned>(payload_ptr.substr(pos,score_pos - pos));
+                pos = score_pos+1;
+            }
+        }
+
+        size_t nsp_json_pos = payload_ptr.find_first_of("{[\"/",pos,4);
+        if(nsp_json_pos==string::npos)//no namespace and no message,the end.
+        {
+            _nsp = "/";
+            return false;
+        }
+        size_t json_pos = nsp_json_pos;
+        if(payload_ptr[nsp_json_pos] == '/')//nsp_json_pos is start of nsp
+        {
+            size_t comma_pos = payload_ptr.find_first_of(",");//end of nsp
+            if(comma_pos == string::npos)//packet end with nsp
+            {
+                _nsp = payload_ptr.substr(nsp_json_pos);
+                return false;
+            }
+            else//we have a message, maybe the message have an id.
+            {
+                _nsp = payload_ptr.substr(nsp_json_pos,comma_pos - nsp_json_pos);
+                pos = comma_pos+1;//start of the message
+                json_pos = payload_ptr.find_first_of("\"[{", pos, 3);//start of the json part of message
+                if(json_pos == string::npos)
+                {
+                    //no message,the end
+                    //assume if there's no message, there's no message id.
+                    return false;
+                }
+            }
+        }
+        else
+        {
+            _nsp = "/";
+        }
+
+        if(pos<json_pos)//we've got pack id.
+        {
+            _pack_id = boost::lexical_cast<int>(payload_ptr.substr(pos,json_pos - pos));
+        }
+        if (_frame == frame_message && (_type == type_binary_event || _type == type_binary_ack)) {
+            //parse later when all buffers are arrived.
+            _buffers.push_back(make_shared<string>(payload_ptr.data() + json_pos, payload_ptr.length() - json_pos));
+            return true;
+        }
+        else
+        {
+            Document doc;
+            doc.Parse<0>(payload_ptr.data()+json_pos);
+            _message = from_json(doc, vector<shared_ptr<const string> >());
+            return false;
+        }
+
+    }
+
+    bool packet::accept(string& payload_ptr, vector<shared_ptr<const string> >&buffers)
+    {
+        char frame_char = _frame+'0';
+        payload_ptr.append(&frame_char,1);
+        if (_frame!=frame_message) {
+            return false;
+        }
+        bool hasMessage = false;
+        Document doc;
+        if (_message) {
+            accept_message(*_message, doc, doc, buffers);
+            hasMessage = true;
+        }
+        bool hasBinary = buffers.size()>0;
+        _type = _type&(~type_undetermined);
+        if(_type == type_event)
+        {
+            _type = hasBinary?type_binary_event:type_event;
+        }
+        else if(_type == type_ack)
+        {
+            _type = hasBinary? type_binary_ack : type_ack;
+        }
+        ostringstream ss;
+        ss.precision(8);
+        ss<<_type;
+        if (hasBinary) {
+            ss<<buffers.size()<<"-";
+        }
+        if(_nsp.size()>0 && _nsp!="/")
+        {
+            ss<<_nsp;
+            if (hasMessage || _pack_id>=0) {
+                ss<<",";
+            }
+        }
+
+        if(_pack_id>=0)
+        {
+            ss<<_pack_id;
+        }
+
+        payload_ptr.append(ss.str());
+        if (hasMessage)
+        {
+            StringBuffer buffer;
+            Writer<StringBuffer> writer(buffer);
+            doc.Accept(writer);
+            payload_ptr.append(buffer.GetString(),buffer.GetSize());
+        }
+        return hasBinary;
+    }
+
+    packet::frame_type packet::get_frame() const
+    {
+        return _frame;
+    }
+
+    packet::type packet::get_type() const
+    {
+        assert((_type & type_undetermined) == 0);
+        return (type)_type;
+    }
+
+    string const& packet::get_nsp() const
+    {
+        return _nsp;
+    }
+
+    message::ptr const& packet::get_message() const
+    {
+        return _message;
+    }
+
+    unsigned packet::get_pack_id() const
+    {
+        return _pack_id;
+    }
+
+
+    void packet_manager::set_decode_callback(function<void (packet const&)> const& decode_callback)
+    {
+        m_decode_callback = decode_callback;
+    }
+
+    void packet_manager::set_encode_callback(function<void (bool,shared_ptr<const string> const&)> const& encode_callback)
+    {
+        m_encode_callback = encode_callback;
+    }
+
+    void packet_manager::reset()
+    {
+        m_partial_packet.reset();
+    }
+
+    void packet_manager::encode(packet& pack,encode_callback_function const& override_encode_callback) const
+    {
+        shared_ptr<string> ptr = make_shared<string>();
+        vector<shared_ptr<const string> > buffers;
+        const encode_callback_function *cb_ptr = &m_encode_callback;
+        if(override_encode_callback)
+        {
+            cb_ptr = &override_encode_callback;
+        }
+        if(pack.accept(*ptr,buffers))
+        {
+            if((*cb_ptr))
+            {
+                (*cb_ptr)(false,ptr);
+            }
+            for(auto it = buffers.begin();it!=buffers.end();++it)
+            {
+                if((*cb_ptr))
+                {
+                    (*cb_ptr)(true,*it);
+                }
+            }
+        }
+        else
+        {
+            if((*cb_ptr))
+            {
+                (*cb_ptr)(false,ptr);
+            }
+        }
+    }
+
+    void packet_manager::put_payload(string const& payload)
+    {
+        unique_ptr<packet> p;
+        do
+        {
+            if(packet::is_text_message(payload))
+            {
+                p.reset(new packet());
+                if(p->parse(payload))
+                {
+                    m_partial_packet = std::move(p);
+                }
+                else
+                {
+                    break;
+                }
+            }
+            else if(packet::is_binary_message(payload))
+            {
+                if(m_partial_packet)
+                {
+                    if(!m_partial_packet->parse_buffer(payload))
+                    {
+                        p = std::move(m_partial_packet);
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                p.reset(new packet());
+                p->parse(payload);
+                break;
+            }
+            return;
+        }while(0);
+
+        if(m_decode_callback)
+        {
+            m_decode_callback(*p);
+        }
+    }
+}
diff --git a/extlibs/socket/sio_packet.h b/extlibs/socket/sio_packet.h
new file mode 100644
index 000000000..1b4394091
--- /dev/null
+++ b/extlibs/socket/sio_packet.h
@@ -0,0 +1,106 @@
+//
+//  sio_packet.h
+//
+//  Created by Melo Yao on 3/19/15.
+//
+
+#ifndef SIO_PACKET_H
+#define SIO_PACKET_H
+#include <sstream>
+#include "sio_message.h"
+#include <functional>
+
+namespace sio
+{
+    using namespace std;
+    
+    class packet
+    {
+    public:
+        enum frame_type
+        {
+            frame_open = 0,
+            frame_close = 1,
+            frame_ping = 2,
+            frame_pong = 3,
+            frame_message = 4,
+            frame_upgrade = 5,
+            frame_noop = 6
+        };
+        
+        enum type
+        {
+            type_min = 0,
+            type_connect = 0,
+            type_disconnect = 1,
+            type_event = 2,
+            type_ack = 3,
+            type_error = 4,
+            type_binary_event = 5,
+            type_binary_ack = 6,
+            type_max = 6,
+            type_undetermined = 0x10 //undetermined mask bit
+        };
+    private:
+        frame_type _frame;
+        int _type;
+        string _nsp;
+        int _pack_id;
+        message::ptr _message;
+        unsigned _pending_buffers;
+        vector<shared_ptr<const string> > _buffers;
+    public:
+        packet(string const& nsp,message::ptr const& msg,int pack_id = -1,bool isAck = false);//message type constructor.
+        
+        packet(frame_type frame);
+        
+        packet(type type,string const& nsp= string(),message::ptr const& msg = message::ptr());//other message types constructor.
+        //empty constructor for parse.
+        packet();
+        
+        frame_type get_frame() const;
+        
+        type get_type() const;
+        
+        bool parse(string const& payload_ptr);//return true if need to parse buffer.
+        
+        bool parse_buffer(string const& buf_payload);
+        
+        bool accept(string& payload_ptr, vector<shared_ptr<const string> >&buffers); //return true if has binary buffers.
+        
+        string const& get_nsp() const;
+        
+        message::ptr const& get_message() const;
+        
+        unsigned get_pack_id() const;
+        
+        static bool is_message(string const& payload_ptr);
+        static bool is_text_message(string const& payload_ptr);
+        static bool is_binary_message(string const& payload_ptr);
+    };
+    
+    class packet_manager
+    {
+    public:
+        typedef function<void (bool,shared_ptr<const string> const&)> encode_callback_function;
+        typedef  function<void (packet const&)> decode_callback_function;
+        
+        void set_decode_callback(decode_callback_function const& decode_callback);
+
+        void set_encode_callback(encode_callback_function const& encode_callback);
+        
+        void encode(packet& pack,encode_callback_function const& override_encode_callback = encode_callback_function()) const;
+        
+        void put_payload(string const& payload);
+        
+        void reset();
+        
+    private:
+        decode_callback_function m_decode_callback;
+        
+        encode_callback_function m_encode_callback;
+        
+        std::unique_ptr<packet> m_partial_packet;
+    };
+}
+#endif
diff --git a/extlibs/socket/sio_socket.cpp b/extlibs/socket/sio_socket.cpp
new file mode 100644
index 000000000..df9c07da7
--- /dev/null
+++ b/extlibs/socket/sio_socket.cpp
@@ -0,0 +1,611 @@
+#include "sio_socket.h"
+#include "sio_packet.h"
+#include "sio_client_impl.h"
+#include <boost/asio/deadline_timer.hpp>
+#include <boost/system/error_code.hpp>
+#include <queue>
+#include <cstdarg>
+
+#if DEBUG || _DEBUG
+#define LOG(x) std::cout << x
+#else
+#define LOG(x)
+#endif
+
+#define NULL_GUARD(_x_)  \
+    if(_x_ == NULL) return
+
+namespace sio
+{
+    class event_adapter
+    {
+    public:
+        static void adapt_func(socket::event_listener_aux  const& func, event& event)
+        {
+            func(event.get_name(),event.get_message(),event.need_ack(),event.get_ack_message_impl());
+        }
+        
+        static inline socket::event_listener do_adapt(socket::event_listener_aux const& func)
+        {
+            return std::bind(&event_adapter::adapt_func, func,std::placeholders::_1);
+        }
+        
+        static inline event create_event(std::string const& nsp,std::string const& name,message::list&& message,bool need_ack)
+        {
+            return event(nsp,name,message,need_ack);
+        }
+    };
+    
+    const std::string& event::get_nsp() const
+    {
+        return m_nsp;
+    }
+    
+    const std::string& event::get_name() const
+    {
+        return m_name;
+    }
+    
+    const message::ptr& event::get_message() const
+    {
+        if(m_messages.size()>0)
+            return m_messages[0];
+        else
+        {
+            static message::ptr null_ptr;
+            return null_ptr;
+        }
+    }
+
+    const message::list& event::get_messages() const
+    {
+        return m_messages;
+    }
+    
+    bool event::need_ack() const
+    {
+        return m_need_ack;
+    }
+    
+    void event::put_ack_message(message::list const& ack_message)
+    {
+        if(m_need_ack)
+            m_ack_message = std::move(ack_message);
+    }
+    
+    inline
+    event::event(std::string const& nsp,std::string const& name,message::list&& messages,bool need_ack):
+        m_nsp(nsp),
+        m_name(name),
+        m_messages(std::move(messages)),
+        m_need_ack(need_ack)
+    {
+    }
+
+    inline
+    event::event(std::string const& nsp,std::string const& name,message::list const& messages,bool need_ack):
+        m_nsp(nsp),
+        m_name(name),
+        m_messages(messages),
+        m_need_ack(need_ack)
+    {
+    }
+    
+    message::list const& event::get_ack_message() const
+    {
+        return m_ack_message;
+    }
+    
+    inline
+    message::list& event::get_ack_message_impl()
+    {
+        return m_ack_message;
+    }
+    
+    class socket::impl
+    {
+    public:
+        
+        impl(client_impl *,std::string const&);
+        ~impl();
+        
+        void on(std::string const& event_name,event_listener_aux const& func);
+        
+        void on(std::string const& event_name,event_listener const& func);
+        
+        void off(std::string const& event_name);
+        
+        void off_all();
+        
+#define SYNTHESIS_SETTER(__TYPE__,__FIELD__) \
+    void set_##__FIELD__(__TYPE__ const& l) \
+        { m_##__FIELD__ = l;}
+        
+        SYNTHESIS_SETTER(error_listener, error_listener) //socket io errors
+        
+#undef SYNTHESIS_SETTER
+        
+        void on_error(error_listener const& l);
+        
+        void off_error();
+        
+        void close();
+        
+        void emit(std::string const& name, message::list const& msglist, std::function<void (message::list const&)> const& ack);
+        
+        std::string const& get_namespace() const {return m_nsp;}
+        
+    protected:
+        void on_connected();
+        
+        void on_close();
+        
+        void on_open();
+        
+        void on_message_packet(packet const& packet);
+        
+        void on_disconnect();
+        
+    private:
+        
+        // Message Parsing callbacks.
+        void on_socketio_event(const std::string& nsp, int msgId,const std::string& name, message::list&& message);
+        void on_socketio_ack(int msgId, message::list const& message);
+        void on_socketio_error(message::ptr const& err_message);
+        
+        event_listener get_bind_listener_locked(string const& event);
+        
+        void ack(int msgId,string const& name,message::list const& ack_message);
+        
+        void timeout_connection(const boost::system::error_code &ec);
+        
+        void send_connect();
+        
+        void send_packet(packet& p);
+        
+        static event_listener s_null_event_listener;
+        
+        static unsigned int s_global_event_id;
+        
+        sio::client_impl *m_client;
+        
+        bool m_connected;
+        std::string m_nsp;
+        
+        std::map<unsigned int, std::function<void (message::list const&)> > m_acks;
+        
+        std::map<std::string, event_listener> m_event_binding;
+        
+        error_listener m_error_listener;
+        
+        std::unique_ptr<boost::asio::deadline_timer> m_connection_timer;
+        
+        std::queue<packet> m_packet_queue;
+        
+        std::mutex m_event_mutex;
+
+		std::mutex m_packet_mutex;
+        
+        friend class socket;
+    };
+    
+    void socket::impl::on(std::string const& event_name,event_listener_aux const& func)
+    {
+        this->on(event_name,event_adapter::do_adapt(func));
+    }
+    
+    void socket::impl::on(std::string const& event_name,event_listener const& func)
+    {
+        std::lock_guard<std::mutex> guard(m_event_mutex);
+        m_event_binding[event_name] = func;
+    }
+    
+    void socket::impl::off(std::string const& event_name)
+    {
+        std::lock_guard<std::mutex> guard(m_event_mutex);
+        auto it = m_event_binding.find(event_name);
+        if(it!=m_event_binding.end())
+        {
+            m_event_binding.erase(it);
+        }
+    }
+    
+    void socket::impl::off_all()
+    {
+        std::lock_guard<std::mutex> guard(m_event_mutex);
+        m_event_binding.clear();
+    }
+    
+    void socket::impl::on_error(error_listener const& l)
+    {
+        m_error_listener = l;
+    }
+    
+    void socket::impl::off_error()
+    {
+        m_error_listener = nullptr;
+    }
+    
+    socket::impl::impl(client_impl *client,std::string const& nsp):
+        m_client(client),
+        m_connected(false),
+        m_nsp(nsp)
+    {
+        NULL_GUARD(client);
+        if(m_client->opened())
+        {
+            send_connect();
+        }
+    }
+    
+    socket::impl::~impl()
+    {
+        
+    }
+    
+    unsigned int socket::impl::s_global_event_id = 1;
+    
+    void socket::impl::emit(std::string const& name, message::list const& msglist, std::function<void (message::list const&)> const& ack)
+    {
+        NULL_GUARD(m_client);
+        message::ptr msg_ptr = msglist.to_array_message(name);
+        int pack_id;
+        if(ack)
+        {
+            pack_id = s_global_event_id++;
+            std::lock_guard<std::mutex> guard(m_event_mutex);
+            m_acks[pack_id] = ack;
+        }
+        else
+        {
+            pack_id = -1;
+        }
+        packet p(m_nsp, msg_ptr,pack_id);
+        send_packet(p);
+    }
+    
+    void socket::impl::send_connect()
+    {
+        NULL_GUARD(m_client);
+        if(m_nsp == "/")
+        {
+            return;
+        }
+        packet p(packet::type_connect,m_nsp);
+        m_client->send(p);
+        m_connection_timer.reset(new boost::asio::deadline_timer(m_client->get_io_service()));
+        boost::system::error_code ec;
+        m_connection_timer->expires_from_now(boost::posix_time::milliseconds(20000), ec);
+        m_connection_timer->async_wait(std::bind(&socket::impl::timeout_connection,this, std::placeholders::_1));
+    }
+    
+    void socket::impl::close()
+    {
+        NULL_GUARD(m_client);
+        if(m_connected)
+        {
+            packet p(packet::type_disconnect,m_nsp);
+            send_packet(p);
+            
+            if(!m_connection_timer)
+            {
+                m_connection_timer.reset(new boost::asio::deadline_timer(m_client->get_io_service()));
+            }
+            boost::system::error_code ec;
+            m_connection_timer->expires_from_now(boost::posix_time::milliseconds(3000), ec);
+            m_connection_timer->async_wait(lib::bind(&socket::impl::on_close, this));
+        }
+    }
+    
+    void socket::impl::on_connected()
+    {
+        if(m_connection_timer)
+        {
+            m_connection_timer->cancel();
+            m_connection_timer.reset();
+        }
+        if(!m_connected)
+        {
+            m_connected = true;
+            m_client->on_socket_opened(m_nsp);
+
+            while (true) {
+				m_packet_mutex.lock();
+				if(m_packet_queue.empty())
+				{
+					m_packet_mutex.unlock();
+					return;
+				}
+				sio::packet front_pack = std::move(m_packet_queue.front());
+                m_packet_queue.pop();
+				m_packet_mutex.unlock();
+				m_client->send(front_pack);
+            }
+        }
+    }
+    
+    void socket::impl::on_close()
+    {
+        NULL_GUARD(m_client);
+        sio::client_impl *client = m_client;
+        m_client = NULL;
+
+        if(m_connection_timer)
+        {
+            m_connection_timer->cancel();
+            m_connection_timer.reset();
+        }
+        m_connected = false;
+		{
+			std::lock_guard<std::mutex> guard(m_packet_mutex);
+			while (!m_packet_queue.empty()) {
+				m_packet_queue.pop();
+			}
+		}
+        client->on_socket_closed(m_nsp);
+        client->remove_socket(m_nsp);
+    }
+    
+    void socket::impl::on_open()
+    {
+        send_connect();
+    }
+    
+    void socket::impl::on_disconnect()
+    {
+        NULL_GUARD(m_client);
+        if(m_connected)
+        {
+            m_connected = false;
+			std::lock_guard<std::mutex> guard(m_packet_mutex);
+            while (!m_packet_queue.empty()) {
+                m_packet_queue.pop();
+            }
+        }
+    }
+    
+    void socket::impl::on_message_packet(packet const& p)
+    {
+        NULL_GUARD(m_client);
+        if(p.get_nsp() == m_nsp)
+        {
+            switch (p.get_type())
+            {
+            // Connect open
+            case packet::type_connect:
+            {
+                LOG("Received Message type (Connect)"<<std::endl);
+
+                this->on_connected();
+                break;
+            }
+            case packet::type_disconnect:
+            {
+                LOG("Received Message type (Disconnect)"<<std::endl);
+                this->on_close();
+                break;
+            }
+            case packet::type_event:
+            case packet::type_binary_event:
+            {
+                LOG("Received Message type (Event)"<<std::endl);
+                const message::ptr ptr = p.get_message();
+                if(ptr->get_flag() == message::flag_array)
+                {
+                    const array_message* array_ptr = static_cast<const array_message*>(ptr.get());
+                    if(array_ptr->get_vector().size() >= 1&&array_ptr->get_vector()[0]->get_flag() == message::flag_string)
+                    {
+                        const string_message* name_ptr = static_cast<const string_message*>(array_ptr->get_vector()[0].get());
+                        message::list mlist;
+                        for(size_t i = 1;i<array_ptr->get_vector().size();++i)
+                        {
+                            mlist.push(array_ptr->get_vector()[i]);
+                        }
+                        this->on_socketio_event(p.get_nsp(), p.get_pack_id(),name_ptr->get_string(), std::move(mlist));
+                    }
+                }
+
+                break;
+            }
+                // Ack
+            case packet::type_ack:
+            case packet::type_binary_ack:
+            {
+                LOG("Received Message type (ACK)"<<std::endl);
+                const message::ptr ptr = p.get_message();
+                if(ptr->get_flag() == message::flag_array)
+                {
+					message::list msglist(ptr->get_vector());
+					this->on_socketio_ack(p.get_pack_id(),msglist);
+                }
+				else
+				{
+					this->on_socketio_ack(p.get_pack_id(),message::list(ptr));
+				}
+                break;
+            }
+                // Error
+            case packet::type_error:
+            {
+                LOG("Received Message type (ERROR)"<<std::endl);
+                this->on_socketio_error(p.get_message());
+                break;
+            }
+            default:
+                break;
+            }
+        }
+    }
+    
+    void socket::impl::on_socketio_event(const std::string& nsp,int msgId,const std::string& name, message::list && message)
+    {
+        bool needAck = msgId >= 0;
+        event ev = event_adapter::create_event(nsp,name, std::move(message),needAck);
+        event_listener func = this->get_bind_listener_locked(name);
+        if(func)func(ev);
+        if(needAck)
+        {
+            this->ack(msgId, name, ev.get_ack_message());
+        }
+    }
+    
+    void socket::impl::ack(int msgId, const string &, const message::list &ack_message)
+    {
+        packet p(m_nsp, ack_message.to_array_message(),msgId,true);
+        send_packet(p);
+    }
+    
+    void socket::impl::on_socketio_ack(int msgId, message::list const& message)
+    {
+        std::function<void (message::list const&)> l;
+        {
+            std::lock_guard<std::mutex> guard(m_event_mutex);
+            auto it = m_acks.find(msgId);
+            if(it!=m_acks.end())
+            {
+                l = it->second;
+                m_acks.erase(it);
+            }
+        }
+        if(l)l(message);
+    }
+    
+    void socket::impl::on_socketio_error(message::ptr const& err_message)
+    {
+        if(m_error_listener)m_error_listener(err_message);
+    }
+    
+    void socket::impl::timeout_connection(const boost::system::error_code &ec)
+    {
+        NULL_GUARD(m_client);
+        if(ec)
+        {
+            return;
+        }
+        m_connection_timer.reset();
+        LOG("Connection timeout,close socket."<<std::endl);
+        //Should close socket if no connected message arrive.Otherwise we'll never ask for open again.
+        this->on_close();
+    }
+    
+    void socket::impl::send_packet(sio::packet &p)
+    {
+        NULL_GUARD(m_client);
+        if(m_connected)
+        {
+            while (true) {
+				m_packet_mutex.lock();
+				if(m_packet_queue.empty())
+				{
+					m_packet_mutex.unlock();
+					break;
+				}
+				sio::packet front_pack = std::move(m_packet_queue.front());
+                m_packet_queue.pop();
+				m_packet_mutex.unlock();
+				m_client->send(front_pack);
+            }
+            m_client->send(p);
+        }
+        else
+        {
+			std::lock_guard<std::mutex> guard(m_packet_mutex);
+            m_packet_queue.push(p);
+        }
+    }
+    
+    socket::event_listener socket::impl::get_bind_listener_locked(const string &event)
+    {
+        std::lock_guard<std::mutex> guard(m_event_mutex);
+        auto it = m_event_binding.find(event);
+        if(it!=m_event_binding.end())
+        {
+            return it->second;
+        }
+        return socket::event_listener();
+    }
+    
+    socket::socket(client_impl* client,std::string const& nsp):
+        m_impl(new impl(client,nsp))
+    {
+    }
+    
+    socket::~socket()
+    {
+        delete m_impl;
+    }
+    
+    void socket::on(std::string const& event_name,event_listener const& func)
+    {
+        m_impl->on(event_name, func);
+    }
+    
+    void socket::on(std::string const& event_name,event_listener_aux const& func)
+    {
+        m_impl->on(event_name, func);
+    }
+    
+    void socket::off(std::string const& event_name)
+    {
+        m_impl->off(event_name);
+    }
+    
+    void socket::off_all()
+    {
+        m_impl->off_all();
+    }
+    
+    void socket::close()
+    {
+        m_impl->close();
+    }
+    
+    void socket::on_error(error_listener const& l)
+    {
+        m_impl->on_error(l);
+    }
+    
+    void socket::off_error()
+    {
+        m_impl->off_error();
+    }
+
+    void socket::emit(std::string const& name, message::list const& msglist, std::function<void (message::list const&)> const& ack)
+    {
+        m_impl->emit(name, msglist,ack);
+    }
+    
+    std::string const& socket::get_namespace() const
+    {
+        return m_impl->get_namespace();
+    }
+    
+    void socket::on_connected()
+    {
+        m_impl->on_connected();
+    }
+    
+    void socket::on_close()
+    {
+        m_impl->on_close();
+    }
+    
+    void socket::on_open()
+    {
+        m_impl->on_open();
+    }
+    
+    void socket::on_message_packet(packet const& p)
+    {
+        m_impl->on_message_packet(p);
+    }
+    
+    void socket::on_disconnect()
+    {
+        m_impl->on_disconnect();
+    }
+}
+
+
+
+
diff --git a/extlibs/socket/sio_socket.h b/extlibs/socket/sio_socket.h
new file mode 100644
index 000000000..69ef1f473
--- /dev/null
+++ b/extlibs/socket/sio_socket.h
@@ -0,0 +1,101 @@
+#ifndef SIO_SOCKET_H
+#define SIO_SOCKET_H
+#include "sio_message.h"
+#include <functional>
+namespace sio
+{
+    class event_adapter;
+    
+    class event
+    {
+    public:
+        const std::string& get_nsp() const;
+        
+        const std::string& get_name() const;
+        
+        const message::ptr& get_message() const;
+
+        const message::list& get_messages() const;
+        
+        bool need_ack() const;
+        
+        void put_ack_message(message::list const& ack_message);
+        
+        message::list const& get_ack_message() const;
+        
+    protected:
+        event(std::string const& nsp,std::string const& name,message::list const& messages,bool need_ack);
+        event(std::string const& nsp,std::string const& name,message::list&& messages,bool need_ack);
+
+        message::list& get_ack_message_impl();
+        
+    private:
+        const std::string m_nsp;
+        const std::string m_name;
+        const message::list m_messages;
+        const bool m_need_ack;
+        message::list m_ack_message;
+        
+        friend class event_adapter;
+    };
+    
+    class client_impl;
+    class packet;
+    
+    //The name 'socket' is taken from concept of official socket.io.
+    class socket
+    {
+    public:
+        typedef std::function<void(const std::string& name,message::ptr const& message,bool need_ack, message::list& ack_message)> event_listener_aux;
+        
+        typedef std::function<void(event& event)> event_listener;
+        
+        typedef std::function<void(message::ptr const& message)> error_listener;
+        
+        typedef std::shared_ptr<socket> ptr;
+        
+        ~socket();
+        
+        void on(std::string const& event_name,event_listener const& func);
+        
+        void on(std::string const& event_name,event_listener_aux const& func);
+        
+        void off(std::string const& event_name);
+        
+        void off_all();
+        
+        void close();
+        
+        void on_error(error_listener const& l);
+        
+        void off_error();
+
+        void emit(std::string const& name, message::list const& msglist = nullptr, std::function<void (message::list const&)> const& ack = nullptr);
+        
+        std::string const& get_namespace() const;
+        
+    protected:
+        socket(client_impl*,std::string const&);
+
+        void on_connected();
+        
+        void on_close();
+        
+        void on_open();
+        
+        void on_disconnect();
+        
+        void on_message_packet(packet const& p);
+        
+        friend class client_impl;
+        
+    private:
+        //disable copy constructor and assign operator.
+        socket(socket const&){}
+        void operator=(socket const&){}
+
+        class impl;
+        impl *m_impl;
+    };
+}
+#endif // SIO_SOCKET_H
diff --git a/extlibs/tinycbor/prep.sh b/extlibs/tinycbor/prep.sh
old mode 100755
new mode 100644
diff --git a/extlibs/websocketpp/.gitattributes b/extlibs/websocketpp/.gitattributes
new file mode 100644
index 000000000..a9e4fc784
--- /dev/null
+++ b/extlibs/websocketpp/.gitattributes
@@ -0,0 +1,18 @@
+# Lineendings
+*.sln       eol=crlf
+*.vcproj    eol=crlf
+*.vcxproj*  eol=crlf
+
+# Whitespace rules
+# strict (no trailing, no tabs)
+*.cpp       whitespace=trailing-space,space-before-tab,tab-in-indent,cr-at-eol
+*.hpp       whitespace=trailing-space,space-before-tab,tab-in-indent,cr-at-eol
+*.c         whitespace=trailing-space,space-before-tab,tab-in-indent,cr-at-eol
+*.h         whitespace=trailing-space,space-before-tab,tab-in-indent,cr-at-eol
+
+# normal (no trailing)
+*.sql       whitespace=trailing-space,space-before-tab,cr-at-eol
+*.txt       whitespace=trailing-space,space-before-tab,cr-at-eol
+
+# special files which must ignore whitespace
+*.patch     whitespace=-trailing-space
diff --git a/extlibs/websocketpp/.gitignore b/extlibs/websocketpp/.gitignore
new file mode 100644
index 000000000..558a1b3d7
--- /dev/null
+++ b/extlibs/websocketpp/.gitignore
@@ -0,0 +1,90 @@
+# make .git* files visible to git
+!.gitignore
+!.gitattributes
+
+.DS_Store
+
+#vim stuff
+*~
+*.swp
+
+*.o
+*.so
+*.so.?
+*.so.?.?.?
+*.a
+*.dylib
+lib/*
+
+# CMake
+*.cmake
+*.dir
+CMakeFiles
+INSTALL.*
+ZERO_CHECK.*
+CMakeCache.txt
+install_manifest.txt
+
+# Windows/Visual Studio
+*.vcproj*
+*.sln
+*.suo
+*.ncb
+*/Debug/*
+*/*/Debug/*
+bin/Debug
+*/Release/*
+*/*/Release/*
+*/RelWithDebInfo/*
+*/*/RelWithDebInfo/*
+
+# explicitly allow this path with /debug/ in it
+!websocketpp/transport/debug/*
+
+objs_shared/
+objs_static/
+
+examples/chat_server/chat_server
+examples/echo_server/echo_server
+examples/chat_client/chat_client
+examples/echo_client/echo_client
+test/basic/tests
+libwebsocketpp.dylib.0.1.0
+
+websocketpp.xcodeproj/xcuserdata/*
+websocketpp.xcodeproj/project.xcworkspace/xcuserdata/*
+policy_based_notes.hpp
+
+examples/echo_server_tls/echo_server_tls
+
+examples/fuzzing_client/fuzzing_client
+
+examples/stress_client/stress_client
+
+examples/broadcast_server_tls/broadcast_server
+
+test/basic/perf
+
+examples/echo_server_tls/echo_server_tls
+
+examples/concurrent_server/concurrent_server
+
+examples/fuzzing_server_tls/fuzzing_server
+
+examples/wsperf/wsperf
+
+.sconsign.dblite
+
+build/
+doxygen/
+examples/wsperf/wsperf_client
+
+*.out
+
+*.log
+*.opensdf
+*.sdf
+*.vcxproj
+*.vcxproj.filters
+*.user
+install
diff --git a/extlibs/websocketpp/.travis.yml b/extlibs/websocketpp/.travis.yml
new file mode 100644
index 000000000..027ac560e
--- /dev/null
+++ b/extlibs/websocketpp/.travis.yml
@@ -0,0 +1,23 @@
+language: cpp
+compiler:
+  - gcc
+before_install:
+ - sudo apt-get install libboost-regex1.48-dev libboost-system1.48-dev libboost-thread1.48-dev libboost-test1.48-dev libboost-random1.48-dev -y
+env:
+  global:
+    - BOOST_INCLUDES=/usr/include
+    - BOOST_LIBS=/usr/lib
+script: scons -j 2 && scons test
+branches:
+  only:
+    - master
+    - permessage-deflate
+    - experimental
+    - 0.3.x-cmake
+    - develop
+notifications:
+  recipients:
+    - travis@zaphoyd.com
+  email:
+    on_success: change
+    on_failure: always
diff --git a/extlibs/websocketpp/CMakeLists.txt b/extlibs/websocketpp/CMakeLists.txt
new file mode 100644
index 000000000..827915602
--- /dev/null
+++ b/extlibs/websocketpp/CMakeLists.txt
@@ -0,0 +1,244 @@
+
+############ Setup project and cmake
+
+# Project name
+project (websocketpp)
+
+# Minimum cmake requirement. We should require a quite recent
+# cmake for the dependency find macros etc. to be up to date.
+cmake_minimum_required (VERSION 2.6)
+
+set (WEBSOCKETPP_MAJOR_VERSION 0)
+set (WEBSOCKETPP_MINOR_VERSION 5)
+set (WEBSOCKETPP_PATCH_VERSION 1)
+set (WEBSOCKETPP_VERSION ${WEBSOCKETPP_MAJOR_VERSION}.${WEBSOCKETPP_MINOR_VERSION}.${WEBSOCKETPP_PATCH_VERSION})
+
+set(INSTALL_INCLUDE_DIR include CACHE PATH "Installation directory for header files")
+if (WIN32 AND NOT CYGWIN)
+  set (DEF_INSTALL_CMAKE_DIR cmake)
+else ()
+  set (DEF_INSTALL_CMAKE_DIR lib/cmake/websocketpp)
+endif ()
+set (INSTALL_CMAKE_DIR ${DEF_INSTALL_CMAKE_DIR} CACHE PATH "Installation directory for CMake files")
+
+# Make relative paths absolute (needed later on)
+foreach (p INCLUDE CMAKE)
+  set (var INSTALL_${p}_DIR)
+  if (NOT IS_ABSOLUTE "${${var}}")
+    set (${var} "${CMAKE_INSTALL_PREFIX}/${${var}}")
+  endif ()
+endforeach ()
+
+# Set CMake library search policy
+if (COMMAND cmake_policy)
+    cmake_policy (SET CMP0003 NEW)
+    cmake_policy (SET CMP0005 NEW)
+endif ()
+
+# Disable unnecessary build types
+set (CMAKE_CONFIGURATION_TYPES "Release;RelWithDebInfo;Debug" CACHE STRING "Configurations" FORCE)
+
+# Include our cmake macros
+set (CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/cmake)
+include (CMakeHelpers)
+
+############ Paths
+
+set (WEBSOCKETPP_ROOT ${CMAKE_CURRENT_SOURCE_DIR})
+set (WEBSOCKETPP_INCLUDE ${WEBSOCKETPP_ROOT}/websocketpp)
+set (WEBSOCKETPP_BUILD_ROOT ${CMAKE_CURRENT_BINARY_DIR})
+set (WEBSOCKETPP_BIN ${WEBSOCKETPP_BUILD_ROOT}/bin)
+set (WEBSOCKETPP_LIB ${WEBSOCKETPP_BUILD_ROOT}/lib)
+
+# CMake install step prefix. I assume linux users want the prefix to
+# be the default /usr or /usr/local so this is only adjusted on Windows.
+# - Windows: Build the INSTALL project in your solution file.
+# - Linux/OSX: make install.
+if (MSVC)
+    set (CMAKE_INSTALL_PREFIX "${WEBSOCKETPP_ROOT}/install")
+endif ()
+
+############  Build customization
+
+# Override from command line "CMake -D<OPTION>=TRUE/FALSE/0/1/ON/OFF"
+option (ENABLE_CPP11 "Build websocketpp with CPP11 features enabled." TRUE)
+option (BUILD_EXAMPLES "Build websocketpp examples." FALSE)
+option (BUILD_TESTS "Build websocketpp tests." FALSE)
+
+if (BUILD_TESTS OR BUILD_EXAMPLES)
+
+    ############ Compiler specific setup
+
+    set (WEBSOCKETPP_PLATFORM_LIBS "")
+    set (WEBSOCKETPP_PLATFORM_TSL_LIBS "")
+    set (WEBSOCKETPP_BOOST_LIBS "")
+
+    # VC9 and C++11 reasoning
+    if (ENABLE_CPP11 AND MSVC AND MSVC90)
+        message("* Detected Visual Studio 9 2008, disabling C++11 support.")
+        set (ENABLE_CPP11 FALSE)
+    endif ()
+
+    # Detect clang. Not officially reported by cmake.
+    execute_process(COMMAND "${CMAKE_CXX_COMPILER}" "-v" ERROR_VARIABLE CXX_VER_STDERR)
+    if ("${CXX_VER_STDERR}" MATCHES ".*clang.*")
+        set (CMAKE_COMPILER_IS_CLANGXX 1)
+    endif ()
+
+    # C++11 defines
+    if (ENABLE_CPP11)
+        if (MSVC)
+            add_definitions (-D_WEBSOCKETPP_CPP11_FUNCTIONAL_)
+            add_definitions (-D_WEBSOCKETPP_CPP11_SYSTEM_ERROR_)
+            add_definitions (-D_WEBSOCKETPP_CPP11_RANDOM_DEVICE_)
+            add_definitions (-D_WEBSOCKETPP_CPP11_MEMORY_)
+        else()
+            add_definitions (-D_WEBSOCKETPP_CPP11_STL_)
+        endif()
+    endif ()
+
+    # Visual studio
+    if (MSVC)
+        set (WEBSOCKETPP_BOOST_LIBS system thread)
+        set (CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /GL /Gy /GF /Ox /Ob2 /Ot /Oi /MP /arch:SSE2 /fp:fast")
+        set (CMAKE_SHARED_LINKER_FLAGS_RELEASE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE} /LTCG /INCREMENTAL:NO /OPT:REF /OPT:ICF")
+        add_definitions (/W3 /wd4996 /wd4995 /wd4355)
+        add_definitions (-DUNICODE -D_UNICODE)
+        add_definitions (-D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS)
+        add_definitions (-DNOMINMAX)
+    endif ()
+
+    # g++
+    if (CMAKE_COMPILER_IS_GNUCXX)
+        set (WEBSOCKETPP_PLATFORM_LIBS pthread rt)
+        set (WEBSOCKETPP_PLATFORM_TSL_LIBS ssl crypto)
+        set (WEBSOCKETPP_BOOST_LIBS system thread)
+        set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x")
+        if (NOT APPLE)
+            add_definitions (-DNDEBUG -Wall -Wcast-align) # todo: should we use CMAKE_C_FLAGS for these?
+        endif ()
+
+        # Try to detect version. Note: Not tested!
+        execute_process (COMMAND ${CMAKE_CXX_COMPILER} "-dumpversion" OUTPUT_VARIABLE GCC_VERSION)
+        if ("${GCC_VERSION}" STRGREATER "4.4.0")
+            message("* C++11 support partially enabled due to GCC version ${GCC_VERSION}")
+            set (WEBSOCKETPP_BOOST_LIBS system thread)
+        endif ()
+    endif ()
+
+    # clang
+    if (CMAKE_COMPILER_IS_CLANGXX)
+        if (NOT APPLE)
+            set (WEBSOCKETPP_PLATFORM_LIBS pthread rt)
+        else()
+            set (WEBSOCKETPP_PLATFORM_LIBS pthread)
+        endif()
+        set (WEBSOCKETPP_PLATFORM_TSL_LIBS ssl crypto)
+        set (WEBSOCKETPP_BOOST_LIBS system thread)
+        set (CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-std=c++0x -stdlib=libc++") # todo: is libc++ really needed here?
+        if (NOT APPLE)
+            add_definitions (-DNDEBUG -Wall -Wno-padded) # todo: should we use CMAKE_C_FLAGS for these?
+        endif ()
+    endif ()
+
+    # OSX, can override above.
+    if (APPLE)
+        add_definitions (-DNDEBUG -Wall)
+    endif ()
+
+    if (BUILD_EXAMPLES)
+        list (APPEND WEBSOCKETPP_BOOST_LIBS random)
+    endif()
+
+    ############ Dependencies
+
+    # Set BOOST_ROOT env variable or pass with cmake -DBOOST_ROOT=path.
+    # BOOST_ROOT can also be defined by a previous run from cmake cache.
+    if (NOT "$ENV{BOOST_ROOT_CPP11}" STREQUAL "")
+        # Scons documentation for BOOST_ROOT_CPP11:
+        # "look for optional second boostroot compiled with clang's libc++ STL library
+        # this prevents warnings/errors when linking code built with two different
+        # incompatible STL libraries."
+        file (TO_CMAKE_PATH "$ENV{BOOST_ROOT_CPP11}" BOOST_ROOT)
+        set (BOOST_ROOT ${BOOST_ROOT} CACHE PATH "BOOST_ROOT dependency path" FORCE)
+    endif ()
+    if ("${BOOST_ROOT}" STREQUAL "")
+        file (TO_CMAKE_PATH "$ENV{BOOST_ROOT}" BOOST_ROOT)
+        # Cache BOOST_ROOT for runs that do not define $ENV{BOOST_ROOT}.
+        set (BOOST_ROOT ${BOOST_ROOT} CACHE PATH "BOOST_ROOT dependency path" FORCE)
+    endif ()
+
+    message ("* Configuring Boost")
+    message (STATUS "-- Using BOOST_ROOT")
+    message (STATUS "       " ${BOOST_ROOT})
+
+    if (MSVC)
+        set (Boost_USE_MULTITHREADED TRUE)
+        set (Boost_USE_STATIC_LIBS TRUE)
+    else ()
+        set (Boost_USE_MULTITHREADED FALSE)
+        set (Boost_USE_STATIC_LIBS FALSE)
+    endif ()
+
+    set (Boost_FIND_REQUIRED TRUE)
+    set (Boost_FIND_QUIETLY TRUE)
+    set (Boost_DEBUG FALSE)
+    set (Boost_USE_MULTITHREADED TRUE)
+    set (Boost_ADDITIONAL_VERSIONS "1.39.0" "1.40.0" "1.41.0" "1.42.0" "1.43.0" "1.44.0" "1.46.1") # todo: someone who knows better spesify these!
+
+    find_package (Boost 1.39.0 COMPONENTS "${WEBSOCKETPP_BOOST_LIBS}")
+
+    if (Boost_FOUND)
+        # Boost is a project wide global dependency.
+        include_directories (${Boost_INCLUDE_DIRS})
+        link_directories (${Boost_LIBRARY_DIRS})
+
+        # Pretty print status
+        message (STATUS "-- Include Directories")
+        foreach (include_dir ${Boost_INCLUDE_DIRS})
+            message (STATUS "       " ${include_dir})
+        endforeach ()
+        message (STATUS "-- Library Directories")
+        foreach (library_dir ${Boost_LIBRARY_DIRS})
+            message (STATUS "       " ${library_dir})
+        endforeach ()
+        message (STATUS "-- Libraries")
+        foreach (boost_lib ${Boost_LIBRARIES})
+            message (STATUS "       " ${boost_lib})
+        endforeach ()
+        message ("")
+    else ()
+        message (FATAL_ERROR "Failed to find required dependency: boost")
+    endif ()
+
+    find_package(OpenSSL)
+endif()
+
+############ Add projects
+
+# Add main library
+add_subdirectory (websocketpp)
+
+# Add examples
+if (BUILD_EXAMPLES)
+    add_subdirectory (examples)
+endif ()
+
+# Add tests
+if (BUILD_TESTS)
+    add_subdirectory (test)
+endif ()
+
+print_used_build_config()
+
+export (PACKAGE websocketpp)
+
+configure_file (websocketpp-config.cmake.in "${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/websocketpp-config.cmake" @ONLY)
+configure_file (websocketpp-configVersion.cmake.in "${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/websocketpp-configVersion.cmake" @ONLY)
+
+# Install the websocketpp-config.cmake and websocketpp-configVersion.cmake
+install (FILES
+  "${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/websocketpp-config.cmake"
+  "${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/websocketpp-configVersion.cmake"
+  DESTINATION "${INSTALL_CMAKE_DIR}" COMPONENT dev)
+
diff --git a/extlibs/websocketpp/COPYING b/extlibs/websocketpp/COPYING
new file mode 100644
index 000000000..f8cc5ba1b
--- /dev/null
+++ b/extlibs/websocketpp/COPYING
@@ -0,0 +1,145 @@
+Main Library:
+
+Copyright (c) 2014, Peter Thorson. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the WebSocket++ Project nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+Bundled Libraries:
+
+****** Base 64 Library (base64/base64.hpp) ******
+base64.hpp is a repackaging of the base64.cpp and base64.h files into a
+single header suitable for use as a header only library. This conversion was
+done by Peter Thorson (webmaster@zaphoyd.com) in 2012. All modifications to
+the code are redistributed under the same license as the original, which is
+listed below.
+
+base64.cpp and base64.h
+
+Copyright (C) 2004-2008 René Nyffenegger
+
+This source code is provided 'as-is', without any express or implied
+warranty. In no event will the author be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+1. The origin of this source code must not be misrepresented; you must not
+  claim that you wrote the original source code. If you use this source code
+  in a product, an acknowledgment in the product documentation would be
+  appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and must not be
+  misrepresented as being the original source code.
+
+3. This notice may not be removed or altered from any source distribution.
+
+René Nyffenegger rene.nyffenegger@adp-gmbh.ch
+
+****** SHA1 Library (sha1/sha1.hpp) ******
+sha1.hpp is a repackaging of the sha1.cpp and sha1.h files from the shallsha1
+library (http://code.google.com/p/smallsha1/) into a single header suitable for
+use as a header only library. This conversion was done by Peter Thorson
+(webmaster@zaphoyd.com) in 2013. All modifications to the code are redistributed
+under the same license as the original, which is listed below.
+
+ Copyright (c) 2011, Micael Hildenborg
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Micael Hildenborg nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY Micael Hildenborg ''AS IS'' AND ANY
+ EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ DISCLAIMED. IN NO EVENT SHALL Micael Hildenborg BE LIABLE FOR ANY
+ DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+****** MD5 Library (common/md5.hpp) ******
+md5.hpp is a reformulation of the md5.h and md5.c code from
+http://www.opensource.apple.com/source/cups/cups-59/cups/md5.c to allow it to
+function as a component of a header only library. This conversion was done by
+Peter Thorson (webmaster@zaphoyd.com) in 2012 for the WebSocket++ project. The
+changes are released under the same license as the original (listed below)
+
+Copyright (C) 1999, 2002 Aladdin Enterprises.  All rights reserved.
+
+This software is provided 'as-is', without any express or implied
+warranty.  In no event will the authors be held liable for any damages
+arising from the use of this software.
+
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it
+freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must not
+ claim that you wrote the original software. If you use this software
+ in a product, an acknowledgment in the product documentation would be
+ appreciated but is not required.
+2. Altered source versions must be plainly marked as such, and must not be
+ misrepresented as being the original software.
+3. This notice may not be removed or altered from any source distribution.
+
+L. Peter Deutsch
+ghost@aladdin.com
+
+****** UTF8 Validation logic (utf8_validation.hpp) ******
+utf8_validation.hpp is adapted from code originally written by Bjoern Hoehrmann
+<bjoern@hoehrmann.de>. See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for
+details.
+
+The original license:
+
+Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/extlibs/websocketpp/Doxyfile b/extlibs/websocketpp/Doxyfile
new file mode 100644
index 000000000..ff9724267
--- /dev/null
+++ b/extlibs/websocketpp/Doxyfile
@@ -0,0 +1,1874 @@
+# Doxyfile 1.8.3.1
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a hash (#) is considered a comment and will be ignored.
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the
+# iconv built into libc) for the transcoding. See
+# http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or sequence of words) that should
+# identify the project. Note that if you do not use Doxywizard you need
+# to put quotes around the project name if it contains spaces.
+
+PROJECT_NAME           = "websocketpp"
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number.
+# This could be handy for archiving the generated documentation or
+# if some version control system is used.
+
+
+PROJECT_NUMBER         = "0.5.1"
+
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer
+# a quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          = "C++/Boost Asio based websocket client/server library"
+
+# With the PROJECT_LOGO tag one can specify an logo or icon that is
+# included in the documentation. The maximum height of the logo should not
+# exceed 55 pixels and the maximum width should not exceed 200 pixels.
+# Doxygen will copy the logo to the output directory.
+
+PROJECT_LOGO           =
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
+# base path where the generated documentation will be put.
+# If a relative path is entered, it will be relative to the location
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = "doxygen"
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
+# 4096 sub-directories (in 2 levels) under the output directory of each output
+# format and will distribute the generated files over these directories.
+# Enabling this option can be useful when feeding doxygen a huge amount of
+# source files, where putting all generated files in the same directory would
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# The default language is English, other supported languages are:
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
+# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German,
+# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
+# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,
+# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak,
+# Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
+# include brief member descriptions after the members that are listed in
+# the file and class documentation (similar to JavaDoc).
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
+# the brief description of a member or function before the detailed description.
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator
+# that is used to form the text in various listings. Each string
+# in this list, if found as the leading text of the brief description, will be
+# stripped from the text and the result after processing the whole list, is
+# used as the annotated text. Otherwise, the brief description is used as-is.
+# If left blank, the following values are used ("$name" is automatically
+# replaced with the name of the entity): "The $name class" "The $name widget"
+# "The $name file" "is" "provides" "specifies" "contains"
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       =
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# Doxygen will generate a detailed section even if there is only a brief
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
+# path before files name in the file list and in the header files. If set
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = YES
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
+# can be used to strip a user-defined part of the path. Stripping is
+# only done if one of the specified strings matches the left-hand part of
+# the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the
+# path to strip. Note that you specify absolute paths here, but also
+# relative paths, which will be relative from the directory where doxygen is
+# started.
+
+STRIP_FROM_PATH        =
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
+# the path mentioned in the documentation of a class, which tells
+# the reader which header file to include in order to use a class.
+# If left blank only the name of the header file containing the class
+# definition is used. Otherwise one should specify the include paths that
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
+# (but less readable) file names. This can be useful if your file system
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
+# will interpret the first line (until the first dot) of a JavaDoc-style
+# comment as the brief description. If set to NO, the JavaDoc
+# comments will behave just like regular Qt-style comments
+# (thus requiring an explicit @brief command for a brief description.)
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will
+# interpret the first line (until the first dot) of a Qt-style
+# comment as the brief description. If set to NO, the comments
+# will behave just like regular Qt-style comments (thus requiring
+# an explicit \brief command for a brief description.)
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
+# treat a multi-line C++ special comment block (i.e. a block of //! or ///
+# comments) as a brief description. This used to be the default behaviour.
+# The new default is to treat a multi-line C++ comment block as a detailed
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
+# member inherits the documentation from any documented member that it
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
+# a new page for each member. If set to NO, the documentation of a member will
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab.
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that acts
+# as commands in the documentation. An alias has the form "name=value".
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to
+# put the command \sideeffect (or @sideeffect) in the documentation, which
+# will result in a user-defined paragraph with heading "Side Effects:".
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                =
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding
+# "class=itcl::class" will allow you to use the command class in the
+# itcl::class meaning.
+
+TCL_SUBST              =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
+# sources only. Doxygen will then generate output that is more tailored for C.
+# For instance, some of the names that are used will be different. The list
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
+# sources only. Doxygen will then generate output that is more tailored for
+# Java. For instance, namespaces will be presented as packages, qualified
+# scopes will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources only. Doxygen will then generate output that is more tailored for
+# Fortran.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for
+# VHDL.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension,
+# and language is one of the parsers supported by doxygen: IDL, Java,
+# Javascript, CSharp, C, C++, D, PHP, Objective-C, Python, Fortran, VHDL, C,
+# C++. For instance to make doxygen treat .inc files as Fortran files (default
+# is PHP), and .f files as C (default is Fortran), use: inc=Fortran f=C. Note
+# that for custom extensions you also need to set FILE_PATTERNS otherwise the
+# files are not read by doxygen.
+
+EXTENSION_MAPPING      =
+
+# If MARKDOWN_SUPPORT is enabled (the default) then doxygen pre-processes all
+# comments according to the Markdown format, which allows for more readable
+# documentation. See http://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you
+# can mix doxygen, HTML, and XML commands with Markdown formatting.
+# Disable only in case of backward compatibilities issues.
+
+MARKDOWN_SUPPORT       = YES
+
+# When enabled doxygen tries to link words that correspond to documented classes,
+# or namespaces to their corresponding documentation. Such a link can be
+# prevented in individual cases by by putting a % sign in front of the word or
+# globally by setting AUTOLINK_SUPPORT to NO.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should
+# set this tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
+# func(std::string) {}). This also makes the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = YES
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
+# Doxygen will parse them like normal C++ but will assume all classes use public
+# instead of private inheritance when no explicit protection keyword is present.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES (the
+# default) will make doxygen replace the get and set methods by a property in
+# the documentation. This will only work if the methods are indeed getting or
+# setting a simple type. If this is not the case, or you want to show the
+# methods anyway, you should set this option to NO.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES, then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of
+# the same type (for instance a group of public functions) to be put as a
+# subgroup of that type (e.g. under the Public Functions section). Set it to
+# NO to prevent subgrouping. Alternatively, this can be done per class using
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and
+# unions are shown inside the group in which they are included (e.g. using
+# @ingroup) instead of on a separate page (for HTML and Man pages) or
+# section (for LaTeX and RTF).
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and
+# unions with only public data fields will be shown inline in the documentation
+# of the scope in which they are defined (i.e. file, namespace, or group
+# documentation), provided this scope is documented. If set to NO (the default),
+# structs, classes, and unions are shown on a separate page (for HTML and Man
+# pages) or section (for LaTeX and RTF).
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
+# is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically
+# be useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to
+# determine which symbols to keep in memory and which to flush to disk.
+# When the cache is full, less often used symbols will be written to disk.
+# For small to medium size projects (<1000 input files) the default value is
+# probably good enough. For larger projects a too small cache size can cause
+# doxygen to be busy swapping symbols to and from disk most of the time
+# causing a significant performance penalty.
+# If the system has enough physical memory increasing the cache will improve the
+# performance by keeping more symbols in memory. Note that the value works on
+# a logarithmic scale so increasing the size by one will roughly double the
+# memory usage. The cache size is given by this formula:
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,
+# corresponding to a cache size of 2^16 = 65536 symbols.
+
+SYMBOL_CACHE_SIZE      = 0
+
+# Similar to the SYMBOL_CACHE_SIZE the size of the symbol lookup cache can be
+# set using LOOKUP_CACHE_SIZE. This cache is used to resolve symbols given
+# their name and scope. Since this can be an expensive process and often the
+# same symbol appear multiple times in the code, doxygen keeps a cache of
+# pre-resolved symbols. If the cache is too small doxygen will become slower.
+# If the cache is too large, memory is wasted. The cache size is given by this
+# formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range is 0..9, the default is 0,
+# corresponding to a cache size of 2^16 = 65536 symbols.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
+# documentation are documented, even if no documentation was available.
+# Private class members and static file members will be hidden unless
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES all members with package or internal
+# scope will be included in the documentation.
+
+EXTRACT_PACKAGE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file
+# will be included in the documentation.
+
+EXTRACT_STATIC         = YES
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
+# defined locally in source files will be included in the documentation.
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local
+# methods, which are defined in the implementation section but not in
+# the interface are included in the documentation.
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base
+# name of the file that contains the anonymous namespace. By default
+# anonymous namespaces are hidden.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
+# undocumented members of documented classes, files or namespaces.
+# If set to NO (the default) these members will be included in the
+# various overviews, but no documentation section is generated.
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy.
+# If set to NO (the default) these classes will be included in the various
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
+# friend (class|struct|union) declarations.
+# If set to NO (the default) these declarations will be included in the
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
+# documentation blocks found inside the body of a function.
+# If set to NO (the default) these blocks will be appended to the
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation
+# that is typed after a \internal command is included. If the tag is set
+# to NO (the default) then the documentation will be excluded.
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
+# file names in lower-case letters. If set to YES upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = NO
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
+# will show members with their full class and namespace scopes in the
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
+# will put a list of the files that are included by a file in the documentation
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen
+# will list include files with double quotes in the documentation
+# rather than with sharp brackets.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
+# will sort the (detailed) documentation of file and class members
+# alphabetically by member name. If set to NO the members will appear in
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
+# brief documentation of file, namespace and class members alphabetically
+# by member name. If set to NO (the default) the members will appear in
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen
+# will sort the (brief and detailed) documentation of class members so that
+# constructors and destructors are listed first. If set to NO (the default)
+# the constructors will appear in the respective orders defined by
+# SORT_MEMBER_DOCS and SORT_BRIEF_DOCS.
+# This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO
+# and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
+# hierarchy of group names into alphabetical order. If set to NO (the default)
+# the group names will appear in their defined order.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
+# sorted by fully-qualified names, including namespaces. If set to
+# NO (the default), the class list will be sorted only by class name,
+# not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to
+# do proper type resolution of all parameters of a function it will reject a
+# match between the prototype and the implementation of a member function even
+# if there is only one candidate or it is obvious which candidate to choose
+# by doing a simple string match. By disabling STRICT_PROTO_MATCHING doxygen
+# will still accept a match between prototype and implementation in such cases.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or
+# disable (NO) the todo list. This list is created by putting \todo
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or
+# disable (NO) the test list. This list is created by putting \test
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or
+# disable (NO) the bug list. This list is created by putting \bug
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
+# disable (NO) the deprecated list. This list is created by putting
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional
+# documentation sections, marked by \if section-label ... \endif
+# and \cond section-label ... \endcond blocks.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines
+# the initial value of a variable or macro consists of for it to appear in
+# the documentation. If the initializer consists of more lines than specified
+# here it will be hidden. Use a value of 0 to hide initializers completely.
+# The appearance of the initializer of individual variables and macros in the
+# documentation can be controlled using \showinitializer or \hideinitializer
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated
+# at the bottom of the documentation of classes and structs. If set to YES the
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page.
+# This will remove the Files entry from the Quick Index and from the
+# Folder Tree View (if specified). The default is YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the
+# Namespaces page.
+# This will remove the Namespaces entry from the Quick Index
+# and from the Folder Tree View (if specified). The default is YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command <command> <input-file>, where <command> is the value of
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
+# provided by doxygen. Whatever the program writes to standard output
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option.
+# You can optionally specify a file name after the option, if omitted
+# DoxygenLayout.xml will be used as the name of the layout file.
+
+LAYOUT_FILE            =
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files
+# containing the references data. This must be a list of .bib files. The
+# .bib extension is automatically appended if omitted. Using this command
+# requires the bibtex tool to be installed. See also
+# http://en.wikipedia.org/wiki/BibTeX for more info. For LaTeX the style
+# of the bibliography can be controlled using LATEX_BIB_STYLE. To use this
+# feature you need bibtex and perl available in the search path. Do not use
+# file names with spaces, bibtex cannot handle them.
+
+CITE_BIB_FILES         =
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated by doxygen. Possible values are YES and NO. If left blank
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some
+# parameters in a documented function, or documenting parameters that
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# The WARN_NO_PARAMDOC option can be enabled to get warnings for
+# functions that are documented, but have no documentation for their parameters
+# or return value. If set to NO (the default) doxygen will only warn about
+# wrong or incomplete parameter documentation, but not about the absence of
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that
+# doxygen can produce. The string should contain the $file, $line, and $text
+# tags, which will be replaced by the file and line number from which the
+# warning originated and the warning text. Optionally the format may contain
+# $version, which will be replaced by the version of the file (if it could
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning
+# and error messages should be written. If left blank the output is written
+# to stderr.
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain
+# documented source files. You may enter file names like "myfile.cpp" or
+# directories like "/usr/src/myproject". Separate the files or directories
+# with spaces.
+
+INPUT                  = websocketpp \
+                         readme.md \
+                         changelog.md \
+                         roadmap.md
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
+# also the default input encoding. Doxygen uses libiconv (or the iconv built
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
+# the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
+# and *.h) to filter out the source-files in the directories. If left
+# blank the following patterns are tested:
+# *.c *.cc *.cxx *.cpp *.c++ *.d *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh
+# *.hxx *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.dox *.py
+# *.f90 *.f *.for *.vhd *.vhdl
+
+FILE_PATTERNS          =
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories
+# should be searched for input files as well. Possible values are YES and NO.
+# If left blank NO is used.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                = build
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories. Note that the wildcards are matched
+# against the file with absolute path, so to exclude all test directories
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or
+# directories that contain example code fragments that are included (see
+# the \include command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
+# and *.h) to filter out the source-files in the directories. If left
+# blank all files are included.
+
+EXAMPLE_PATTERNS       =
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude
+# commands irrespective of the value of the RECURSIVE tag.
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or
+# directories that contain image that are included in the documentation (see
+# the \image command).
+
+IMAGE_PATH             =
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command <filter> <input-file>, where <filter>
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
+# input file. Doxygen will then use the output that the filter program writes
+# to standard output.
+# If FILTER_PATTERNS is specified, this tag will be
+# ignored.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis.
+# Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match.
+# The filters are a list of the form:
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
+# info on how filters are used. If FILTER_PATTERNS is empty or if
+# non of the patterns match the file name, INPUT_FILTER is applied.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will be used to filter the input files when producing source
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any)
+# and it is also possible to disable source filtering for a specific pattern
+# using *.ext= (so without naming a filter). This option only has effect when
+# FILTER_SOURCE_FILES is enabled.
+
+FILTER_SOURCE_PATTERNS =
+
+# If the USE_MD_FILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page (index.html).
+# This can be useful if you have a project on for instance GitHub and want reuse
+# the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE =
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will
+# be generated. Documented entities will be cross-referenced with these sources.
+# Note: To get rid of all source code in the generated output, make sure also
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
+# doxygen to hide any special comment blocks from generated source code
+# fragments. Normal C, C++ and Fortran comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES
+# then for each documented function all documented
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES
+# then for each documented function all documented entities
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
+# link to the source code.
+# Otherwise they will link to the documentation.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code
+# will point to the HTML generated by the htags(1) tool instead of doxygen
+# built-in source browser. The htags tool is part of GNU's global source
+# tagging system (see http://www.gnu.org/software/global/global.html). You
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
+# will generate a verbatim copy of the header file for each class for
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
+# of all compounds will be generated. Enable this if the project
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = YES
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all
+# classes will be put under the same header in the alphabetical index.
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for
+# each generated HTML page. If it is left blank doxygen will generate a
+# standard header. Note that when using a custom header you are responsible
+#  for the proper inclusion of any scripts and style sheets that doxygen
+# needs, which is dependent on the configuration options used.
+# It is advised to generate a default header using "doxygen -w html
+# header.html footer.html stylesheet.css YourConfigFile" and then modify
+# that header. Note that the header is subject to change so you typically
+# have to redo this when upgrading to a newer version of doxygen or when
+# changing the value of configuration settings such as GENERATE_TREEVIEW!
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for
+# each generated HTML page. If it is left blank doxygen will generate a
+# standard footer.
+
+HTML_FOOTER            =
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
+# style sheet that is used by each HTML page. It can be used to
+# fine-tune the look of the HTML output. If left blank doxygen will
+# generate a default style sheet. Note that it is recommended to use
+# HTML_EXTRA_STYLESHEET instead of this one, as it is more robust and this
+# tag will in the future become obsolete.
+
+HTML_STYLESHEET        =
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify an additional
+# user-defined cascading style sheet that is included after the standard
+# style sheets created by doxygen. Using this option one can overrule
+# certain style aspects. This is preferred over using HTML_STYLESHEET
+# since it does not replace the standard style sheet and is therefor more
+# robust against future updates. Doxygen will copy the style sheet file to
+# the output directory.
+
+HTML_EXTRA_STYLESHEET  =
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath$ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that
+# the files will be copied as-is; there are no commands or markers available.
+
+HTML_EXTRA_FILES       =
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output.
+# Doxygen will adjust the colors in the style sheet and background images
+# according to this color. Hue is specified as an angle on a colorwheel,
+# see http://en.wikipedia.org/wiki/Hue for more information.
+# For instance the value 0 represents red, 60 is yellow, 120 is green,
+# 180 is cyan, 240 is blue, 300 purple, and 360 is red again.
+# The allowed range is 0 to 359.
+
+HTML_COLORSTYLE_HUE    = 236
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of
+# the colors in the HTML output. For a value of 0 the output will use
+# grayscales only. A value of 255 will produce the most vivid colors.
+
+HTML_COLORSTYLE_SAT    = 0
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to
+# the luminance component of the colors in the HTML output. Values below
+# 100 gradually make the output lighter, whereas values above 100 make
+# the output darker. The value divided by 100 is the actual gamma applied,
+# so 80 represents a gamma of 0.8, The value 220 represents a gamma of 2.2,
+# and 100 does not change the gamma.
+
+HTML_COLORSTYLE_GAMMA  = 148
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting
+# this to NO can help when comparing the output of multiple runs.
+
+HTML_TIMESTAMP         = NO
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of
+# entries shown in the various tree structured indices initially; the user
+# can expand and collapse entries dynamically later on. Doxygen will expand
+# the tree to such a level that at most the specified number of entries are
+# visible (unless a fully collapsed tree already exceeds this amount).
+# So setting the number of entries 1 will produce a full collapsed tree by
+# default. 0 is a special value representing an infinite number of entries
+# and will result in a full expanded tree by default.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files
+# will be generated that can be used as input for Apple's Xcode 3
+# integrated development environment, introduced with OSX 10.5 (Leopard).
+# To create a documentation set, doxygen will generate a Makefile in the
+# HTML output directory. Running make will produce the docset in that
+# directory and running "make install" will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
+# it at startup.
+# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
+# for more information.
+
+GENERATE_DOCSET        = NO
+
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
+# feed. A documentation feed provides an umbrella under which multiple
+# documentation sets from a single provider (such as a company or product suite)
+# can be grouped.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
+# should uniquely identify the documentation set bundle. This should be a
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
+# will append .docset to the name.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# When GENERATE_PUBLISHER_ID tag specifies a string that should uniquely
+# identify the documentation publisher. This should be a reverse domain-name
+# style string, e.g. com.mycompany.MyDocSet.documentation.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The GENERATE_PUBLISHER_NAME tag identifies the documentation publisher.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files
+# will be generated that can be used as input for tools like the
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm)
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
+# be used to specify the file name of the resulting .chm file. You
+# can add a path in front of the file if the result should not be
+# written to the html output directory.
+
+CHM_FILE               =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
+# be used to specify the location (absolute path including file name) of
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
+# controls if a separate .chi index file is generated (YES) or that
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file
+# content.
+
+CHM_INDEX_ENCODING     =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
+# controls whether a binary table of contents is generated (YES) or a
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated
+# that can be used as input for Qt's qhelpgenerator to generate a
+# Qt Compressed Help (.qch) of the generated HTML documentation.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can
+# be used to specify the file name of the resulting .qch file.
+# The path specified is relative to the HTML output folder.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating
+# Qt Help Project output. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#namespace
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating
+# Qt Help Project output. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#virtual-folders
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to
+# add. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#custom-filters
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see
+# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">
+# Qt Help Project / Custom Filters</a>.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's
+# filter section matches.
+# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">
+# Qt Help Project / Filter Attributes</a>.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can
+# be used to specify the location of Qt's qhelpgenerator.
+# If non-empty doxygen will try to run qhelpgenerator on the generated
+# .qhp file.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files
+#  will be generated, which together with the HTML files, form an Eclipse help
+# plugin. To install this plugin and make it available under the help contents
+# menu in Eclipse, the contents of the directory containing the HTML and XML
+# files needs to be copied into the plugins directory of eclipse. The name of
+# the directory within the plugins directory should be the same as
+# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before
+# the help appears.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have
+# this name.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs)
+# at top of each HTML page. The value NO (the default) enables the index and
+# the value YES disables it. Since the tabs have the same information as the
+# navigation tree you can set this option to NO if you already set
+# GENERATE_TREEVIEW to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information.
+# If the tag value is set to YES, a side panel will be generated
+# containing a tree-like index structure (just like the one that
+# is generated for HTML Help). For this to work a browser that supports
+# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser).
+# Windows users are probably better off using the HTML help feature.
+# Since the tree basically has the same information as the tab index you
+# could consider to set DISABLE_INDEX to NO when enabling this option.
+
+GENERATE_TREEVIEW      = NO
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values
+# (range [0,1..20]) that doxygen will group on one line in the generated HTML
+# documentation. Note that a value of 0 will completely suppress the enum
+# values from appearing in the overview section.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
+# used to set the initial width (in pixels) of the frame in which the tree
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open
+# links to external symbols imported via tag files in a separate window.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of Latex formulas included
+# as images in the HTML documentation. The default is 10. Note that
+# when you change the font size after a successful doxygen run you need
+# to manually remove any form_*.png images from the HTML output directory
+# to force them to be regenerated.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are
+# not supported properly for IE 6.0, but are supported on all modern browsers.
+# Note that when changing this option you need to delete any form_*.png files
+# in the HTML output before the changes have effect.
+
+FORMULA_TRANSPARENT    = YES
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax
+# (see http://www.mathjax.org) which uses client side Javascript for the
+# rendering instead of using prerendered bitmaps. Use this if you do not
+# have LaTeX installed or if you want to formulas look prettier in the HTML
+# output. When enabled you may also need to install MathJax separately and
+# configure the path to it using the MATHJAX_RELPATH option.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# thA MathJax output. Supported types are HTML-CSS, NativeMML (i.e. MathML) and
+# SVG. The default value is HTML-CSS, which is slower, but has the best
+# compatibility.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the
+# HTML output directory using the MATHJAX_RELPATH option. The destination
+# directory should contain the MathJax.js script. For instance, if the mathjax
+# directory is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to
+# the MathJax Content Delivery Network so you can quickly see the result without
+# installing MathJax.
+# However, it is strongly recommended to install a local
+# copy of MathJax from http://www.mathjax.org before deployment.
+
+MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or MathJax extension
+# names that should be enabled during MathJax rendering.
+
+MATHJAX_EXTENSIONS     =
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box
+# for the HTML output. The underlying search engine uses javascript
+# and DHTML and should work on any modern browser. Note that when using
+# HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets
+# (GENERATE_DOCSET) there is already a search function so this one should
+# typically be disabled. For large projects the javascript based search engine
+# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using Javascript.
+# There are two flavours of web server based search depending on the
+# EXTERNAL_SEARCH setting. When disabled, doxygen will generate a PHP script for
+# searching and an index file used by the script. When EXTERNAL_SEARCH is
+# enabled the indexing and searching needs to be provided by external tools.
+# See the manual for details.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain
+# the search results. Doxygen ships with an example indexer (doxyindexer) and
+# search engine (doxysearch.cgi) which are based on the open source search engine
+# library Xapian. See the manual for configuration details.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will returned the search results when EXTERNAL_SEARCH is enabled.
+# Doxygen ships with an example search engine (doxysearch) which is based on
+# the open source search engine library Xapian. See the manual for configuration
+# details.
+
+SEARCHENGINE_URL       =
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH AND EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+
+EXTERNAL_SEARCH_ID     =
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id
+# of to a relative location where the documentation can be found.
+# The format is: EXTRA_SEARCH_MAPPINGS = id1=loc1 id2=loc2 ...
+
+EXTRA_SEARCH_MAPPINGS  =
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
+# generate Latex output.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked. If left blank `latex' will be used as the default command name.
+# Note that when enabling USE_PDFLATEX this option is only used for
+# generating bitmaps for formulas in the HTML output, but not in the
+# Makefile that is written to the output directory.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
+# generate index for LaTeX. If left blank `makeindex' will be used as the
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
+# LaTeX documents. This may be useful for small projects and may help to
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used
+# by the printer. Possible values are: a4, letter, legal and
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for
+# the generated latex document. The header should contain everything until
+# the first chapter. If it is left blank doxygen will generate a
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           =
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for
+# the generated latex document. The footer should contain everything after
+# the last chapter. If it is left blank doxygen will generate a
+# standard footer. Notice: only use this tag if you know what you are doing!
+
+LATEX_FOOTER           =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will
+# contain links (just like the HTML output) instead of page references
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
+# plain latex in the generated Makefile. Set this option to YES to get a
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
+# command to the generated LaTeX files. This will instruct LaTeX to keep
+# running if errors occur, instead of asking the user for help.
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not
+# include the index chapters (such as File Index, Compound Index, etc.)
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+# If LATEX_SOURCE_CODE is set to YES then doxygen will include
+# source code with syntax highlighting in the LaTeX output.
+# Note that which sources are shown also depends on other settings
+# such as SOURCE_BROWSER.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. The default style is "plain". See
+# http://en.wikipedia.org/wiki/BibTeX for more info.
+
+LATEX_BIB_STYLE        = plain
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
+# The RTF output is optimized for Word 97 and may not look very pretty with
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact
+# RTF documents. This may be useful for small projects and may help to
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
+# will contain hyperlink fields. The RTF file will
+# contain links (just like the HTML output) instead of page references.
+# This makes the output suitable for online browsing using WORD or other
+# programs which support those fields.
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load style sheet definitions from file. Syntax is similar to doxygen's
+# config file, i.e. a series of assignments. You only have to provide
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an rtf document.
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    =
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output,
+# then it will generate one additional man file for each entity
+# documented in the real man page(s). These additional files
+# only source the real man page, but without them the man command
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will
+# generate an XML file that captures the structure of
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema,
+# which can be used by a validating XML parser to check the
+# syntax of the XML files.
+
+XML_SCHEMA             =
+
+# The XML_DTD tag can be used to specify an XML DTD,
+# which can be used by a validating XML parser to check the
+# syntax of the XML files.
+
+XML_DTD                =
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will
+# dump the program listings (including syntax highlighting
+# and cross-referencing information) to the XML output. Note that
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
+# generate an AutoGen Definitions (see autogen.sf.net) file
+# that captures the structure of the code including all
+# documentation. Note that this feature is still experimental
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will
+# generate a Perl module file that captures the structure of
+# the code including all documentation. Note that this
+# feature is still experimental and incomplete at the
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
+# nicely formatted so it can be parsed by a human reader.
+# This is useful
+# if you want to understand what is going on.
+# On the other hand, if this
+# tag is set to NO the size of the Perl module output will be much smaller
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
+# This is useful so different doxyrules.make files included by the same
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
+# evaluate all C-preprocessor directives found in the sources and include
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
+# names in the source code. If set to NO (the default) only conditional
+# compilation will be performed. Macro expansion can be done in a controlled
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
+# then the macro expansion is limited to the macros specified with the
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
+# pointed to by INCLUDE_PATH will be searched when a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by
+# the preprocessor.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will
+# be used.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that
+# are defined before the preprocessor is started (similar to the -D option of
+# gcc). The argument of the tag is a list of macros of the form: name
+# or name=definition (no spaces). If the definition and the = are
+# omitted =1 is assumed. To prevent a macro definition from being
+# undefined via #undef or recursively expanded use the := operator
+# instead of the = operator.
+
+PREDEFINED             =
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
+# this tag can be used to specify a list of macro names that should be expanded.
+# The macro definition that is found in the sources will be used.
+# Use the PREDEFINED tag if you want to use a different macro definition that
+# overrules the definition found in the source code.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
+# doxygen's preprocessor will remove all references to function-like macros
+# that are alone on a line, have an all uppercase name, and do not end with a
+# semicolon, because these will confuse the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. For each
+# tag file the location of the external documentation should be added. The
+# format of a tag file without this location is as follows:
+#
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+#
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where "loc1" and "loc2" can be relative or absolute paths
+# or URLs. Note that each tag file must have a unique name (where the name does
+# NOT include the path). If a tag file is not located in the directory in which
+# doxygen is run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed
+# in the class index. If set to NO only the inherited external classes
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
+# or super classes. Setting the tag to NO turns the diagrams off. Note that
+# this option also works with HAVE_DOT disabled, but it is recommended to
+# install and use dot, since it yields more powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            =
+
+# If set to YES, the inheritance and collaboration graphs will hide
+# inheritance and usage relations if the target is undocumented
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz, a graph visualization
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = NO
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is
+# allowed to run in parallel. When set to 0 (the default) doxygen will
+# base this on the number of processors available in the system. You can set it
+# explicitly to a value larger than 0 to get control over the balance
+# between CPU load and processing speed.
+
+DOT_NUM_THREADS        = 0
+
+# By default doxygen will use the Helvetica font for all dot files that
+# doxygen generates. When you want a differently looking font you can specify
+# the font name using DOT_FONTNAME. You need to make sure dot is able to find
+# the font, which can be done by putting it in a standard location or by setting
+# the DOTFONTPATH environment variable or by setting DOT_FONTPATH to the
+# directory containing the font.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.
+# The default size is 10pt.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the Helvetica font.
+# If you specify a different font using DOT_FONTNAME you can use DOT_FONTPATH to
+# set the path where dot can find it.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for each documented class showing the direct and
+# indirect inheritance relations. Setting this tag to YES will force the
+# CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for each documented class showing the direct and
+# indirect implementation dependencies (inheritance, containment, and
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside
+# the class node. If there are many fields or methods and many nodes the
+# graph may become too big to be useful. The UML_LIMIT_NUM_FIELDS
+# threshold limits the number of items for each type to make the size more
+# managable. Set this to 0 for no limit. Note that the threshold may be
+# exceeded by 50% before the limit is enforced.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If set to YES, the inheritance and collaboration graphs will show the
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
+# tags are set to YES then doxygen will generate a graph for each documented
+# file showing the direct and indirect include dependencies of the file with
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each
+# documented header file showing the documented files that directly or
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then
+# doxygen will generate a call dependency graph for every global function
+# or class method. Note that enabling this option will significantly increase
+# the time of a run. So in most cases it will be better to enable call graphs
+# for selected functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
+# doxygen will generate a caller dependency graph for every global function
+# or class method. Note that enabling this option will significantly increase
+# the time of a run. So in most cases it will be better to enable caller
+# graphs for selected functions only using the \callergraph command.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
+# will generate a graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH and HAVE_DOT tags are set to YES
+# then doxygen will show the dependencies a directory has on other directories
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. Possible values are svg, png, jpg, or gif.
+# If left blank png will be used. If you choose svg you need to set
+# HTML_FILE_EXTENSION to xhtml in order to make the SVG files
+# visible in IE 9+ (other browsers do not have this requirement).
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+# Note that this requires a modern browser other than Internet Explorer.
+# Tested and working are Firefox, Chrome, Safari, and Opera. For IE 9+ you
+# need to set HTML_FILE_EXTENSION to xhtml in order to make the SVG files
+# visible. Older versions of IE do not have SVG support.
+
+INTERACTIVE_SVG        = NO
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               =
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the
+# \dotfile command).
+
+DOTFILE_DIRS           =
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the
+# \mscfile command).
+
+MSCFILE_DIRS           =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of
+# nodes that will be shown in the graph. If the number of nodes in a graph
+# becomes larger than this value, doxygen will truncate the graph, which is
+# visualized by representing a node as a red box. Note that doxygen if the
+# number of direct children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
+# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
+# graphs generated by dot. A depth value of 3 means that only nodes reachable
+# from the root by following a path via at most 3 edges will be shown. Nodes
+# that lay further from the root node will be omitted. Note that setting this
+# option to 1 or 2 may greatly reduce the computation time needed for large
+# code bases. Also note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not
+# seem to support this out of the box. Warning: Depending on the platform used,
+# enabling this option may lead to badly anti-aliased labels on the edges of
+# a graph (i.e. they become hard to read).
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10)
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
+# generate a legend page explaining the meaning of the various boxes and
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
+# remove the intermediate dot files that are used to generate
+# the various graphs.
+
+DOT_CLEANUP            = YES
diff --git a/extlibs/websocketpp/SConstruct b/extlibs/websocketpp/SConstruct
new file mode 100644
index 000000000..e01ff04e9
--- /dev/null
+++ b/extlibs/websocketpp/SConstruct
@@ -0,0 +1,266 @@
+import os, sys, commands
+env = Environment(ENV = os.environ)
+
+# figure out a better way to configure this
+if os.environ.has_key('CXX'):
+    env['CXX'] = os.environ['CXX']
+
+if os.environ.has_key('DEBUG'):
+    env['DEBUG'] = os.environ['DEBUG']
+
+if os.environ.has_key('CXXFLAGS'):
+    #env['CXXFLAGS'] = os.environ['CXXFLAGS']
+    env.Append(CXXFLAGS = os.environ['CXXFLAGS'])
+
+if os.environ.has_key('LINKFLAGS'):
+    #env['LDFLAGS'] = os.environ['LDFLAGS']
+    env.Append(LINKFLAGS = os.environ['LINKFLAGS'])
+
+## Boost
+##
+## Note: You need to either set BOOSTROOT to the root of a stock Boost distribution
+## or set BOOST_INCLUDES and BOOST_LIBS if Boost comes with your OS distro e.g. and
+## needs BOOST_INCLUDES=/usr/include/boost and BOOST_LIBS=/usr/lib like Ubuntu.
+##
+if os.environ.has_key('BOOSTROOT'):
+    os.environ['BOOST_ROOT'] = os.environ['BOOSTROOT']
+
+if os.environ.has_key('BOOST_ROOT'):
+   env['BOOST_INCLUDES'] = os.environ['BOOST_ROOT']
+   env['BOOST_LIBS'] = os.path.join(os.environ['BOOST_ROOT'], 'stage', 'lib')
+elif os.environ.has_key('BOOST_INCLUDES') and os.environ.has_key('BOOST_LIBS'):
+   env['BOOST_INCLUDES'] = os.environ['BOOST_INCLUDES']
+   env['BOOST_LIBS'] = os.environ['BOOST_LIBS']
+else:
+   raise SCons.Errors.UserError, "Neither BOOST_ROOT, nor BOOST_INCLUDES + BOOST_LIBS was set!"
+
+if os.environ.has_key('WSPP_ENABLE_CPP11'):
+   env['WSPP_ENABLE_CPP11'] = True
+else:
+   env['WSPP_ENABLE_CPP11'] = False
+
+boost_linkshared = False
+
+def boostlibs(libnames,localenv):
+   if localenv['PLATFORM'].startswith('win'):
+      # Win/VC++ supports autolinking. nothing to do.
+      # http://www.boost.org/doc/libs/1_49_0/more/getting_started/windows.html#auto-linking
+      return []
+   else:
+      libs = []
+      prefix = localenv['SHLIBPREFIX'] if boost_linkshared else localenv['LIBPREFIX']
+      suffix = localenv['SHLIBSUFFIX'] if boost_linkshared else localenv['LIBSUFFIX']
+      for name in libnames:
+         lib = File(os.path.join(localenv['BOOST_LIBS'], '%sboost_%s%s' % (prefix, name, suffix)))
+         libs.append(lib)
+      return libs
+
+if env['PLATFORM'].startswith('win'):
+   env.Append(CPPDEFINES = ['WIN32',
+                            'NDEBUG',
+                            'WIN32_LEAN_AND_MEAN',
+                            '_WIN32_WINNT=0x0600',
+                            '_CONSOLE',
+                            'BOOST_TEST_DYN_LINK',
+                            'NOMINMAX',
+                            '_WEBSOCKETPP_CPP11_MEMORY_',
+                            '_WEBSOCKETPP_CPP11_FUNCTIONAL_'])
+   arch_flags  = '/arch:SSE2'
+   opt_flags   = '/Ox /Oi /fp:fast'
+   warn_flags  = '/W3 /wd4996 /wd4995 /wd4355'
+   env['CCFLAGS'] = '%s /EHsc /GR /GS- /MD /nologo %s %s' % (warn_flags, arch_flags, opt_flags)
+   env['LINKFLAGS'] = '/INCREMENTAL:NO /MANIFEST /NOLOGO /OPT:REF /OPT:ICF /MACHINE:X86'
+elif env['PLATFORM'] == 'posix':
+   if env.has_key('DEBUG'):
+      env.Append(CCFLAGS = ['-g', '-O0'])
+   else:
+      env.Append(CPPDEFINES = ['NDEBUG'])
+      env.Append(CCFLAGS = ['-O1', '-fomit-frame-pointer'])
+   env.Append(CCFLAGS = ['-Wall'])
+   #env['LINKFLAGS'] = ''
+elif env['PLATFORM'] == 'darwin':
+   if not os.environ.has_key('CXX'):
+      env['CXX'] = "clang++"
+   if env.has_key('DEBUG'):
+      env.Append(CCFLAGS = ['-g', '-O0'])
+   else:
+      env.Append(CPPDEFINES = ['NDEBUG'])
+      env.Append(CCFLAGS = ['-O1', '-fomit-frame-pointer'])
+   env.Append(CCFLAGS = ['-Wall'])
+   #env['LINKFLAGS'] = ''
+
+if env['PLATFORM'].startswith('win'):
+   #env['LIBPATH'] = env['BOOST_LIBS']
+   pass
+else:
+   env['LIBPATH'] = ['/usr/lib',
+                     '/usr/local/lib'] #, env['BOOST_LIBS']
+
+# Compiler specific warning flags
+if env['CXX'].startswith('g++'):
+   #env.Append(CCFLAGS = ['-Wconversion'])
+   env.Append(CCFLAGS = ['-Wcast-align'])
+   env.Append(CCFLAGS = ['-Wshadow'])
+   env.Append(CCFLAGS = ['-Wunused-parameter'])
+elif env['CXX'].startswith('clang++'):
+   #env.Append(CCFLAGS = ['-Wcast-align'])
+   #env.Append(CCFLAGS = ['-Wglobal-constructors'])
+   #env.Append(CCFLAGS = ['-Wconversion'])
+   env.Append(CCFLAGS = ['-Wno-padded'])
+   env.Append(CCFLAGS = ['-Wshadow'])
+   env.Append(CCFLAGS = ['-Wunused-parameter'])
+
+   env.Append(CCFLAGS = ['-Wsometimes-uninitialized'])
+   env.Append(CCFLAGS = ['-Wuninitialized'])
+
+   #env.Append(CCFLAGS = ['-Weverything'])
+   #env.Append(CCFLAGS = ['-Wno-documentation'])
+   #env.Append(CCFLAGS = ['-Wno-weak-vtables'])
+   #env.Append(CCFLAGS = ['-Wno-global-constructors'])
+   #env.Append(CCFLAGS = ['-Wno-sign-conversion'])
+   #env.Append(CCFLAGS = ['-Wno-exit-time-destructors'])
+
+
+
+
+   # Wpadded
+   # Wsign-conversion
+
+platform_libs = []
+tls_libs = []
+
+tls_build = False
+
+if env['PLATFORM'] == 'posix':
+   platform_libs = ['pthread', 'rt']
+   tls_libs = ['ssl', 'crypto']
+   tls_build = True
+elif env['PLATFORM'] == 'darwin':
+   tls_libs = ['ssl', 'crypto']
+   tls_build = True
+elif env['PLATFORM'].startswith('win'):
+   # Win/VC++ supports autolinking. nothing to do.
+   pass
+
+## Append WebSocket++ path
+env.Append(CPPPATH = ['#'])
+
+##### Set up C++11 environment
+polyfill_libs = [] # boost libraries used as drop in replacements for incomplete
+                   # C++11 STL implementations
+env_cpp11 = env.Clone ()
+
+if env_cpp11['CXX'].startswith('g++'):
+   # TODO: check g++ version
+   GCC_VERSION = commands.getoutput(env_cpp11['CXX'] + ' -dumpversion')
+
+   if GCC_VERSION > "4.4.0":
+      print "C++11 build environment partially enabled"
+      env_cpp11.Append(WSPP_CPP11_ENABLED = "true",CXXFLAGS = ['-std=c++0x'],TOOLSET = ['g++'],CPPDEFINES = ['_WEBSOCKETPP_CPP11_STL_'])
+   else:
+      print "C++11 build environment is not supported on this version of G++"
+elif env_cpp11['CXX'].startswith('clang++'):
+   print "C++11 build environment enabled"
+   env.Append(CXXFLANGS = ['-stdlib=libc++'],LINKFLAGS=['-stdlib=libc++'])
+   env_cpp11.Append(WSPP_CPP11_ENABLED = "true",CXXFLAGS = ['-std=c++0x','-stdlib=libc++'],LINKFLAGS = ['-stdlib=libc++'],TOOLSET = ['clang++'],CPPDEFINES = ['_WEBSOCKETPP_CPP11_STL_'])
+
+   # look for optional second boostroot compiled with clang's libc++ STL library
+   # this prevents warnings/errors when linking code built with two different
+   # incompatible STL libraries.
+   if os.environ.has_key('BOOST_ROOT_CPP11'):
+      env_cpp11['BOOST_INCLUDES'] = os.environ['BOOST_ROOT_CPP11']
+      env_cpp11['BOOST_LIBS'] = os.path.join(os.environ['BOOST_ROOT_CPP11'], 'stage', 'lib')
+   elif os.environ.has_key('BOOST_INCLUDES_CPP11') and os.environ.has_key('BOOST_LIBS_CPP11'):
+      env_cpp11['BOOST_INCLUDES'] = os.environ['BOOST_INCLUDES_CPP11']
+      env_cpp11['BOOST_LIBS'] = os.environ['BOOST_LIBS_CPP11']
+else:
+   print "C++11 build environment disabled"
+
+# if the build system is known to allow the isystem modifier for library include
+# values then use it for the boost libraries. Otherwise just add them to the
+# regular CPPPATH values.
+if env['CXX'].startswith('g++') or env['CXX'].startswith('clang'):
+    env.Append(CPPFLAGS = '-isystem ' + env['BOOST_INCLUDES'])
+else:
+    env.Append(CPPPATH = [env['BOOST_INCLUDES']])
+env.Append(LIBPATH = [env['BOOST_LIBS']])
+
+# if the build system is known to allow the isystem modifier for library include
+# values then use it for the boost libraries. Otherwise just add them to the
+# regular CPPPATH values.
+if env_cpp11['CXX'].startswith('g++') or env_cpp11['CXX'].startswith('clang'):
+    env_cpp11.Append(CPPFLAGS = '-isystem ' + env_cpp11['BOOST_INCLUDES'])
+else:
+    env_cpp11.Append(CPPPATH = [env_cpp11['BOOST_INCLUDES']])
+env_cpp11.Append(LIBPATH = [env_cpp11['BOOST_LIBS']])
+
+releasedir = 'build/release/'
+debugdir = 'build/debug/'
+testdir = 'build/test/'
+builddir = releasedir
+
+Export('env')
+Export('env_cpp11')
+Export('platform_libs')
+Export('boostlibs')
+Export('tls_libs')
+Export('polyfill_libs')
+
+## END OF CONFIG !!
+
+## TARGETS:
+
+if not env['PLATFORM'].startswith('win'):
+    # Unit tests, add test folders with SConscript files to to_test list.
+    to_test = ['utility','http','logger','random','processors','message_buffer','extension','transport/iostream','transport/asio','roles','endpoint','connection','transport'] #,'http','processors','connection'
+
+    for t in to_test:
+       new_tests = SConscript('#/test/'+t+'/SConscript',variant_dir = testdir + t, duplicate = 0)
+       for a in new_tests:
+          new_alias = Alias('test', [a], a.abspath)
+          AlwaysBuild(new_alias)
+
+# Main test application
+#main = SConscript('#/examples/dev/SConscript',variant_dir = builddir + 'dev',duplicate = 0)
+
+# echo_server
+echo_server = SConscript('#/examples/echo_server/SConscript',variant_dir = builddir + 'echo_server',duplicate = 0)
+
+# echo_server_tls
+if tls_build:
+    echo_server_tls = SConscript('#/examples/echo_server_tls/SConscript',variant_dir = builddir + 'echo_server_tls',duplicate = 0)
+    echo_server_both = SConscript('#/examples/echo_server_both/SConscript',variant_dir = builddir + 'echo_server_both',duplicate = 0)
+
+# broadcast_server
+broadcast_server = SConscript('#/examples/broadcast_server/SConscript',variant_dir = builddir + 'broadcast_server',duplicate = 0)
+
+# testee_server
+testee_server = SConscript('#/examples/testee_server/SConscript',variant_dir = builddir + 'testee_server',duplicate = 0)
+
+# testee_client
+testee_client = SConscript('#/examples/testee_client/SConscript',variant_dir = builddir + 'testee_client',duplicate = 0)
+
+# utility_client
+utility_client = SConscript('#/examples/utility_client/SConscript',variant_dir = builddir + 'utility_client',duplicate = 0)
+
+# debug_client
+debug_client = SConscript('#/examples/debug_client/SConscript',variant_dir = builddir + 'debug_client',duplicate = 0)
+
+# debug_server
+debug_server = SConscript('#/examples/debug_server/SConscript',variant_dir = builddir + 'debug_server',duplicate = 0)
+
+# subprotocol_server
+subprotocol_server = SConscript('#/examples/subprotocol_server/SConscript',variant_dir = builddir + 'subprotocol_server',duplicate = 0)
+
+# telemetry_server
+telemetry_server = SConscript('#/examples/telemetry_server/SConscript',variant_dir = builddir + 'telemetry_server',duplicate = 0)
+
+if not env['PLATFORM'].startswith('win'):
+    # iostream_server
+    iostream_server = SConscript('#/examples/iostream_server/SConscript',variant_dir = builddir + 'iostream_server',duplicate = 0)
+
+    # telemetry_client
+    telemetry_client = SConscript('#/examples/telemetry_client/SConscript',variant_dir = builddir + 'telemetry_client',duplicate = 0)
+
+    # print_server
+    print_server = SConscript('#/examples/print_server/SConscript',variant_dir = builddir + 'print_server',duplicate = 0)
diff --git a/extlibs/websocketpp/changelog.md b/extlibs/websocketpp/changelog.md
new file mode 100644
index 000000000..296f1054e
--- /dev/null
+++ b/extlibs/websocketpp/changelog.md
@@ -0,0 +1,234 @@
+HEAD
+
+0.5.1 - 2015-02-27
+- Bug: Fixes an issue where some frame data was counted against the max header
+  size limit, resulting in connections that included a lot of frame data
+  immediately after the opening handshake to fail.
+- Bug: Fix a type in the name of the set method for `max_http_body_size`. #406
+  Thank you jplatte for reporting.
+
+0.5.0 - 2015-01-22
+- BREAKING UTILITY CHANGE: Deprecated methods `http::parser::parse_headers`,
+  `http::response::parse_complete`, and `http::request::parse_complete` have
+  been removed.
+- Security: Disabled SSLv3 in example servers.
+- Feature: Adds basic support for accessing HTTP request bodies in the http
+  handler. #181
+- Feature: Adds the ability to register a shutdown handler when using the
+  iostream transport. This provides a clean interface for triggering the shut
+  down of external sockets and other cleanup without hooking in to higher level
+  WebSocket handlers.
+- Feature: Adds the ability to register a write handler when using the iostream
+  transport. This handler can be used to handle transport output in place of
+  registering an ostream to write to.
+- Feature: Adds a new logging policy that outputs to syslog. #386 Thank you Tom
+  Hughes for submitting the initial version of this policy.
+- Improvement: Message payload logging now prints text for text messages rather
+  than binary.
+- Improvement: Overhaul of handshake state machine. Should make it impossible
+  for exceptions to bubble out of transport methods like `io_service::run`.
+- Improvement: Overhaul of handshake error reporting. Fail handler error codes
+  will be more detailed and precise. Adds new [fail] and [http] logging channels
+  that log failed websocket connections and successful HTTP connections
+  respectively. A new aggregate channel package, `alevel::access_core`, allows
+  enabling connect, disconnect, fail, and http together. Successful HTTP
+  connections will no longer trigger a fail handler.
+- Improvement: Ability to terminate connection during an http handler to cleanly
+  suppress the default outgoing HTTP response.
+- Documentation: Add Sending & Receiving Messages step to chapter one of the
+  `utility_client` tutorial. Update `utility_client` example to match.
+- Cleanup: Removes unused files & STL includes. Adds required STL includes.
+  Normalizes include order.
+- Bug: Fixes a fatal state error when a handshake response is completed
+  immediately after that handshake times out. #389
+- Bug: MinGW fixes; C++11 feature detection, localtime use. #393 Thank you
+  Schebb for reporting, code, and testing.
+- Bug: Fixes an issue where `websocketpp::exception::what()` could return an out
+  of scope pointer. #397 Thank you fabioang for reporting.
+- Bug: Fixes an issue where endpoints were not reset properly after a call to
+  `endpoint::listen` failed. #390 Thank you wyyqyl for reporting.
+
+0.4.0 - 2014-11-04
+- BREAKING API CHANGE: All WebSocket++ methods now throw an exception of type
+  `websocketpp::exception` which derives from `std::exception`. This normalizes
+  all exception types under the standard exception hierarchy and allows
+  WebSocket++ exceptions to be caught in the same statement as others. The error
+  code that was previously thrown is wrapped in the exception object and can be
+  accessed via the `websocketpp::exception::code()` method.
+- BREAKING API CHANGE: Custom logging policies have some new required
+  constructors that take generic config settings rather than pointers to
+  std::ostreams. This allows writing logging policies that do not involve the
+  use of std::ostream. This does not affect anyone using the built in logging
+  policies.
+- BREAKING UTILITY CHANGE: `websocketpp::lib::net::htonll` and
+  `websocketpp::lib::net::ntohll` have been prefixed with an underscore to avoid
+  conflicts with similarly named macros in some operating systems. If you are
+  using the WebSocket++ provided 64 bit host/network byte order functions you
+  will need to switch to the prefixed versions.
+- BREAKING UTILITY CHANGE: The signature of `base64_encode` has changed from
+  `websocketpp::base64_encode(unsigned char const *, unsigned int)` to
+  `websocketpp::base64_encode(unsigned char const *, size_t)`.
+- BREAKING UTILITY CHANGE: The signature of `sha1::calc` has changed from
+  `websocketpp::sha1::calc(void const *, int, unsigned char *)` to
+  `websocketpp::sha1::calc(void const *, size_t, unsigned char *)`
+- Feature: Adds incomplete `minimal_server` and `minimal_client` configs that
+  can be used to build custom configs without pulling in the dependencies of
+  `core` or `core_client`. These configs will offer a stable base config to
+  future-proof custom configs.
+- Improvement: Core library no longer has std::iostream as a dependency.
+  std::iostream is still required for the optional iostream logging policy and
+  iostream transport.
+- Bug: C++11 Chrono support was being incorrectly detected by the `boost_config`
+  header. Thank you Max Dmitrichenko for reporting and a patch.
+- Bug: use of `std::put_time` is now guarded by a unique flag rather than a
+  chrono library flag. Thank you Max Dmitrichenko for reporting.
+- Bug: Fixes non-thread safe use of std::localtime. #347 #383
+- Compatibility: Adjust usage of std::min to be more compatible with systems
+  that define a min(...) macro.
+- Compatibility: Removes unused parameters from all library, test, and example
+  code. This assists with those developing with -Werror and -Wunused-parameter
+  #376
+- Compatibility: Renames ntohll and htonll methods to avoid conflicts with
+  platform specific macros. #358 #381, #382 Thank you logotype, unphased,
+  svendjo
+- Cleanup: Removes unused functions, fixes variable shadow warnings, normalizes
+  all whitespace in library, examples, and tests to 4 spaces. #376
+
+0.3.0 - 2014-08-10
+- Feature: Adds `start_perpetual` and `stop_perpetual` methods to asio transport
+  These may be used to replace manually managed `asio::io_service::work` objects
+- Feature: Allow setting pong and handshake timeouts at runtime.
+- Feature: Allows changing the listen backlog queue length.
+- Feature: Split tcp init into pre and post init.
+- Feature: Adds URI method to extract query string from URI. Thank you Banaan
+  for code. #298
+- Feature: Adds a compile time switch to asio transport config to disable
+  certain multithreading features (some locks, asio strands)
+- Feature: Adds the ability to pause reading on a connection. Paused connections
+  will not read more data from their socket, allowing TCP flow control to work
+  without blocking the main thread.
+- Feature: Adds the ability to specify whether or not to use the `SO_REUSEADDR`
+  TCP socket option. The default for this value has been changed from `true` to
+  `false`.
+- Feature: Adds the ability to specify a maximum message size.
+- Feature: Adds `close::status::get_string(...)` method to look up a human
+  readable string given a close code value.
+- Feature: Adds `connection::read_all(...)` method to iostream transport as a
+  convenience method for reading all data into the connection buffer without the
+  end user needing to manually loop on `read_some`.
+- Improvement: Open, close, and pong timeouts can be disabled entirely by
+  setting their duration to 0.
+- Improvement: Numerous performance improvements. Including: tuned default
+  buffer sizes based on profiling, caching of handler binding for async
+  reads/writes, non-malloc allocators for read/write handlers, disabling of a
+  number of questionably useful range sanity checks in tight inner loops.
+- Improvement: Cleaned up the handling of TLS related errors. TLS errors will
+  now be reported with more detail on the info channel rather than all being
+  `tls_short_read` or `pass_through`. In addition, many cases where a TLS short
+  read was in fact expected are no longer classified as errors. Expected TLS
+  short reads and quasi-expected socket shutdown related errors will no longer
+  be reported as unclean WebSocket shutdowns to the application. Information
+  about them will remain in the info error channel for debugging purposes.
+- Improvement: `start_accept` and `listen` errors are now reported to the caller
+  either via an exception or an ec parameter.
+- Improvement: Outgoing writes are now batched for improved message throughput
+  and reduced system call and TCP frame overhead.
+- Bug: Fix some cases of calls to empty lib::function objects.
+- Bug: Fix memory leak of connection objects due to cached handlers holding on to
+  reference counted pointers. #310 Thank you otaras for reporting.
+- Bug: Fix issue with const endpoint accessors (such as `get_user_agent`) not
+  compiling due to non-const mutex use. #292 Thank you logofive for reporting.
+- Bug: Fix handler allocation crash with multithreaded `io_service`.
+- Bug: Fixes incorrect whitespace handling in header parsing. #301 Thank you
+  Wolfram Schroers for reporting
+- Bug: Fix a crash when parsing empty HTTP headers. Thank you Thingol for
+  reporting.
+- Bug: Fix a crash following use of the `stop_listening` function. Thank you
+  Thingol for reporting.
+- Bug: Fix use of variable names that shadow function parameters. The library
+  should compile cleanly with -Wshadow now. Thank you giszo for reporting. #318
+- Bug: Fix an issue where `set_open_handshake_timeout` was ignored by server
+  code. Thank you Robin Rowe for reporting.
+- Bug: Fix an issue where custom timeout values weren't being propagated from
+  endpoints to new connections.
+- Bug: Fix a number of memory leaks related to server connection failures. #323
+  #333 #334 #335 Thank you droppy and aydany for reporting and patches.
+  reporting.
+- Compatibility: Fix compile time conflict with Visual Studio's MIN/MAX macros.
+  Thank you Robin Rowe for reporting.
+- Documentation: Examples and test suite build system now defaults to clang on
+  OS X
+
+0.3.0-alpha4 - 2013-10-11
+- HTTP requests ending normally are no longer logged as errors. Thank you Banaan
+  for reporting. #294
+- Eliminates spurious expired timers in certain error conditions. Thank you
+  Banaan for reporting. #295
+- Consolidates all bundled library licenses into the COPYING file. #294
+- Updates bundled sha1 library to one with a cleaner interface and more
+  straight-forward license. Thank you lotodore for reporting and Evgeni Golov
+  for reviewing. #294
+- Re-introduces strands to asio transport, allowing `io_service` thread pools to
+  be used (with some limitations).
+- Removes endpoint code that kept track of a connection list that was never used
+  anywhere. Removes a lock and reduces connection creation/deletion complexity
+  from O(log n) to O(1) in the number of connections.
+- A number of internal changes to transport APIs
+- Deprecates iostream transport `readsome` in favor of `read_some` which is more
+  consistent with the naming of the rest of the library.
+- Adds preliminary signaling to iostream transport of eof and fatal transport
+  errors
+- Updates transport code to use shared pointers rather than raw pointers to
+  prevent asio from retaining pointers to connection methods after the
+  connection goes out of scope. #293 Thank you otaras for reporting.
+- Fixes an issue where custom headers couldn't be set for client connections
+  Thank you Jerry Win and Wolfram Schroers for reporting.
+- Fixes a compile error on visual studio when using interrupts. Thank you Javier
+  Rey Neira for reporting this.
+- Adds new 1012 and 1013 close codes per IANA registry
+- Add `set_remote_endpoint` method to iostream transport.
+- Add `set_secure` method to iostream transport.
+- Fix typo in .gitattributes file. Thank you jstarasov for reporting this. #280
+- Add missing locale include. Thank you Toninoso for reporting this. #281
+- Refactors `asio_transport` endpoint and adds full documentation and exception
+  free varients of all methods.
+- Removes `asio_transport` endpoint method cancel(). Use `stop_listen()` instead
+- Wrap internal `io_service` `run_one()` method
+- Suppress error when trying to shut down a connection that was already closed
+
+0.3.0-alpha3 - 2013-07-16
+- Minor refactor to bundled sha1 library
+- HTTP header comparisons are now case insensitive. #220, #275
+- Refactors URI to be exception free and not use regular expressions. This
+  eliminates the dependency on boost or C++11 regex libraries allowing native
+  C++11 usage on GCC 4.4 and higher and significantly reduces staticly built
+  binary sizes.
+- Updates handling of Server and User-Agent headers to better handle custom
+  settings and allow suppression of these headers for security purposes.
+- Fix issue where pong timeout handler always fired. Thank you Steven Klassen
+  for reporting this bug.
+- Add ping and pong endpoint wrapper methods
+- Add `get_request()` pass through method to connection to allow calling methods
+  specific to the HTTP policy in use.
+- Fix issue compile error with `WEBSOCKETPP_STRICT_MASKING` enabled and another
+  issue where `WEBSOCKETPP_STRICT_MASKING` was not applied to incoming messages.
+  Thank you Petter Norby for reporting and testing these bugs. #264
+- Add additional macro guards for use with boost_config. Thank you breyed
+  for testing and code. #261
+
+0.3.0-alpha2 - 2013-06-09
+- Fix a regression that caused servers being sent two close frames in a row
+  to end a connection uncleanly. #259
+- Fix a regression that caused spurious frames following a legitimate close
+  frames to erroneously trigger handlers. #258
+- Change default HTTP response error code when no http_handler is defined from
+  500/Internal Server Error to 426/Upgrade Required
+- Remove timezone from logger timestamp to work around issues with the Windows
+  implementation of strftime. Thank you breyed for testing and code. #257
+- Switch integer literals to char literals to improve VCPP compatibility.
+  Thank you breyed for testing and code. #257
+- Add MSVCPP warning suppression for the bundled SHA1 library. Thank you breyed
+  for testing and code. #257
+
+0.3.0-alpha1 - 2013-06-09
+- Initial Release
diff --git a/extlibs/websocketpp/docs/simple_broadcast_server.cpp b/extlibs/websocketpp/docs/simple_broadcast_server.cpp
new file mode 100644
index 000000000..955d71115
--- /dev/null
+++ b/extlibs/websocketpp/docs/simple_broadcast_server.cpp
@@ -0,0 +1,52 @@
+#include <set>
+
+#include <websocketpp/config/asio_no_tls.hpp>
+#include <websocketpp/server.hpp>
+
+typedef websocketpp::server<websocketpp::config::asio> server;
+
+using websocketpp::connection_hdl;
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+class broadcast_server {
+public:
+    broadcast_server() {
+        m_server.init_asio();
+                
+        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));
+        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));
+        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));
+    }
+    
+    void on_open(connection_hdl hdl) {
+        m_connections.insert(hdl);
+    }
+    
+    void on_close(connection_hdl hdl) {
+        m_connections.erase(hdl);
+    }
+    
+    void on_message(connection_hdl hdl, server::message_ptr msg) {
+        for (auto it : m_connections) {
+            m_server.send(it,msg);
+        }
+    }
+
+    void run(uint16_t port) {
+        m_server.listen(port);
+        m_server.start_accept();
+        m_server.run();
+    }
+private:
+    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;
+
+    server m_server;
+    con_list m_connections;
+};
+
+int main() {
+    broadcast_server server;
+    server.run(9002);
+}
\ No newline at end of file
diff --git a/extlibs/websocketpp/docs/simple_count_server_thread.cpp b/extlibs/websocketpp/docs/simple_count_server_thread.cpp
new file mode 100644
index 000000000..a30af9948
--- /dev/null
+++ b/extlibs/websocketpp/docs/simple_count_server_thread.cpp
@@ -0,0 +1,65 @@
+#include <functional>
+#include <mutex>
+#include <set>
+#include <thread>
+
+#include <websocketpp/config/asio_no_tls.hpp>
+#include <websocketpp/server.hpp>
+
+typedef websocketpp::server<websocketpp::config::asio> server;
+
+using websocketpp::connection_hdl;
+
+class count_server {
+public:
+    count_server() : m_count(0) {
+        m_server.init_asio();
+                
+        m_server.set_open_handler(bind(&count_server::on_open,this,_1));
+        m_server.set_close_handler(bind(&count_server::on_close,this,_1));
+    }
+    
+    void on_open(connection_hdl hdl) {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        m_connections.insert(hdl);
+    }
+    
+    void on_close(connection_hdl hdl) {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        m_connections.erase(hdl);
+    }
+    
+    void count() {
+        while (1) {
+            sleep(1);
+            m_count++;
+            
+            std::stringstream ss;
+            ss << m_count;
+            
+            std::lock_guard<std::mutex> lock(m_mutex);    
+            for (auto it : m_connections) {
+                m_server.send(it,ss.str(),websocketpp::frame::opcode::text);
+            }
+        }
+    }
+    
+    void run(uint16_t port) {
+        m_server.listen(port);
+        m_server.start_accept();
+        m_server.run();
+    }
+private:
+    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;
+    
+    int m_count;
+    server m_server;
+    con_list m_connections;
+    std::mutex m_mutex;
+};
+
+int main() {
+    count_server server;
+    std::thread t(std::bind(&count_server::count,&server));
+    server.run(9002);
+}
\ No newline at end of file
diff --git a/extlibs/websocketpp/examples/CMakeLists.txt b/extlibs/websocketpp/examples/CMakeLists.txt
new file mode 100644
index 000000000..cb746662a
--- /dev/null
+++ b/extlibs/websocketpp/examples/CMakeLists.txt
@@ -0,0 +1,6 @@
+file (GLOB SDIRS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *)
+foreach (SUBDIR ${SDIRS})
+    if (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${SUBDIR}/CMakeLists.txt")
+        add_subdirectory (${SUBDIR})
+    endif ()
+endforeach ()
diff --git a/extlibs/websocketpp/examples/associative_storage/associative_storage.cpp b/extlibs/websocketpp/examples/associative_storage/associative_storage.cpp
new file mode 100644
index 000000000..e2245e4e4
--- /dev/null
+++ b/extlibs/websocketpp/examples/associative_storage/associative_storage.cpp
@@ -0,0 +1,88 @@
+#include <iostream>
+#include <map>
+#include <exception>
+#include <websocketpp/config/asio_no_tls.hpp>
+#include <websocketpp/server.hpp>
+
+typedef websocketpp::server<websocketpp::config::asio> server;
+
+using websocketpp::connection_hdl;
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+struct connection_data {
+    int sessionid;
+    std::string name;
+};
+
+class print_server {
+public:
+    print_server() : m_next_sessionid(1) {
+        m_server.init_asio();
+
+        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));
+        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));
+        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));
+    }
+
+    void on_open(connection_hdl hdl) {
+        connection_data data;
+
+        data.sessionid = m_next_sessionid++;
+        data.name = "";
+
+        m_connections[hdl] = data;
+    }
+
+    void on_close(connection_hdl hdl) {
+        connection_data& data = get_data_from_hdl(hdl);
+
+        std::cout << "Closing connection " << data.name
+                  << " with sessionid " << data.sessionid << std::endl;
+
+        m_connections.erase(hdl);
+    }
+
+    void on_message(connection_hdl hdl, server::message_ptr msg) {
+        connection_data& data = get_data_from_hdl(hdl);
+
+        if (data.name == "") {
+            data.name = msg->get_payload();
+            std::cout << "Setting name of connection with sessionid "
+                      << data.sessionid << " to " << data.name << std::endl;
+        } else {
+            std::cout << "Got a message from connection " << data.name
+                      << " with sessionid " << data.sessionid << std::endl;
+        }
+    }
+
+    connection_data& get_data_from_hdl(connection_hdl hdl) {
+        auto it = m_connections.find(hdl);
+
+        if (it == m_connections.end()) {
+            // this connection is not in the list. This really shouldn't happen
+            // and probably means something else is wrong.
+            throw std::invalid_argument("No data available for session");
+        }
+
+        return it->second;
+    }
+
+    void run(uint16_t port) {
+        m_server.listen(port);
+        m_server.start_accept();
+        m_server.run();
+    }
+private:
+    typedef std::map<connection_hdl,connection_data,std::owner_less<connection_hdl>> con_list;
+
+    int m_next_sessionid;
+    server m_server;
+    con_list m_connections;
+};
+
+int main() {
+    print_server server;
+    server.run(9002);
+}
diff --git a/extlibs/websocketpp/examples/broadcast_server/SConscript b/extlibs/websocketpp/examples/broadcast_server/SConscript
new file mode 100644
index 000000000..5786f570d
--- /dev/null
+++ b/extlibs/websocketpp/examples/broadcast_server/SConscript
@@ -0,0 +1,23 @@
+## Broadcast Server example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('broadcast_server', ["broadcast_server.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system','thread'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('broadcast_server', ["broadcast_server.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/broadcast_server/broadcast_server.cpp b/extlibs/websocketpp/examples/broadcast_server/broadcast_server.cpp
new file mode 100644
index 000000000..e87e879ee
--- /dev/null
+++ b/extlibs/websocketpp/examples/broadcast_server/broadcast_server.cpp
@@ -0,0 +1,156 @@
+#include <websocketpp/config/asio_no_tls.hpp>
+
+#include <websocketpp/server.hpp>
+
+#include <iostream>
+#include <set>
+
+/*#include <boost/thread.hpp>
+#include <boost/thread/mutex.hpp>
+#include <boost/thread/condition_variable.hpp>*/
+#include <websocketpp/common/thread.hpp>
+
+typedef websocketpp::server<websocketpp::config::asio> server;
+
+using websocketpp::connection_hdl;
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+using websocketpp::lib::thread;
+using websocketpp::lib::mutex;
+using websocketpp::lib::unique_lock;
+using websocketpp::lib::condition_variable;
+
+/* on_open insert connection_hdl into channel
+ * on_close remove connection_hdl from channel
+ * on_message queue send to all channels
+ */
+
+enum action_type {
+    SUBSCRIBE,
+    UNSUBSCRIBE,
+    MESSAGE
+};
+
+struct action {
+    action(action_type t, connection_hdl h) : type(t), hdl(h) {}
+    action(action_type t, connection_hdl h, server::message_ptr m)
+      : type(t), hdl(h), msg(m) {}
+
+    action_type type;
+    websocketpp::connection_hdl hdl;
+    server::message_ptr msg;
+};
+
+class broadcast_server {
+public:
+    broadcast_server() {
+        // Initialize Asio Transport
+        m_server.init_asio();
+
+        // Register handler callbacks
+        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));
+        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));
+        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));
+    }
+
+    void run(uint16_t port) {
+        // listen on specified port
+        m_server.listen(port);
+
+        // Start the server accept loop
+        m_server.start_accept();
+
+        // Start the ASIO io_service run loop
+        try {
+            m_server.run();
+        } catch (const std::exception & e) {
+            std::cout << e.what() << std::endl;
+        }
+    }
+
+    void on_open(connection_hdl hdl) {
+        unique_lock<mutex> lock(m_action_lock);
+        //std::cout << "on_open" << std::endl;
+        m_actions.push(action(SUBSCRIBE,hdl));
+        lock.unlock();
+        m_action_cond.notify_one();
+    }
+
+    void on_close(connection_hdl hdl) {
+        unique_lock<mutex> lock(m_action_lock);
+        //std::cout << "on_close" << std::endl;
+        m_actions.push(action(UNSUBSCRIBE,hdl));
+        lock.unlock();
+        m_action_cond.notify_one();
+    }
+
+    void on_message(connection_hdl hdl, server::message_ptr msg) {
+        // queue message up for sending by processing thread
+        unique_lock<mutex> lock(m_action_lock);
+        //std::cout << "on_message" << std::endl;
+        m_actions.push(action(MESSAGE,hdl,msg));
+        lock.unlock();
+        m_action_cond.notify_one();
+    }
+
+    void process_messages() {
+        while(1) {
+            unique_lock<mutex> lock(m_action_lock);
+
+            while(m_actions.empty()) {
+                m_action_cond.wait(lock);
+            }
+
+            action a = m_actions.front();
+            m_actions.pop();
+
+            lock.unlock();
+
+            if (a.type == SUBSCRIBE) {
+                unique_lock<mutex> con_lock(m_connection_lock);
+                m_connections.insert(a.hdl);
+            } else if (a.type == UNSUBSCRIBE) {
+                unique_lock<mutex> con_lock(m_connection_lock);
+                m_connections.erase(a.hdl);
+            } else if (a.type == MESSAGE) {
+                unique_lock<mutex> con_lock(m_connection_lock);
+
+                con_list::iterator it;
+                for (it = m_connections.begin(); it != m_connections.end(); ++it) {
+                    m_server.send(*it,a.msg);
+                }
+            } else {
+                // undefined.
+            }
+        }
+    }
+private:
+    typedef std::set<connection_hdl,std::owner_less<connection_hdl> > con_list;
+
+    server m_server;
+    con_list m_connections;
+    std::queue<action> m_actions;
+
+    mutex m_action_lock;
+    mutex m_connection_lock;
+    condition_variable m_action_cond;
+};
+
+int main() {
+    try {
+    broadcast_server server_instance;
+
+    // Start a thread to run the processing loop
+    thread t(bind(&broadcast_server::process_messages,&server_instance));
+
+    // Run the asio loop with the main thread
+    server_instance.run(9002);
+
+    t.join();
+
+    } catch (websocketpp::exception const & e) {
+        std::cout << e.what() << std::endl;
+    }
+}
diff --git a/extlibs/websocketpp/examples/debug_client/SConscript b/extlibs/websocketpp/examples/debug_client/SConscript
new file mode 100644
index 000000000..781db8371
--- /dev/null
+++ b/extlibs/websocketpp/examples/debug_client/SConscript
@@ -0,0 +1,24 @@
+## Debug client example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+Import('tls_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs] + [tls_libs]
+   prgs += env_cpp11.Program('debug_client', ["debug_client.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system','random'],env) + [platform_libs] + [polyfill_libs] + [tls_libs]
+   prgs += env.Program('debug_client', ["debug_client.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/debug_client/debug_client.cpp b/extlibs/websocketpp/examples/debug_client/debug_client.cpp
new file mode 100644
index 000000000..c6be2c111
--- /dev/null
+++ b/extlibs/websocketpp/examples/debug_client/debug_client.cpp
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** ====== WARNING ========
+ * This example is presently used as a scratch space. It may or may not be broken
+ * at any given time.
+ */
+
+#include <websocketpp/config/asio_client.hpp>
+
+#include <websocketpp/client.hpp>
+
+#include <iostream>
+#include <chrono>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+// pull out the type of messages sent by our config
+typedef websocketpp::config::asio_tls_client::message_type::ptr message_ptr;
+typedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;
+typedef client::connection_ptr connection_ptr;
+
+
+
+class perftest {
+public:
+    typedef perftest type;
+    typedef std::chrono::duration<int,std::micro> dur_type;
+
+    perftest () {
+        m_endpoint.set_access_channels(websocketpp::log::alevel::all);
+        m_endpoint.set_error_channels(websocketpp::log::elevel::all);
+
+        // Initialize ASIO
+        m_endpoint.init_asio();
+
+        // Register our handlers
+        m_endpoint.set_socket_init_handler(bind(&type::on_socket_init,this,::_1));
+        //m_endpoint.set_tls_init_handler(bind(&type::on_tls_init,this,::_1));
+        m_endpoint.set_message_handler(bind(&type::on_message,this,::_1,::_2));
+        m_endpoint.set_open_handler(bind(&type::on_open,this,::_1));
+        m_endpoint.set_close_handler(bind(&type::on_close,this,::_1));
+        m_endpoint.set_fail_handler(bind(&type::on_fail,this,::_1));
+    }
+
+    void start(std::string uri) {
+        websocketpp::lib::error_code ec;
+        client::connection_ptr con = m_endpoint.get_connection(uri, ec);
+
+        if (ec) {
+            m_endpoint.get_alog().write(websocketpp::log::alevel::app,ec.message());
+        }
+
+        //con->set_proxy("http://humupdates.uchicago.edu:8443");
+
+        m_endpoint.connect(con);
+
+        // Start the ASIO io_service run loop
+        m_start = std::chrono::high_resolution_clock::now();
+        m_endpoint.run();
+    }
+
+    void on_socket_init(websocketpp::connection_hdl) {
+        m_socket_init = std::chrono::high_resolution_clock::now();
+    }
+
+    context_ptr on_tls_init(websocketpp::connection_hdl) {
+        m_tls_init = std::chrono::high_resolution_clock::now();
+        context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::tlsv1);
+
+        try {
+            ctx->set_options(boost::asio::ssl::context::default_workarounds |
+                             boost::asio::ssl::context::no_sslv2 |
+                             boost::asio::ssl::context::no_sslv3 |
+                             boost::asio::ssl::context::single_dh_use);
+        } catch (std::exception& e) {
+            std::cout << e.what() << std::endl;
+        }
+        return ctx;
+    }
+
+    void on_fail(websocketpp::connection_hdl hdl) {
+        client::connection_ptr con = m_endpoint.get_con_from_hdl(hdl);
+        
+        std::cout << "Fail handler" << std::endl;
+        std::cout << con->get_state() << std::endl;
+        std::cout << con->get_local_close_code() << std::endl;
+        std::cout << con->get_local_close_reason() << std::endl;
+        std::cout << con->get_remote_close_code() << std::endl;
+        std::cout << con->get_remote_close_reason() << std::endl;
+        std::cout << con->get_ec() << " - " << con->get_ec().message() << std::endl;
+    }
+
+    void on_open(websocketpp::connection_hdl hdl) {
+        m_open = std::chrono::high_resolution_clock::now();
+        m_endpoint.send(hdl, "", websocketpp::frame::opcode::text);
+    }
+    void on_message(websocketpp::connection_hdl hdl, message_ptr) {
+        m_message = std::chrono::high_resolution_clock::now();
+        m_endpoint.close(hdl,websocketpp::close::status::going_away,"");
+    }
+    void on_close(websocketpp::connection_hdl) {
+        m_close = std::chrono::high_resolution_clock::now();
+
+        std::cout << "Socket Init: " << std::chrono::duration_cast<dur_type>(m_socket_init-m_start).count() << std::endl;
+        std::cout << "TLS Init: " << std::chrono::duration_cast<dur_type>(m_tls_init-m_start).count() << std::endl;
+        std::cout << "Open: " << std::chrono::duration_cast<dur_type>(m_open-m_start).count() << std::endl;
+        std::cout << "Message: " << std::chrono::duration_cast<dur_type>(m_message-m_start).count() << std::endl;
+        std::cout << "Close: " << std::chrono::duration_cast<dur_type>(m_close-m_start).count() << std::endl;
+    }
+private:
+    client m_endpoint;
+
+    std::chrono::high_resolution_clock::time_point m_start;
+    std::chrono::high_resolution_clock::time_point m_socket_init;
+    std::chrono::high_resolution_clock::time_point m_tls_init;
+    std::chrono::high_resolution_clock::time_point m_open;
+    std::chrono::high_resolution_clock::time_point m_message;
+    std::chrono::high_resolution_clock::time_point m_close;
+};
+
+int main(int argc, char* argv[]) {
+    std::string uri = "wss://echo.websocket.org";
+
+    if (argc == 2) {
+        uri = argv[1];
+    }
+
+    try {
+        perftest endpoint;
+        endpoint.start(uri);
+    } catch (const std::exception & e) {
+        std::cout << e.what() << std::endl;
+    } catch (websocketpp::lib::error_code e) {
+        std::cout << e.message() << std::endl;
+    } catch (...) {
+        std::cout << "other exception" << std::endl;
+    }
+}
diff --git a/extlibs/websocketpp/examples/debug_server/CMakeLists.txt b/extlibs/websocketpp/examples/debug_server/CMakeLists.txt
new file mode 100644
index 000000000..02f6dcf72
--- /dev/null
+++ b/extlibs/websocketpp/examples/debug_server/CMakeLists.txt
@@ -0,0 +1,10 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+init_target (debug_server)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+final_target ()
diff --git a/extlibs/websocketpp/examples/debug_server/SConscript b/extlibs/websocketpp/examples/debug_server/SConscript
new file mode 100644
index 000000000..4d02261c6
--- /dev/null
+++ b/extlibs/websocketpp/examples/debug_server/SConscript
@@ -0,0 +1,23 @@
+## Debug server example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('debug_server', ["debug_server.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('debug_server', ["debug_server.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/debug_server/debug_server.cpp b/extlibs/websocketpp/examples/debug_server/debug_server.cpp
new file mode 100644
index 000000000..111a394bb
--- /dev/null
+++ b/extlibs/websocketpp/examples/debug_server/debug_server.cpp
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** ====== WARNING ========
+ * This example is presently used as a scratch space. It may or may not be broken
+ * at any given time.
+ */
+
+#include <websocketpp/config/debug_asio_no_tls.hpp>
+
+// Custom logger
+#include <websocketpp/logger/syslog.hpp>
+
+#include <websocketpp/server.hpp>
+
+#include <iostream>
+
+////////////////////////////////////////////////////////////////////////////////
+///////////////// Custom Config for debugging custom policies //////////////////
+////////////////////////////////////////////////////////////////////////////////
+
+struct debug_custom : public websocketpp::config::debug_asio {
+    typedef debug_custom type;
+    typedef debug_asio base;
+
+    typedef base::concurrency_type concurrency_type;
+
+    typedef base::request_type request_type;
+    typedef base::response_type response_type;
+
+    typedef base::message_type message_type;
+    typedef base::con_msg_manager_type con_msg_manager_type;
+    typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    /// Custom Logging policies
+    /*typedef websocketpp::log::syslog<concurrency_type,
+        websocketpp::log::elevel> elog_type;
+    typedef websocketpp::log::syslog<concurrency_type,
+        websocketpp::log::alevel> alog_type;
+    */
+    typedef base::alog_type alog_type;
+    typedef base::elog_type elog_type;
+
+    typedef base::rng_type rng_type;
+
+    struct transport_config : public base::transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::alog_type alog_type;
+        typedef type::elog_type elog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+        typedef websocketpp::transport::asio::basic_socket::endpoint
+            socket_type;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+    
+    static const long timeout_open_handshake = 0;
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+typedef websocketpp::server<debug_custom> server;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+// pull out the type of messages sent by our config
+typedef server::message_ptr message_ptr;
+
+bool validate(server *, websocketpp::connection_hdl) {
+    //sleep(6);
+    return true;
+}
+
+void on_http(server* s, websocketpp::connection_hdl hdl) {
+    server::connection_ptr con = s->get_con_from_hdl(hdl);
+
+    std::string res = con->get_request_body();
+
+    std::stringstream ss;
+    ss << "got HTTP request with " << res.size() << " bytes of body data.";
+
+    con->set_body(ss.str());
+    con->set_status(websocketpp::http::status_code::ok);
+}
+
+void on_fail(server* s, websocketpp::connection_hdl hdl) {
+    server::connection_ptr con = s->get_con_from_hdl(hdl);
+    
+    std::cout << "Fail handler: " << con->get_ec() << " " << con->get_ec().message()  << std::endl;
+}
+
+void on_close(websocketpp::connection_hdl) {
+    std::cout << "Close handler" << std::endl;
+}
+
+// Define a callback to handle incoming messages
+void on_message(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
+    std::cout << "on_message called with hdl: " << hdl.lock().get()
+              << " and message: " << msg->get_payload()
+              << std::endl;
+
+    try {
+        s->send(hdl, msg->get_payload(), msg->get_opcode());
+    } catch (const websocketpp::lib::error_code& e) {
+        std::cout << "Echo failed because: " << e
+                  << "(" << e.message() << ")" << std::endl;
+    }
+}
+
+int main() {
+    // Create a server endpoint
+    server echo_server;
+
+    try {
+        // Set logging settings
+        echo_server.set_access_channels(websocketpp::log::alevel::all);
+        echo_server.clear_access_channels(websocketpp::log::alevel::frame_payload);
+
+        // Initialize ASIO
+        echo_server.init_asio();
+        echo_server.set_reuse_addr(true);
+
+        // Register our message handler
+        echo_server.set_message_handler(bind(&on_message,&echo_server,::_1,::_2));
+
+        echo_server.set_http_handler(bind(&on_http,&echo_server,::_1));
+        echo_server.set_fail_handler(bind(&on_fail,&echo_server,::_1));
+        echo_server.set_close_handler(&on_close);
+
+        echo_server.set_validate_handler(bind(&validate,&echo_server,::_1));
+
+        // Listen on port 9012
+        echo_server.listen(9012);
+
+        // Start the server accept loop
+        echo_server.start_accept();
+
+        // Start the ASIO io_service run loop
+        echo_server.run();
+    } catch (const std::exception & e) {
+        std::cout << e.what() << std::endl;
+    } catch (websocketpp::lib::error_code e) {
+        std::cout << e.message() << std::endl;
+    } catch (...) {
+        std::cout << "other exception" << std::endl;
+    }
+}
diff --git a/extlibs/websocketpp/examples/dev/SConscript b/extlibs/websocketpp/examples/dev/SConscript
new file mode 100644
index 000000000..34ddac2d5
--- /dev/null
+++ b/extlibs/websocketpp/examples/dev/SConscript
@@ -0,0 +1,18 @@
+## Main development example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework','system','timer','chrono'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('main', ["main.cpp"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/dev/main.cpp b/extlibs/websocketpp/examples/dev/main.cpp
new file mode 100644
index 000000000..3b7bdfbb0
--- /dev/null
+++ b/extlibs/websocketpp/examples/dev/main.cpp
@@ -0,0 +1,200 @@
+//#ifndef _WEBSOCKETPP_CPP11_STL_
+//    #define _WEBSOCKETPP_CPP11_STL_
+//#endif
+
+#include <random>
+#include <boost/timer/timer.hpp>
+
+#include <websocketpp/config/core.hpp>
+
+//#include <websocketpp/security/none.hpp>
+
+//#include <websocketpp/concurrency/none.hpp>
+//#include <websocketpp/concurrency/stl.hpp>
+
+//#include <websocketpp/transport/iostream.hpp>
+#include <websocketpp/server.hpp>
+
+#include <iostream>
+#include <sstream>
+
+//typedef websocketpp::concurrency::stl concurrency;
+//typedef websocketpp::transport::iostream<concurrency> transport;
+//typedef websocketpp::server<concurrency,transport> server;
+typedef websocketpp::server<websocketpp::config::core> server;
+
+/*class handler : public server::handler {
+    bool validate(connection_ptr con) {
+        std::cout << "handler validate" << std::endl;
+        if (con->get_origin() != "http://www.example.com") {
+            con->set_status(websocketpp::http::status_code::FORBIDDEN);
+            return false;
+        }
+        return true;
+    }
+
+    void http(connection_ptr con) {
+        std::cout << "handler http" << std::endl;
+    }
+
+    void on_load(connection_ptr con, ptr old_handler) {
+        std::cout << "handler on_load" << std::endl;
+    }
+    void on_unload(connection_ptr con, ptr new_handler) {
+        std::cout << "handler on_unload" << std::endl;
+    }
+
+    void on_open(connection_ptr con) {
+        std::cout << "handler on_open" << std::endl;
+    }
+    void on_fail(connection_ptr con) {
+        std::cout << "handler on_fail" << std::endl;
+    }
+
+    void on_message(connection_ptr con, message_ptr msg) {
+        std::cout << "handler on_message" << std::endl;
+
+
+    }
+
+    void on_close(connection_ptr con) {
+        std::cout << "handler on_close" << std::endl;
+    }
+};*/
+
+int main() {
+    typedef websocketpp::message_buffer::message<websocketpp::message_buffer::alloc::con_msg_manager>
+        message_type;
+    typedef websocketpp::message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_man_type;
+
+    con_msg_man_type::ptr manager = websocketpp::lib::make_shared<con_msg_man_type>();
+
+    size_t foo = 1024;
+
+    message_type::ptr input = manager->get_message(websocketpp::frame::opcode::TEXT,foo);
+    message_type::ptr output = manager->get_message(websocketpp::frame::opcode::TEXT,foo);
+    websocketpp::frame::masking_key_type key;
+
+    std::random_device dev;
+
+
+
+    key.i = 0x12345678;
+
+    double m = 18094238402394.0824923;
+
+    /*std::cout << "Some Math" << std::endl;
+    {
+        boost::timer::auto_cpu_timer t;
+
+        for (int i = 0; i < foo; i++) {
+            m /= 1.001;
+        }
+
+    }*/
+
+    std::cout << m << std::endl;
+
+    std::cout << "Random Gen" << std::endl;
+    {
+        boost::timer::auto_cpu_timer t;
+
+        input->get_raw_payload().replace(0,foo,foo,'\0');
+        output->get_raw_payload().replace(0,foo,foo,'\0');
+    }
+
+    std::cout << "Out of place accelerated" << std::endl;
+    {
+        boost::timer::auto_cpu_timer t;
+
+        websocketpp::frame::word_mask_exact(reinterpret_cast<uint8_t*>(const_cast<char*>(input->get_raw_payload().data())), reinterpret_cast<uint8_t*>(const_cast<char*>(output->get_raw_payload().data())), foo, key);
+    }
+
+    std::cout << websocketpp::utility::to_hex(input->get_payload().c_str(),20) << std::endl;
+    std::cout << websocketpp::utility::to_hex(output->get_payload().c_str(),20) << std::endl;
+
+    input->get_raw_payload().replace(0,foo,foo,'\0');
+    output->get_raw_payload().replace(0,foo,foo,'\0');
+
+    std::cout << "In place accelerated" << std::endl;
+    {
+        boost::timer::auto_cpu_timer t;
+
+        websocketpp::frame::word_mask_exact(reinterpret_cast<uint8_t*>(const_cast<char*>(input->get_raw_payload().data())), reinterpret_cast<uint8_t*>(const_cast<char*>(input->get_raw_payload().data())), foo, key);
+    }
+
+    std::cout << websocketpp::utility::to_hex(input->get_payload().c_str(),20) << std::endl;
+    std::cout << websocketpp::utility::to_hex(output->get_payload().c_str(),20) << std::endl;
+
+    input->get_raw_payload().replace(0,foo,foo,'\0');
+    output->get_raw_payload().replace(0,foo,foo,'\0');
+    std::cout << "Out of place byte by byte" << std::endl;
+    {
+        boost::timer::auto_cpu_timer t;
+
+        websocketpp::frame::byte_mask(input->get_raw_payload().begin(), input->get_raw_payload().end(), output->get_raw_payload().begin(), key);
+    }
+
+    std::cout << websocketpp::utility::to_hex(input->get_payload().c_str(),20) << std::endl;
+    std::cout << websocketpp::utility::to_hex(output->get_payload().c_str(),20) << std::endl;
+
+    input->get_raw_payload().replace(0,foo,foo,'\0');
+    output->get_raw_payload().replace(0,foo,foo,'\0');
+    std::cout << "In place byte by byte" << std::endl;
+    {
+        boost::timer::auto_cpu_timer t;
+
+        websocketpp::frame::byte_mask(input->get_raw_payload().begin(), input->get_raw_payload().end(), input->get_raw_payload().begin(), key);
+    }
+
+    std::cout << websocketpp::utility::to_hex(input->get_payload().c_str(),20) << std::endl;
+    std::cout << websocketpp::utility::to_hex(output->get_payload().c_str(),20) << std::endl;
+
+    input->get_raw_payload().replace(0,foo,foo,'a');
+    output->get_raw_payload().replace(0,foo,foo,'b');
+    std::cout << "Copy" << std::endl;
+    {
+        boost::timer::auto_cpu_timer t;
+
+        std::copy(input->get_raw_payload().begin(), input->get_raw_payload().end(), output->get_raw_payload().begin());
+    }
+
+    std::cout << websocketpp::utility::to_hex(input->get_payload().c_str(),20) << std::endl;
+    std::cout << websocketpp::utility::to_hex(output->get_payload().c_str(),20) << std::endl;
+
+    /*server::handler::ptr h(new handler());
+
+    server test_server(h);
+    server::connection_ptr con;
+
+    std::stringstream output;
+
+    test_server.register_ostream(&output);
+
+    con = test_server.get_connection();
+
+    con->start();
+
+    //foo.handle_accept(con,true);
+
+    std::stringstream input;
+    input << "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+    //input << "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n";
+    input >> *con;
+
+    std::stringstream input2;
+    input2 << "messageabc2";
+    input2 >> *con;
+
+    std::stringstream input3;
+    input3 << "messageabc3";
+    input3 >> *con;
+
+    std::stringstream input4;
+    input4 << "close";
+    input4 >> *con;
+
+    std::cout << "connection output:" << std::endl;
+    std::cout << output.str() << std::endl;*/
+}
diff --git a/extlibs/websocketpp/examples/echo_server/CMakeLists.txt b/extlibs/websocketpp/examples/echo_server/CMakeLists.txt
new file mode 100644
index 000000000..a82dfa792
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server/CMakeLists.txt
@@ -0,0 +1,10 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+init_target (echo_server)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+final_target ()
diff --git a/extlibs/websocketpp/examples/echo_server/SConscript b/extlibs/websocketpp/examples/echo_server/SConscript
new file mode 100644
index 000000000..a2978852e
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server/SConscript
@@ -0,0 +1,23 @@
+## Main development example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('echo_server', ["echo_server.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('echo_server', ["echo_server.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/echo_server/echo_handler.hpp b/extlibs/websocketpp/examples/echo_server/echo_handler.hpp
new file mode 100644
index 000000000..f55b867a2
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server/echo_handler.hpp
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2012, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_ECHO_SERVER_HANDLER_HPP
+#define WEBSOCKETPP_ECHO_SERVER_HANDLER_HPP
+
+class echo_handler : public server::handler {
+    void on_message(connection_ptr con, std::string msg) {
+        con->write(msg);
+    }
+};
+
+#endif // WEBSOCKETPP_ECHO_SERVER_HANDLER_HPP
diff --git a/extlibs/websocketpp/examples/echo_server/echo_server.cpp b/extlibs/websocketpp/examples/echo_server/echo_server.cpp
new file mode 100644
index 000000000..5ec576f94
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server/echo_server.cpp
@@ -0,0 +1,58 @@
+#include <websocketpp/config/asio_no_tls.hpp>
+
+#include <websocketpp/server.hpp>
+
+#include <iostream>
+
+typedef websocketpp::server<websocketpp::config::asio> server;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+// pull out the type of messages sent by our config
+typedef server::message_ptr message_ptr;
+
+// Define a callback to handle incoming messages
+void on_message(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
+    std::cout << "on_message called with hdl: " << hdl.lock().get()
+              << " and message: " << msg->get_payload()
+              << std::endl;
+
+    try {
+        s->send(hdl, msg->get_payload(), msg->get_opcode());
+    } catch (const websocketpp::lib::error_code& e) {
+        std::cout << "Echo failed because: " << e
+                  << "(" << e.message() << ")" << std::endl;
+    }
+}
+
+int main() {
+    // Create a server endpoint
+    server echo_server;
+
+    try {
+        // Set logging settings
+        echo_server.set_access_channels(websocketpp::log::alevel::all);
+        echo_server.clear_access_channels(websocketpp::log::alevel::frame_payload);
+
+        // Initialize ASIO
+        echo_server.init_asio();
+
+        // Register our message handler
+        echo_server.set_message_handler(bind(&on_message,&echo_server,::_1,::_2));
+
+        // Listen on port 9002
+        echo_server.listen(9002);
+
+        // Start the server accept loop
+        echo_server.start_accept();
+
+        // Start the ASIO io_service run loop
+        echo_server.run();
+    } catch (websocketpp::exception const & e) {
+        std::cout << e.what() << std::endl;
+    } catch (...) {
+        std::cout << "other exception" << std::endl;
+    }
+}
diff --git a/extlibs/websocketpp/examples/echo_server_both/CMakeLists.txt b/extlibs/websocketpp/examples/echo_server_both/CMakeLists.txt
new file mode 100644
index 000000000..1bb194db2
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server_both/CMakeLists.txt
@@ -0,0 +1,15 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+
+if (OPENSSL_FOUND)
+
+init_target (echo_server_both)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+link_openssl()
+final_target ()
+endif()
diff --git a/extlibs/websocketpp/examples/echo_server_both/SConscript b/extlibs/websocketpp/examples/echo_server_both/SConscript
new file mode 100644
index 000000000..d1ecf202f
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server_both/SConscript
@@ -0,0 +1,24 @@
+## Combo plain+tls echo server
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+Import('tls_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs] + [tls_libs]
+   prgs += env_cpp11.Program('echo_server_both', ["echo_server_both.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system'],env) + [platform_libs] + [polyfill_libs] + [tls_libs]
+   prgs += env.Program('echo_server_both', ["echo_server_both.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/echo_server_both/echo_server_both.cpp b/extlibs/websocketpp/examples/echo_server_both/echo_server_both.cpp
new file mode 100644
index 000000000..b277d5cf1
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server_both/echo_server_both.cpp
@@ -0,0 +1,87 @@
+#include <websocketpp/config/asio.hpp>
+#include <websocketpp/server.hpp>
+
+#include <iostream>
+
+// define types for two different server endpoints, one for each config we are
+// using
+typedef websocketpp::server<websocketpp::config::asio> server_plain;
+typedef websocketpp::server<websocketpp::config::asio_tls> server_tls;
+
+// alias some of the bind related functions as they are a bit long
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+// type of the ssl context pointer is long so alias it
+typedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;
+
+// The shared on_message handler takes a template parameter so the function can
+// resolve any endpoint dependent types like message_ptr or connection_ptr
+template <typename EndpointType>
+void on_message(EndpointType* s, websocketpp::connection_hdl hdl,
+    typename EndpointType::message_ptr msg)
+{
+    std::cout << "on_message called with hdl: " << hdl.lock().get()
+              << " and message: " << msg->get_payload()
+              << std::endl;
+
+    try {
+        s->send(hdl, msg->get_payload(), msg->get_opcode());
+    } catch (const websocketpp::lib::error_code& e) {
+        std::cout << "Echo failed because: " << e
+                  << "(" << e.message() << ")" << std::endl;
+    }
+}
+
+// No change to TLS init methods from echo_server_tls
+std::string get_password() {
+    return "test";
+}
+
+context_ptr on_tls_init(websocketpp::connection_hdl hdl) {
+    std::cout << "on_tls_init called with hdl: " << hdl.lock().get() << std::endl;
+    context_ptr ctx(new boost::asio::ssl::context(boost::asio::ssl::context::tlsv1));
+
+    try {
+        ctx->set_options(boost::asio::ssl::context::default_workarounds |
+                         boost::asio::ssl::context::no_sslv2 |
+                         boost::asio::ssl::context::no_sslv3 |
+                         boost::asio::ssl::context::single_dh_use);
+        ctx->set_password_callback(bind(&get_password));
+        ctx->use_certificate_chain_file("server.pem");
+        ctx->use_private_key_file("server.pem", boost::asio::ssl::context::pem);
+    } catch (std::exception& e) {
+        std::cout << e.what() << std::endl;
+    }
+    return ctx;
+}
+
+int main() {
+    // set up an external io_service to run both endpoints on. This is not
+    // strictly necessary, but simplifies thread management a bit.
+    boost::asio::io_service ios;
+
+    // set up plain endpoint
+    server_plain endpoint_plain;
+    // initialize asio with our external io_service rather than an internal one
+    endpoint_plain.init_asio(&ios);
+    endpoint_plain.set_message_handler(
+        bind(&on_message<server_plain>,&endpoint_plain,::_1,::_2));
+    endpoint_plain.listen(80);
+    endpoint_plain.start_accept();
+
+    // set up tls endpoint
+    server_tls endpoint_tls;
+    endpoint_tls.init_asio(&ios);
+    endpoint_tls.set_message_handler(
+        bind(&on_message<server_tls>,&endpoint_tls,::_1,::_2));
+    // TLS endpoint has an extra handler for the tls init
+    endpoint_tls.set_tls_init_handler(bind(&on_tls_init,::_1));
+    // tls endpoint listens on a different port
+    endpoint_tls.listen(443);
+    endpoint_tls.start_accept();
+
+    // Start the ASIO io_service run loop running both endpoints
+    ios.run();
+}
diff --git a/extlibs/websocketpp/examples/echo_server_both/server.pem b/extlibs/websocketpp/examples/echo_server_both/server.pem
new file mode 100644
index 000000000..9f679a49b
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server_both/server.pem
@@ -0,0 +1,58 @@
+-----BEGIN RSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: DES-EDE3-CBC,A0ED66EF872A48A9
+
+gXuvKojXzApVhhPVNdRliiajbC4PtwQG5c8TA7JADLgwOR7o9t6KtXEr37bDRpvB
+9aO9P+SJaK5OOp3XKPGthOdqv+tvCRTlmzmC8GjPLBX389DWT2xoGu7JkGwDtdSm
+rnF49Rlp5bfjpACk5xKNiKeDo1CWfeEJzw9Kto0g+5eMaEdors64oPzjXs3geA2g
+TxCJSHv9qSX6++pCLKKCUTbyzidAxV/Zb0AAubt5V40QKqX4HhSwwstFnTaX3tlb
+3QOdY+y04VIkM6d7qN5W8M7NzRkMpZ1qBpQcUMpkhQcRzWP2wub5AAff9D2GntRd
+4Dz1vn3u41U3Okdr0CNj+iH7byCzuokoAhk6ZQEN6WB+GTpGgfBXdtUZrfpb0MKm
+UNYP5AF2AmUqJRXhViTDVtu/V2tHF3LGuNT+W2Dz+spFZEq0byEO0N858eR0dikc
+6jOASvNQbSwD0+mkgBC1gXKKU3ngj2gpJUwljeACdWFd8N2egrZfyI05CmX7vPNC
+NXbs7k2buWNdjP4/D8IM+HDVidWzQa/kG/qokXKqllem9Egg37lUucwnP3cX2/Hw
+U2mfaBWzeZtqc+GqRp08rYIql+Reai3sUYlQMnNk01prVY47UQb+dxuqjaxGV5Xx
+Xkx0s2mfQnNRjL4S7Hjhqelufi6GpkCQ2EGsPpA+6K1ztZ0ame9Q2BE1SXeM/6vU
+rxT5nRrCxueyXAyQSGcqMX9//gSeK8WWBqG/c1IAMVDa0NWrJeOJhSziE+ta3B0m
+bHAPBY6vh0iB3lLdRlbUOPbC6R1TpxMOs+6Vbs2+OTifFpvOVymEoZq/nroyg68P
+vn5uCKogwWA7o8EArf/UTlIwWJmH9bgILdZKld4wMel2HQg16RDzm+mEXAJi52a/
+FC+fgfphdxltmUJ+rqOyR4AHULjaTWUQqTIB6sdlzgmES1nXAiE71zX//KFqomar
+O60SPPk3C1bs0x5DsvmGJa8SIfDhyd+D7NPyqwEKqrZsaotYGklNkfqxa6pa8mrc
+ejxquW1PK4FvBk26+osu5a90Jih0PcQM7DUMMr2WHdTiMSXWAiK2ToYF8Itt25Qv
+Cd0CsSYw9CJkXNr1u1+mObheaY9QYOmztnSJLy4ZO2JsMhqNwuAueIcwmhXOREq7
+kzlnGMgJcuSeAS/OBNj8Zgx0c7QQ0kzc+YmnOCsqoMtPsu/CsXJ4iJiM3Tki/2jT
+bywrTiQwE6R3a/87GREOREX+WLicZBWX3k9/4tBL5XSe1p5wPpuIRQUDvAGNfNHP
+JN7kujDF4SehilF1qtvCygAwvxHFDj+EwhXKNDKJzoZZIM15rAk3k92n2j6nz1qH
+a3xOU05yydOlO6F6w51I1QoDddmkzCRNB0TeO3D6rekHsCK1aDWmC+qRcm2ZFtVz
+sY6fdZN2NEmMQokIh9Opi1f8CSYSizPESMzdu2SF0xVO9n/IGIkn1ksK04O2BZo0
+X3LBPHLfCRsQNY1eF17bj07fYU2oPZKs/XzJiwxkqK6LFvpeAVaYrtg9fqRO/UVe
+QhUIj3BL550ocEpa15xLehLrmwzYiW5zwGjSHQ4EgZluGLCwyKGTh4QswEJRA9Rt
+-----END RSA PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIIE0DCCA7igAwIBAgIJAM5MuKJezXq0MA0GCSqGSIb3DQEBBQUAMIGgMQswCQYD
+VQQGEwJVUzERMA8GA1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xGDAW
+BgNVBAoTD1phcGhveWQgU3R1ZGlvczEUMBIGA1UECxMLV2ViU29ja2V0KysxFjAU
+BgNVBAMTDVBldGVyIFRob3Jzb24xJDAiBgkqhkiG9w0BCQEWFXdlYm1hc3RlckB6
+YXBob3lkLmNvbTAeFw0xMTExMTUyMTIwMDZaFw0xMjExMTQyMTIwMDZaMIGgMQsw
+CQYDVQQGEwJVUzERMA8GA1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28x
+GDAWBgNVBAoTD1phcGhveWQgU3R1ZGlvczEUMBIGA1UECxMLV2ViU29ja2V0Kysx
+FjAUBgNVBAMTDVBldGVyIFRob3Jzb24xJDAiBgkqhkiG9w0BCQEWFXdlYm1hc3Rl
+ckB6YXBob3lkLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANR0
+tdwAnIB8I9qRZ7QbzEWY95RpM7GIn0u/9oH90PzdHiE0rXSkKT+yw3XUzH0iw5t0
+5dEwSC+srSP5Vm4cA6kXc94agVVaPW89tGcdP4fHptCruSrzQsDXELCPl5UUvMpA
+YUcGisdXYPN/EeOoqb9wKWxoW5mREsyyeWWS89fYN5qU/d0QpbSvEWghqLbL/ZS2
+hOlXT9LufOeA+vHiV1/T/h5xC7ecIH02YDQw1EnqxbPmkLPcWThztLS9FiufNDRM
+Rhcoaj2b9VDHvDwdbeA0T5v5qNdG34LaapYOelxzQMOtM0f9Dgqehodyxl2qm9mR
+lq432dlOEzDnVCPNHwECAwEAAaOCAQkwggEFMB0GA1UdDgQWBBTTPKfNMnKOykhv
++vKS7vql5JsMyzCB1QYDVR0jBIHNMIHKgBTTPKfNMnKOykhv+vKS7vql5JsMy6GB
+pqSBozCBoDELMAkGA1UEBhMCVVMxETAPBgNVBAgTCElsbGlub2lzMRAwDgYDVQQH
+EwdDaGljYWdvMRgwFgYDVQQKEw9aYXBob3lkIFN0dWRpb3MxFDASBgNVBAsTC1dl
+YlNvY2tldCsrMRYwFAYDVQQDEw1QZXRlciBUaG9yc29uMSQwIgYJKoZIhvcNAQkB
+FhV3ZWJtYXN0ZXJAemFwaG95ZC5jb22CCQDOTLiiXs16tDAMBgNVHRMEBTADAQH/
+MA0GCSqGSIb3DQEBBQUAA4IBAQB+SH0s/hrv5VYqgX6SNLzxdSLvCVsUkCdTpxwY
+wOJ84XmYcXDMhKDtZqLtOtN6pfEwVusFlC9mkieuunztCnWNmsSG83RuljJPjFSi
+1d4Id4bKEQkQ4cfnjoHKivRrViWLnxuNnLzC6tpyGH/35kKWhhr6T58AXerFgVw3
+mHvLPTr1DuhdAZA0ZuvuseVAFFAjI3RetSySwHJE3ak8KswDVfLi6E3XxMVsIWTS
+/iFsC2WwoZQlljya2V/kRYIhu+uCdqJ01wunn2BvmURPSgr4GTBF0FQ9JGpNbXxM
+TAU7oQJgyFc5sCcuEgPTO0dWVQTvdZVgay4tkmduKDRkmJBF
+-----END CERTIFICATE-----
diff --git a/extlibs/websocketpp/examples/echo_server_tls/CMakeLists.txt b/extlibs/websocketpp/examples/echo_server_tls/CMakeLists.txt
new file mode 100644
index 000000000..b87cbb1f0
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server_tls/CMakeLists.txt
@@ -0,0 +1,15 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+
+if (OPENSSL_FOUND)
+
+init_target (echo_server_tls)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+link_openssl()
+final_target ()
+endif()
diff --git a/extlibs/websocketpp/examples/echo_server_tls/SConscript b/extlibs/websocketpp/examples/echo_server_tls/SConscript
new file mode 100644
index 000000000..e24cc4ce8
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server_tls/SConscript
@@ -0,0 +1,24 @@
+## Main development example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+Import('tls_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs] + [tls_libs]
+   prgs += env_cpp11.Program('echo_server_tls', ["echo_server_tls.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system'],env) + [platform_libs] + [polyfill_libs] + [tls_libs]
+   prgs += env.Program('echo_server_tls', ["echo_server_tls.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/echo_server_tls/echo_server_tls.cpp b/extlibs/websocketpp/examples/echo_server_tls/echo_server_tls.cpp
new file mode 100644
index 000000000..8408ebccc
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server_tls/echo_server_tls.cpp
@@ -0,0 +1,73 @@
+#include <websocketpp/config/asio.hpp>
+
+#include <websocketpp/server.hpp>
+
+#include <iostream>
+
+typedef websocketpp::server<websocketpp::config::asio_tls> server;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+// pull out the type of messages sent by our config
+typedef websocketpp::config::asio::message_type::ptr message_ptr;
+typedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;
+
+void on_message(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
+    std::cout << "on_message called with hdl: " << hdl.lock().get()
+              << " and message: " << msg->get_payload()
+              << std::endl;
+
+    try {
+        s->send(hdl, msg->get_payload(), msg->get_opcode());
+    } catch (const websocketpp::lib::error_code& e) {
+        std::cout << "Echo failed because: " << e
+                  << "(" << e.message() << ")" << std::endl;
+    }
+}
+
+std::string get_password() {
+    return "test";
+}
+
+context_ptr on_tls_init(websocketpp::connection_hdl hdl) {
+    std::cout << "on_tls_init called with hdl: " << hdl.lock().get() << std::endl;
+    context_ptr ctx = websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::tlsv1);
+
+    try {
+        ctx->set_options(boost::asio::ssl::context::default_workarounds |
+                         boost::asio::ssl::context::no_sslv2 |
+                         boost::asio::ssl::context::no_sslv3 |
+                         boost::asio::ssl::context::single_dh_use);
+        ctx->set_password_callback(bind(&get_password));
+        ctx->use_certificate_chain_file("server.pem");
+        ctx->use_private_key_file("server.pem", boost::asio::ssl::context::pem);
+    } catch (std::exception& e) {
+        std::cout << e.what() << std::endl;
+    }
+    return ctx;
+}
+
+int main() {
+    // Create a server endpoint
+    server echo_server;
+
+    // Initialize ASIO
+    echo_server.init_asio();
+
+    // Register our message handler
+    echo_server.set_message_handler(bind(&on_message,&echo_server,::_1,::_2));
+    echo_server.set_tls_init_handler(bind(&on_tls_init,::_1));
+
+
+    // Listen on port 9002
+    echo_server.listen(9002);
+
+    // Start the server accept loop
+    echo_server.start_accept();
+
+    // Start the ASIO io_service run loop
+    echo_server.run();
+
+}
diff --git a/extlibs/websocketpp/examples/echo_server_tls/server.pem b/extlibs/websocketpp/examples/echo_server_tls/server.pem
new file mode 100644
index 000000000..9f679a49b
--- /dev/null
+++ b/extlibs/websocketpp/examples/echo_server_tls/server.pem
@@ -0,0 +1,58 @@
+-----BEGIN RSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: DES-EDE3-CBC,A0ED66EF872A48A9
+
+gXuvKojXzApVhhPVNdRliiajbC4PtwQG5c8TA7JADLgwOR7o9t6KtXEr37bDRpvB
+9aO9P+SJaK5OOp3XKPGthOdqv+tvCRTlmzmC8GjPLBX389DWT2xoGu7JkGwDtdSm
+rnF49Rlp5bfjpACk5xKNiKeDo1CWfeEJzw9Kto0g+5eMaEdors64oPzjXs3geA2g
+TxCJSHv9qSX6++pCLKKCUTbyzidAxV/Zb0AAubt5V40QKqX4HhSwwstFnTaX3tlb
+3QOdY+y04VIkM6d7qN5W8M7NzRkMpZ1qBpQcUMpkhQcRzWP2wub5AAff9D2GntRd
+4Dz1vn3u41U3Okdr0CNj+iH7byCzuokoAhk6ZQEN6WB+GTpGgfBXdtUZrfpb0MKm
+UNYP5AF2AmUqJRXhViTDVtu/V2tHF3LGuNT+W2Dz+spFZEq0byEO0N858eR0dikc
+6jOASvNQbSwD0+mkgBC1gXKKU3ngj2gpJUwljeACdWFd8N2egrZfyI05CmX7vPNC
+NXbs7k2buWNdjP4/D8IM+HDVidWzQa/kG/qokXKqllem9Egg37lUucwnP3cX2/Hw
+U2mfaBWzeZtqc+GqRp08rYIql+Reai3sUYlQMnNk01prVY47UQb+dxuqjaxGV5Xx
+Xkx0s2mfQnNRjL4S7Hjhqelufi6GpkCQ2EGsPpA+6K1ztZ0ame9Q2BE1SXeM/6vU
+rxT5nRrCxueyXAyQSGcqMX9//gSeK8WWBqG/c1IAMVDa0NWrJeOJhSziE+ta3B0m
+bHAPBY6vh0iB3lLdRlbUOPbC6R1TpxMOs+6Vbs2+OTifFpvOVymEoZq/nroyg68P
+vn5uCKogwWA7o8EArf/UTlIwWJmH9bgILdZKld4wMel2HQg16RDzm+mEXAJi52a/
+FC+fgfphdxltmUJ+rqOyR4AHULjaTWUQqTIB6sdlzgmES1nXAiE71zX//KFqomar
+O60SPPk3C1bs0x5DsvmGJa8SIfDhyd+D7NPyqwEKqrZsaotYGklNkfqxa6pa8mrc
+ejxquW1PK4FvBk26+osu5a90Jih0PcQM7DUMMr2WHdTiMSXWAiK2ToYF8Itt25Qv
+Cd0CsSYw9CJkXNr1u1+mObheaY9QYOmztnSJLy4ZO2JsMhqNwuAueIcwmhXOREq7
+kzlnGMgJcuSeAS/OBNj8Zgx0c7QQ0kzc+YmnOCsqoMtPsu/CsXJ4iJiM3Tki/2jT
+bywrTiQwE6R3a/87GREOREX+WLicZBWX3k9/4tBL5XSe1p5wPpuIRQUDvAGNfNHP
+JN7kujDF4SehilF1qtvCygAwvxHFDj+EwhXKNDKJzoZZIM15rAk3k92n2j6nz1qH
+a3xOU05yydOlO6F6w51I1QoDddmkzCRNB0TeO3D6rekHsCK1aDWmC+qRcm2ZFtVz
+sY6fdZN2NEmMQokIh9Opi1f8CSYSizPESMzdu2SF0xVO9n/IGIkn1ksK04O2BZo0
+X3LBPHLfCRsQNY1eF17bj07fYU2oPZKs/XzJiwxkqK6LFvpeAVaYrtg9fqRO/UVe
+QhUIj3BL550ocEpa15xLehLrmwzYiW5zwGjSHQ4EgZluGLCwyKGTh4QswEJRA9Rt
+-----END RSA PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIIE0DCCA7igAwIBAgIJAM5MuKJezXq0MA0GCSqGSIb3DQEBBQUAMIGgMQswCQYD
+VQQGEwJVUzERMA8GA1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28xGDAW
+BgNVBAoTD1phcGhveWQgU3R1ZGlvczEUMBIGA1UECxMLV2ViU29ja2V0KysxFjAU
+BgNVBAMTDVBldGVyIFRob3Jzb24xJDAiBgkqhkiG9w0BCQEWFXdlYm1hc3RlckB6
+YXBob3lkLmNvbTAeFw0xMTExMTUyMTIwMDZaFw0xMjExMTQyMTIwMDZaMIGgMQsw
+CQYDVQQGEwJVUzERMA8GA1UECBMISWxsaW5vaXMxEDAOBgNVBAcTB0NoaWNhZ28x
+GDAWBgNVBAoTD1phcGhveWQgU3R1ZGlvczEUMBIGA1UECxMLV2ViU29ja2V0Kysx
+FjAUBgNVBAMTDVBldGVyIFRob3Jzb24xJDAiBgkqhkiG9w0BCQEWFXdlYm1hc3Rl
+ckB6YXBob3lkLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANR0
+tdwAnIB8I9qRZ7QbzEWY95RpM7GIn0u/9oH90PzdHiE0rXSkKT+yw3XUzH0iw5t0
+5dEwSC+srSP5Vm4cA6kXc94agVVaPW89tGcdP4fHptCruSrzQsDXELCPl5UUvMpA
+YUcGisdXYPN/EeOoqb9wKWxoW5mREsyyeWWS89fYN5qU/d0QpbSvEWghqLbL/ZS2
+hOlXT9LufOeA+vHiV1/T/h5xC7ecIH02YDQw1EnqxbPmkLPcWThztLS9FiufNDRM
+Rhcoaj2b9VDHvDwdbeA0T5v5qNdG34LaapYOelxzQMOtM0f9Dgqehodyxl2qm9mR
+lq432dlOEzDnVCPNHwECAwEAAaOCAQkwggEFMB0GA1UdDgQWBBTTPKfNMnKOykhv
++vKS7vql5JsMyzCB1QYDVR0jBIHNMIHKgBTTPKfNMnKOykhv+vKS7vql5JsMy6GB
+pqSBozCBoDELMAkGA1UEBhMCVVMxETAPBgNVBAgTCElsbGlub2lzMRAwDgYDVQQH
+EwdDaGljYWdvMRgwFgYDVQQKEw9aYXBob3lkIFN0dWRpb3MxFDASBgNVBAsTC1dl
+YlNvY2tldCsrMRYwFAYDVQQDEw1QZXRlciBUaG9yc29uMSQwIgYJKoZIhvcNAQkB
+FhV3ZWJtYXN0ZXJAemFwaG95ZC5jb22CCQDOTLiiXs16tDAMBgNVHRMEBTADAQH/
+MA0GCSqGSIb3DQEBBQUAA4IBAQB+SH0s/hrv5VYqgX6SNLzxdSLvCVsUkCdTpxwY
+wOJ84XmYcXDMhKDtZqLtOtN6pfEwVusFlC9mkieuunztCnWNmsSG83RuljJPjFSi
+1d4Id4bKEQkQ4cfnjoHKivRrViWLnxuNnLzC6tpyGH/35kKWhhr6T58AXerFgVw3
+mHvLPTr1DuhdAZA0ZuvuseVAFFAjI3RetSySwHJE3ak8KswDVfLi6E3XxMVsIWTS
+/iFsC2WwoZQlljya2V/kRYIhu+uCdqJ01wunn2BvmURPSgr4GTBF0FQ9JGpNbXxM
+TAU7oQJgyFc5sCcuEgPTO0dWVQTvdZVgay4tkmduKDRkmJBF
+-----END CERTIFICATE-----
diff --git a/extlibs/websocketpp/examples/enriched_storage/enriched_storage.cpp b/extlibs/websocketpp/examples/enriched_storage/enriched_storage.cpp
new file mode 100644
index 000000000..fbedc8ee2
--- /dev/null
+++ b/extlibs/websocketpp/examples/enriched_storage/enriched_storage.cpp
@@ -0,0 +1,87 @@
+#include <iostream>
+#include <websocketpp/config/asio_no_tls.hpp>
+#include <websocketpp/server.hpp>
+
+struct connection_data {
+    int sessionid;
+    std::string name;
+};
+
+struct custom_config : public websocketpp::config::asio {
+    // pull default settings from our core config
+    typedef websocketpp::config::asio core;
+    
+    typedef core::concurrency_type concurrency_type;
+    typedef core::request_type request_type;
+    typedef core::response_type response_type;
+    typedef core::message_type message_type;
+    typedef core::con_msg_manager_type con_msg_manager_type;
+    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;
+    typedef core::alog_type alog_type;
+    typedef core::elog_type elog_type;
+    typedef core::rng_type rng_type;
+    typedef core::transport_type transport_type;
+    typedef core::endpoint_base endpoint_base;
+    
+    // Set a custom connection_base class
+    typedef connection_data connection_base;
+};
+
+typedef websocketpp::server<custom_config> server;
+typedef server::connection_ptr connection_ptr;
+
+using websocketpp::connection_hdl;
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+class print_server {
+public:
+    print_server() : m_next_sessionid(1) {
+        m_server.init_asio();
+                
+        m_server.set_open_handler(bind(&print_server::on_open,this,::_1));
+        m_server.set_close_handler(bind(&print_server::on_close,this,::_1));
+        m_server.set_message_handler(bind(&print_server::on_message,this,::_1,::_2));
+    }
+    
+    void on_open(connection_hdl hdl) {
+        connection_ptr con = m_server.get_con_from_hdl(hdl);
+        
+        con->sessionid = m_next_sessionid++;
+    }
+    
+    void on_close(connection_hdl hdl) {
+        connection_ptr con = m_server.get_con_from_hdl(hdl);
+        
+        std::cout << "Closing connection " << con->name 
+                  << " with sessionid " << con->sessionid << std::endl;
+    }
+    
+    void on_message(connection_hdl hdl, server::message_ptr msg) {
+        connection_ptr con = m_server.get_con_from_hdl(hdl);
+        
+        if (con->name == "") {
+            con->name = msg->get_payload();
+            std::cout << "Setting name of connection with sessionid " 
+                      << con->sessionid << " to " << con->name << std::endl;
+        } else {
+            std::cout << "Got a message from connection " << con->name 
+                      << " with sessionid " << con->sessionid << std::endl;
+        }
+    }
+    
+    void run(uint16_t port) {
+        m_server.listen(port);
+        m_server.start_accept();
+        m_server.run();
+    }
+private:
+    int m_next_sessionid;
+    server m_server;
+};
+
+int main() {
+    print_server server;
+    server.run(9002);
+}
\ No newline at end of file
diff --git a/extlibs/websocketpp/examples/handler_switch/handler_switch.cpp b/extlibs/websocketpp/examples/handler_switch/handler_switch.cpp
new file mode 100644
index 000000000..c2cf6ffa4
--- /dev/null
+++ b/extlibs/websocketpp/examples/handler_switch/handler_switch.cpp
@@ -0,0 +1,42 @@
+#include <iostream>
+
+#include <websocketpp/config/asio_no_tls.hpp>
+#include <websocketpp/server.hpp>
+
+typedef websocketpp::server<websocketpp::config::asio> server;
+
+using websocketpp::connection_hdl;
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+using websocketpp::lib::ref;
+
+void custom_on_msg(server & s, connection_hdl hdl, server::message_ptr msg) {
+        std::cout << "Message sent to custom handler" << std::endl;
+}
+
+void default_on_msg(server & s, connection_hdl hdl, server::message_ptr msg) {
+    std::cout << "Message sent to default handler" << std::endl;
+
+    if (msg->get_payload() == "upgrade") {
+        // Upgrade our connection_hdl to a full connection_ptr
+        server::connection_ptr con = s.get_con_from_hdl(hdl);
+
+        // Change the on message handler for this connection only to
+        // custom_on_mesage
+        con->set_message_handler(bind(&custom_on_msg,ref(s),::_1,::_2));
+        std::cout << "Upgrading connection to custom handler" << std::endl;
+    }
+}
+
+int main() {
+    server s;
+
+    s.set_message_handler(bind(&default_on_msg,ref(s),::_1,::_2));
+
+    s.init_asio();
+    s.listen(9002);
+    s.start_accept();
+
+    s.run();
+}
diff --git a/extlibs/websocketpp/examples/iostream_server/SConscript b/extlibs/websocketpp/examples/iostream_server/SConscript
new file mode 100644
index 000000000..dc90834cf
--- /dev/null
+++ b/extlibs/websocketpp/examples/iostream_server/SConscript
@@ -0,0 +1,23 @@
+## iostream server example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('iostream_server', ["iostream_server.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('iostream_server', ["iostream_server.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/iostream_server/iostream_server.cpp b/extlibs/websocketpp/examples/iostream_server/iostream_server.cpp
new file mode 100644
index 000000000..6843659cd
--- /dev/null
+++ b/extlibs/websocketpp/examples/iostream_server/iostream_server.cpp
@@ -0,0 +1,89 @@
+#include <websocketpp/config/core.hpp>
+
+#include <websocketpp/server.hpp>
+
+#include <iostream>
+#include <fstream>
+
+typedef websocketpp::server<websocketpp::config::core> server;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+// pull out the type of messages sent by our config
+typedef server::message_ptr message_ptr;
+
+// Define a callback to handle incoming messages
+void on_message(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
+    if (msg->get_opcode() == websocketpp::frame::opcode::text) {
+        s->get_alog().write(websocketpp::log::alevel::app,
+                    "Text Message Received: "+msg->get_payload());
+    } else {
+        s->get_alog().write(websocketpp::log::alevel::app,
+                    "Binary Message Received: "+websocketpp::utility::to_hex(msg->get_payload()));
+    }
+
+    try {
+        s->send(hdl, msg->get_payload(), msg->get_opcode());
+    } catch (const websocketpp::lib::error_code& e) {
+        s->get_alog().write(websocketpp::log::alevel::app,
+                    "Echo Failed: "+e.message());
+    }
+}
+
+int main() {
+    server s;
+    std::ofstream log;
+
+    try {
+        // set up access channels to only log interesting things
+        s.clear_access_channels(websocketpp::log::alevel::all);
+        s.set_access_channels(websocketpp::log::alevel::connect);
+        s.set_access_channels(websocketpp::log::alevel::disconnect);
+        s.set_access_channels(websocketpp::log::alevel::app);
+
+        // Log to a file rather than stdout, as we are using stdout for real
+        // output
+        log.open("output.log");
+        s.get_alog().set_ostream(&log);
+        s.get_elog().set_ostream(&log);
+
+        // print all output to stdout
+        s.register_ostream(&std::cout);
+
+        // Register our message handler
+        s.set_message_handler(bind(&on_message,&s,::_1,::_2));
+
+        server::connection_ptr con = s.get_connection();
+
+        con->start();
+
+        // C++ iostream's don't support the idea of asynchronous i/o. As such
+        // there are two input strategies demonstrated here. Buffered I/O will
+        // read from stdin in chunks until EOF. This works very well for
+        // replaying canned connections as would be done in automated testing.
+        //
+        // If the server is being used live however, assuming input is being
+        // piped from elsewhere in realtime, this strategy will result in small
+        // messages being buffered forever. The non-buffered strategy below
+        // reads characters from stdin one at a time. This is inefficient and
+        // for more serious uses should be replaced with a platform specific
+        // asyncronous i/o technique like select, poll, IOCP, etc
+        bool buffered_io = false;
+
+        if (buffered_io) {
+            std::cin >> *con;
+            con->eof();
+        } else {
+            char a;
+            while(std::cin.get(a)) {
+                con->read_some(&a,1);
+            }
+            con->eof();
+        }
+    } catch (websocketpp::exception const & e) {
+        std::cout << e.what() << std::endl;
+    }
+    log.close();
+}
diff --git a/extlibs/websocketpp/examples/print_server/CMakeLists.txt b/extlibs/websocketpp/examples/print_server/CMakeLists.txt
new file mode 100644
index 000000000..dc34879b6
--- /dev/null
+++ b/extlibs/websocketpp/examples/print_server/CMakeLists.txt
@@ -0,0 +1,10 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+init_target (print_server)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+final_target ()
diff --git a/extlibs/websocketpp/examples/print_server/SConscript b/extlibs/websocketpp/examples/print_server/SConscript
new file mode 100644
index 000000000..4f0e492be
--- /dev/null
+++ b/extlibs/websocketpp/examples/print_server/SConscript
@@ -0,0 +1,23 @@
+## Print server example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('print_server', ["print_server.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('print_server', ["print_server.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/print_server/print_server.cpp b/extlibs/websocketpp/examples/print_server/print_server.cpp
new file mode 100644
index 000000000..78fb0e8f9
--- /dev/null
+++ b/extlibs/websocketpp/examples/print_server/print_server.cpp
@@ -0,0 +1,22 @@
+#include <iostream>
+
+#include <websocketpp/config/asio_no_tls.hpp>
+#include <websocketpp/server.hpp>
+
+typedef websocketpp::server<websocketpp::config::asio> server;
+
+void on_message(websocketpp::connection_hdl, server::message_ptr msg) {
+        std::cout << msg->get_payload() << std::endl;
+}
+
+int main() {
+    server print_server;
+
+    print_server.set_message_handler(&on_message);
+
+    print_server.init_asio();
+    print_server.listen(9002);
+    print_server.start_accept();
+
+    print_server.run();
+}
diff --git a/extlibs/websocketpp/examples/simple_broadcast_server/simple_broadcast_server.cpp b/extlibs/websocketpp/examples/simple_broadcast_server/simple_broadcast_server.cpp
new file mode 100644
index 000000000..7c4847693
--- /dev/null
+++ b/extlibs/websocketpp/examples/simple_broadcast_server/simple_broadcast_server.cpp
@@ -0,0 +1,51 @@
+#include <set>
+#include <websocketpp/config/asio_no_tls.hpp>
+#include <websocketpp/server.hpp>
+
+typedef websocketpp::server<websocketpp::config::asio> server;
+
+using websocketpp::connection_hdl;
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+class broadcast_server {
+public:
+    broadcast_server() {
+        m_server.init_asio();
+
+        m_server.set_open_handler(bind(&broadcast_server::on_open,this,::_1));
+        m_server.set_close_handler(bind(&broadcast_server::on_close,this,::_1));
+        m_server.set_message_handler(bind(&broadcast_server::on_message,this,::_1,::_2));
+    }
+
+    void on_open(connection_hdl hdl) {
+        m_connections.insert(hdl);
+    }
+
+    void on_close(connection_hdl hdl) {
+        m_connections.erase(hdl);
+    }
+
+    void on_message(connection_hdl hdl, server::message_ptr msg) {
+        for (auto it : m_connections) {
+            m_server.send(it,msg);
+        }
+    }
+
+    void run(uint16_t port) {
+        m_server.listen(port);
+        m_server.start_accept();
+        m_server.run();
+    }
+private:
+    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;
+
+    server m_server;
+    con_list m_connections;
+};
+
+int main() {
+    broadcast_server server;
+    server.run(9002);
+}
diff --git a/extlibs/websocketpp/examples/sip_client/CMakeLists.txt b/extlibs/websocketpp/examples/sip_client/CMakeLists.txt
new file mode 100644
index 000000000..65a90b01c
--- /dev/null
+++ b/extlibs/websocketpp/examples/sip_client/CMakeLists.txt
@@ -0,0 +1,11 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+init_target (sip_client)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+final_target ()
+
diff --git a/extlibs/websocketpp/examples/sip_client/README.txt b/extlibs/websocketpp/examples/sip_client/README.txt
new file mode 100644
index 000000000..ce3271c33
--- /dev/null
+++ b/extlibs/websocketpp/examples/sip_client/README.txt
@@ -0,0 +1,22 @@
+
+
+Checkout the project from git
+
+At the top level, run cmake:
+
+  cmake -G 'Unix Makefiles' \
+     -D BUILD_EXAMPLES=ON \
+     -D WEBSOCKETPP_ROOT=/tmp/cm1 \
+     -D ENABLE_CPP11=OFF .
+
+and then make the example:
+
+  make -C examples/sip_client
+
+Now run it:
+
+  bin/sip_client ws://ws-server:80
+
+It has been tested against the repro SIP proxy from reSIProcate
+
+  http://www.resiprocate.org/WebRTC_and_SIP_Over_WebSockets
diff --git a/extlibs/websocketpp/examples/sip_client/SConscript b/extlibs/websocketpp/examples/sip_client/SConscript
new file mode 100644
index 000000000..59b62d091
--- /dev/null
+++ b/extlibs/websocketpp/examples/sip_client/SConscript
@@ -0,0 +1,23 @@
+## SIP client example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is avaliable build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('sip_client', ["sip_client.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system','random'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('sip_client', ["sip_client.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/sip_client/sip_client.cpp b/extlibs/websocketpp/examples/sip_client/sip_client.cpp
new file mode 100644
index 000000000..66fa85784
--- /dev/null
+++ b/extlibs/websocketpp/examples/sip_client/sip_client.cpp
@@ -0,0 +1,84 @@
+#include <condition_variable>
+
+#include <websocketpp/config/asio_no_tls_client.hpp>
+
+#include <websocketpp/client.hpp>
+
+#include <iostream>
+
+#include <boost/thread/thread.hpp>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+// pull out the type of messages sent by our config
+typedef websocketpp::config::asio_client::message_type::ptr message_ptr;
+
+// Create a server endpoint
+client sip_client;
+
+
+bool received;
+
+void on_open(client* c, websocketpp::connection_hdl hdl) {
+    // now it is safe to use the connection
+    std::cout << "connection ready" << std::endl;
+
+    received=false;
+    // Send a SIP OPTIONS message to the server:
+    std::string SIP_msg="OPTIONS sip:carol@chicago.com SIP/2.0\r\nVia: SIP/2.0/WS df7jal23ls0d.invalid;rport;branch=z9hG4bKhjhs8ass877\r\nMax-Forwards: 70\r\nTo: <sip:carol@chicago.com>\r\nFrom: Alice <sip:alice@atlanta.com>;tag=1928301774\r\nCall-ID: a84b4c76e66710\r\nCSeq: 63104 OPTIONS\r\nContact: <sip:alice@pc33.atlanta.com>\r\nAccept: application/sdp\r\nContent-Length: 0\r\n\r\n";
+    sip_client.send(hdl, SIP_msg.c_str(), websocketpp::frame::opcode::text);
+}
+
+void on_message(client* c, websocketpp::connection_hdl hdl, message_ptr msg) {
+    client::connection_ptr con = sip_client.get_con_from_hdl(hdl);
+
+    std::cout << "Received a reply:" << std::endl;
+    fwrite(msg->get_payload().c_str(), msg->get_payload().size(), 1, stdout);
+    received=true;
+}
+
+int main(int argc, char* argv[]) {
+
+    std::string uri = "ws://localhost:9001";
+
+    if (argc == 2) {
+        uri = argv[1];
+    }
+
+    try {
+        // We expect there to be a lot of errors, so suppress them
+        sip_client.clear_access_channels(websocketpp::log::alevel::all);
+        sip_client.clear_error_channels(websocketpp::log::elevel::all);
+
+        // Initialize ASIO
+        sip_client.init_asio();
+
+        // Register our handlers
+        sip_client.set_open_handler(bind(&on_open,&sip_client,::_1));
+        sip_client.set_message_handler(bind(&on_message,&sip_client,::_1,::_2));
+
+        websocketpp::lib::error_code ec;
+        client::connection_ptr con = sip_client.get_connection(uri, ec);
+
+        // Specify the SIP subprotocol:
+        con->add_subprotocol("sip");
+
+        sip_client.connect(con);
+
+        // Start the ASIO io_service run loop
+        sip_client.run();
+
+        while(!received) {
+            boost::this_thread::sleep(boost::posix_time::milliseconds(100));
+        }
+
+        std::cout << "done" << std::endl;
+
+    } catch (websocketpp::exception const & e) {
+        std::cout << e.what() << std::endl;
+    }
+}
diff --git a/extlibs/websocketpp/examples/subprotocol_server/SConscript b/extlibs/websocketpp/examples/subprotocol_server/SConscript
new file mode 100644
index 000000000..e97535ca5
--- /dev/null
+++ b/extlibs/websocketpp/examples/subprotocol_server/SConscript
@@ -0,0 +1,23 @@
+## Main development example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('subprotocol_server', ["subprotocol_server.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('subprotocol_server', ["subprotocol_server.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/subprotocol_server/subprotocol_server.cpp b/extlibs/websocketpp/examples/subprotocol_server/subprotocol_server.cpp
new file mode 100644
index 000000000..9593c0152
--- /dev/null
+++ b/extlibs/websocketpp/examples/subprotocol_server/subprotocol_server.cpp
@@ -0,0 +1,48 @@
+#include <iostream>
+
+#include <websocketpp/config/asio_no_tls.hpp>
+#include <websocketpp/server.hpp>
+
+typedef websocketpp::server<websocketpp::config::asio> server;
+
+using websocketpp::connection_hdl;
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+using websocketpp::lib::ref;
+
+
+bool validate(server & s, connection_hdl hdl) {
+    server::connection_ptr con = s.get_con_from_hdl(hdl);
+
+    std::cout << "Cache-Control: " << con->get_request_header("Cache-Control") << std::endl;
+
+    const std::vector<std::string> & subp_requests = con->get_requested_subprotocols();
+    std::vector<std::string>::const_iterator it;
+
+    for (it = subp_requests.begin(); it != subp_requests.end(); ++it) {
+        std::cout << "Requested: " << *it << std::endl;
+    }
+
+    if (subp_requests.size() > 0) {
+        con->select_subprotocol(subp_requests[0]);
+    }
+
+    return true;
+}
+
+int main() {
+    try {
+        server s;
+
+        s.set_validate_handler(bind(&validate,ref(s),::_1));
+
+        s.init_asio();
+        s.listen(9005);
+        s.start_accept();
+
+        s.run();
+    } catch (websocketpp::exception const & e) {
+        std::cout << e.what() << std::endl;
+    }
+}
diff --git a/extlibs/websocketpp/examples/telemetry_client/CMakeLists.txt b/extlibs/websocketpp/examples/telemetry_client/CMakeLists.txt
new file mode 100644
index 000000000..5cf4964e9
--- /dev/null
+++ b/extlibs/websocketpp/examples/telemetry_client/CMakeLists.txt
@@ -0,0 +1,10 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+init_target (telemetry_client)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+final_target ()
diff --git a/extlibs/websocketpp/examples/telemetry_client/SConscript b/extlibs/websocketpp/examples/telemetry_client/SConscript
new file mode 100644
index 000000000..62396a5e3
--- /dev/null
+++ b/extlibs/websocketpp/examples/telemetry_client/SConscript
@@ -0,0 +1,23 @@
+## Telemetry client example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('telemetry_client', ["telemetry_client.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system','random'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('telemetry_client', ["telemetry_client.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/telemetry_client/telemetry_client.cpp b/extlibs/websocketpp/examples/telemetry_client/telemetry_client.cpp
new file mode 100644
index 000000000..658fb3d46
--- /dev/null
+++ b/extlibs/websocketpp/examples/telemetry_client/telemetry_client.cpp
@@ -0,0 +1,156 @@
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+// This header pulls in the WebSocket++ abstracted thread support that will
+// select between boost::thread and std::thread based on how the build system
+// is configured.
+#include <websocketpp/common/thread.hpp>
+
+/**
+ * The telemetry client connects to a WebSocket server and sends a message every
+ * second containing an integer count. This example can be used as the basis for
+ * programs where a client connects and pushes data for logging, stress/load
+ * testing, etc.
+ */
+class telemetry_client {
+public:
+    typedef websocketpp::client<websocketpp::config::asio_client> client;
+    typedef websocketpp::lib::lock_guard<websocketpp::lib::mutex> scoped_lock;
+
+    telemetry_client() : m_open(false),m_done(false) {
+        // set up access channels to only log interesting things
+        m_client.clear_access_channels(websocketpp::log::alevel::all);
+        m_client.set_access_channels(websocketpp::log::alevel::connect);
+        m_client.set_access_channels(websocketpp::log::alevel::disconnect);
+        m_client.set_access_channels(websocketpp::log::alevel::app);
+
+        // Initialize the Asio transport policy
+        m_client.init_asio();
+
+        // Bind the handlers we are using
+        using websocketpp::lib::placeholders::_1;
+        using websocketpp::lib::bind;
+        m_client.set_open_handler(bind(&telemetry_client::on_open,this,::_1));
+        m_client.set_close_handler(bind(&telemetry_client::on_close,this,::_1));
+        m_client.set_fail_handler(bind(&telemetry_client::on_fail,this,::_1));
+    }
+
+    // This method will block until the connection is complete
+    void run(const std::string & uri) {
+        // Create a new connection to the given URI
+        websocketpp::lib::error_code ec;
+        client::connection_ptr con = m_client.get_connection(uri, ec);
+        if (ec) {
+            m_client.get_alog().write(websocketpp::log::alevel::app,
+                    "Get Connection Error: "+ec.message());
+            return;
+        }
+
+        // Grab a handle for this connection so we can talk to it in a thread
+        // safe manor after the event loop starts.
+        m_hdl = con->get_handle();
+
+        // Queue the connection. No DNS queries or network connections will be
+        // made until the io_service event loop is run.
+        m_client.connect(con);
+
+        // Create a thread to run the ASIO io_service event loop
+        websocketpp::lib::thread asio_thread(&client::run, &m_client);
+
+        // Create a thread to run the telemetry loop
+        websocketpp::lib::thread telemetry_thread(&telemetry_client::telemetry_loop,this);
+
+        asio_thread.join();
+        telemetry_thread.join();
+    }
+
+    // The open handler will signal that we are ready to start sending telemetry
+    void on_open(websocketpp::connection_hdl) {
+        m_client.get_alog().write(websocketpp::log::alevel::app,
+            "Connection opened, starting telemetry!");
+
+        scoped_lock guard(m_lock);
+        m_open = true;
+    }
+
+    // The close handler will signal that we should stop sending telemetry
+    void on_close(websocketpp::connection_hdl) {
+        m_client.get_alog().write(websocketpp::log::alevel::app,
+            "Connection closed, stopping telemetry!");
+
+        scoped_lock guard(m_lock);
+        m_done = true;
+    }
+
+    // The fail handler will signal that we should stop sending telemetry
+    void on_fail(websocketpp::connection_hdl) {
+        m_client.get_alog().write(websocketpp::log::alevel::app,
+            "Connection failed, stopping telemetry!");
+
+        scoped_lock guard(m_lock);
+        m_done = true;
+    }
+
+    void telemetry_loop() {
+        uint64_t count = 0;
+        std::stringstream val;
+        websocketpp::lib::error_code ec;
+
+        while(1) {
+            bool wait = false;
+
+            {
+                scoped_lock guard(m_lock);
+                // If the connection has been closed, stop generating telemetry
+                if (m_done) {break;}
+
+                // If the connection hasn't been opened yet wait a bit and retry
+                if (!m_open) {
+                    wait = true;
+                }
+            }
+
+            if (wait) {
+                sleep(1);
+                continue;
+            }
+
+            val.str("");
+            val << "count is " << count++;
+
+            m_client.get_alog().write(websocketpp::log::alevel::app, val.str());
+            m_client.send(m_hdl,val.str(),websocketpp::frame::opcode::text,ec);
+
+            // The most likely error that we will get is that the connection is
+            // not in the right state. Usually this means we tried to send a
+            // message to a connection that was closed or in the process of
+            // closing. While many errors here can be easily recovered from,
+            // in this simple example, we'll stop the telemetry loop.
+            if (ec) {
+                m_client.get_alog().write(websocketpp::log::alevel::app,
+                    "Send Error: "+ec.message());
+                break;
+            }
+
+            sleep(1);
+        }
+    }
+private:
+    client m_client;
+    websocketpp::connection_hdl m_hdl;
+    websocketpp::lib::mutex m_lock;
+    bool m_open;
+    bool m_done;
+};
+
+int main(int argc, char* argv[]) {
+    telemetry_client c;
+
+    std::string uri = "ws://localhost:9002";
+
+    if (argc == 2) {
+        uri = argv[1];
+    }
+
+    c.run(uri);
+}
diff --git a/extlibs/websocketpp/examples/telemetry_server/CMakeLists.txt b/extlibs/websocketpp/examples/telemetry_server/CMakeLists.txt
new file mode 100644
index 000000000..7ee569b07
--- /dev/null
+++ b/extlibs/websocketpp/examples/telemetry_server/CMakeLists.txt
@@ -0,0 +1,10 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+init_target (telemetry_server)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+final_target ()
diff --git a/extlibs/websocketpp/examples/telemetry_server/SConscript b/extlibs/websocketpp/examples/telemetry_server/SConscript
new file mode 100644
index 000000000..1b8ff2295
--- /dev/null
+++ b/extlibs/websocketpp/examples/telemetry_server/SConscript
@@ -0,0 +1,23 @@
+## Main development example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('telemetry_server', ["telemetry_server.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('telemetry_server', ["telemetry_server.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/telemetry_server/index.html b/extlibs/websocketpp/examples/telemetry_server/index.html
new file mode 100644
index 000000000..def50dd6a
--- /dev/null
+++ b/extlibs/websocketpp/examples/telemetry_server/index.html
@@ -0,0 +1,85 @@
+<!doctype html>
+<html>
+<head>
+<title>WebSocket++ Telemetry Client</title>
+</head>
+<body>
+
+<script type="text/javascript">
+var ws;
+var url;
+
+function connect() {
+	url = document.getElementById("server_url").value;
+	
+	if ("WebSocket" in window) {
+		ws = new WebSocket(url);
+	} else if ("MozWebSocket" in window) {
+		ws = new MozWebSocket(url);
+	} else {
+		document.getElementById("messages").innerHTML += "This Browser does not support WebSockets<br />";
+		return;
+	}
+	ws.onopen = function(e) {
+		document.getElementById("messages").innerHTML += "Client: A connection to "+ws.url+" has been opened.<br />";
+		
+		document.getElementById("server_url").disabled = true;
+		document.getElementById("toggle_connect").innerHTML = "Disconnect";
+	};
+	
+	ws.onerror = function(e) {
+		document.getElementById("messages").innerHTML += "Client: An error occured, see console log for more details.<br />";
+		console.log(e);
+	};
+	
+	ws.onclose = function(e) {
+		document.getElementById("messages").innerHTML += "Client: The connection to "+url+" was closed. ["+e.code+(e.reason != "" ? ","+e.reason : "")+"]<br />";
+	    cleanup_disconnect();
+	};
+	
+	ws.onmessage = function(e) {
+		document.getElementById("messages").innerHTML += "Server: "+e.data+"<br />";
+	};
+}
+
+function disconnect() {
+	ws.close();
+	cleanup_disconnect();
+}
+
+function cleanup_disconnect() {
+    document.getElementById("server_url").disabled = false;
+	document.getElementById("toggle_connect").innerHTML = "Connect";
+}
+
+function toggle_connect() {
+	if (document.getElementById("server_url").disabled === false) {
+		connect();
+	} else {
+		disconnect();
+	}
+}
+</script>
+
+<style>
+body,html {
+	margin: 0px;
+	padding: 0px;
+}
+#controls {
+	float:right;
+	background-color: #999;
+}
+
+</style>
+
+<div id="controls">
+	<div id="server">
+	<input type="text" name="server_url" id="server_url" value="ws://localhost:9002" /><br />
+	<button id="toggle_connect" onclick="toggle_connect();">Connect</button>
+	</div>
+</div>
+<div id="messages"></div>
+
+</body>
+</html>
diff --git a/extlibs/websocketpp/examples/telemetry_server/telemetry_server.cpp b/extlibs/websocketpp/examples/telemetry_server/telemetry_server.cpp
new file mode 100644
index 000000000..80a791343
--- /dev/null
+++ b/extlibs/websocketpp/examples/telemetry_server/telemetry_server.cpp
@@ -0,0 +1,204 @@
+#include <websocketpp/config/asio_no_tls.hpp>
+
+#include <websocketpp/server.hpp>
+
+#include <fstream>
+#include <iostream>
+#include <set>
+#include <streambuf>
+#include <string>
+
+/**
+ * The telemetry server accepts connections and sends a message every second to
+ * each client containing an integer count. This example can be used as the
+ * basis for programs that expose a stream of telemetry data for logging,
+ * dashboards, etc.
+ *
+ * This example uses the timer based concurrency method and is self contained
+ * and singled threaded. Refer to telemetry client for an example of a similar
+ * telemetry setup using threads rather than timers.
+ *
+ * This example also includes an example simple HTTP server that serves a web
+ * dashboard displaying the count. This simple design is suitable for use 
+ * delivering a small number of files to a small number of clients. It is ideal
+ * for cases like embedded dashboards that don't want the complexity of an extra
+ * HTTP server to serve static files.
+ *
+ * This design *will* fall over under high traffic or DoS conditions. In such
+ * cases you are much better off proxying to a real HTTP server for the http
+ * requests.
+ */
+class telemetry_server {
+public:
+    typedef websocketpp::connection_hdl connection_hdl;
+    typedef websocketpp::server<websocketpp::config::asio> server;
+    typedef websocketpp::lib::lock_guard<websocketpp::lib::mutex> scoped_lock;
+
+    telemetry_server() : m_count(0) {
+        // set up access channels to only log interesting things
+        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);
+        m_endpoint.set_access_channels(websocketpp::log::alevel::access_core);
+        m_endpoint.set_access_channels(websocketpp::log::alevel::app);
+
+        // Initialize the Asio transport policy
+        m_endpoint.init_asio();
+
+        // Bind the handlers we are using
+        using websocketpp::lib::placeholders::_1;
+        using websocketpp::lib::bind;
+        m_endpoint.set_open_handler(bind(&telemetry_server::on_open,this,::_1));
+        m_endpoint.set_close_handler(bind(&telemetry_server::on_close,this,::_1));
+        m_endpoint.set_http_handler(bind(&telemetry_server::on_http,this,::_1));
+    }
+
+    void run(std::string docroot, uint16_t port) {
+        std::stringstream ss;
+        ss << "Running telemetry server on port "<< port <<" using docroot=" << docroot;
+        m_endpoint.get_alog().write(websocketpp::log::alevel::app,ss.str());
+        
+        m_docroot = docroot;
+        
+        // listen on specified port
+        m_endpoint.listen(port);
+
+        // Start the server accept loop
+        m_endpoint.start_accept();
+
+        // Set the initial timer to start telemetry
+        set_timer();
+
+        // Start the ASIO io_service run loop
+        try {
+            m_endpoint.run();
+        } catch (websocketpp::exception const & e) {
+            std::cout << e.what() << std::endl;
+        }
+    }
+
+    void set_timer() {
+        m_timer = m_endpoint.set_timer(
+            1000,
+            websocketpp::lib::bind(
+                &telemetry_server::on_timer,
+                this,
+                websocketpp::lib::placeholders::_1
+            )
+        );
+    }
+
+    void on_timer(websocketpp::lib::error_code const & ec) {
+        if (ec) {
+            // there was an error, stop telemetry
+            m_endpoint.get_alog().write(websocketpp::log::alevel::app,
+                    "Timer Error: "+ec.message());
+            return;
+        }
+        
+        std::stringstream val;
+        val << "count is " << m_count++;
+        
+        // Broadcast count to all connections
+        con_list::iterator it;
+        for (it = m_connections.begin(); it != m_connections.end(); ++it) {
+            m_endpoint.send(*it,val.str(),websocketpp::frame::opcode::text);
+        }
+        
+        // set timer for next telemetry check
+        set_timer();
+    }
+
+    void on_http(connection_hdl hdl) {
+        // Upgrade our connection handle to a full connection_ptr
+        server::connection_ptr con = m_endpoint.get_con_from_hdl(hdl);
+    
+        std::ifstream file;
+        std::string filename = con->get_uri()->get_resource();
+        std::string response;
+    
+        m_endpoint.get_alog().write(websocketpp::log::alevel::app,
+            "http request1: "+filename);
+    
+        if (filename == "/") {
+            filename = m_docroot+"index.html";
+        } else {
+            filename = m_docroot+filename.substr(1);
+        }
+        
+        m_endpoint.get_alog().write(websocketpp::log::alevel::app,
+            "http request2: "+filename);
+    
+        file.open(filename.c_str(), std::ios::in);
+        if (!file) {
+            // 404 error
+            std::stringstream ss;
+        
+            ss << "<!doctype html><html><head>"
+               << "<title>Error 404 (Resource not found)</title><body>"
+               << "<h1>Error 404</h1>"
+               << "<p>The requested URL " << filename << " was not found on this server.</p>"
+               << "</body></head></html>";
+        
+            con->set_body(ss.str());
+            con->set_status(websocketpp::http::status_code::not_found);
+            return;
+        }
+    
+        file.seekg(0, std::ios::end);
+        response.reserve(file.tellg());
+        file.seekg(0, std::ios::beg);
+    
+        response.assign((std::istreambuf_iterator<char>(file)),
+                        std::istreambuf_iterator<char>());
+    
+        con->set_body(response);
+        con->set_status(websocketpp::http::status_code::ok);
+    }
+
+    void on_open(connection_hdl hdl) {
+        m_connections.insert(hdl);
+    }
+
+    void on_close(connection_hdl hdl) {
+        m_connections.erase(hdl);
+    }
+private:
+    typedef std::set<connection_hdl,std::owner_less<connection_hdl>> con_list;
+    
+    server m_endpoint;
+    con_list m_connections;
+    server::timer_ptr m_timer;
+    
+    std::string m_docroot;
+    
+    // Telemetry data
+    uint64_t m_count;
+};
+
+int main(int argc, char* argv[]) {
+    telemetry_server s;
+
+    std::string docroot;
+    uint16_t port = 9002;
+
+    if (argc == 1) {
+        std::cout << "Usage: telemetry_server [documentroot] [port]" << std::endl;
+        return 1;
+    }
+    
+    if (argc >= 2) {
+        docroot = std::string(argv[1]);
+    }
+        
+    if (argc >= 3) {
+        int i = atoi(argv[2]);
+        if (i <= 0 || i > 65535) {
+            std::cout << "invalid port" << std::endl;
+            return 1;
+        }
+        
+        port = uint16_t(i);
+    }
+
+    s.run(docroot, port);
+    return 0;
+}
\ No newline at end of file
diff --git a/extlibs/websocketpp/examples/testee_client/CMakeLists.txt b/extlibs/websocketpp/examples/testee_client/CMakeLists.txt
new file mode 100644
index 000000000..a6ca6dd35
--- /dev/null
+++ b/extlibs/websocketpp/examples/testee_client/CMakeLists.txt
@@ -0,0 +1,11 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+init_target (testee_client)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+final_target ()
+
diff --git a/extlibs/websocketpp/examples/testee_client/SConscript b/extlibs/websocketpp/examples/testee_client/SConscript
new file mode 100644
index 000000000..9547f3fc4
--- /dev/null
+++ b/extlibs/websocketpp/examples/testee_client/SConscript
@@ -0,0 +1,23 @@
+## Autobahn test client example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('testee_client', ["testee_client.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system','random'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('testee_client', ["testee_client.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/testee_client/testee_client.cpp b/extlibs/websocketpp/examples/testee_client/testee_client.cpp
new file mode 100644
index 000000000..d191df579
--- /dev/null
+++ b/extlibs/websocketpp/examples/testee_client/testee_client.cpp
@@ -0,0 +1,80 @@
+#include <websocketpp/config/asio_no_tls_client.hpp>
+
+#include <websocketpp/client.hpp>
+
+#include <iostream>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+// pull out the type of messages sent by our config
+typedef websocketpp::config::asio_client::message_type::ptr message_ptr;
+
+int case_count = 0;
+
+void on_message(client* c, websocketpp::connection_hdl hdl, message_ptr msg) {
+    client::connection_ptr con = c->get_con_from_hdl(hdl);
+
+    if (con->get_resource() == "/getCaseCount") {
+        std::cout << "Detected " << msg->get_payload() << " test cases."
+                  << std::endl;
+        case_count = atoi(msg->get_payload().c_str());
+    } else {
+        c->send(hdl, msg->get_payload(), msg->get_opcode());
+    }
+}
+
+int main(int argc, char* argv[]) {
+    // Create a server endpoint
+    client c;
+
+    std::string uri = "ws://localhost:9001";
+
+    if (argc == 2) {
+        uri = argv[1];
+    }
+
+    try {
+        // We expect there to be a lot of errors, so suppress them
+        c.clear_access_channels(websocketpp::log::alevel::all);
+        c.clear_error_channels(websocketpp::log::elevel::all);
+
+        // Initialize ASIO
+        c.init_asio();
+
+        // Register our handlers
+        c.set_message_handler(bind(&on_message,&c,::_1,::_2));
+
+        websocketpp::lib::error_code ec;
+        client::connection_ptr con = c.get_connection(uri+"/getCaseCount", ec);
+        c.connect(con);
+
+        // Start the ASIO io_service run loop
+        c.run();
+
+        std::cout << "case count: " << case_count << std::endl;
+
+        for (int i = 1; i <= case_count; i++) {
+            c.reset();
+
+            std::stringstream url;
+
+            url << uri << "/runCase?case=" << i << "&agent="
+                << websocketpp::user_agent;
+
+            con = c.get_connection(url.str(), ec);
+
+            c.connect(con);
+
+            c.run();
+        }
+
+        std::cout << "done" << std::endl;
+
+    } catch (websocketpp::exception const & e) {
+        std::cout << e.what() << std::endl;
+    }
+}
diff --git a/extlibs/websocketpp/examples/testee_server/SConscript b/extlibs/websocketpp/examples/testee_server/SConscript
new file mode 100644
index 000000000..526886f68
--- /dev/null
+++ b/extlibs/websocketpp/examples/testee_server/SConscript
@@ -0,0 +1,23 @@
+## Autobahn Testee Server
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('testee_server', ["testee_server.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('testee_server', ["testee_server.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/testee_server/testee_server.cpp b/extlibs/websocketpp/examples/testee_server/testee_server.cpp
new file mode 100644
index 000000000..d44368c88
--- /dev/null
+++ b/extlibs/websocketpp/examples/testee_server/testee_server.cpp
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <websocketpp/config/asio_no_tls.hpp>
+#include <websocketpp/server.hpp>
+#include <iostream>
+
+struct testee_config : public websocketpp::config::asio {
+    // pull default settings from our core config
+    typedef websocketpp::config::asio core;
+
+    typedef core::concurrency_type concurrency_type;
+    typedef core::request_type request_type;
+    typedef core::response_type response_type;
+    typedef core::message_type message_type;
+    typedef core::con_msg_manager_type con_msg_manager_type;
+    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef core::alog_type alog_type;
+    typedef core::elog_type elog_type;
+    typedef core::rng_type rng_type;
+    typedef core::endpoint_base endpoint_base;
+
+    static bool const enable_multithreading = true;
+
+    struct transport_config : public core::transport_config {
+        typedef core::concurrency_type concurrency_type;
+        typedef core::elog_type elog_type;
+        typedef core::alog_type alog_type;
+        typedef core::request_type request_type;
+        typedef core::response_type response_type;
+
+        static bool const enable_multithreading = true;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+
+    static const websocketpp::log::level elog_level =
+        websocketpp::log::elevel::none;
+    static const websocketpp::log::level alog_level =
+        websocketpp::log::alevel::none;
+};
+
+typedef websocketpp::server<testee_config> server;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+// pull out the type of messages sent by our config
+typedef server::message_ptr message_ptr;
+
+// Define a callback to handle incoming messages
+void on_message(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
+    s->send(hdl, msg->get_payload(), msg->get_opcode());
+}
+
+void on_socket_init(websocketpp::connection_hdl, boost::asio::ip::tcp::socket & s) {
+    boost::asio::ip::tcp::no_delay option(true);
+    s.set_option(option);
+}
+
+int main(int argc, char * argv[]) {
+    // Create a server endpoint
+    server testee_server;
+
+    short port = 9002;
+    size_t num_threads = 1;
+
+    if (argc == 3) {
+        port = atoi(argv[1]);
+        num_threads = atoi(argv[2]);
+    }
+
+    try {
+        // Total silence
+        testee_server.clear_access_channels(websocketpp::log::alevel::all);
+        testee_server.clear_error_channels(websocketpp::log::alevel::all);
+
+        // Initialize ASIO
+        testee_server.init_asio();
+        testee_server.set_reuse_addr(true);
+
+        // Register our message handler
+        testee_server.set_message_handler(bind(&on_message,&testee_server,::_1,::_2));
+        testee_server.set_socket_init_handler(bind(&on_socket_init,::_1,::_2));
+
+        // Listen on specified port with extended listen backlog
+        testee_server.set_listen_backlog(8192);
+        testee_server.listen(port);
+
+        // Start the server accept loop
+        testee_server.start_accept();
+
+        // Start the ASIO io_service run loop
+        if (num_threads == 1) {
+            testee_server.run();
+        } else {
+            typedef websocketpp::lib::shared_ptr<websocketpp::lib::thread> thread_ptr;
+            std::vector<thread_ptr> ts;
+            for (size_t i = 0; i < num_threads; i++) {
+                ts.push_back(websocketpp::lib::make_shared<websocketpp::lib::thread>(&server::run, &testee_server));
+            }
+
+            for (size_t i = 0; i < num_threads; i++) {
+                ts[i]->join();
+            }
+        }
+
+    } catch (websocketpp::exception const & e) {
+        std::cout << "exception: " << e.what() << std::endl;
+    }
+}
diff --git a/extlibs/websocketpp/examples/utility_client/CMakeLists.txt b/extlibs/websocketpp/examples/utility_client/CMakeLists.txt
new file mode 100644
index 000000000..865a4c783
--- /dev/null
+++ b/extlibs/websocketpp/examples/utility_client/CMakeLists.txt
@@ -0,0 +1,11 @@
+
+file (GLOB SOURCE_FILES *.cpp)
+file (GLOB HEADER_FILES *.hpp)
+
+init_target (utility_client)
+
+build_executable (${TARGET_NAME} ${SOURCE_FILES} ${HEADER_FILES})
+
+link_boost ()
+final_target ()
+
diff --git a/extlibs/websocketpp/examples/utility_client/SConscript b/extlibs/websocketpp/examples/utility_client/SConscript
new file mode 100644
index 000000000..88def4b08
--- /dev/null
+++ b/extlibs/websocketpp/examples/utility_client/SConscript
@@ -0,0 +1,23 @@
+## Utility client example
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+prgs = []
+
+# if a C++11 environment is available build using that, otherwise use boost
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   ALL_LIBS = boostlibs(['system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   prgs += env_cpp11.Program('utility_client', ["utility_client.cpp"], LIBS = ALL_LIBS)
+else:
+   ALL_LIBS = boostlibs(['system','random'],env) + [platform_libs] + [polyfill_libs]
+   prgs += env.Program('utility_client', ["utility_client.cpp"], LIBS = ALL_LIBS)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/examples/utility_client/utility_client.cpp b/extlibs/websocketpp/examples/utility_client/utility_client.cpp
new file mode 100644
index 000000000..ee13f16a5
--- /dev/null
+++ b/extlibs/websocketpp/examples/utility_client/utility_client.cpp
@@ -0,0 +1,325 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+// **NOTE:** This file is a snapshot of the WebSocket++ utility client tutorial.
+// Additional related material can be found in the tutorials/utility_client
+// directory of the WebSocket++ repository.
+
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+#include <websocketpp/common/thread.hpp>
+#include <websocketpp/common/memory.hpp>
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <string>
+#include <sstream>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+class connection_metadata {
+public:
+    typedef websocketpp::lib::shared_ptr<connection_metadata> ptr;
+
+    connection_metadata(int id, websocketpp::connection_hdl hdl, std::string uri)
+      : m_id(id)
+      , m_hdl(hdl)
+      , m_status("Connecting")
+      , m_uri(uri)
+      , m_server("N/A")
+    {}
+
+    void on_open(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Open";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+    }
+
+    void on_fail(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Failed";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+        m_error_reason = con->get_ec().message();
+    }
+    
+    void on_close(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Closed";
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        std::stringstream s;
+        s << "close code: " << con->get_remote_close_code() << " (" 
+          << websocketpp::close::status::get_string(con->get_remote_close_code()) 
+          << "), close reason: " << con->get_remote_close_reason();
+        m_error_reason = s.str();
+    }
+
+    void on_message(websocketpp::connection_hdl, client::message_ptr msg) {
+        if (msg->get_opcode() == websocketpp::frame::opcode::text) {
+            m_messages.push_back("<< " + msg->get_payload());
+        } else {
+            m_messages.push_back("<< " + websocketpp::utility::to_hex(msg->get_payload()));
+        }
+    }
+
+    websocketpp::connection_hdl get_hdl() const {
+        return m_hdl;
+    }
+    
+    int get_id() const {
+        return m_id;
+    }
+    
+    std::string get_status() const {
+        return m_status;
+    }
+
+    void record_sent_message(std::string message) {
+        m_messages.push_back(">> " + message);
+    }
+
+    friend std::ostream & operator<< (std::ostream & out, connection_metadata const & data);
+private:
+    int m_id;
+    websocketpp::connection_hdl m_hdl;
+    std::string m_status;
+    std::string m_uri;
+    std::string m_server;
+    std::string m_error_reason;
+    std::vector<std::string> m_messages;
+};
+
+std::ostream & operator<< (std::ostream & out, connection_metadata const & data) {
+    out << "> URI: " << data.m_uri << "\n"
+        << "> Status: " << data.m_status << "\n"
+        << "> Remote Server: " << (data.m_server.empty() ? "None Specified" : data.m_server) << "\n"
+        << "> Error/close reason: " << (data.m_error_reason.empty() ? "N/A" : data.m_error_reason) << "\n";
+    out << "> Messages Processed: (" << data.m_messages.size() << ") \n";
+
+    std::vector<std::string>::const_iterator it;
+    for (it = data.m_messages.begin(); it != data.m_messages.end(); ++it) {
+        out << *it << "\n";
+    }
+
+    return out;
+}
+
+class websocket_endpoint {
+public:
+    websocket_endpoint () : m_next_id(0) {
+        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);
+        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);
+
+        m_endpoint.init_asio();
+        m_endpoint.start_perpetual();
+
+        m_thread = websocketpp::lib::make_shared<websocketpp::lib::thread>(&client::run, &m_endpoint);
+    }
+
+    ~websocket_endpoint() {
+        m_endpoint.stop_perpetual();
+        
+        for (con_list::const_iterator it = m_connection_list.begin(); it != m_connection_list.end(); ++it) {
+            if (it->second->get_status() != "Open") {
+                // Only close open connections
+                continue;
+            }
+            
+            std::cout << "> Closing connection " << it->second->get_id() << std::endl;
+            
+            websocketpp::lib::error_code ec;
+            m_endpoint.close(it->second->get_hdl(), websocketpp::close::status::going_away, "", ec);
+            if (ec) {
+                std::cout << "> Error closing connection " << it->second->get_id() << ": "  
+                          << ec.message() << std::endl;
+            }
+        }
+        
+        m_thread->join();
+    }
+
+    int connect(std::string const & uri) {
+        websocketpp::lib::error_code ec;
+
+        client::connection_ptr con = m_endpoint.get_connection(uri, ec);
+
+        if (ec) {
+            std::cout << "> Connect initialization error: " << ec.message() << std::endl;
+            return -1;
+        }
+
+        int new_id = m_next_id++;
+        connection_metadata::ptr metadata_ptr = websocketpp::lib::make_shared<connection_metadata>(new_id, con->get_handle(), uri);
+        m_connection_list[new_id] = metadata_ptr;
+
+        con->set_open_handler(websocketpp::lib::bind(
+            &connection_metadata::on_open,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_fail_handler(websocketpp::lib::bind(
+            &connection_metadata::on_fail,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_close_handler(websocketpp::lib::bind(
+            &connection_metadata::on_close,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_message_handler(websocketpp::lib::bind(
+            &connection_metadata::on_message,
+            metadata_ptr,
+            websocketpp::lib::placeholders::_1,
+            websocketpp::lib::placeholders::_2
+        ));
+
+        m_endpoint.connect(con);
+
+        return new_id;
+    }
+
+    void close(int id, websocketpp::close::status::value code, std::string reason) {
+        websocketpp::lib::error_code ec;
+        
+        con_list::iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            std::cout << "> No connection found with id " << id << std::endl;
+            return;
+        }
+        
+        m_endpoint.close(metadata_it->second->get_hdl(), code, reason, ec);
+        if (ec) {
+            std::cout << "> Error initiating close: " << ec.message() << std::endl;
+        }
+    }
+
+    void send(int id, std::string message) {
+        websocketpp::lib::error_code ec;
+        
+        con_list::iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            std::cout << "> No connection found with id " << id << std::endl;
+            return;
+        }
+        
+        m_endpoint.send(metadata_it->second->get_hdl(), message, websocketpp::frame::opcode::text, ec);
+        if (ec) {
+            std::cout << "> Error sending message: " << ec.message() << std::endl;
+            return;
+        }
+        
+        metadata_it->second->record_sent_message(message);
+    }
+
+    connection_metadata::ptr get_metadata(int id) const {
+        con_list::const_iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            return connection_metadata::ptr();
+        } else {
+            return metadata_it->second;
+        }
+    }
+private:
+    typedef std::map<int,connection_metadata::ptr> con_list;
+
+    client m_endpoint;
+    websocketpp::lib::shared_ptr<websocketpp::lib::thread> m_thread;
+
+    con_list m_connection_list;
+    int m_next_id;
+};
+
+int main() {
+    bool done = false;
+    std::string input;
+    websocket_endpoint endpoint;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout
+                << "\nCommand List:\n"
+                << "connect <ws uri>\n"
+                << "send <connection id> <message>\n"
+                << "close <connection id> [<close code:default=1000>] [<close reason>]\n"
+                << "show <connection id>\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else if (input.substr(0,7) == "connect") {
+            int id = endpoint.connect(input.substr(8));
+            if (id != -1) {
+                std::cout << "> Created connection with id " << id << std::endl;
+            }
+        } else if (input.substr(0,4) == "send") {
+            std::stringstream ss(input);
+            
+            std::string cmd;
+            int id;
+            std::string message = "";
+            
+            ss >> cmd >> id;
+            std::getline(ss,message);
+            
+            endpoint.send(id, message);
+        } else if (input.substr(0,5) == "close") {
+            std::stringstream ss(input);
+            
+            std::string cmd;
+            int id;
+            int close_code = websocketpp::close::status::normal;
+            std::string reason = "";
+            
+            ss >> cmd >> id >> close_code;
+            std::getline(ss,reason);
+            
+            endpoint.close(id, close_code, reason);
+        } else if (input.substr(0,4) == "show") {
+            int id = atoi(input.substr(5).c_str());
+
+            connection_metadata::ptr metadata = endpoint.get_metadata(id);
+            if (metadata) {
+                std::cout << *metadata << std::endl;
+            } else {
+                std::cout << "> Unknown connection id " << id << std::endl;
+            }
+        } else {
+            std::cout << "> Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
diff --git a/extlibs/websocketpp/readme.md b/extlibs/websocketpp/readme.md
new file mode 100644
index 000000000..a9551373d
--- /dev/null
+++ b/extlibs/websocketpp/readme.md
@@ -0,0 +1,45 @@
+WebSocket++ (0.5.1)
+==========================
+
+WebSocket++ is a header only C++ library that implements RFC6455 The WebSocket
+Protocol. It allows integrating WebSocket client and server functionality into
+C++ programs. It uses interchangeable network transport modules including one
+based on C++ iostreams and one based on Boost Asio.
+
+Major Features
+==============
+* Full support for RFC6455
+* Partial support for Hixie 76 / Hybi 00, 07-17 draft specs (server only)
+* Message/event based interface
+* Supports secure WebSockets (TLS), IPv6, and explicit proxies.
+* Flexible dependency management (C++11 Standard Library or Boost)
+* Interchangeable network transport modules (iostream and Boost Asio)
+* Portable/cross platform (Posix/Windows, 32/64bit, Intel/ARM/PPC)
+* Thread-safe
+
+Get Involved
+============
+
+[![Build Status](https://travis-ci.org/zaphoyd/websocketpp.png)](https://travis-ci.org/zaphoyd/websocketpp)
+
+**Project Website**
+http://www.zaphoyd.com/websocketpp/
+
+**User Manual**
+http://www.zaphoyd.com/websocketpp/manual/
+
+**GitHub Repository**
+https://github.com/zaphoyd/websocketpp/
+
+**Announcements Mailing List**
+http://groups.google.com/group/websocketpp-announcements/
+
+**IRC Channel**
+ #websocketpp (freenode)
+
+**Discussion / Development / Support Mailing List / Forum**
+http://groups.google.com/group/websocketpp/
+
+Author
+======
+Peter Thorson - websocketpp@zaphoyd.com
diff --git a/extlibs/websocketpp/roadmap.md b/extlibs/websocketpp/roadmap.md
new file mode 100644
index 000000000..b35c54ad0
--- /dev/null
+++ b/extlibs/websocketpp/roadmap.md
@@ -0,0 +1,43 @@
+Complete & Tested:
+- Server and client roles pass all Autobahn v0.5.9 test suite tests strictly
+- Streaming UTF8 validation
+- random number generation
+- iostream based transport
+- C++11 support
+- LLVM/Clang support
+- GCC support
+- 64 bit support
+- 32 bit support
+- Logging
+- Client role
+- message_handler
+- ping_handler
+- pong_handler
+- open_handler
+- close_handler
+- echo_server & echo_server_tls
+- External io_service support
+- TLS support
+- exception/error handling
+- Timeouts
+- Subprotocol negotiation
+- validate_handler
+- Hybi 00/Hixie 76 legacy protocol support
+- Outgoing Proxy Support
+- socket_init_handler
+- tls_init_handler
+- tcp_init_handler
+
+Ongoing work
+- Performance tuning
+- PowerPC support
+- Visual Studio / Windows support
+- CMake build/install support
+- http_handler
+
+Future feature roadmap
+- Extension support
+- permessage_compress extension
+- Message buffer pool
+- flow control
+- tutorials & documentation
diff --git a/extlibs/websocketpp/test/connection/SConscript b/extlibs/websocketpp/test/connection/SConscript
new file mode 100644
index 000000000..4ed7a4e69
--- /dev/null
+++ b/extlibs/websocketpp/test/connection/SConscript
@@ -0,0 +1,25 @@
+## connection unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system'],env) + [platform_libs]
+
+objs = env.Object('connection_boost.o', ["connection.cpp"], LIBS = BOOST_LIBS)
+objs = env.Object('connection_tu2_boost.o', ["connection_tu2.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_connection_boost', ["connection_boost.o","connection_tu2_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework','system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   objs += env_cpp11.Object('connection_stl.o', ["connection.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('connection_tu2_stl.o', ["connection_tu2.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_connection_stl', ["connection_stl.o","connection_tu2_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/connection/connection.cpp b/extlibs/websocketpp/test/connection/connection.cpp
new file mode 100644
index 000000000..0c67bd193
--- /dev/null
+++ b/extlibs/websocketpp/test/connection/connection.cpp
@@ -0,0 +1,478 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE connection
+#include <boost/test/unit_test.hpp>
+
+#include "connection_tu2.hpp"
+
+// Include special debugging transport
+//#include <websocketpp/config/minimal_client.hpp>
+#include <websocketpp/transport/debug/endpoint.hpp>
+
+// NOTE: these tests currently test against hardcoded output values. I am not
+// sure how problematic this will be. If issues arise like order of headers the
+// output should be parsed by http::response and have values checked directly
+
+BOOST_AUTO_TEST_CASE( basic_http_request ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n";
+    std::string output = "HTTP/1.1 426 Upgrade Required\r\nServer: " +
+                         std::string(websocketpp::user_agent)+"\r\n\r\n";
+
+    std::string o2 = run_server_test(input);
+
+    BOOST_CHECK(o2 == output);
+}
+
+struct connection_extension {
+    connection_extension() : extension_value(5) {}
+
+    int extension_method() {
+        return extension_value;
+    }
+
+    bool is_server() const {
+        return false;
+    }
+
+    int extension_value;
+};
+
+struct stub_config : public websocketpp::config::core {
+    typedef core::concurrency_type concurrency_type;
+
+    typedef core::request_type request_type;
+    typedef core::response_type response_type;
+
+    typedef core::message_type message_type;
+    typedef core::con_msg_manager_type con_msg_manager_type;
+    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef core::alog_type alog_type;
+    typedef core::elog_type elog_type;
+
+    typedef core::rng_type rng_type;
+
+    typedef core::transport_type transport_type;
+
+    typedef core::endpoint_base endpoint_base;
+    typedef connection_extension connection_base;
+};
+
+struct debug_config_client : public websocketpp::config::core {
+    typedef debug_config_client type;
+    
+    typedef core::concurrency_type concurrency_type;
+
+    typedef core::request_type request_type;
+    typedef core::response_type response_type;
+
+    typedef core::message_type message_type;
+    typedef core::con_msg_manager_type con_msg_manager_type;
+    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef core::alog_type alog_type;
+    typedef core::elog_type elog_type;
+
+    typedef websocketpp::random::none::int_generator<uint32_t> rng_type;
+
+    struct transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::elog_type elog_type;
+        typedef type::alog_type alog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+
+        /// Controls compile time enabling/disabling of thread syncronization
+        /// code Disabling can provide a minor performance improvement to single
+        /// threaded applications
+        static bool const enable_multithreading = true;
+
+        /// Default timer values (in ms)
+        static const long timeout_socket_pre_init = 5000;
+        static const long timeout_proxy = 5000;
+        static const long timeout_socket_post_init = 5000;
+        static const long timeout_connect = 5000;
+        static const long timeout_socket_shutdown = 5000;
+    };
+
+    /// Transport Endpoint Component
+    typedef websocketpp::transport::debug::endpoint<transport_config>
+        transport_type;
+
+    typedef core::endpoint_base endpoint_base;
+    typedef connection_extension connection_base;
+    
+    static const websocketpp::log::level elog_level = websocketpp::log::elevel::none;
+    static const websocketpp::log::level alog_level = websocketpp::log::alevel::none;
+};
+
+struct connection_setup {
+    connection_setup(bool p_is_server) : c(p_is_server, "", alog, elog, rng) {}
+
+    websocketpp::lib::error_code ec;
+    stub_config::alog_type alog;
+    stub_config::elog_type elog;
+    stub_config::rng_type rng;
+    websocketpp::connection<stub_config> c;
+};
+
+typedef websocketpp::client<debug_config_client> debug_client;
+typedef websocketpp::server<debug_config_client> debug_server;
+
+/*void echo_func(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
+    s->send(hdl, msg->get_payload(), msg->get_opcode());
+}*/
+
+void validate_func(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
+    s->send(hdl, msg->get_payload(), msg->get_opcode());
+}
+
+bool validate_set_ua(server* s, websocketpp::connection_hdl hdl) {
+    server::connection_ptr con = s->get_con_from_hdl(hdl);
+    con->replace_header("Server","foo");
+    return true;
+}
+
+void http_func(server* s, websocketpp::connection_hdl hdl) {
+    server::connection_ptr con = s->get_con_from_hdl(hdl);
+
+    std::string res = con->get_resource();
+
+    con->set_body(res);
+    con->set_status(websocketpp::http::status_code::ok);
+}
+
+void check_on_fail(server* s, websocketpp::lib::error_code ec, bool & called, 
+    websocketpp::connection_hdl hdl)
+{
+    server::connection_ptr con = s->get_con_from_hdl(hdl);
+
+    BOOST_CHECK_EQUAL(ec, con->get_ec());
+    called = true;
+}
+
+void on_open_print(server* s, websocketpp::connection_hdl hdl)
+{
+    server::connection_ptr con = s->get_con_from_hdl(hdl);
+
+    std::cout << con->get_uri() << std::endl;
+}
+
+void fail_on_open(websocketpp::connection_hdl) {
+    BOOST_CHECK(false);
+}
+void fail_on_http(websocketpp::connection_hdl) {
+    BOOST_CHECK(false);
+}
+
+BOOST_AUTO_TEST_CASE( connection_extensions ) {
+    connection_setup env(true);
+
+    BOOST_CHECK( env.c.extension_value == 5 );
+    BOOST_CHECK( env.c.extension_method() == 5 );
+
+    BOOST_CHECK( env.c.is_server() == true );
+}
+
+BOOST_AUTO_TEST_CASE( basic_websocket_request ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nServer: ";
+    output+=websocketpp::user_agent;
+    output+="\r\nUpgrade: websocket\r\n\r\n";
+
+    server s;
+    s.set_message_handler(bind(&echo_func,&s,::_1,::_2));
+
+    BOOST_CHECK(run_server_test(s,input) == output);
+}
+
+BOOST_AUTO_TEST_CASE( http_request ) {
+    std::string input = "GET /foo/bar HTTP/1.1\r\nHost: www.example.com\r\nOrigin: http://www.example.com\r\n\r\n";
+    std::string output = "HTTP/1.1 200 OK\r\nContent-Length: 8\r\nServer: ";
+    output+=websocketpp::user_agent;
+    output+="\r\n\r\n/foo/bar";
+
+    server s;
+    s.set_http_handler(bind(&http_func,&s,::_1));
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+}
+
+BOOST_AUTO_TEST_CASE( request_no_server_header ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nUpgrade: websocket\r\n\r\n";
+
+    server s;
+    s.set_user_agent("");
+    s.set_message_handler(bind(&echo_func,&s,::_1,::_2));
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+}
+
+BOOST_AUTO_TEST_CASE( request_no_server_header_override ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nServer: foo\r\nUpgrade: websocket\r\n\r\n";
+
+    server s;
+    s.set_user_agent("");
+    s.set_message_handler(bind(&echo_func,&s,::_1,::_2));
+    s.set_validate_handler(bind(&validate_set_ua,&s,::_1));
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+}
+
+BOOST_AUTO_TEST_CASE( basic_client_websocket ) {
+    std::string uri = "ws://localhost";
+
+    //std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nServer: foo\r\nUpgrade: websocket\r\n\r\n";
+
+    std::string ref = "GET / HTTP/1.1\r\nConnection: Upgrade\r\nFoo: Bar\r\nHost: localhost\r\nSec-WebSocket-Key: AAAAAAAAAAAAAAAAAAAAAA==\r\nSec-WebSocket-Version: 13\r\nUpgrade: websocket\r\nUser-Agent: foo\r\n\r\n";
+
+    std::stringstream output;
+
+    client e;
+    e.set_access_channels(websocketpp::log::alevel::none);
+    e.set_error_channels(websocketpp::log::elevel::none);
+    e.set_user_agent("foo");
+    e.register_ostream(&output);
+
+    client::connection_ptr con;
+    websocketpp::lib::error_code ec;
+    con = e.get_connection(uri, ec);
+    con->append_header("Foo","Bar");
+    e.connect(con);
+
+    BOOST_CHECK_EQUAL(ref, output.str());
+}
+
+BOOST_AUTO_TEST_CASE( set_max_message_size ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n\r\n";
+    
+    // After the handshake, add a single frame with a message that is too long.
+    char frame0[10] = {char(0x82), char(0x83), 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01};
+    input.append(frame0, 10);
+    
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nServer: foo\r\nUpgrade: websocket\r\n\r\n";
+
+    // After the handshake, add a single frame with a close message with message too big
+    // error code.
+    char frame1[4] = {char(0x88), 0x19, 0x03, char(0xf1)};
+    output.append(frame1, 4);
+    output.append("A message was too large");
+
+    server s;
+    s.set_user_agent("");
+    s.set_validate_handler(bind(&validate_set_ua,&s,::_1));
+    s.set_max_message_size(2);
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+}
+
+BOOST_AUTO_TEST_CASE( websocket_fail_parse_error ) {
+    std::string input = "asdf\r\n\r\n";
+
+    server s;
+    websocketpp::lib::error_code ec = make_error_code(websocketpp::error::http_parse_error);
+    bool called = false;
+    s.set_fail_handler(bind(&check_on_fail,&s,ec,websocketpp::lib::ref(called),::_1));
+
+    run_server_test(s,input,false);
+    BOOST_CHECK(called);
+}
+
+BOOST_AUTO_TEST_CASE( websocket_fail_invalid_version ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: foo\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+
+    server s;
+    websocketpp::lib::error_code ec = make_error_code(websocketpp::error::invalid_version);
+    bool called = false;
+    s.set_fail_handler(bind(&check_on_fail,&s,ec,websocketpp::lib::ref(called),::_1));
+
+    run_server_test(s,input,false);
+    BOOST_CHECK(called);
+}
+
+BOOST_AUTO_TEST_CASE( websocket_fail_unsupported_version ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 12\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+
+    server s;
+    websocketpp::lib::error_code ec = make_error_code(websocketpp::error::unsupported_version);
+    bool called = false;
+    s.set_fail_handler(bind(&check_on_fail,&s,ec,websocketpp::lib::ref(called),::_1));
+
+    run_server_test(s,input,false);
+    BOOST_CHECK(called);
+}
+
+/*BOOST_AUTO_TEST_CASE( websocket_fail_invalid_uri ) {
+    std::string input = "GET http://345.123.123.123/foo HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+
+    server s;
+    websocketpp::lib::error_code ec = make_error_code(websocketpp::error::unsupported_version);
+    bool called = false;
+    s.set_fail_handler(bind(&check_on_fail,&s,ec,websocketpp::lib::ref(called),::_1));
+    s.set_open_handler(bind(&on_open_print,&s,::_1));
+
+    std::cout << run_server_test(s,input,true) << std::endl;
+    BOOST_CHECK(called);
+}
+
+BOOST_AUTO_TEST_CASE( websocket_fail_invalid_uri_http ) {
+    std::string input = "GET http://345.123.123.123/foo HTTP/1.1\r\nHost: www.example.com\r\nOrigin: http://www.example.com\r\n\r\n";
+
+    server s;
+    websocketpp::lib::error_code ec = make_error_code(websocketpp::error::unsupported_version);
+    bool called = false;
+    s.set_fail_handler(bind(&check_on_fail,&s,ec,websocketpp::lib::ref(called),::_1));
+    s.set_open_handler(bind(&on_open_print,&s,::_1));
+
+    std::cout << run_server_test(s,input,true) << std::endl;
+    BOOST_CHECK(called);
+}*/
+
+BOOST_AUTO_TEST_CASE( websocket_fail_upgrade_required ) {
+    std::string input = "GET /foo/bar HTTP/1.1\r\nHost: www.example.com\r\nOrigin: http://www.example.com\r\n\r\n";
+
+    server s;
+    websocketpp::lib::error_code ec = make_error_code(websocketpp::error::upgrade_required);
+    bool called = false;
+    s.set_fail_handler(bind(&check_on_fail,&s,ec,websocketpp::lib::ref(called),::_1));
+
+    run_server_test(s,input,false);
+    BOOST_CHECK(called);
+}
+
+// TODO: set max message size in client endpoint test case
+// TODO: set max message size mid connection test case
+// TODO: [maybe] set max message size in open handler
+
+/*
+
+BOOST_AUTO_TEST_CASE( user_reject_origin ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example2.com\r\n\r\n";
+    std::string output = "HTTP/1.1 403 Forbidden\r\nServer: "+websocketpp::USER_AGENT+"\r\n\r\n";
+
+    BOOST_CHECK(run_server_test(input) == output);
+}
+
+BOOST_AUTO_TEST_CASE( basic_text_message ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+
+    unsigned char frames[8] = {0x82,0x82,0xFF,0xFF,0xFF,0xFF,0xD5,0xD5};
+    input.append(reinterpret_cast<char*>(frames),8);
+
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nServer: "+websocketpp::USER_AGENT+"\r\nUpgrade: websocket\r\n\r\n**";
+
+    BOOST_CHECK( run_server_test(input) == output);
+}
+*/
+
+
+
+
+
+BOOST_AUTO_TEST_CASE( client_handshake_timeout_race1 ) {
+    debug_client c;
+
+    websocketpp::lib::error_code ec;
+    debug_client::connection_ptr con = c.get_connection("ws://localhost:9002", ec);
+
+    BOOST_CHECK(!ec);
+
+    // This test the case where a handshake times out immediately before the 
+    // handler that would have completed it gets invoked. This situation happens
+    // when clients are connecting to overloaded servers and on servers that are
+    // overloaded. 
+    c.connect(con);
+    
+    con->expire_timer(websocketpp::lib::error_code());
+    // Fullfil the write to simulate the write completing immediately after
+    // timer expires
+    con->fullfil_write();
+    
+    BOOST_CHECK_EQUAL(con->get_ec(), make_error_code(websocketpp::error::open_handshake_timeout));
+}
+
+BOOST_AUTO_TEST_CASE( client_handshake_timeout_race2 ) {
+    debug_client c;
+
+    websocketpp::lib::error_code ec;
+    debug_client::connection_ptr con = c.get_connection("ws://localhost:9002", ec);
+
+    BOOST_CHECK(!ec);
+
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: ICX+Yqv66kxgM0FcWaLWlFLwTAI=\r\nServer: foo\r\nUpgrade: websocket\r\n\r\n";
+
+    // This test the case where a handshake times out immediately before the 
+    // handler that would have completed it gets invoked. This situation happens
+    // when clients are connecting to overloaded servers and on servers that are
+    // overloaded. 
+    c.connect(con);
+    con->fullfil_write();
+    
+    con->expire_timer(websocketpp::lib::error_code());
+    // Read valid handshake to simulate receiving the handshake response
+    // immediately after the timer expires
+    con->read_all(output.data(),output.size());
+    
+    BOOST_CHECK_EQUAL(con->get_ec(), make_error_code(websocketpp::error::open_handshake_timeout));
+}
+
+BOOST_AUTO_TEST_CASE( server_handshake_timeout_race1 ) {
+    debug_server s;
+
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: AAAAAAAAAAAAAAAAAAAAAA==\r\n\r\n";
+
+    debug_server::connection_ptr con = s.get_connection();
+    con->start();
+    
+    con->expire_timer(websocketpp::lib::error_code());
+    // Read handshake immediately after timer expire
+    con->read_all(input.data(), input.size());
+    
+    BOOST_CHECK_EQUAL(con->get_ec(), make_error_code(websocketpp::error::open_handshake_timeout));
+}
+
+BOOST_AUTO_TEST_CASE( server_handshake_timeout_race2 ) {
+    debug_server s;
+
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: AAAAAAAAAAAAAAAAAAAAAA==\r\n\r\n";
+
+    debug_server::connection_ptr con = s.get_connection();
+    con->start();
+    
+    con->read_all(input.data(), input.size());
+    
+    con->expire_timer(websocketpp::lib::error_code());
+    // Complete write immediately after timer expire
+    con->fullfil_write();
+    
+    BOOST_CHECK_EQUAL(con->get_ec(), make_error_code(websocketpp::error::open_handshake_timeout));
+}
+
+
diff --git a/extlibs/websocketpp/test/connection/connection_tu2.cpp b/extlibs/websocketpp/test/connection/connection_tu2.cpp
new file mode 100644
index 000000000..540962486
--- /dev/null
+++ b/extlibs/websocketpp/test/connection/connection_tu2.cpp
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "connection_tu2.hpp"
+
+void echo_func(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
+    s->send(hdl, msg->get_payload(), msg->get_opcode());
+}
+
+std::string run_server_test(std::string input, bool log) {
+    server test_server;
+    return run_server_test(test_server,input,log);
+}
+
+std::string run_server_test(server & s, std::string input, bool log) {
+    server::connection_ptr con;
+    std::stringstream output;
+
+    if (log) {
+        s.set_access_channels(websocketpp::log::alevel::all);
+        s.set_error_channels(websocketpp::log::elevel::all);
+    } else {
+        s.clear_access_channels(websocketpp::log::alevel::all);
+        s.clear_error_channels(websocketpp::log::elevel::all);
+    }
+
+    s.register_ostream(&output);
+
+    con = s.get_connection();
+    con->start();
+
+    std::stringstream channel;
+
+    channel << input;
+    channel >> *con;
+
+    return output.str();
+}
diff --git a/extlibs/websocketpp/test/connection/connection_tu2.hpp b/extlibs/websocketpp/test/connection/connection_tu2.hpp
new file mode 100644
index 000000000..8990ce00c
--- /dev/null
+++ b/extlibs/websocketpp/test/connection/connection_tu2.hpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <iostream>
+#include <sstream>
+
+// Test Environment:
+// server, no TLS, no locks, iostream based transport
+#include <websocketpp/config/debug.hpp>
+#include <websocketpp/config/core.hpp>
+#include <websocketpp/server.hpp>
+#include <websocketpp/client.hpp>
+
+typedef websocketpp::server<websocketpp::config::core> server;
+/// NOTE: the "server" config is being used for the client here because we don't
+/// want to pull in the real RNG. A better way to do this might be a custom
+/// client config with the RNG explicitly stubbed out.
+typedef websocketpp::client<websocketpp::config::core> client;
+typedef websocketpp::config::core::message_type::ptr message_ptr;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+void echo_func(server* s, websocketpp::connection_hdl hdl, message_ptr msg);
+std::string run_server_test(std::string input, bool log = false);
+std::string run_server_test(server & s, std::string input, bool log = false);
diff --git a/extlibs/websocketpp/test/endpoint/SConscript b/extlibs/websocketpp/test/endpoint/SConscript
new file mode 100644
index 000000000..5cb3ede91
--- /dev/null
+++ b/extlibs/websocketpp/test/endpoint/SConscript
@@ -0,0 +1,24 @@
+## endpoint unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+Import('tls_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system'],env) + [platform_libs] + [tls_libs]
+
+objs = env.Object('endpoint_boost.o', ["endpoint.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_endpoint_boost', ["endpoint_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework','system'],env_cpp11) + [platform_libs] + [polyfill_libs] + [tls_libs]
+   objs += env_cpp11.Object('endpoint_stl.o', ["endpoint.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_endpoint_stl', ["endpoint_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/endpoint/endpoint.cpp b/extlibs/websocketpp/test/endpoint/endpoint.cpp
new file mode 100644
index 000000000..08b0560b5
--- /dev/null
+++ b/extlibs/websocketpp/test/endpoint/endpoint.cpp
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2015, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE endpoint
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <sstream>
+
+#include <websocketpp/config/asio.hpp>
+#include <websocketpp/server.hpp>
+
+BOOST_AUTO_TEST_CASE( construct_server_iostream ) {
+    websocketpp::server<websocketpp::config::core> s;
+}
+
+BOOST_AUTO_TEST_CASE( construct_server_asio_plain ) {
+    websocketpp::server<websocketpp::config::asio> s;
+}
+
+BOOST_AUTO_TEST_CASE( construct_server_asio_tls ) {
+    websocketpp::server<websocketpp::config::asio_tls> s;
+}
+
+BOOST_AUTO_TEST_CASE( initialize_server_asio ) {
+    websocketpp::server<websocketpp::config::asio> s;
+    s.init_asio();
+}
+
+BOOST_AUTO_TEST_CASE( initialize_server_asio_external ) {
+    websocketpp::server<websocketpp::config::asio> s;
+    boost::asio::io_service ios;
+    s.init_asio(&ios);
+}
+
+struct endpoint_extension {
+    endpoint_extension() : extension_value(5) {}
+
+    int extension_method() {
+        return extension_value;
+    }
+
+    bool is_server() const {
+        return false;
+    }
+
+    int extension_value;
+};
+
+struct stub_config : public websocketpp::config::core {
+    typedef core::concurrency_type concurrency_type;
+
+    typedef core::request_type request_type;
+    typedef core::response_type response_type;
+
+    typedef core::message_type message_type;
+    typedef core::con_msg_manager_type con_msg_manager_type;
+    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef core::alog_type alog_type;
+    typedef core::elog_type elog_type;
+
+    typedef core::rng_type rng_type;
+
+    typedef core::transport_type transport_type;
+
+    typedef endpoint_extension endpoint_base;
+};
+
+BOOST_AUTO_TEST_CASE( endpoint_extensions ) {
+    websocketpp::server<stub_config> s;
+
+    BOOST_CHECK_EQUAL( s.extension_value, 5 );
+    BOOST_CHECK_EQUAL( s.extension_method(), 5 );
+
+    BOOST_CHECK( s.is_server() );
+}
+
+BOOST_AUTO_TEST_CASE( listen_after_listen_failure ) {
+    using websocketpp::transport::asio::error::make_error_code;
+    using websocketpp::transport::asio::error::pass_through;
+
+    websocketpp::server<websocketpp::config::asio> server1;
+    websocketpp::server<websocketpp::config::asio> server2;
+
+    websocketpp::lib::error_code ec;
+
+    server1.init_asio();
+    server2.init_asio();
+
+    boost::asio::ip::tcp::endpoint ep1(boost::asio::ip::address::from_string("127.0.0.1"), 12345);
+    boost::asio::ip::tcp::endpoint ep2(boost::asio::ip::address::from_string("127.0.0.1"), 23456);
+
+    server1.listen(ep1, ec);
+    BOOST_CHECK(!ec);
+
+    server2.listen(ep1, ec);
+    BOOST_REQUIRE_EQUAL(ec, make_error_code(pass_through));
+
+    server2.listen(ep2, ec);
+    BOOST_CHECK(!ec);
+}
diff --git a/extlibs/websocketpp/test/extension/SConscript b/extlibs/websocketpp/test/extension/SConscript
new file mode 100644
index 000000000..d8b425fda
--- /dev/null
+++ b/extlibs/websocketpp/test/extension/SConscript
@@ -0,0 +1,27 @@
+## http unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system'],env) + [platform_libs] + ['z']
+
+objs = env.Object('extension_boost.o', ["extension.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('permessage_deflate_boost.o', ["permessage_deflate.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_extension_boost', ["extension_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_permessage_deflate_boost', ["permessage_deflate_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework'],env_cpp11) + [platform_libs] + [polyfill_libs] + ['z']
+   objs += env_cpp11.Object('extension_stl.o', ["extension.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('permessage_deflate_stl.o', ["permessage_deflate.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_extension_stl', ["extension_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_permessage_deflate_stl', ["permessage_deflate_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/extension/extension.cpp b/extlibs/websocketpp/test/extension/extension.cpp
new file mode 100644
index 000000000..5439c0741
--- /dev/null
+++ b/extlibs/websocketpp/test/extension/extension.cpp
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE extension
+#include <boost/test/unit_test.hpp>
+
+#include <string>
+
+#include <websocketpp/extensions/extension.hpp>
+
+BOOST_AUTO_TEST_CASE( blank ) {
+    BOOST_CHECK( true );
+}
diff --git a/extlibs/websocketpp/test/extension/permessage_deflate.cpp b/extlibs/websocketpp/test/extension/permessage_deflate.cpp
new file mode 100644
index 000000000..60e3c24d5
--- /dev/null
+++ b/extlibs/websocketpp/test/extension/permessage_deflate.cpp
@@ -0,0 +1,543 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE permessage_deflate
+#include <boost/test/unit_test.hpp>
+
+#include <websocketpp/error.hpp>
+
+#include <websocketpp/extensions/extension.hpp>
+#include <websocketpp/extensions/permessage_deflate/disabled.hpp>
+#include <websocketpp/extensions/permessage_deflate/enabled.hpp>
+
+#include <string>
+
+#include <websocketpp/utilities.hpp>
+#include <iostream>
+
+class config {};
+
+typedef websocketpp::extensions::permessage_deflate::enabled<config> enabled_type;
+typedef websocketpp::extensions::permessage_deflate::disabled<config> disabled_type;
+
+struct ext_vars {
+    enabled_type exts;
+    enabled_type extc;
+    websocketpp::lib::error_code ec;
+    websocketpp::err_str_pair esp;
+    websocketpp::http::attribute_list attr;
+};
+namespace pmde = websocketpp::extensions::permessage_deflate::error;
+namespace pmd_mode = websocketpp::extensions::permessage_deflate::mode;
+
+// Ensure the disabled extension behaves appropriately disabled
+
+BOOST_AUTO_TEST_CASE( disabled_is_disabled ) {
+    disabled_type exts;
+    BOOST_CHECK( !exts.is_implemented() );
+}
+
+BOOST_AUTO_TEST_CASE( disabled_is_off ) {
+    disabled_type exts;
+    BOOST_CHECK( !exts.is_enabled() );
+}
+
+// Ensure the enabled version actually works
+
+BOOST_AUTO_TEST_CASE( enabled_is_enabled ) {
+    ext_vars v;
+    BOOST_CHECK( v.exts.is_implemented() );
+    BOOST_CHECK( v.extc.is_implemented() );
+}
+
+
+BOOST_AUTO_TEST_CASE( enabled_starts_disabled ) {
+    ext_vars v;
+    BOOST_CHECK( !v.exts.is_enabled() );
+    BOOST_CHECK( !v.extc.is_enabled() );
+}
+
+BOOST_AUTO_TEST_CASE( negotiation_empty_attr ) {
+    ext_vars v;
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate");
+}
+
+BOOST_AUTO_TEST_CASE( negotiation_invalid_attr ) {
+    ext_vars v;
+    v.attr["foo"] = "bar";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( !v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, pmde::make_error_code(pmde::invalid_attributes) );
+    BOOST_CHECK_EQUAL( v.esp.second, "");
+}
+
+// Negotiate s2c_no_context_takeover
+BOOST_AUTO_TEST_CASE( negotiate_s2c_no_context_takeover_invalid ) {
+    ext_vars v;
+    v.attr["s2c_no_context_takeover"] = "foo";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( !v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, pmde::make_error_code(pmde::invalid_attribute_value) );
+    BOOST_CHECK_EQUAL( v.esp.second, "");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_s2c_no_context_takeover ) {
+    ext_vars v;
+    v.attr["s2c_no_context_takeover"] = "";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_no_context_takeover");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_s2c_no_context_takeover_server_initiated ) {
+    ext_vars v;
+
+    v.exts.enable_s2c_no_context_takeover();
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_no_context_takeover");
+}
+
+// Negotiate c2s_no_context_takeover
+BOOST_AUTO_TEST_CASE( negotiate_c2s_no_context_takeover_invalid ) {
+    ext_vars v;
+    v.attr["c2s_no_context_takeover"] = "foo";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( !v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, pmde::make_error_code(pmde::invalid_attribute_value) );
+    BOOST_CHECK_EQUAL( v.esp.second, "");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_c2s_no_context_takeover ) {
+    ext_vars v;
+    v.attr["c2s_no_context_takeover"] = "";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; c2s_no_context_takeover");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_c2s_no_context_takeover_server_initiated ) {
+    ext_vars v;
+
+    v.exts.enable_c2s_no_context_takeover();
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; c2s_no_context_takeover");
+}
+
+
+// Negotiate s2c_max_window_bits
+BOOST_AUTO_TEST_CASE( negotiate_s2c_max_window_bits_invalid ) {
+    ext_vars v;
+
+    std::vector<std::string> values;
+    values.push_back("");
+    values.push_back("foo");
+    values.push_back("7");
+    values.push_back("16");
+
+    std::vector<std::string>::const_iterator it;
+    for (it = values.begin(); it != values.end(); ++it) {
+        v.attr["s2c_max_window_bits"] = *it;
+
+        v.esp = v.exts.negotiate(v.attr);
+        BOOST_CHECK( !v.exts.is_enabled() );
+        BOOST_CHECK_EQUAL( v.esp.first, pmde::make_error_code(pmde::invalid_attribute_value) );
+        BOOST_CHECK_EQUAL( v.esp.second, "");
+    }
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_s2c_max_window_bits_valid ) {
+    ext_vars v;
+    v.attr["s2c_max_window_bits"] = "8";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_max_window_bits=8");
+
+    v.attr["s2c_max_window_bits"] = "15";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate");
+}
+
+BOOST_AUTO_TEST_CASE( invalid_set_s2c_max_window_bits ) {
+    ext_vars v;
+
+    v.ec = v.exts.set_s2c_max_window_bits(7,pmd_mode::decline);
+    BOOST_CHECK_EQUAL(v.ec,pmde::make_error_code(pmde::invalid_max_window_bits));
+
+    v.ec = v.exts.set_s2c_max_window_bits(16,pmd_mode::decline);
+    BOOST_CHECK_EQUAL(v.ec,pmde::make_error_code(pmde::invalid_max_window_bits));
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_s2c_max_window_bits_decline ) {
+    ext_vars v;
+    v.attr["s2c_max_window_bits"] = "8";
+
+    v.ec = v.exts.set_s2c_max_window_bits(15,pmd_mode::decline);
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_s2c_max_window_bits_accept ) {
+    ext_vars v;
+    v.attr["s2c_max_window_bits"] = "8";
+
+    v.ec = v.exts.set_s2c_max_window_bits(15,pmd_mode::accept);
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_max_window_bits=8");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_s2c_max_window_bits_largest ) {
+    ext_vars v;
+    v.attr["s2c_max_window_bits"] = "8";
+
+    v.ec = v.exts.set_s2c_max_window_bits(15,pmd_mode::largest);
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_max_window_bits=8");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_s2c_max_window_bits_smallest ) {
+    ext_vars v;
+    v.attr["s2c_max_window_bits"] = "8";
+
+    v.ec = v.exts.set_s2c_max_window_bits(15,pmd_mode::smallest);
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_max_window_bits=8");
+}
+
+// Negotiate s2c_max_window_bits
+BOOST_AUTO_TEST_CASE( negotiate_c2s_max_window_bits_invalid ) {
+    ext_vars v;
+
+    std::vector<std::string> values;
+    values.push_back("foo");
+    values.push_back("7");
+    values.push_back("16");
+
+    std::vector<std::string>::const_iterator it;
+    for (it = values.begin(); it != values.end(); ++it) {
+        v.attr["c2s_max_window_bits"] = *it;
+
+        v.esp = v.exts.negotiate(v.attr);
+        BOOST_CHECK( !v.exts.is_enabled() );
+        BOOST_CHECK_EQUAL( v.esp.first, pmde::make_error_code(pmde::invalid_attribute_value) );
+        BOOST_CHECK_EQUAL( v.esp.second, "");
+    }
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_c2s_max_window_bits_valid ) {
+    ext_vars v;
+
+    v.attr["c2s_max_window_bits"] = "";
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate");
+
+    v.attr["c2s_max_window_bits"] = "8";
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; c2s_max_window_bits=8");
+
+    v.attr["c2s_max_window_bits"] = "15";
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate");
+}
+
+BOOST_AUTO_TEST_CASE( invalid_set_c2s_max_window_bits ) {
+    ext_vars v;
+
+    v.ec = v.exts.set_c2s_max_window_bits(7,pmd_mode::decline);
+    BOOST_CHECK_EQUAL(v.ec,pmde::make_error_code(pmde::invalid_max_window_bits));
+
+    v.ec = v.exts.set_c2s_max_window_bits(16,pmd_mode::decline);
+    BOOST_CHECK_EQUAL(v.ec,pmde::make_error_code(pmde::invalid_max_window_bits));
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_c2s_max_window_bits_decline ) {
+    ext_vars v;
+    v.attr["c2s_max_window_bits"] = "8";
+
+    v.ec = v.exts.set_c2s_max_window_bits(8,pmd_mode::decline);
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_c2s_max_window_bits_accept ) {
+    ext_vars v;
+    v.attr["c2s_max_window_bits"] = "8";
+
+    v.ec = v.exts.set_c2s_max_window_bits(15,pmd_mode::accept);
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; c2s_max_window_bits=8");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_c2s_max_window_bits_largest ) {
+    ext_vars v;
+    v.attr["c2s_max_window_bits"] = "8";
+
+    v.ec = v.exts.set_c2s_max_window_bits(15,pmd_mode::largest);
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; c2s_max_window_bits=8");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_c2s_max_window_bits_smallest ) {
+    ext_vars v;
+    v.attr["c2s_max_window_bits"] = "8";
+
+    v.ec = v.exts.set_c2s_max_window_bits(15,pmd_mode::smallest);
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; c2s_max_window_bits=8");
+}
+
+
+// Combinations with 2
+BOOST_AUTO_TEST_CASE( negotiate_two_client_initiated1 ) {
+    ext_vars v;
+
+    v.attr["s2c_no_context_takeover"] = "";
+    v.attr["c2s_no_context_takeover"] = "";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_no_context_takeover; c2s_no_context_takeover");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_two_client_initiated2 ) {
+    ext_vars v;
+
+    v.attr["s2c_no_context_takeover"] = "";
+    v.attr["s2c_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_no_context_takeover; s2c_max_window_bits=10");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_two_client_initiated3 ) {
+    ext_vars v;
+
+    v.attr["s2c_no_context_takeover"] = "";
+    v.attr["c2s_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_no_context_takeover; c2s_max_window_bits=10");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_two_client_initiated4 ) {
+    ext_vars v;
+
+    v.attr["c2s_no_context_takeover"] = "";
+    v.attr["s2c_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; c2s_no_context_takeover; s2c_max_window_bits=10");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_two_client_initiated5 ) {
+    ext_vars v;
+
+    v.attr["c2s_no_context_takeover"] = "";
+    v.attr["c2s_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; c2s_no_context_takeover; c2s_max_window_bits=10");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_two_client_initiated6 ) {
+    ext_vars v;
+
+    v.attr["s2c_max_window_bits"] = "10";
+    v.attr["c2s_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_max_window_bits=10; c2s_max_window_bits=10");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_three_client_initiated1 ) {
+    ext_vars v;
+
+    v.attr["s2c_no_context_takeover"] = "";
+    v.attr["c2s_no_context_takeover"] = "";
+    v.attr["s2c_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_no_context_takeover; c2s_no_context_takeover; s2c_max_window_bits=10");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_three_client_initiated2 ) {
+    ext_vars v;
+
+    v.attr["s2c_no_context_takeover"] = "";
+    v.attr["c2s_no_context_takeover"] = "";
+    v.attr["c2s_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_no_context_takeover; c2s_no_context_takeover; c2s_max_window_bits=10");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_three_client_initiated3 ) {
+    ext_vars v;
+
+    v.attr["s2c_no_context_takeover"] = "";
+    v.attr["s2c_max_window_bits"] = "10";
+    v.attr["c2s_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_no_context_takeover; s2c_max_window_bits=10; c2s_max_window_bits=10");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_three_client_initiated4 ) {
+    ext_vars v;
+
+    v.attr["c2s_no_context_takeover"] = "";
+    v.attr["s2c_max_window_bits"] = "10";
+    v.attr["c2s_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; c2s_no_context_takeover; s2c_max_window_bits=10; c2s_max_window_bits=10");
+}
+
+BOOST_AUTO_TEST_CASE( negotiate_four_client_initiated ) {
+    ext_vars v;
+
+    v.attr["s2c_no_context_takeover"] = "";
+    v.attr["c2s_no_context_takeover"] = "";
+    v.attr["s2c_max_window_bits"] = "10";
+    v.attr["c2s_max_window_bits"] = "10";
+
+    v.esp = v.exts.negotiate(v.attr);
+    BOOST_CHECK( v.exts.is_enabled() );
+    BOOST_CHECK_EQUAL( v.esp.first, websocketpp::lib::error_code() );
+    BOOST_CHECK_EQUAL( v.esp.second, "permessage-deflate; s2c_no_context_takeover; c2s_no_context_takeover; s2c_max_window_bits=10; c2s_max_window_bits=10");
+}
+
+// Compression
+/*
+BOOST_AUTO_TEST_CASE( compress_data ) {
+    ext_vars v;
+
+    std::string in = "Hello";
+    std::string out;
+    std::string in2;
+    std::string out2;
+
+    v.exts.init();
+
+    v.ec = v.exts.compress(in,out);
+
+    std::cout << "in : " << websocketpp::utility::to_hex(in) << std::endl;
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    std::cout << "out: " << websocketpp::utility::to_hex(out) << std::endl;
+
+    in2 = out;
+
+    v.ec = v.exts.decompress(reinterpret_cast<const uint8_t *>(in2.data()),in2.size(),out2);
+
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    std::cout << "out: " << websocketpp::utility::to_hex(out2) << std::endl;
+    BOOST_CHECK_EQUAL( out, out2 );
+}
+
+BOOST_AUTO_TEST_CASE( decompress_data ) {
+    ext_vars v;
+
+    uint8_t in[12] = {0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x07, 0x00, 0x00, 0x00, 0xff, 0xff};
+    std::string out;
+
+    v.exts.init();
+
+    v.ec = v.exts.decompress(in,12,out);
+
+    BOOST_CHECK_EQUAL( v.ec, websocketpp::lib::error_code() );
+    std::cout << "out: " << websocketpp::utility::to_hex(out) << std::endl;
+    BOOST_CHECK( false );
+}
+*/
diff --git a/extlibs/websocketpp/test/http/SConscript b/extlibs/websocketpp/test/http/SConscript
new file mode 100644
index 000000000..0a24a8774
--- /dev/null
+++ b/extlibs/websocketpp/test/http/SConscript
@@ -0,0 +1,23 @@
+## http unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework'],env) + [platform_libs]
+
+objs = env.Object('parser_boost.o', ["parser.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_http_boost', ["parser_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   objs += env_cpp11.Object('parser_stl.o', ["parser.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_http_stl', ["parser_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/http/parser.cpp b/extlibs/websocketpp/test/http/parser.cpp
new file mode 100644
index 000000000..dc7cf56eb
--- /dev/null
+++ b/extlibs/websocketpp/test/http/parser.cpp
@@ -0,0 +1,1127 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE http_parser
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+
+BOOST_AUTO_TEST_CASE( is_token_char ) {
+    // Valid characters
+
+    // misc
+    BOOST_CHECK( websocketpp::http::is_token_char('!') );
+    BOOST_CHECK( websocketpp::http::is_token_char('#') );
+    BOOST_CHECK( websocketpp::http::is_token_char('$') );
+    BOOST_CHECK( websocketpp::http::is_token_char('%') );
+    BOOST_CHECK( websocketpp::http::is_token_char('&') );
+    BOOST_CHECK( websocketpp::http::is_token_char('\'') );
+    BOOST_CHECK( websocketpp::http::is_token_char('*') );
+    BOOST_CHECK( websocketpp::http::is_token_char('+') );
+    BOOST_CHECK( websocketpp::http::is_token_char('-') );
+    BOOST_CHECK( websocketpp::http::is_token_char('.') );
+    BOOST_CHECK( websocketpp::http::is_token_char('^') );
+    BOOST_CHECK( websocketpp::http::is_token_char('_') );
+    BOOST_CHECK( websocketpp::http::is_token_char('`') );
+    BOOST_CHECK( websocketpp::http::is_token_char('~') );
+
+    // numbers
+    for (int i = 0x30; i < 0x3a; i++) {
+        BOOST_CHECK( websocketpp::http::is_token_char((unsigned char)(i)) );
+    }
+
+    // upper
+    for (int i = 0x41; i < 0x5b; i++) {
+        BOOST_CHECK( websocketpp::http::is_token_char((unsigned char)(i)) );
+    }
+
+    // lower
+    for (int i = 0x61; i < 0x7b; i++) {
+        BOOST_CHECK( websocketpp::http::is_token_char((unsigned char)(i)) );
+    }
+
+    // invalid characters
+
+    // lower unprintable
+    for (int i = 0; i < 33; i++) {
+        BOOST_CHECK( !websocketpp::http::is_token_char((unsigned char)(i)) );
+    }
+
+    // misc
+    BOOST_CHECK( !websocketpp::http::is_token_char('(') );
+    BOOST_CHECK( !websocketpp::http::is_token_char(')') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('<') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('>') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('@') );
+    BOOST_CHECK( !websocketpp::http::is_token_char(',') );
+    BOOST_CHECK( !websocketpp::http::is_token_char(';') );
+    BOOST_CHECK( !websocketpp::http::is_token_char(':') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('\\') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('"') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('/') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('[') );
+    BOOST_CHECK( !websocketpp::http::is_token_char(']') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('?') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('=') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('{') );
+    BOOST_CHECK( !websocketpp::http::is_token_char('}') );
+
+    // upper unprintable and out of ascii range
+    for (int i = 127; i < 256; i++) {
+        BOOST_CHECK( !websocketpp::http::is_token_char((unsigned char)(i)) );
+    }
+
+    // is not
+    BOOST_CHECK( !websocketpp::http::is_not_token_char('!') );
+    BOOST_CHECK( websocketpp::http::is_not_token_char('(') );
+}
+
+BOOST_AUTO_TEST_CASE( extract_token ) {
+    std::string d1 = "foo";
+    std::string d2 = " foo ";
+
+    std::pair<std::string,std::string::const_iterator> ret;
+
+    ret = websocketpp::http::parser::extract_token(d1.begin(),d1.end());
+    BOOST_CHECK( ret.first == "foo" );
+    BOOST_CHECK( ret.second == d1.begin()+3 );
+
+    ret = websocketpp::http::parser::extract_token(d2.begin(),d2.end());
+    BOOST_CHECK( ret.first == "" );
+    BOOST_CHECK( ret.second == d2.begin()+0 );
+
+    ret = websocketpp::http::parser::extract_token(d2.begin()+1,d2.end());
+    BOOST_CHECK( ret.first == "foo" );
+    BOOST_CHECK( ret.second == d2.begin()+4 );
+}
+
+BOOST_AUTO_TEST_CASE( extract_quoted_string ) {
+    std::string d1 = "\"foo\"";
+    std::string d2 = "\"foo\\\"bar\\\"baz\"";
+    std::string d3 = "\"foo\"     ";
+    std::string d4 = "";
+    std::string d5 = "foo";
+
+    std::pair<std::string,std::string::const_iterator> ret;
+
+    using websocketpp::http::parser::extract_quoted_string;
+
+    ret = extract_quoted_string(d1.begin(),d1.end());
+    BOOST_CHECK( ret.first == "foo" );
+    BOOST_CHECK( ret.second == d1.end() );
+
+    ret = extract_quoted_string(d2.begin(),d2.end());
+    BOOST_CHECK( ret.first == "foo\"bar\"baz" );
+    BOOST_CHECK( ret.second == d2.end() );
+
+    ret = extract_quoted_string(d3.begin(),d3.end());
+    BOOST_CHECK( ret.first == "foo" );
+    BOOST_CHECK( ret.second == d3.begin()+5 );
+
+    ret = extract_quoted_string(d4.begin(),d4.end());
+    BOOST_CHECK( ret.first == "" );
+    BOOST_CHECK( ret.second == d4.begin() );
+
+    ret = extract_quoted_string(d5.begin(),d5.end());
+    BOOST_CHECK( ret.first == "" );
+    BOOST_CHECK( ret.second == d5.begin() );
+}
+
+BOOST_AUTO_TEST_CASE( extract_all_lws ) {
+    std::string d1 = " foo     bar";
+    d1.append(1,char(9));
+    d1.append("baz\r\n d\r\n  \r\n  e\r\nf");
+
+    std::string::const_iterator ret;
+
+    ret = websocketpp::http::parser::extract_all_lws(d1.begin(),d1.end());
+    BOOST_CHECK( ret == d1.begin()+1 );
+
+    ret = websocketpp::http::parser::extract_all_lws(d1.begin()+1,d1.end());
+    BOOST_CHECK( ret == d1.begin()+1 );
+
+    ret = websocketpp::http::parser::extract_all_lws(d1.begin()+4,d1.end());
+    BOOST_CHECK( ret == d1.begin()+9 );
+
+    ret = websocketpp::http::parser::extract_all_lws(d1.begin()+12,d1.end());
+    BOOST_CHECK( ret == d1.begin()+13 );
+
+    ret = websocketpp::http::parser::extract_all_lws(d1.begin()+16,d1.end());
+    BOOST_CHECK( ret == d1.begin()+19 );
+
+    ret = websocketpp::http::parser::extract_all_lws(d1.begin()+20,d1.end());
+    BOOST_CHECK( ret == d1.begin()+28 );
+
+    ret = websocketpp::http::parser::extract_all_lws(d1.begin()+29,d1.end());
+    BOOST_CHECK( ret == d1.begin()+29 );
+}
+
+BOOST_AUTO_TEST_CASE( extract_attributes_blank ) {
+    std::string s = "";
+
+    websocketpp::http::attribute_list a;
+    std::string::const_iterator it;
+
+    it = websocketpp::http::parser::extract_attributes(s.begin(),s.end(),a);
+    BOOST_CHECK( it == s.begin() );
+    BOOST_CHECK_EQUAL( a.size(), 0 );
+}
+
+BOOST_AUTO_TEST_CASE( extract_attributes_simple ) {
+    std::string s = "foo";
+
+    websocketpp::http::attribute_list a;
+    std::string::const_iterator it;
+
+    it = websocketpp::http::parser::extract_attributes(s.begin(),s.end(),a);
+    BOOST_CHECK( it == s.end() );
+    BOOST_CHECK_EQUAL( a.size(), 1 );
+    BOOST_CHECK( a.find("foo") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("foo")->second, "" );
+}
+
+BOOST_AUTO_TEST_CASE( extract_parameters ) {
+    std::string s1 = "";
+    std::string s2 = "foo";
+    std::string s3 = " foo \r\nAbc";
+    std::string s4 = "  \r\n   foo  ";
+    std::string s5 = "foo,bar";
+    std::string s6 = "foo;bar";
+    std::string s7 = "foo;baz,bar";
+    std::string s8 = "foo;bar;baz";
+    std::string s9 = "foo;bar=baz";
+    std::string s10 = "foo;bar=baz;boo";
+    std::string s11 = "foo;bar=baz;boo,bob";
+    std::string s12 = "foo;bar=\"a b c\"";
+    std::string s13 = "foo;bar=\"a \\\"b\\\" c\"";
+
+
+    std::string sx = "foo;bar=\"a \\\"b\\\" c\"";
+    websocketpp::http::parameter_list p;
+    websocketpp::http::attribute_list a;
+    std::string::const_iterator it;
+
+    using websocketpp::http::parser::extract_parameters;
+
+    it = extract_parameters(s1.begin(),s1.end(),p);
+    BOOST_CHECK( it == s1.begin() );
+
+    p.clear();
+    it = extract_parameters(s2.begin(),s2.end(),p);
+    BOOST_CHECK( it == s2.end() );
+    BOOST_CHECK_EQUAL( p.size(), 1 );
+    BOOST_CHECK( p[0].first == "foo" );
+    BOOST_CHECK_EQUAL( p[0].second.size(), 0 );
+
+    p.clear();
+    it = extract_parameters(s3.begin(),s3.end(),p);
+    BOOST_CHECK( it == s3.begin()+5 );
+    BOOST_CHECK_EQUAL( p.size(), 1 );
+    BOOST_CHECK( p[0].first == "foo" );
+    BOOST_CHECK_EQUAL( p[0].second.size(), 0 );
+
+    p.clear();
+    it = extract_parameters(s4.begin(),s4.end(),p);
+    BOOST_CHECK( it == s4.end() );
+    BOOST_CHECK_EQUAL( p.size(), 1 );
+    BOOST_CHECK( p[0].first == "foo" );
+    BOOST_CHECK_EQUAL( p[0].second.size(), 0 );
+
+    p.clear();
+    it = extract_parameters(s5.begin(),s5.end(),p);
+    BOOST_CHECK( it == s5.end() );
+    BOOST_CHECK_EQUAL( p.size(), 2 );
+    BOOST_CHECK( p[0].first == "foo" );
+    BOOST_CHECK_EQUAL( p[0].second.size(), 0 );
+    BOOST_CHECK( p[1].first == "bar" );
+    BOOST_CHECK_EQUAL( p[1].second.size(), 0 );
+
+    p.clear();
+    it = extract_parameters(s6.begin(),s6.end(),p);
+    BOOST_CHECK( it == s6.end() );
+    BOOST_CHECK_EQUAL( p.size(), 1 );
+    BOOST_CHECK( p[0].first == "foo" );
+    a = p[0].second;
+    BOOST_CHECK_EQUAL( a.size(), 1 );
+    BOOST_CHECK( a.find("bar") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("bar")->second, "" );
+
+    p.clear();
+    it = extract_parameters(s7.begin(),s7.end(),p);
+    BOOST_CHECK( it == s7.end() );
+    BOOST_CHECK_EQUAL( p.size(), 2 );
+    BOOST_CHECK( p[0].first == "foo" );
+    a = p[0].second;
+    BOOST_CHECK_EQUAL( a.size(), 1 );
+    BOOST_CHECK( a.find("baz") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("baz")->second, "" );
+    BOOST_CHECK( p[1].first == "bar" );
+    a = p[1].second;
+    BOOST_CHECK_EQUAL( a.size(), 0 );
+
+    p.clear();
+    it = extract_parameters(s8.begin(),s8.end(),p);
+    BOOST_CHECK( it == s8.end() );
+    BOOST_CHECK_EQUAL( p.size(), 1 );
+    BOOST_CHECK( p[0].first == "foo" );
+    a = p[0].second;
+    BOOST_CHECK_EQUAL( a.size(), 2 );
+    BOOST_CHECK( a.find("bar") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("bar")->second, "" );
+    BOOST_CHECK( a.find("baz") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("baz")->second, "" );
+
+    p.clear();
+    it = extract_parameters(s9.begin(),s9.end(),p);
+    BOOST_CHECK( it == s9.end() );
+    BOOST_CHECK_EQUAL( p.size(), 1 );
+    BOOST_CHECK( p[0].first == "foo" );
+    a = p[0].second;
+    BOOST_CHECK_EQUAL( a.size(), 1 );
+    BOOST_CHECK( a.find("bar") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("bar")->second, "baz" );
+
+    p.clear();
+    it = extract_parameters(s10.begin(),s10.end(),p);
+    BOOST_CHECK( it == s10.end() );
+    BOOST_CHECK_EQUAL( p.size(), 1 );
+    BOOST_CHECK( p[0].first == "foo" );
+    a = p[0].second;
+    BOOST_CHECK_EQUAL( a.size(), 2 );
+    BOOST_CHECK( a.find("bar") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("bar")->second, "baz" );
+    BOOST_CHECK( a.find("boo") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("boo")->second, "" );
+
+    p.clear();
+    it = extract_parameters(s11.begin(),s11.end(),p);
+    BOOST_CHECK( it == s11.end() );
+    BOOST_CHECK_EQUAL( p.size(), 2 );
+    BOOST_CHECK( p[0].first == "foo" );
+    a = p[0].second;
+    BOOST_CHECK_EQUAL( a.size(), 2 );
+    BOOST_CHECK( a.find("bar") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("bar")->second, "baz" );
+    BOOST_CHECK( a.find("boo") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("boo")->second, "" );
+    a = p[1].second;
+    BOOST_CHECK_EQUAL( a.size(), 0 );
+
+    p.clear();
+    it = extract_parameters(s12.begin(),s12.end(),p);
+    BOOST_CHECK( it == s12.end() );
+    BOOST_CHECK_EQUAL( p.size(), 1 );
+    BOOST_CHECK( p[0].first == "foo" );
+    a = p[0].second;
+    BOOST_CHECK_EQUAL( a.size(), 1 );
+    BOOST_CHECK( a.find("bar") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("bar")->second, "a b c" );
+
+    p.clear();
+    it = extract_parameters(s13.begin(),s13.end(),p);
+    BOOST_CHECK( it == s13.end() );
+    BOOST_CHECK_EQUAL( p.size(), 1 );
+    BOOST_CHECK( p[0].first == "foo" );
+    a = p[0].second;
+    BOOST_CHECK_EQUAL( a.size(), 1 );
+    BOOST_CHECK( a.find("bar") != a.end() );
+    BOOST_CHECK_EQUAL( a.find("bar")->second, "a \"b\" c" );
+}
+
+BOOST_AUTO_TEST_CASE( strip_lws ) {
+    std::string test1 = "foo";
+    std::string test2 = " foo ";
+    std::string test3 = "foo ";
+    std::string test4 = " foo";
+    std::string test5 = "    foo     ";
+    std::string test6 = "  \r\n  foo     ";
+    std::string test7 = "  \t  foo     ";
+    std::string test8 = "  \t       ";
+
+    BOOST_CHECK_EQUAL( websocketpp::http::parser::strip_lws(test1), "foo" );
+    BOOST_CHECK_EQUAL( websocketpp::http::parser::strip_lws(test2), "foo" );
+    BOOST_CHECK_EQUAL( websocketpp::http::parser::strip_lws(test3), "foo" );
+    BOOST_CHECK_EQUAL( websocketpp::http::parser::strip_lws(test4), "foo" );
+    BOOST_CHECK_EQUAL( websocketpp::http::parser::strip_lws(test5), "foo" );
+    BOOST_CHECK_EQUAL( websocketpp::http::parser::strip_lws(test6), "foo" );
+    BOOST_CHECK_EQUAL( websocketpp::http::parser::strip_lws(test7), "foo" );
+    BOOST_CHECK_EQUAL( websocketpp::http::parser::strip_lws(test8), "" );
+}
+
+BOOST_AUTO_TEST_CASE( case_insensitive_headers ) {
+    websocketpp::http::parser::parser r;
+
+    r.replace_header("foo","bar");
+
+    BOOST_CHECK_EQUAL( r.get_header("foo"), "bar" );
+    BOOST_CHECK_EQUAL( r.get_header("FOO"), "bar" );
+    BOOST_CHECK_EQUAL( r.get_header("Foo"), "bar" );
+}
+
+BOOST_AUTO_TEST_CASE( case_insensitive_headers_overwrite ) {
+    websocketpp::http::parser::parser r;
+
+    r.replace_header("foo","bar");
+
+    BOOST_CHECK_EQUAL( r.get_header("foo"), "bar" );
+    BOOST_CHECK_EQUAL( r.get_header("Foo"), "bar" );
+
+    r.replace_header("Foo","baz");
+
+    BOOST_CHECK_EQUAL( r.get_header("foo"), "baz" );
+    BOOST_CHECK_EQUAL( r.get_header("Foo"), "baz" );
+
+    r.remove_header("FoO");
+
+    BOOST_CHECK_EQUAL( r.get_header("foo"), "" );
+    BOOST_CHECK_EQUAL( r.get_header("Foo"), "" );
+}
+
+BOOST_AUTO_TEST_CASE( blank_consume ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "";
+
+    bool exception = false;
+
+    try {
+        r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK( r.ready() == false );
+}
+
+BOOST_AUTO_TEST_CASE( blank_request ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "\r\n\r\n";
+
+    bool exception = false;
+
+    try {
+        r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == true );
+    BOOST_CHECK( r.ready() == false );
+}
+
+BOOST_AUTO_TEST_CASE( bad_request_no_host ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\n\r\n";
+
+    bool exception = false;
+
+    try {
+        r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == true );
+    BOOST_CHECK( r.ready() == false );
+}
+
+BOOST_AUTO_TEST_CASE( basic_request ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK( pos == 41 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK( r.get_version() == "HTTP/1.1" );
+    BOOST_CHECK( r.get_method() == "GET" );
+    BOOST_CHECK( r.get_uri() == "/" );
+    BOOST_CHECK( r.get_header("Host") == "www.example.com" );
+}
+
+BOOST_AUTO_TEST_CASE( basic_request_with_body ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: www.example.com\r\nContent-Length: 5\r\n\r\nabcdef";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 65 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_method(), "GET" );
+    BOOST_CHECK_EQUAL( r.get_uri(), "/" );
+    BOOST_CHECK_EQUAL( r.get_header("Host"), "www.example.com" );
+    BOOST_CHECK_EQUAL( r.get_header("Content-Length"), "5" );
+    BOOST_CHECK_EQUAL( r.get_body(), "abcde" );
+}
+
+BOOST_AUTO_TEST_CASE( basic_request_with_body_split ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: www.example.com\r\nContent-Length: 6\r\n\r\nabc";
+    std::string raw2 = "def";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+        pos += r.consume(raw2.c_str(),raw2.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 66 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_method(), "GET" );
+    BOOST_CHECK_EQUAL( r.get_uri(), "/" );
+    BOOST_CHECK_EQUAL( r.get_header("Host"), "www.example.com" );
+    BOOST_CHECK_EQUAL( r.get_header("Content-Length"), "6" );
+    BOOST_CHECK_EQUAL( r.get_body(), "abcdef" );
+}
+
+
+
+BOOST_AUTO_TEST_CASE( trailing_body_characters ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\na";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK( pos == 41 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK( r.get_version() == "HTTP/1.1" );
+    BOOST_CHECK( r.get_method() == "GET" );
+    BOOST_CHECK( r.get_uri() == "/" );
+    BOOST_CHECK( r.get_header("Host") == "www.example.com" );
+}
+
+BOOST_AUTO_TEST_CASE( trailing_body_characters_beyond_max_lenth ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n";
+    raw.append(websocketpp::http::max_header_size,'*');
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK( pos == 41 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK( r.get_version() == "HTTP/1.1" );
+    BOOST_CHECK( r.get_method() == "GET" );
+    BOOST_CHECK( r.get_uri() == "/" );
+    BOOST_CHECK( r.get_header("Host") == "www.example.com" );
+}
+
+BOOST_AUTO_TEST_CASE( basic_split1 ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\n";
+    std::string raw2 = "Host: www.example.com\r\n\r\na";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+        pos += r.consume(raw2.c_str(),raw2.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK( pos == 41 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK( r.get_version() == "HTTP/1.1" );
+    BOOST_CHECK( r.get_method() == "GET" );
+    BOOST_CHECK( r.get_uri() == "/" );
+    BOOST_CHECK( r.get_header("Host") == "www.example.com" );
+}
+
+BOOST_AUTO_TEST_CASE( basic_split2 ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: www.example.com\r";
+    std::string raw2 = "\n\r\na";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+        pos += r.consume(raw2.c_str(),raw2.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK( pos == 41 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK( r.get_version() == "HTTP/1.1" );
+    BOOST_CHECK( r.get_method() == "GET" );
+    BOOST_CHECK( r.get_uri() == "/" );
+    BOOST_CHECK( r.get_header("Host") == "www.example.com" );
+}
+
+BOOST_AUTO_TEST_CASE( max_header_len ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw(websocketpp::http::max_header_size-1,'*');
+    raw += "\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+    } catch (const websocketpp::http::exception& e) {
+        if (e.m_error_code == websocketpp::http::status_code::request_header_fields_too_large) {
+            exception = true;
+        }
+    }
+
+    BOOST_CHECK( exception == true );
+}
+
+BOOST_AUTO_TEST_CASE( max_header_len_split ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw(websocketpp::http::max_header_size-1,'*');
+    std::string raw2(2,'*');
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+        pos += r.consume(raw2.c_str(),raw2.size());
+    } catch (const websocketpp::http::exception& e) {
+        if (e.m_error_code == websocketpp::http::status_code::request_header_fields_too_large) {
+            exception = true;
+        }
+    }
+
+    BOOST_CHECK( exception == true );
+}
+
+BOOST_AUTO_TEST_CASE( max_body_len ) {
+    websocketpp::http::parser::request r;
+    
+    r.set_max_body_size(5);
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: www.example.com\r\nContent-Length: 6\r\n\r\nabcdef";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+    } catch (websocketpp::http::exception const & e) {
+        exception = true;
+        BOOST_CHECK_EQUAL(e.m_error_code,websocketpp::http::status_code::request_entity_too_large);
+    }
+
+    BOOST_CHECK_EQUAL(r.get_max_body_size(),5);
+    BOOST_CHECK( exception == true );
+}
+
+BOOST_AUTO_TEST_CASE( firefox_full_request ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: localhost:5000\r\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:10.0) Gecko/20100101 Firefox/10.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-us,en;q=0.5\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive, Upgrade\r\nSec-WebSocket-Version: 8\r\nSec-WebSocket-Origin: http://zaphoyd.com\r\nSec-WebSocket-Key: pFik//FxwFk0riN4ZiPFjQ==\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nUpgrade: websocket\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK( pos == 482 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK( r.get_version() == "HTTP/1.1" );
+    BOOST_CHECK( r.get_method() == "GET" );
+    BOOST_CHECK( r.get_uri() == "/" );
+    BOOST_CHECK( r.get_header("Host") == "localhost:5000" );
+    BOOST_CHECK( r.get_header("User-Agent") == "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:10.0) Gecko/20100101 Firefox/10.0" );
+    BOOST_CHECK( r.get_header("Accept") == "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" );
+    BOOST_CHECK( r.get_header("Accept-Language") == "en-us,en;q=0.5" );
+    BOOST_CHECK( r.get_header("Accept-Encoding") == "gzip, deflate" );
+    BOOST_CHECK( r.get_header("Connection") == "keep-alive, Upgrade" );
+    BOOST_CHECK( r.get_header("Sec-WebSocket-Version") == "8" );
+    BOOST_CHECK( r.get_header("Sec-WebSocket-Origin") == "http://zaphoyd.com" );
+    BOOST_CHECK( r.get_header("Sec-WebSocket-Key") == "pFik//FxwFk0riN4ZiPFjQ==" );
+    BOOST_CHECK( r.get_header("Pragma") == "no-cache" );
+    BOOST_CHECK( r.get_header("Cache-Control") == "no-cache" );
+    BOOST_CHECK( r.get_header("Upgrade") == "websocket" );
+}
+
+BOOST_AUTO_TEST_CASE( bad_method ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GE]T / HTTP/1.1\r\nHost: www.example.com\r\n\r\n";
+
+    bool exception = false;
+
+    try {
+        r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == true );
+}
+
+BOOST_AUTO_TEST_CASE( bad_header_name ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHo]st: www.example.com\r\n\r\n";
+
+    bool exception = false;
+
+    try {
+        r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == true );
+}
+
+BOOST_AUTO_TEST_CASE( old_http_version ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.0\r\nHost: www.example.com\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 41 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.0" );
+    BOOST_CHECK_EQUAL( r.get_method(), "GET" );
+    BOOST_CHECK_EQUAL( r.get_uri(), "/" );
+    BOOST_CHECK_EQUAL( r.get_header("Host"), "www.example.com" );
+}
+
+BOOST_AUTO_TEST_CASE( new_http_version1 ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.12\r\nHost: www.example.com\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 42 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.12" );
+    BOOST_CHECK_EQUAL( r.get_method(), "GET" );
+    BOOST_CHECK_EQUAL( r.get_uri(), "/" );
+    BOOST_CHECK_EQUAL( r.get_header("Host"), "www.example.com" );
+}
+
+BOOST_AUTO_TEST_CASE( new_http_version2 ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/12.12\r\nHost: www.example.com\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 43 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/12.12" );
+    BOOST_CHECK_EQUAL( r.get_method(), "GET" );
+    BOOST_CHECK_EQUAL( r.get_uri(), "/" );
+    BOOST_CHECK_EQUAL( r.get_header("Host"), "www.example.com" );
+}
+
+/* commented out due to not being implemented yet
+
+BOOST_AUTO_TEST_CASE( new_http_version3 ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTPS/12.12\r\nHost: www.example.com\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == true );
+}*/
+
+BOOST_AUTO_TEST_CASE( header_whitespace1 ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost:  www.example.com \r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 43 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_method(), "GET" );
+    BOOST_CHECK_EQUAL( r.get_uri(), "/" );
+    BOOST_CHECK_EQUAL( r.get_header("Host"), "www.example.com" );
+}
+
+BOOST_AUTO_TEST_CASE( header_whitespace2 ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost:www.example.com\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 40 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_method(), "GET" );
+    BOOST_CHECK_EQUAL( r.get_uri(), "/" );
+    BOOST_CHECK_EQUAL( r.get_header("Host"), "www.example.com" );
+}
+
+BOOST_AUTO_TEST_CASE( header_aggregation ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: www.example.com\r\nFoo: bar\r\nFoo: bat\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos = r.consume(raw.c_str(),raw.size());
+    } catch (...) {
+        exception = true;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 61 );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_method(), "GET" );
+    BOOST_CHECK_EQUAL( r.get_uri(), "/" );
+    BOOST_CHECK_EQUAL( r.get_header("Foo"), "bar, bat" );
+}
+
+BOOST_AUTO_TEST_CASE( wikipedia_example_response ) {
+    websocketpp::http::parser::response r;
+
+    std::string raw = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\r\nSec-WebSocket-Protocol: chat\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 159 );
+    BOOST_CHECK( r.headers_ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_status_code(), websocketpp::http::status_code::switching_protocols );
+    BOOST_CHECK_EQUAL( r.get_status_msg(), "Switching Protocols" );
+    BOOST_CHECK_EQUAL( r.get_header("Upgrade"), "websocket" );
+    BOOST_CHECK_EQUAL( r.get_header("Connection"), "Upgrade" );
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Accept"), "HSmrc0sMlYUkAGmm5OPpG2HaGWk=" );
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Protocol"), "chat" );
+}
+
+BOOST_AUTO_TEST_CASE( wikipedia_example_response_trailing ) {
+    websocketpp::http::parser::response r;
+
+    std::string raw = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\r\nSec-WebSocket-Protocol: chat\r\n\r\n";
+    raw += "a";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 159 );
+    BOOST_CHECK( r.headers_ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_status_code(), websocketpp::http::status_code::switching_protocols );
+    BOOST_CHECK_EQUAL( r.get_status_msg(), "Switching Protocols" );
+    BOOST_CHECK_EQUAL( r.get_header("Upgrade"), "websocket" );
+    BOOST_CHECK_EQUAL( r.get_header("Connection"), "Upgrade" );
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Accept"), "HSmrc0sMlYUkAGmm5OPpG2HaGWk=" );
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Protocol"), "chat" );
+}
+
+BOOST_AUTO_TEST_CASE( wikipedia_example_response_trailing_large ) {
+    websocketpp::http::parser::response r;
+
+    std::string raw = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\r\nSec-WebSocket-Protocol: chat\r\n\r\n";
+    raw.append(websocketpp::http::max_header_size,'*');
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 159 );
+    BOOST_CHECK( r.headers_ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_status_code(), websocketpp::http::status_code::switching_protocols );
+    BOOST_CHECK_EQUAL( r.get_status_msg(), "Switching Protocols" );
+    BOOST_CHECK_EQUAL( r.get_header("Upgrade"), "websocket" );
+    BOOST_CHECK_EQUAL( r.get_header("Connection"), "Upgrade" );
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Accept"), "HSmrc0sMlYUkAGmm5OPpG2HaGWk=" );
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Protocol"), "chat" );
+}
+
+BOOST_AUTO_TEST_CASE( response_with_non_standard_lws ) {
+    websocketpp::http::parser::response r;
+
+    std::string raw = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept:HSmrc0sMlYUkAGmm5OPpG2HaGWk=\r\nSec-WebSocket-Protocol: chat\r\n\r\n";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 158 );
+    BOOST_CHECK( r.headers_ready() );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_status_code(), websocketpp::http::status_code::switching_protocols );
+    BOOST_CHECK_EQUAL( r.get_status_msg(), "Switching Protocols" );
+    BOOST_CHECK_EQUAL( r.get_header("Upgrade"), "websocket" );
+    BOOST_CHECK_EQUAL( r.get_header("Connection"), "Upgrade" );
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Accept"), "HSmrc0sMlYUkAGmm5OPpG2HaGWk=" );
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Protocol"), "chat" );
+}
+
+BOOST_AUTO_TEST_CASE( plain_http_response ) {
+    websocketpp::http::parser::response r;
+
+    std::string raw = "HTTP/1.1 200 OK\r\nDate: Thu, 10 May 2012 11:59:25 GMT\r\nServer: Apache/2.2.21 (Unix) mod_ssl/2.2.21 OpenSSL/0.9.8r DAV/2 PHP/5.3.8 with Suhosin-Patch\r\nLast-Modified: Tue, 30 Mar 2010 17:41:28 GMT\r\nETag: \"16799d-55-4830823a78200\"\r\nAccept-Ranges: bytes\r\nContent-Length: 85\r\nVary: Accept-Encoding\r\nContent-Type: text/html\r\n\r\n<!doctype html>\n<html>\n<head>\n<title>Thor</title>\n</head>\n<body> \n<p>Thor</p>\n</body>";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(raw.c_str(),raw.size());
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK( exception == false );
+    BOOST_CHECK_EQUAL( pos, 405 );
+    BOOST_CHECK( r.headers_ready() == true );
+    BOOST_CHECK( r.ready() == true );
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1" );
+    BOOST_CHECK_EQUAL( r.get_status_code(), websocketpp::http::status_code::ok );
+    BOOST_CHECK_EQUAL( r.get_status_msg(), "OK" );
+    BOOST_CHECK_EQUAL( r.get_header("Date"), "Thu, 10 May 2012 11:59:25 GMT" );
+    BOOST_CHECK_EQUAL( r.get_header("Server"), "Apache/2.2.21 (Unix) mod_ssl/2.2.21 OpenSSL/0.9.8r DAV/2 PHP/5.3.8 with Suhosin-Patch" );
+    BOOST_CHECK_EQUAL( r.get_header("Last-Modified"), "Tue, 30 Mar 2010 17:41:28 GMT" );
+    BOOST_CHECK_EQUAL( r.get_header("ETag"), "\"16799d-55-4830823a78200\"" );
+    BOOST_CHECK_EQUAL( r.get_header("Accept-Ranges"), "bytes" );
+    BOOST_CHECK_EQUAL( r.get_header("Content-Length"), "85" );
+    BOOST_CHECK_EQUAL( r.get_header("Vary"), "Accept-Encoding" );
+    BOOST_CHECK_EQUAL( r.get_header("Content-Type"), "text/html" );
+    BOOST_CHECK_EQUAL( r.get_body(), "<!doctype html>\n<html>\n<head>\n<title>Thor</title>\n</head>\n<body> \n<p>Thor</p>\n</body>" );
+}
+
+BOOST_AUTO_TEST_CASE( parse_istream ) {
+    websocketpp::http::parser::response r;
+
+    std::stringstream s;
+
+    s << "HTTP/1.1 200 OK\r\nDate: Thu, 10 May 2012 11:59:25 GMT\r\nServer: Apache/2.2.21 (Unix) mod_ssl/2.2.21 OpenSSL/0.9.8r DAV/2 PHP/5.3.8 with Suhosin-Patch\r\nLast-Modified: Tue, 30 Mar 2010 17:41:28 GMT\r\nETag: \"16799d-55-4830823a78200\"\r\nAccept-Ranges: bytes\r\nContent-Length: 85\r\nVary: Accept-Encoding\r\nContent-Type: text/html\r\n\r\n<!doctype html>\n<html>\n<head>\n<title>Thor</title>\n</head>\n<body> \n<p>Thor</p>\n</body>";
+
+    bool exception = false;
+    size_t pos = 0;
+
+    try {
+        pos += r.consume(s);
+    } catch (std::exception &e) {
+        exception = true;
+        std::cout << e.what() << std::endl;
+    }
+
+    BOOST_CHECK_EQUAL( exception, false );
+    BOOST_CHECK_EQUAL( pos, 405 );
+    BOOST_CHECK_EQUAL( r.headers_ready(), true );
+    BOOST_CHECK_EQUAL( r.ready(), true );
+}
+
+BOOST_AUTO_TEST_CASE( write_request_basic ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\n\r\n";
+
+    r.set_version("HTTP/1.1");
+    r.set_method("GET");
+    r.set_uri("/");
+
+    BOOST_CHECK_EQUAL( r.raw(), raw );
+}
+
+BOOST_AUTO_TEST_CASE( write_request_with_header ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "GET / HTTP/1.1\r\nHost: http://example.com\r\n\r\n";
+
+    r.set_version("HTTP/1.1");
+    r.set_method("GET");
+    r.set_uri("/");
+    r.replace_header("Host","http://example.com");
+
+    BOOST_CHECK_EQUAL( r.raw(), raw );
+}
+
+BOOST_AUTO_TEST_CASE( write_request_with_body ) {
+    websocketpp::http::parser::request r;
+
+    std::string raw = "POST / HTTP/1.1\r\nContent-Length: 48\r\nContent-Type: application/x-www-form-urlencoded\r\nHost: http://example.com\r\n\r\nlicenseID=string&content=string&paramsXML=string";
+
+    r.set_version("HTTP/1.1");
+    r.set_method("POST");
+    r.set_uri("/");
+    r.replace_header("Host","http://example.com");
+    r.replace_header("Content-Type","application/x-www-form-urlencoded");
+    r.set_body("licenseID=string&content=string&paramsXML=string");
+
+    BOOST_CHECK_EQUAL( r.raw(), raw );
+}
diff --git a/extlibs/websocketpp/test/http/parser_perf.cpp b/extlibs/websocketpp/test/http/parser_perf.cpp
new file mode 100644
index 000000000..0c76bc77a
--- /dev/null
+++ b/extlibs/websocketpp/test/http/parser_perf.cpp
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <websocketpp/http/parser.hpp>
+
+#include <chrono>
+
+class scoped_timer {
+public:
+    scoped_timer(std::string i) : m_id(i),m_start(std::chrono::steady_clock::now()) {
+        std::cout << "Clock " << i << ": ";
+    }
+    ~scoped_timer() {
+        std::chrono::nanoseconds time_taken = std::chrono::steady_clock::now()-m_start;
+
+        //nanoseconds_per_test
+
+        //tests_per_second
+
+        //1000000000.0/(double(time_taken.count())/1000.0)
+
+        std::cout << 1000000000.0/(double(time_taken.count())/1000.0) << std::endl;
+
+        //std::cout << (1.0/double(time_taken.count())) * double(1000000000*1000) << std::endl;
+    }
+
+private:
+    std::string m_id;
+    std::chrono::steady_clock::time_point m_start;
+};
+
+int main() {
+    std::string raw = "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n";
+
+    std::string firefox = "GET / HTTP/1.1\r\nHost: localhost:5000\r\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:10.0) Gecko/20100101 Firefox/10.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-us,en;q=0.5\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive, Upgrade\r\nSec-WebSocket-Version: 8\r\nSec-WebSocket-Origin: http://zaphoyd.com\r\nSec-WebSocket-Key: pFik//FxwFk0riN4ZiPFjQ==\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nUpgrade: websocket\r\n\r\n";
+
+    std::string firefox1 = "GET / HTTP/1.1\r\nHost: localhost:5000\r\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:10.0) Gecko/20100101 Firefox/10.0\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-us,en;q=0.5\r\n";
+
+    std::string firefox2 = "Accept-Encoding: gzip, deflate\r\nConnection: keep-alive, Upgrade\r\nSec-WebSocket-Version: 8\r\nSec-WebSocket-Origin: http://zaphoyd.com\r\nSec-WebSocket-Key: pFik//FxwFk0riN4ZiPFjQ==\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nUpgrade: websocket\r\n\r\n";
+
+    {
+        scoped_timer timer("Simplest 1 chop");
+        for (int i = 0; i < 1000; i++) {
+            websocketpp::http::parser::request r;
+
+            try {
+                r.consume(raw.c_str(),raw.size());
+            } catch (...) {
+                std::cout << "exception" << std::endl;
+            }
+
+            if (!r.ready()) {
+                std::cout << "error" << std::endl;
+                break;
+            }
+        }
+    }
+
+    {
+        scoped_timer timer("FireFox, 1 chop, consume old");
+        for (int i = 0; i < 1000; i++) {
+            websocketpp::http::parser::request r;
+
+            try {
+                r.consume2(firefox.c_str(),firefox.size());
+            } catch (...) {
+                std::cout << "exception" << std::endl;
+            }
+
+            if (!r.ready()) {
+                std::cout << "error" << std::endl;
+                break;
+            }
+        }
+    }
+
+    {
+        scoped_timer timer("FireFox, 1 chop");
+        for (int i = 0; i < 1000; i++) {
+            websocketpp::http::parser::request r;
+
+            try {
+                r.consume(firefox.c_str(),firefox.size());
+            } catch (...) {
+                std::cout << "exception" << std::endl;
+            }
+
+            if (!r.ready()) {
+                std::cout << "error" << std::endl;
+                break;
+            }
+        }
+    }
+
+
+
+    {
+        scoped_timer timer("FireFox, 2 chop");
+        for (int i = 0; i < 1000; i++) {
+            websocketpp::http::parser::request r;
+
+            try {
+                r.consume(firefox1.c_str(),firefox1.size());
+                r.consume(firefox2.c_str(),firefox2.size());
+            } catch (...) {
+                std::cout << "exception" << std::endl;
+            }
+
+            if (!r.ready()) {
+                std::cout << "error" << std::endl;
+                break;
+            }
+        }
+    }
+
+    return 0;
+}
diff --git a/extlibs/websocketpp/test/logger/SConscript b/extlibs/websocketpp/test/logger/SConscript
new file mode 100644
index 000000000..81d607601
--- /dev/null
+++ b/extlibs/websocketpp/test/logger/SConscript
@@ -0,0 +1,23 @@
+## logger unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system'],env) + [platform_libs]
+
+objs = env.Object('logger_basic_boost.o', ["basic.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('logger_basic_boost', ["logger_basic_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework','system'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   objs += env_cpp11.Object('logger_basic_stl.o', ["basic.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('logger_basic_stl', ["logger_basic_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/logger/basic.cpp b/extlibs/websocketpp/test/logger/basic.cpp
new file mode 100644
index 000000000..de51e5ad2
--- /dev/null
+++ b/extlibs/websocketpp/test/logger/basic.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE basic_log
+#include <boost/test/unit_test.hpp>
+
+#include <string>
+
+#include <websocketpp/logger/basic.hpp>
+#include <websocketpp/concurrency/none.hpp>
+#include <websocketpp/concurrency/basic.hpp>
+
+BOOST_AUTO_TEST_CASE( is_token_char ) {
+    typedef websocketpp::log::basic<websocketpp::concurrency::none,websocketpp::log::elevel> error_log;
+
+    error_log elog;
+
+    BOOST_CHECK( elog.static_test(websocketpp::log::elevel::info ) == true );
+    BOOST_CHECK( elog.static_test(websocketpp::log::elevel::warn ) == true );
+    BOOST_CHECK( elog.static_test(websocketpp::log::elevel::rerror ) == true );
+    BOOST_CHECK( elog.static_test(websocketpp::log::elevel::fatal ) == true );
+
+    elog.set_channels(websocketpp::log::elevel::info);
+
+    elog.write(websocketpp::log::elevel::info,"Information");
+    elog.write(websocketpp::log::elevel::warn,"A warning");
+    elog.write(websocketpp::log::elevel::rerror,"A error");
+    elog.write(websocketpp::log::elevel::fatal,"A critical error");
+}
+
+BOOST_AUTO_TEST_CASE( access_clear ) {
+    typedef websocketpp::log::basic<websocketpp::concurrency::none,websocketpp::log::alevel> access_log;
+
+    std::stringstream out;
+    access_log logger(0xffffffff,&out);
+
+    // clear all channels
+    logger.clear_channels(0xffffffff);
+
+    // writes shouldn't happen
+    logger.write(websocketpp::log::alevel::devel,"devel");
+    //std::cout << "|" << out.str() << "|" << std::endl;
+    BOOST_CHECK( out.str().size() == 0 );
+}
+
+BOOST_AUTO_TEST_CASE( basic_concurrency ) {
+    typedef websocketpp::log::basic<websocketpp::concurrency::basic,websocketpp::log::alevel> access_log;
+
+    std::stringstream out;
+    access_log logger(0xffffffff,&out);
+
+    logger.set_channels(0xffffffff);
+
+    logger.write(websocketpp::log::alevel::devel,"devel");
+    //std::cout << "|" << out.str() << "|" << std::endl;
+    BOOST_CHECK( out.str().size() > 0 );
+}
diff --git a/extlibs/websocketpp/test/message_buffer/SConscript b/extlibs/websocketpp/test/message_buffer/SConscript
new file mode 100644
index 000000000..2ef6d71f3
--- /dev/null
+++ b/extlibs/websocketpp/test/message_buffer/SConscript
@@ -0,0 +1,27 @@
+## message_buffer unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system'],env) + [platform_libs]
+
+objs = env.Object('message_boost.o', ["message.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('alloc_boost.o', ["alloc.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_message_boost', ["message_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_alloc_boost', ["alloc_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   objs += env_cpp11.Object('message_stl.o', ["message.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('alloc_stl.o', ["alloc.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_message_stl', ["message_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_alloc_stl', ["alloc_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/message_buffer/alloc.cpp b/extlibs/websocketpp/test/message_buffer/alloc.cpp
new file mode 100644
index 000000000..9f6ba2ab7
--- /dev/null
+++ b/extlibs/websocketpp/test/message_buffer/alloc.cpp
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE message_buffer_alloc
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/message_buffer/alloc.hpp>
+
+template <template <class> class con_msg_manager>
+struct stub {
+    typedef websocketpp::lib::shared_ptr<stub> ptr;
+
+    typedef con_msg_manager<stub> con_msg_man_type;
+    typedef typename con_msg_man_type::ptr con_msg_man_ptr;
+    typedef typename con_msg_man_type::weak_ptr con_msg_man_weak_ptr;
+
+    stub(con_msg_man_ptr manager, websocketpp::frame::opcode::value op, size_t size = 128)
+      : m_opcode(op)
+      , m_manager(manager)
+      , m_size(size) {}
+
+    bool recycle() {
+        con_msg_man_ptr shared = m_manager.lock();
+
+        if (shared) {
+            return shared->recycle(this);
+        } else {
+            return false;
+        }
+    }
+
+    websocketpp::frame::opcode::value   m_opcode;
+    con_msg_man_weak_ptr                m_manager;
+    size_t                              m_size;
+};
+
+BOOST_AUTO_TEST_CASE( basic_get_message ) {
+    typedef stub<websocketpp::message_buffer::alloc::con_msg_manager>
+        message_type;
+    typedef websocketpp::message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_man_type;
+
+    con_msg_man_type::ptr manager(new con_msg_man_type());
+    message_type::ptr msg = manager->get_message(websocketpp::frame::opcode::TEXT,512);
+
+    BOOST_CHECK(msg);
+    BOOST_CHECK(msg->m_opcode == websocketpp::frame::opcode::TEXT);
+    BOOST_CHECK(msg->m_manager.lock() == manager);
+    BOOST_CHECK(msg->m_size == 512);
+}
+
+BOOST_AUTO_TEST_CASE( basic_get_manager ) {
+    typedef stub<websocketpp::message_buffer::alloc::con_msg_manager>
+        message_type;
+    typedef websocketpp::message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_man_type;
+    typedef websocketpp::message_buffer::alloc::endpoint_msg_manager
+        <con_msg_man_type> endpoint_manager_type;
+
+    endpoint_manager_type em;
+    con_msg_man_type::ptr manager = em.get_manager();
+    message_type::ptr msg = manager->get_message(websocketpp::frame::opcode::TEXT,512);
+
+    BOOST_CHECK(msg);
+    BOOST_CHECK(msg->m_opcode == websocketpp::frame::opcode::TEXT);
+    BOOST_CHECK(msg->m_manager.lock() == manager);
+    BOOST_CHECK(msg->m_size == 512);
+}
+
diff --git a/extlibs/websocketpp/test/message_buffer/message.cpp b/extlibs/websocketpp/test/message_buffer/message.cpp
new file mode 100644
index 000000000..1fb12d319
--- /dev/null
+++ b/extlibs/websocketpp/test/message_buffer/message.cpp
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE message
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/message_buffer/message.hpp>
+
+template <typename message>
+struct stub {
+    typedef websocketpp::lib::weak_ptr<stub> weak_ptr;
+    typedef websocketpp::lib::shared_ptr<stub> ptr;
+
+    stub() : recycled(false) {}
+
+    bool recycle(message *) {
+        this->recycled = true;
+        return false;
+    }
+
+    bool recycled;
+};
+
+BOOST_AUTO_TEST_CASE( basic_size_check ) {
+    typedef websocketpp::message_buffer::message<stub> message_type;
+    typedef stub<message_type> stub_type;
+
+    stub_type::ptr s(new stub_type());
+    message_type::ptr msg(new message_type(s,websocketpp::frame::opcode::TEXT,500));
+
+    BOOST_CHECK(msg->get_payload().capacity() >= 500);
+}
+
+BOOST_AUTO_TEST_CASE( recycle ) {
+    typedef websocketpp::message_buffer::message<stub> message_type;
+    typedef stub<message_type> stub_type;
+
+    stub_type::ptr s(new stub_type());
+    message_type::ptr msg(new message_type(s,websocketpp::frame::opcode::TEXT,500));
+
+    BOOST_CHECK(s->recycled == false);
+    BOOST_CHECK(msg->recycle() == false);
+    BOOST_CHECK(s->recycled == true);
+}
+
diff --git a/extlibs/websocketpp/test/message_buffer/pool.cpp b/extlibs/websocketpp/test/message_buffer/pool.cpp
new file mode 100644
index 000000000..70f020d7b
--- /dev/null
+++ b/extlibs/websocketpp/test/message_buffer/pool.cpp
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE hybi_00_processor
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/processors/hybi00.hpp>
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+
+
+BOOST_AUTO_TEST_CASE( exact_match ) {
+    websocketpp::http::parser::request r;
+    websocketpp::http::parser::response response;
+    websocketpp::processor::hybi00<websocketpp::http::parser::request,websocketpp::http::parser::response> p(false);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nOrigin: http://example.com\r\nSec-WebSocket-Key1: 3e6b263  4 17 80\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+    r.replace_header("Sec-WebSocket-Key3","WjN}|M(6");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    BOOST_CHECK(p.validate_handshake(r));
+
+    websocketpp::uri_ptr u;
+    bool exception;
+
+    try {
+        u = p.get_uri(r);
+    } catch (const websocketpp::uri_exception& e) {
+        exception = true;
+    }
+
+    BOOST_CHECK(exception == false);
+    BOOST_CHECK(u->get_secure() == false);
+    BOOST_CHECK(u->get_host() == "www.example.com");
+    BOOST_CHECK(u->get_resource() == "/");
+    BOOST_CHECK(u->get_port() == websocketpp::URI_DEFAULT_PORT);
+
+    p.process_handshake(r,response);
+
+    BOOST_CHECK(response.get_header("Connection") == "Upgrade");
+    BOOST_CHECK(response.get_header("Upgrade") == "websocket");
+    BOOST_CHECK(response.get_header("Sec-WebSocket-Origin") == "http://example.com");
+
+    BOOST_CHECK(response.get_header("Sec-WebSocket-Location") == "ws://www.example.com/");
+    BOOST_CHECK(response.get_header("Sec-WebSocket-Key3") == "n`9eBk9z$R8pOtVb");
+}
+
+BOOST_AUTO_TEST_CASE( non_get_method ) {
+    websocketpp::http::parser::request r;
+    websocketpp::processor::hybi00<websocketpp::http::parser::request,websocketpp::http::parser::response> p(false);
+
+    std::string handshake = "POST / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Key1: 3e6b263  4 17 80\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+    r.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    BOOST_CHECK(!p.validate_handshake(r));
+}
+
+BOOST_AUTO_TEST_CASE( old_http_version ) {
+    websocketpp::http::parser::request r;
+    websocketpp::processor::hybi00<websocketpp::http::parser::request,websocketpp::http::parser::response> p(false);
+
+    std::string handshake = "GET / HTTP/1.0\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Key1: 3e6b263  4 17 80\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+    r.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    BOOST_CHECK(!p.validate_handshake(r));
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key1 ) {
+    websocketpp::http::parser::request r;
+    websocketpp::processor::hybi00<websocketpp::http::parser::request,websocketpp::http::parser::response> p(false);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Key1: 3e6b263  4 17 80\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+    r.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    BOOST_CHECK(!p.validate_handshake(r));
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key2 ) {
+    websocketpp::http::parser::request r;
+    websocketpp::processor::hybi00<websocketpp::http::parser::request,websocketpp::http::parser::response> p(false);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+    r.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    BOOST_CHECK(!p.validate_handshake(r));
+}
+
+BOOST_AUTO_TEST_CASE( bad_host ) {
+    websocketpp::http::parser::request r;
+    websocketpp::processor::hybi00<websocketpp::http::parser::request,websocketpp::http::parser::response> p(false);
+    websocketpp::uri_ptr u;
+    bool exception = false;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com:70000\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+    r.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    BOOST_CHECK(!p.validate_handshake(r));
+
+    try {
+        u = p.get_uri(r);
+    } catch (const websocketpp::uri_exception& e) {
+        exception = true;
+    }
+
+    BOOST_CHECK(exception == true);
+}
diff --git a/extlibs/websocketpp/test/processors/SConscript b/extlibs/websocketpp/test/processors/SConscript
new file mode 100644
index 000000000..406a7edc9
--- /dev/null
+++ b/extlibs/websocketpp/test/processors/SConscript
@@ -0,0 +1,47 @@
+## processor unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system'],env) + [platform_libs] + ['z']
+
+objs = env.Object('test_processor_boost.o', ["processor.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('test_hybi13_boost.o', ["hybi13.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('test_hybi08_boost.o', ["hybi08.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('test_hybi07_boost.o', ["hybi07.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('test_hybi00_boost.o', ["hybi00.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('test_extension_permessage_compress_boost.o', ["extension_permessage_compress.cpp"], LIBS = BOOST_LIBS)
+
+prgs = env.Program('test_processor_boost', ["test_processor_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_hybi13_boost', ["test_hybi13_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_hybi08_boost', ["test_hybi08_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_hybi07_boost', ["test_hybi07_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_hybi00_boost', ["test_hybi00_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_extension_permessage_compress_boost', ["test_extension_permessage_compress_boost.o"], LIBS = BOOST_LIBS + ['z'])
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework'],env_cpp11) + [platform_libs] + [polyfill_libs] + ['z']
+   # no C++11 features are used in processor so there are no C++11 versions of
+   # these tests.
+   objs += env_cpp11.Object('test_processor_stl.o', ["processor.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('test_hybi13_stl.o', ["hybi13.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('test_hybi08_stl.o', ["hybi08.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('test_hybi07_stl.o', ["hybi07.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('test_hybi00_stl.o', ["hybi00.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('test_extension_permessage_compress_stl.o', ["extension_permessage_compress.cpp"], LIBS = BOOST_LIBS_CPP11 + ['z'])
+
+   prgs += env_cpp11.Program('test_processor_stl', ["test_processor_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_hybi13_stl', ["test_hybi13_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_hybi08_stl', ["test_hybi08_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_hybi07_stl', ["test_hybi07_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_hybi00_stl', ["test_hybi00_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_extension_permessage_compress_stl', ["test_extension_permessage_compress_stl.o"], LIBS = BOOST_LIBS_CPP11 + ['z'])
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/processors/extension_permessage_compress.cpp b/extlibs/websocketpp/test/processors/extension_permessage_compress.cpp
new file mode 100644
index 000000000..9b84c995a
--- /dev/null
+++ b/extlibs/websocketpp/test/processors/extension_permessage_compress.cpp
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE extension_permessage_deflate
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+#include <websocketpp/common/memory.hpp>
+
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/extensions/permessage_deflate/enabled.hpp>
+
+struct config {
+    typedef websocketpp::http::parser::request request_type;
+};
+typedef websocketpp::extensions::permessage_deflate::enabled<config>
+    compressor_type;
+
+using namespace websocketpp;
+
+BOOST_AUTO_TEST_CASE( deflate_init ) {
+    /*compressor_type compressor;
+    websocketpp::http::parser::attribute_list attributes;
+    std::pair<lib::error_code,std::string> neg_ret;
+
+    neg_ret = compressor.negotiate(attributes);
+
+    BOOST_CHECK_EQUAL( neg_ret.first,
+        extensions::permessage_deflate::error::invalid_parameters );*/
+
+    /**
+     * Window size is primarily controlled by the writer. A stream can only be
+     * read by a window size equal to or greater than the one use to compress
+     * it initially. The default windows size is also the maximum window size.
+     * Thus:
+     *
+     * Outbound window size can be limited unilaterally under the assumption
+     * that the opposite end will be using the default (maximum size which can
+     * read anything)
+     *
+     * Inbound window size must be limited by asking the remote endpoint to
+     * do so and it agreeing.
+     *
+     * Context takeover is also primarily controlled by the writer. If the
+     * compressor does not clear its context between messages then the reader
+     * can't either.
+     *
+     * Outbound messages may clear context between messages unilaterally.
+     * Inbound messages must retain state unless the remote endpoint signals
+     * otherwise.
+     *
+     * Negotiation options:
+     * Client must choose from the following options:
+     * - whether or not to request an inbound window limit
+     * - whether or not to signal that it will honor an outbound window limit
+     * - whether or not to request that the server disallow context takeover
+     *
+     * Server must answer in the following ways
+     * - If client requested a window size limit, is the window size limit
+     *   acceptable?
+     * - If client allows window limit requests, should we send one?
+     * - If client requested no context takeover, should we accept?
+     *
+     *
+     *
+     * All Defaults
+     * Req: permessage-compress; method=deflate
+     * Ans: permessage-compress; method=deflate
+     *
+     * # Client wants to limit the size of inbound windows from server
+     * permessage-compress; method="deflate; s2c_max_window_bits=8, deflate"
+     * Ans: permessage-compress; method="deflate; s2c_max_window_bits=8"
+     * OR
+     * Ans: permessage-compress; method=deflate
+     *
+     * # Server wants to limit the size of inbound windows from client
+     * Client:
+     * permessage-compress; method="deflate; c2s_max_window_bits, deflate"
+     *
+     * Server:
+     * permessage-compress; method="deflate; c2s_max_window_bits=8"
+     *
+     * # Client wants to
+     *
+     *
+     *
+     *
+     *
+     *
+     */
+
+
+
+
+   /* processor::extensions::deflate_method d(true);
+    http::parser::attribute_list attributes;
+    lib::error_code ec;
+
+    attributes.push_back(http::parser::attribute("foo","bar"));
+    ec = d.init(attributes);
+    BOOST_CHECK(ec == processor::extensions::error::unknown_method_parameter);
+
+    attributes.clear();
+    attributes.push_back(http::parser::attribute("s2c_max_window_bits","bar"));
+    ec = d.init(attributes);
+    BOOST_CHECK(ec == processor::extensions::error::invalid_algorithm_settings);
+
+    attributes.clear();
+    attributes.push_back(http::parser::attribute("s2c_max_window_bits","7"));
+    ec = d.init(attributes);
+    BOOST_CHECK(ec == processor::extensions::error::invalid_algorithm_settings);
+
+    attributes.clear();
+    attributes.push_back(http::parser::attribute("s2c_max_window_bits","16"));
+    ec = d.init(attributes);
+    BOOST_CHECK(ec == processor::extensions::error::invalid_algorithm_settings);
+
+    attributes.clear();
+    attributes.push_back(http::parser::attribute("s2c_max_window_bits","9"));
+    ec = d.init(attributes);
+    BOOST_CHECK( !ec);
+
+    attributes.clear();
+    ec = d.init(attributes);
+    BOOST_CHECK( !ec);
+
+    processor::extensions::deflate_engine de;
+
+    unsigned char test_in[] = "HelloHelloHelloHello";
+    unsigned char test_out[30];
+
+    uLongf test_out_size = 30;
+
+    int ret;
+
+    ret = compress(test_out, &test_out_size, test_in, 20);
+
+    std::cout << ret << std::endl
+              << websocketpp::utility::to_hex(test_in,20) << std::endl
+              << websocketpp::utility::to_hex(test_out,test_out_size) << std::endl;
+
+    std::string input = "Hello";
+    std::string output = "";
+    ec = de.compress(input,output);
+
+    BOOST_CHECK( ec == processor::extensions::error::uninitialized );
+
+    //std::cout << ec.message() << websocketpp::utility::to_hex(output) << std::endl;
+
+    ec = de.init(15,15,Z_DEFAULT_COMPRESSION,8,Z_FIXED);
+    //ec = de.init();
+    BOOST_CHECK( !ec );
+
+    ec = de.compress(input,output);
+    std::cout << ec.message() << std::endl
+              << websocketpp::utility::to_hex(input) << std::endl
+              << websocketpp::utility::to_hex(output) << std::endl;
+
+    output = "";
+
+    ec = de.compress(input,output);
+    std::cout << ec.message() << std::endl
+              << websocketpp::utility::to_hex(input) << std::endl
+              << websocketpp::utility::to_hex(output) << std::endl;
+
+    input = output;
+    output = "";
+    ec = de.decompress(input,output);
+    std::cout << ec.message() << std::endl
+              << websocketpp::utility::to_hex(input) << std::endl
+              << websocketpp::utility::to_hex(output) << std::endl;
+    */
+}
diff --git a/extlibs/websocketpp/test/processors/hybi00.cpp b/extlibs/websocketpp/test/processors/hybi00.cpp
new file mode 100644
index 000000000..b201e8ac3
--- /dev/null
+++ b/extlibs/websocketpp/test/processors/hybi00.cpp
@@ -0,0 +1,274 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE hybi_00_processor
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/processors/hybi00.hpp>
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+#include <websocketpp/message_buffer/message.hpp>
+#include <websocketpp/message_buffer/alloc.hpp>
+
+struct stub_config {
+    typedef websocketpp::http::parser::request request_type;
+    typedef websocketpp::http::parser::response response_type;
+
+    typedef websocketpp::message_buffer::message
+        <websocketpp::message_buffer::alloc::con_msg_manager> message_type;
+    typedef websocketpp::message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_manager_type;
+        
+    static const size_t max_message_size = 16000000;
+};
+
+struct processor_setup {
+    processor_setup(bool server)
+      : msg_manager(new stub_config::con_msg_manager_type())
+      , p(false,server,msg_manager) {}
+
+    websocketpp::lib::error_code ec;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::request_type req;
+    stub_config::response_type res;
+    websocketpp::processor::hybi00<stub_config> p;
+};
+
+typedef stub_config::message_type::ptr message_ptr;
+
+BOOST_AUTO_TEST_CASE( exact_match ) {
+    processor_setup env(true);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nOrigin: http://example.com\r\nSec-WebSocket-Key1: 3e6b263  4 17 80\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+    env.req.replace_header("Sec-WebSocket-Key3","WjN}|M(6");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(env.req));
+    BOOST_CHECK_EQUAL(websocketpp::processor::get_websocket_version(env.req), env.p.get_version());
+    env.ec = env.p.validate_handshake(env.req);
+    BOOST_CHECK(!env.ec);
+
+    websocketpp::uri_ptr u;
+
+    BOOST_CHECK_NO_THROW( u = env.p.get_uri(env.req) );
+
+    BOOST_CHECK_EQUAL(u->get_secure(), false);
+    BOOST_CHECK_EQUAL(u->get_host(), "www.example.com");
+    BOOST_CHECK_EQUAL(u->get_resource(), "/");
+    BOOST_CHECK_EQUAL(u->get_port(), websocketpp::uri_default_port);
+
+    env.p.process_handshake(env.req,"",env.res);
+
+    BOOST_CHECK_EQUAL(env.res.get_header("Connection"), "Upgrade");
+    BOOST_CHECK_EQUAL(env.res.get_header("Upgrade"), "WebSocket");
+    BOOST_CHECK_EQUAL(env.res.get_header("Sec-WebSocket-Origin"), "http://example.com");
+
+    BOOST_CHECK_EQUAL(env.res.get_header("Sec-WebSocket-Location"), "ws://www.example.com/");
+    BOOST_CHECK_EQUAL(env.res.get_header("Sec-WebSocket-Key3"), "n`9eBk9z$R8pOtVb");
+}
+
+BOOST_AUTO_TEST_CASE( non_get_method ) {
+    processor_setup env(true);
+
+    std::string handshake = "POST / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Key1: 3e6b263  4 17 80\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+    env.req.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(env.req));
+    BOOST_CHECK_EQUAL(websocketpp::processor::get_websocket_version(env.req), env.p.get_version());
+    BOOST_CHECK_EQUAL( env.p.validate_handshake(env.req), websocketpp::processor::error::invalid_http_method );
+}
+
+BOOST_AUTO_TEST_CASE( old_http_version ) {
+    processor_setup env(true);
+
+    std::string handshake = "GET / HTTP/1.0\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Key1: 3e6b263  4 17 80\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+    env.req.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(env.req));
+    BOOST_CHECK_EQUAL(websocketpp::processor::get_websocket_version(env.req), env.p.get_version());
+    BOOST_CHECK_EQUAL( env.p.validate_handshake(env.req), websocketpp::processor::error::invalid_http_version );
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key1 ) {
+    processor_setup env(true);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Key1: 3e6b263  4 17 80\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+    env.req.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(env.req));
+    BOOST_CHECK_EQUAL(websocketpp::processor::get_websocket_version(env.req), env.p.get_version());
+    BOOST_CHECK_EQUAL( env.p.validate_handshake(env.req), websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key2 ) {
+    processor_setup env(true);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+    env.req.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(env.req));
+    BOOST_CHECK_EQUAL(websocketpp::processor::get_websocket_version(env.req), env.p.get_version());
+    BOOST_CHECK_EQUAL( env.p.validate_handshake(env.req), websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( bad_host ) {
+    processor_setup env(true);
+    websocketpp::uri_ptr u;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com:70000\r\nConnection: upgrade\r\nUpgrade: websocket\r\nOrigin: http://example.com\r\nSec-WebSocket-Key1: 3e6b263  4 17 80\r\nSec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+    env.req.replace_header("Sec-WebSocket-Key3","janelle!");
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(env.req));
+    BOOST_CHECK_EQUAL(websocketpp::processor::get_websocket_version(env.req), env.p.get_version());
+    BOOST_CHECK( !env.p.validate_handshake(env.req) );
+
+    BOOST_CHECK( !env.p.get_uri(env.req)->get_valid() );
+}
+
+BOOST_AUTO_TEST_CASE( extract_subprotocols ) {
+    processor_setup env(true);
+
+    std::vector<std::string> subps;
+
+    BOOST_CHECK( !env.p.extract_subprotocols(env.req,subps) );
+    BOOST_CHECK_EQUAL( subps.size(), 0 );
+}
+
+BOOST_AUTO_TEST_CASE( prepare_data_frame_null ) {
+    processor_setup env(true);
+
+    message_ptr in = env.msg_manager->get_message();
+    message_ptr out = env.msg_manager->get_message();
+    message_ptr invalid;
+
+
+    // empty pointers arguements should return sane error
+    BOOST_CHECK_EQUAL( env.p.prepare_data_frame(invalid,invalid), websocketpp::processor::error::invalid_arguments );
+
+    BOOST_CHECK_EQUAL( env.p.prepare_data_frame(in,invalid), websocketpp::processor::error::invalid_arguments );
+
+    BOOST_CHECK_EQUAL( env.p.prepare_data_frame(invalid,out), websocketpp::processor::error::invalid_arguments );
+
+    // test valid opcodes
+    // text (1) should be the only valid opcode
+    for (int i = 0; i < 0xF; i++) {
+        in->set_opcode(websocketpp::frame::opcode::value(i));
+
+        env.ec = env.p.prepare_data_frame(in,out);
+
+        if (i != 1) {
+            BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::invalid_opcode );
+        } else {
+            BOOST_CHECK_NE( env.ec, websocketpp::processor::error::invalid_opcode );
+        }
+    }
+
+    /*
+     * TODO: tests for invalid UTF8
+    char buf[2] = {0x00, 0x00};
+
+    in->set_opcode(websocketpp::frame::opcode::text);
+    in->set_payload("foo");
+
+    env.ec = env.p.prepare_data_frame(in,out);
+    BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::invalid_payload );
+    */
+}
+
+BOOST_AUTO_TEST_CASE( prepare_data_frame ) {
+    processor_setup env(true);
+
+    message_ptr in = env.msg_manager->get_message();
+    message_ptr out = env.msg_manager->get_message();
+
+    in->set_opcode(websocketpp::frame::opcode::text);
+    in->set_payload("foo");
+
+    env.ec = env.p.prepare_data_frame(in,out);
+
+    unsigned char raw_header[1] = {0x00};
+    unsigned char raw_payload[4] = {0x66,0x6f,0x6f,0xff};
+
+    BOOST_CHECK( !env.ec );
+    BOOST_CHECK_EQUAL( out->get_header(), std::string(reinterpret_cast<char*>(raw_header),1) );
+    BOOST_CHECK_EQUAL( out->get_payload(), std::string(reinterpret_cast<char*>(raw_payload),4) );
+}
+
+
+BOOST_AUTO_TEST_CASE( empty_consume ) {
+    uint8_t frame[2] = {0x00,0x00};
+
+    processor_setup env(true);
+
+    size_t ret = env.p.consume(frame,0,env.ec);
+
+    BOOST_CHECK_EQUAL( ret, 0);
+    BOOST_CHECK( !env.ec );
+    BOOST_CHECK_EQUAL( env.p.ready(), false );
+}
+
+BOOST_AUTO_TEST_CASE( empty_frame ) {
+    uint8_t frame[2] = {0x00, 0xff};
+
+    processor_setup env(true);
+
+    size_t ret = env.p.consume(frame,2,env.ec);
+
+    BOOST_CHECK_EQUAL( ret, 2);
+    BOOST_CHECK( !env.ec );
+    BOOST_CHECK_EQUAL( env.p.ready(), true );
+    BOOST_CHECK_EQUAL( env.p.get_message()->get_payload(), "" );
+    BOOST_CHECK_EQUAL( env.p.ready(), false );
+}
+
+BOOST_AUTO_TEST_CASE( short_frame ) {
+    uint8_t frame[5] = {0x00, 0x66, 0x6f, 0x6f, 0xff};
+
+    processor_setup env(true);
+
+    size_t ret = env.p.consume(frame,5,env.ec);
+
+    BOOST_CHECK_EQUAL( ret, 5);
+    BOOST_CHECK( !env.ec );
+    BOOST_CHECK_EQUAL( env.p.ready(), true );
+    BOOST_CHECK_EQUAL( env.p.get_message()->get_payload(), "foo" );
+    BOOST_CHECK_EQUAL( env.p.ready(), false );
+}
diff --git a/extlibs/websocketpp/test/processors/hybi07.cpp b/extlibs/websocketpp/test/processors/hybi07.cpp
new file mode 100644
index 000000000..7898f35d5
--- /dev/null
+++ b/extlibs/websocketpp/test/processors/hybi07.cpp
@@ -0,0 +1,193 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE hybi_07_processor
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/processors/hybi07.hpp>
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+#include <websocketpp/message_buffer/message.hpp>
+#include <websocketpp/message_buffer/alloc.hpp>
+#include <websocketpp/extensions/permessage_deflate/disabled.hpp>
+#include <websocketpp/random/none.hpp>
+
+struct stub_config {
+    typedef websocketpp::http::parser::request request_type;
+    typedef websocketpp::http::parser::response response_type;
+
+    typedef websocketpp::message_buffer::message
+        <websocketpp::message_buffer::alloc::con_msg_manager> message_type;
+    typedef websocketpp::message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_manager_type;
+
+    typedef websocketpp::random::none::int_generator<uint32_t> rng_type;
+
+    static const size_t max_message_size = 16000000;
+
+    /// Extension related config
+    static const bool enable_extensions = false;
+
+    /// Extension specific config
+
+    /// permessage_compress_config
+    struct permessage_deflate_config {
+        typedef stub_config::request_type request_type;
+    };
+
+    typedef websocketpp::extensions::permessage_deflate::disabled
+        <permessage_deflate_config> permessage_deflate_type;
+};
+
+BOOST_AUTO_TEST_CASE( exact_match ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi07<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 7\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK(!ec);
+
+    websocketpp::uri_ptr u;
+
+    u = p.get_uri(r);
+
+    BOOST_CHECK(u->get_valid());
+    BOOST_CHECK(!u->get_secure());
+    BOOST_CHECK_EQUAL(u->get_host(), "www.example.com");
+    BOOST_CHECK_EQUAL(u->get_resource(), "/");
+    BOOST_CHECK_EQUAL(u->get_port(), websocketpp::uri_default_port);
+
+    p.process_handshake(r,"",response);
+
+    BOOST_CHECK_EQUAL(response.get_header("Connection"), "upgrade");
+    BOOST_CHECK_EQUAL(response.get_header("Upgrade"), "websocket");
+    BOOST_CHECK_EQUAL(response.get_header("Sec-WebSocket-Accept"), "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=");
+}
+
+BOOST_AUTO_TEST_CASE( non_get_method ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi07<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "POST / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 7\r\nSec-WebSocket-Key: foo\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( ec == websocketpp::processor::error::invalid_http_method );
+}
+
+BOOST_AUTO_TEST_CASE( old_http_version ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi07<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.0\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 7\r\nSec-WebSocket-Key: foo\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( ec == websocketpp::processor::error::invalid_http_version );
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key1 ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi07<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 7\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( ec == websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key2 ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi07<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 7\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( ec == websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( bad_host ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi07<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com:70000\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 7\r\nSec-WebSocket-Key: foo\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( !ec );
+
+    BOOST_CHECK( !p.get_uri(r)->get_valid() );
+}
diff --git a/extlibs/websocketpp/test/processors/hybi08.cpp b/extlibs/websocketpp/test/processors/hybi08.cpp
new file mode 100644
index 000000000..b16b68e1a
--- /dev/null
+++ b/extlibs/websocketpp/test/processors/hybi08.cpp
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE hybi_08_processor
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/processors/hybi08.hpp>
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+#include <websocketpp/message_buffer/message.hpp>
+#include <websocketpp/message_buffer/alloc.hpp>
+#include <websocketpp/extensions/permessage_deflate/disabled.hpp>
+#include <websocketpp/random/none.hpp>
+
+struct stub_config {
+    typedef websocketpp::http::parser::request request_type;
+    typedef websocketpp::http::parser::response response_type;
+
+    typedef websocketpp::message_buffer::message
+        <websocketpp::message_buffer::alloc::con_msg_manager> message_type;
+    typedef websocketpp::message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_manager_type;
+
+    typedef websocketpp::random::none::int_generator<uint32_t> rng_type;
+
+    static const size_t max_message_size = 16000000;
+
+    /// Extension related config
+    static const bool enable_extensions = false;
+
+    /// Extension specific config
+
+    /// permessage_deflate_config
+    struct permessage_deflate_config {
+        typedef stub_config::request_type request_type;
+    };
+
+    typedef websocketpp::extensions::permessage_deflate::disabled
+        <permessage_deflate_config> permessage_deflate_type;
+};
+
+BOOST_AUTO_TEST_CASE( exact_match ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi08<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 8\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK(!ec);
+
+    websocketpp::uri_ptr u;
+
+    u = p.get_uri(r);
+
+    BOOST_CHECK(u->get_valid() == true);
+    BOOST_CHECK(u->get_secure() == false);
+    BOOST_CHECK(u->get_host() == "www.example.com");
+    BOOST_CHECK(u->get_resource() == "/");
+    BOOST_CHECK(u->get_port() == websocketpp::uri_default_port);
+
+    p.process_handshake(r,"",response);
+
+    BOOST_CHECK(response.get_header("Connection") == "upgrade");
+    BOOST_CHECK(response.get_header("Upgrade") == "websocket");
+    BOOST_CHECK(response.get_header("Sec-WebSocket-Accept") == "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=");
+}
+
+BOOST_AUTO_TEST_CASE( non_get_method ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::rng_type rng;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    websocketpp::processor::hybi08<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "POST / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 8\r\nSec-WebSocket-Key: foo\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( ec == websocketpp::processor::error::invalid_http_method );
+}
+
+BOOST_AUTO_TEST_CASE( old_http_version ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi08<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.0\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 8\r\nSec-WebSocket-Key: foo\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( ec == websocketpp::processor::error::invalid_http_version );
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key1 ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi08<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 8\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( ec == websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key2 ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi08<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 8\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( ec == websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( bad_host ) {
+    stub_config::request_type r;
+    stub_config::response_type response;
+    stub_config::con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    websocketpp::processor::hybi08<stub_config> p(false,true,msg_manager,rng);
+    websocketpp::uri_ptr u;
+    websocketpp::lib::error_code ec;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com:70000\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 8\r\nSec-WebSocket-Key: foo\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == p.get_version());
+    ec = p.validate_handshake(r);
+    BOOST_CHECK( !ec );
+
+    u = p.get_uri(r);
+
+    BOOST_CHECK( !u->get_valid() );
+}
+
diff --git a/extlibs/websocketpp/test/processors/hybi13.cpp b/extlibs/websocketpp/test/processors/hybi13.cpp
new file mode 100644
index 000000000..d16ba1797
--- /dev/null
+++ b/extlibs/websocketpp/test/processors/hybi13.cpp
@@ -0,0 +1,693 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE hybi_13_processor
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/processors/hybi13.hpp>
+
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+#include <websocketpp/message_buffer/message.hpp>
+#include <websocketpp/message_buffer/alloc.hpp>
+#include <websocketpp/random/none.hpp>
+
+#include <websocketpp/extensions/permessage_deflate/disabled.hpp>
+#include <websocketpp/extensions/permessage_deflate/enabled.hpp>
+
+struct stub_config {
+    typedef websocketpp::http::parser::request request_type;
+    typedef websocketpp::http::parser::response response_type;
+
+    typedef websocketpp::message_buffer::message
+        <websocketpp::message_buffer::alloc::con_msg_manager> message_type;
+    typedef websocketpp::message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_manager_type;
+
+    typedef websocketpp::random::none::int_generator<uint32_t> rng_type;
+
+    struct permessage_deflate_config {
+        typedef stub_config::request_type request_type;
+    };
+
+    typedef websocketpp::extensions::permessage_deflate::disabled
+        <permessage_deflate_config> permessage_deflate_type;
+
+    static const size_t max_message_size = 16000000;
+    static const bool enable_extensions = false;
+};
+
+struct stub_config_ext {
+    typedef websocketpp::http::parser::request request_type;
+    typedef websocketpp::http::parser::response response_type;
+
+    typedef websocketpp::message_buffer::message
+        <websocketpp::message_buffer::alloc::con_msg_manager> message_type;
+    typedef websocketpp::message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_manager_type;
+
+    typedef websocketpp::random::none::int_generator<uint32_t> rng_type;
+
+    struct permessage_deflate_config {
+        typedef stub_config_ext::request_type request_type;
+    };
+
+    typedef websocketpp::extensions::permessage_deflate::enabled
+        <permessage_deflate_config> permessage_deflate_type;
+
+    static const size_t max_message_size = 16000000;
+    static const bool enable_extensions = true;
+};
+
+typedef stub_config::con_msg_manager_type con_msg_manager_type;
+typedef stub_config::message_type::ptr message_ptr;
+
+// Set up a structure that constructs new copies of all of the support structure
+// for using connection processors
+struct processor_setup {
+    processor_setup(bool server)
+      : msg_manager(new con_msg_manager_type())
+      , p(false,server,msg_manager,rng) {}
+
+    websocketpp::lib::error_code ec;
+    con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    stub_config::request_type req;
+    stub_config::response_type res;
+    websocketpp::processor::hybi13<stub_config> p;
+};
+
+struct processor_setup_ext {
+    processor_setup_ext(bool server)
+      : msg_manager(new con_msg_manager_type())
+      , p(false,server,msg_manager,rng) {}
+
+    websocketpp::lib::error_code ec;
+    con_msg_manager_type::ptr msg_manager;
+    stub_config::rng_type rng;
+    stub_config::request_type req;
+    stub_config::response_type res;
+    websocketpp::processor::hybi13<stub_config_ext> p;
+};
+
+BOOST_AUTO_TEST_CASE( exact_match ) {
+    processor_setup env(true);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(env.req));
+    BOOST_CHECK_EQUAL(websocketpp::processor::get_websocket_version(env.req), env.p.get_version());
+    BOOST_CHECK(!env.p.validate_handshake(env.req));
+
+    websocketpp::uri_ptr u;
+
+    BOOST_CHECK_NO_THROW( u = env.p.get_uri(env.req) );
+
+    BOOST_CHECK_EQUAL(u->get_secure(), false);
+    BOOST_CHECK_EQUAL(u->get_host(), "www.example.com");
+    BOOST_CHECK_EQUAL(u->get_resource(), "/");
+    BOOST_CHECK_EQUAL(u->get_port(), websocketpp::uri_default_port);
+
+    env.p.process_handshake(env.req,"",env.res);
+
+    BOOST_CHECK_EQUAL(env.res.get_header("Connection"), "upgrade");
+    BOOST_CHECK_EQUAL(env.res.get_header("Upgrade"), "websocket");
+    BOOST_CHECK_EQUAL(env.res.get_header("Sec-WebSocket-Accept"), "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=");
+}
+
+BOOST_AUTO_TEST_CASE( non_get_method ) {
+    processor_setup env(true);
+
+    std::string handshake = "POST / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: foo\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(env.req));
+    BOOST_CHECK_EQUAL(websocketpp::processor::get_websocket_version(env.req), env.p.get_version());
+    BOOST_CHECK( env.p.validate_handshake(env.req) == websocketpp::processor::error::invalid_http_method );
+}
+
+BOOST_AUTO_TEST_CASE( old_http_version ) {
+    processor_setup env(true);
+
+    std::string handshake = "GET / HTTP/1.0\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: foo\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(env.req));
+    BOOST_CHECK_EQUAL(websocketpp::processor::get_websocket_version(env.req), env.p.get_version());
+    BOOST_CHECK_EQUAL( env.p.validate_handshake(env.req), websocketpp::processor::error::invalid_http_version );
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key1 ) {
+    processor_setup env(true);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK( websocketpp::processor::is_websocket_handshake(env.req) );
+    BOOST_CHECK_EQUAL( websocketpp::processor::get_websocket_version(env.req), env.p.get_version() );
+    BOOST_CHECK_EQUAL( env.p.validate_handshake(env.req), websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( missing_handshake_key2 ) {
+    processor_setup env(true);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK( websocketpp::processor::is_websocket_handshake(env.req) );
+    BOOST_CHECK_EQUAL( websocketpp::processor::get_websocket_version(env.req), env.p.get_version() );
+    BOOST_CHECK_EQUAL( env.p.validate_handshake(env.req), websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( bad_host ) {
+    processor_setup env(true);
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com:70000\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: foo\r\n\r\n";
+
+    env.req.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK( websocketpp::processor::is_websocket_handshake(env.req) );
+    BOOST_CHECK_EQUAL( websocketpp::processor::get_websocket_version(env.req), env.p.get_version() );
+    BOOST_CHECK( !env.p.validate_handshake(env.req) );
+    BOOST_CHECK( !env.p.get_uri(env.req)->get_valid() );
+}
+
+// FRAME TESTS TO DO
+//
+// unmasked, 0 length, binary
+// 0x82 0x00
+//
+// masked, 0 length, binary
+// 0x82 0x80
+//
+// unmasked, 0 length, text
+// 0x81 0x00
+//
+// masked, 0 length, text
+// 0x81 0x80
+
+BOOST_AUTO_TEST_CASE( frame_empty_binary_unmasked ) {
+    uint8_t frame[2] = {0x82, 0x00};
+
+    // all in one chunk
+    processor_setup env1(false);
+
+    size_t ret1 = env1.p.consume(frame,2,env1.ec);
+
+    BOOST_CHECK_EQUAL( ret1, 2 );
+    BOOST_CHECK( !env1.ec );
+    BOOST_CHECK_EQUAL( env1.p.ready(), true );
+
+    // two separate chunks
+    processor_setup env2(false);
+
+    BOOST_CHECK_EQUAL( env2.p.consume(frame,1,env2.ec), 1 );
+    BOOST_CHECK( !env2.ec );
+    BOOST_CHECK_EQUAL( env2.p.ready(), false );
+
+    BOOST_CHECK_EQUAL( env2.p.consume(frame+1,1,env2.ec), 1 );
+    BOOST_CHECK( !env2.ec );
+    BOOST_CHECK_EQUAL( env2.p.ready(), true );
+}
+
+BOOST_AUTO_TEST_CASE( frame_small_binary_unmasked ) {
+    processor_setup env(false);
+
+    uint8_t frame[4] = {0x82, 0x02, 0x2A, 0x2A};
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( env.p.consume(frame,4,env.ec), 4 );
+    BOOST_CHECK( !env.ec );
+    BOOST_CHECK_EQUAL( env.p.ready(), true );
+
+    message_ptr foo = env.p.get_message();
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( foo->get_payload(), "**" );
+
+}
+
+BOOST_AUTO_TEST_CASE( frame_extended_binary_unmasked ) {
+    processor_setup env(false);
+
+    uint8_t frame[130] = {0x82, 0x7E, 0x00, 0x7E};
+    frame[0] = 0x82;
+    frame[1] = 0x7E;
+    frame[2] = 0x00;
+    frame[3] = 0x7E;
+    std::fill_n(frame+4,126,0x2A);
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( env.p.consume(frame,130,env.ec), 130 );
+    BOOST_CHECK( !env.ec );
+    BOOST_CHECK_EQUAL( env.p.ready(), true );
+
+    message_ptr foo = env.p.get_message();
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( foo->get_payload().size(), 126 );
+}
+
+BOOST_AUTO_TEST_CASE( frame_jumbo_binary_unmasked ) {
+    processor_setup env(false);
+
+    uint8_t frame[130] = {0x82, 0x7E, 0x00, 0x7E};
+    std::fill_n(frame+4,126,0x2A);
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( env.p.consume(frame,130,env.ec), 130 );
+    BOOST_CHECK( !env.ec );
+    BOOST_CHECK_EQUAL( env.p.ready(), true );
+
+    message_ptr foo = env.p.get_message();
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( foo->get_payload().size(), 126 );
+}
+
+BOOST_AUTO_TEST_CASE( control_frame_too_large ) {
+    processor_setup env(false);
+
+    uint8_t frame[130] = {0x88, 0x7E, 0x00, 0x7E};
+    std::fill_n(frame+4,126,0x2A);
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_GT( env.p.consume(frame,130,env.ec), 0 );
+    BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::control_too_big  );
+    BOOST_CHECK_EQUAL( env.p.ready(), false );
+}
+
+BOOST_AUTO_TEST_CASE( rsv_bits_used ) {
+    uint8_t frame[3][2] = {{0x90, 0x00},
+                           {0xA0, 0x00},
+                           {0xC0, 0x00}};
+
+    for (int i = 0; i < 3; i++) {
+        processor_setup env(false);
+
+        BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+        BOOST_CHECK_GT( env.p.consume(frame[i],2,env.ec), 0 );
+        BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::invalid_rsv_bit  );
+        BOOST_CHECK_EQUAL( env.p.ready(), false );
+    }
+}
+
+
+BOOST_AUTO_TEST_CASE( reserved_opcode_used ) {
+    uint8_t frame[10][2] = {{0x83, 0x00},
+                            {0x84, 0x00},
+                            {0x85, 0x00},
+                            {0x86, 0x00},
+                            {0x87, 0x00},
+                            {0x8B, 0x00},
+                            {0x8C, 0x00},
+                            {0x8D, 0x00},
+                            {0x8E, 0x00},
+                            {0x8F, 0x00}};
+
+    for (int i = 0; i < 10; i++) {
+        processor_setup env(false);
+
+        BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+        BOOST_CHECK_GT( env.p.consume(frame[i],2,env.ec), 0 );
+        BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::invalid_opcode  );
+        BOOST_CHECK_EQUAL( env.p.ready(), false );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( fragmented_control_message ) {
+    processor_setup env(false);
+
+    uint8_t frame[2] = {0x08, 0x00};
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_GT( env.p.consume(frame,2,env.ec), 0 );
+    BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::fragmented_control );
+    BOOST_CHECK_EQUAL( env.p.ready(), false );
+}
+
+BOOST_AUTO_TEST_CASE( fragmented_binary_message ) {
+    processor_setup env0(false);
+    processor_setup env1(false);
+
+    uint8_t frame0[6] = {0x02, 0x01, 0x2A, 0x80, 0x01, 0x2A};
+    uint8_t frame1[8] = {0x02, 0x01, 0x2A, 0x89, 0x00, 0x80, 0x01, 0x2A};
+
+    // read fragmented message in one chunk
+    BOOST_CHECK_EQUAL( env0.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( env0.p.consume(frame0,6,env0.ec), 6 );
+    BOOST_CHECK( !env0.ec );
+    BOOST_CHECK_EQUAL( env0.p.ready(), true );
+    BOOST_CHECK_EQUAL( env0.p.get_message()->get_payload(), "**" );
+
+    // read fragmented message in two chunks
+    BOOST_CHECK_EQUAL( env0.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( env0.p.consume(frame0,3,env0.ec), 3 );
+    BOOST_CHECK( !env0.ec );
+    BOOST_CHECK_EQUAL( env0.p.ready(), false );
+    BOOST_CHECK_EQUAL( env0.p.consume(frame0+3,3,env0.ec), 3 );
+    BOOST_CHECK( !env0.ec );
+    BOOST_CHECK_EQUAL( env0.p.ready(), true );
+    BOOST_CHECK_EQUAL( env0.p.get_message()->get_payload(), "**" );
+
+    // read fragmented message with control message in between
+    BOOST_CHECK_EQUAL( env0.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( env0.p.consume(frame1,8,env0.ec), 5 );
+    BOOST_CHECK( !env0.ec );
+    BOOST_CHECK_EQUAL( env0.p.ready(), true );
+    BOOST_CHECK_EQUAL( env0.p.get_message()->get_opcode(), websocketpp::frame::opcode::PING);
+    BOOST_CHECK_EQUAL( env0.p.consume(frame1+5,3,env0.ec), 3 );
+    BOOST_CHECK( !env0.ec );
+    BOOST_CHECK_EQUAL( env0.p.ready(), true );
+    BOOST_CHECK_EQUAL( env0.p.get_message()->get_payload(), "**" );
+
+    // read lone continuation frame
+    BOOST_CHECK_EQUAL( env0.p.get_message(), message_ptr() );
+    BOOST_CHECK_GT( env0.p.consume(frame0+3,3,env0.ec), 0);
+    BOOST_CHECK_EQUAL( env0.ec, websocketpp::processor::error::invalid_continuation );
+
+    // read two start frames in a row
+    BOOST_CHECK_EQUAL( env1.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( env1.p.consume(frame0,3,env1.ec), 3);
+    BOOST_CHECK( !env1.ec );
+    BOOST_CHECK_GT( env1.p.consume(frame0,3,env1.ec), 0);
+    BOOST_CHECK_EQUAL( env1.ec, websocketpp::processor::error::invalid_continuation );
+}
+
+BOOST_AUTO_TEST_CASE( unmasked_client_frame ) {
+    processor_setup env(true);
+
+    uint8_t frame[2] = {0x82, 0x00};
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_GT( env.p.consume(frame,2,env.ec), 0 );
+    BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::masking_required );
+    BOOST_CHECK_EQUAL( env.p.ready(), false );
+}
+
+BOOST_AUTO_TEST_CASE( masked_server_frame ) {
+    processor_setup env(false);
+
+    uint8_t frame[8] = {0x82, 0x82, 0xFF, 0xFF, 0xFF, 0xFF, 0xD5, 0xD5};
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_GT( env.p.consume(frame,8,env.ec), 0 );
+    BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::masking_forbidden );
+    BOOST_CHECK_EQUAL( env.p.ready(), false );
+}
+
+BOOST_AUTO_TEST_CASE( frame_small_binary_masked ) {
+    processor_setup env(true);
+
+    uint8_t frame[8] = {0x82, 0x82, 0xFF, 0xFF, 0xFF, 0xFF, 0xD5, 0xD5};
+
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( env.p.consume(frame,8,env.ec), 8 );
+    BOOST_CHECK( !env.ec );
+    BOOST_CHECK_EQUAL( env.p.ready(), true );
+    BOOST_CHECK_EQUAL( env.p.get_message()->get_payload(), "**" );
+}
+
+BOOST_AUTO_TEST_CASE( masked_fragmented_binary_message ) {
+    processor_setup env(true);
+
+    uint8_t frame0[14] = {0x02, 0x81, 0xAB, 0x23, 0x98, 0x45, 0x81,
+                         0x80, 0x81, 0xB8, 0x34, 0x12, 0xFF, 0x92};
+
+    // read fragmented message in one chunk
+    BOOST_CHECK_EQUAL( env.p.get_message(), message_ptr() );
+    BOOST_CHECK_EQUAL( env.p.consume(frame0,14,env.ec), 14 );
+    BOOST_CHECK( !env.ec );
+    BOOST_CHECK_EQUAL( env.p.ready(), true );
+    BOOST_CHECK_EQUAL( env.p.get_message()->get_payload(), "**" );
+}
+
+BOOST_AUTO_TEST_CASE( prepare_data_frame ) {
+    processor_setup env(true);
+
+    message_ptr in = env.msg_manager->get_message();
+    message_ptr out = env.msg_manager->get_message();
+    message_ptr invalid;
+
+    // empty pointers arguements should return sane error
+    BOOST_CHECK_EQUAL( env.p.prepare_data_frame(invalid,invalid), websocketpp::processor::error::invalid_arguments );
+
+    BOOST_CHECK_EQUAL( env.p.prepare_data_frame(in,invalid), websocketpp::processor::error::invalid_arguments );
+
+    BOOST_CHECK_EQUAL( env.p.prepare_data_frame(invalid,out), websocketpp::processor::error::invalid_arguments );
+
+    // test valid opcodes
+    // control opcodes should return an error, data ones shouldn't
+    for (int i = 0; i < 0xF; i++) {
+        in->set_opcode(websocketpp::frame::opcode::value(i));
+
+        env.ec = env.p.prepare_data_frame(in,out);
+
+        if (websocketpp::frame::opcode::is_control(in->get_opcode())) {
+            BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::invalid_opcode );
+        } else {
+            BOOST_CHECK_NE( env.ec, websocketpp::processor::error::invalid_opcode );
+        }
+    }
+
+
+    //in.set_payload("foo");
+
+    //e = prepare_data_frame(in,out);
+
+
+}
+
+BOOST_AUTO_TEST_CASE( single_frame_message_too_large ) {
+    processor_setup env(true);
+    
+    env.p.set_max_message_size(3);
+    
+    uint8_t frame0[10] = {0x82, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01};
+
+    // read message that is one byte too large
+    BOOST_CHECK_EQUAL( env.p.consume(frame0,10,env.ec), 6 );
+    BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::message_too_big );
+}
+
+BOOST_AUTO_TEST_CASE( multiple_frame_message_too_large ) {
+    processor_setup env(true);
+    
+    env.p.set_max_message_size(4);
+    
+    uint8_t frame0[8] = {0x02, 0x82, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01};
+    uint8_t frame1[9] = {0x80, 0x83, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01};
+
+    // read first message frame with size under the limit
+    BOOST_CHECK_EQUAL( env.p.consume(frame0,8,env.ec), 8 );
+    BOOST_CHECK( !env.ec );
+    
+    // read second message frame that puts the size over the limit
+    BOOST_CHECK_EQUAL( env.p.consume(frame1,9,env.ec), 6 );
+    BOOST_CHECK_EQUAL( env.ec, websocketpp::processor::error::message_too_big );
+}
+
+
+
+BOOST_AUTO_TEST_CASE( client_handshake_request ) {
+    processor_setup env(false);
+
+    websocketpp::uri_ptr u(new websocketpp::uri("ws://localhost/"));
+
+    env.p.client_handshake_request(env.req,u, std::vector<std::string>());
+
+    BOOST_CHECK_EQUAL( env.req.get_method(), "GET" );
+    BOOST_CHECK_EQUAL( env.req.get_version(), "HTTP/1.1");
+    BOOST_CHECK_EQUAL( env.req.get_uri(), "/");
+
+    BOOST_CHECK_EQUAL( env.req.get_header("Host"), "localhost");
+    BOOST_CHECK_EQUAL( env.req.get_header("Sec-WebSocket-Version"), "13");
+    BOOST_CHECK_EQUAL( env.req.get_header("Connection"), "Upgrade");
+    BOOST_CHECK_EQUAL( env.req.get_header("Upgrade"), "websocket");
+}
+
+// TODO:
+// test cases
+// - adding headers
+// - adding Upgrade header
+// - adding Connection header
+// - adding Sec-WebSocket-Version, Sec-WebSocket-Key, or Host header
+// - other Sec* headers?
+// - User Agent header?
+
+// Origin support
+// Subprotocol requests
+
+//websocketpp::uri_ptr u(new websocketpp::uri("ws://localhost/"));
+    //env.p.client_handshake_request(env.req,u);
+
+BOOST_AUTO_TEST_CASE( client_handshake_response_404 ) {
+    processor_setup env(false);
+
+    std::string res = "HTTP/1.1 404 Not Found\r\n\r\n";
+    env.res.consume(res.data(),res.size());
+
+    BOOST_CHECK_EQUAL( env.p.validate_server_handshake_response(env.req,env.res), websocketpp::processor::error::invalid_http_status );
+}
+
+BOOST_AUTO_TEST_CASE( client_handshake_response_no_upgrade ) {
+    processor_setup env(false);
+
+    std::string res = "HTTP/1.1 101 Switching Protocols\r\n\r\n";
+    env.res.consume(res.data(),res.size());
+
+    BOOST_CHECK_EQUAL( env.p.validate_server_handshake_response(env.req,env.res), websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( client_handshake_response_no_connection ) {
+    processor_setup env(false);
+
+    std::string res = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: foo, wEbsOckEt\r\n\r\n";
+    env.res.consume(res.data(),res.size());
+
+    BOOST_CHECK_EQUAL( env.p.validate_server_handshake_response(env.req,env.res), websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( client_handshake_response_no_accept ) {
+    processor_setup env(false);
+
+    std::string res = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: foo, wEbsOckEt\r\nConnection: bar, UpGrAdE\r\n\r\n";
+    env.res.consume(res.data(),res.size());
+
+    BOOST_CHECK_EQUAL( env.p.validate_server_handshake_response(env.req,env.res), websocketpp::processor::error::missing_required_header );
+}
+
+BOOST_AUTO_TEST_CASE( client_handshake_response ) {
+    processor_setup env(false);
+
+    env.req.append_header("Sec-WebSocket-Key", "dGhlIHNhbXBsZSBub25jZQ==");
+
+    std::string res = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: foo, wEbsOckEt\r\nConnection: bar, UpGrAdE\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\n\r\n";
+    env.res.consume(res.data(),res.size());
+
+    BOOST_CHECK( !env.p.validate_server_handshake_response(env.req,env.res) );
+}
+
+BOOST_AUTO_TEST_CASE( extensions_disabled ) {
+    processor_setup env(true);
+
+    env.req.replace_header("Sec-WebSocket-Extensions","");
+
+    std::pair<websocketpp::lib::error_code,std::string> neg_results;
+    neg_results = env.p.negotiate_extensions(env.req);
+
+    BOOST_CHECK_EQUAL( neg_results.first, websocketpp::processor::error::extensions_disabled );
+    BOOST_CHECK_EQUAL( neg_results.second, "" );
+}
+
+BOOST_AUTO_TEST_CASE( extension_negotiation_blank ) {
+    processor_setup_ext env(true);
+
+    env.req.replace_header("Sec-WebSocket-Extensions","");
+
+    std::pair<websocketpp::lib::error_code,std::string> neg_results;
+    neg_results = env.p.negotiate_extensions(env.req);
+
+    BOOST_CHECK( !neg_results.first );
+    BOOST_CHECK_EQUAL( neg_results.second, "" );
+}
+
+BOOST_AUTO_TEST_CASE( extension_negotiation_unknown ) {
+    processor_setup_ext env(true);
+
+    env.req.replace_header("Sec-WebSocket-Extensions","foo");
+
+    std::pair<websocketpp::lib::error_code,std::string> neg_results;
+    neg_results = env.p.negotiate_extensions(env.req);
+
+    BOOST_CHECK( !neg_results.first );
+    BOOST_CHECK_EQUAL( neg_results.second, "" );
+}
+
+BOOST_AUTO_TEST_CASE( extract_subprotocols_empty ) {
+    processor_setup env(true);
+    std::vector<std::string> subps;
+
+    BOOST_CHECK( !env.p.extract_subprotocols(env.req,subps) );
+    BOOST_CHECK_EQUAL( subps.size(), 0 );
+}
+
+BOOST_AUTO_TEST_CASE( extract_subprotocols_one ) {
+    processor_setup env(true);
+    std::vector<std::string> subps;
+
+    env.req.replace_header("Sec-WebSocket-Protocol","foo");
+
+    BOOST_CHECK( !env.p.extract_subprotocols(env.req,subps) );
+    BOOST_REQUIRE_EQUAL( subps.size(), 1 );
+    BOOST_CHECK_EQUAL( subps[0], "foo" );
+}
+
+BOOST_AUTO_TEST_CASE( extract_subprotocols_multiple ) {
+    processor_setup env(true);
+    std::vector<std::string> subps;
+
+    env.req.replace_header("Sec-WebSocket-Protocol","foo,bar");
+
+    BOOST_CHECK( !env.p.extract_subprotocols(env.req,subps) );
+    BOOST_REQUIRE_EQUAL( subps.size(), 2 );
+    BOOST_CHECK_EQUAL( subps[0], "foo" );
+    BOOST_CHECK_EQUAL( subps[1], "bar" );
+}
+
+BOOST_AUTO_TEST_CASE( extract_subprotocols_invalid) {
+    processor_setup env(true);
+    std::vector<std::string> subps;
+
+    env.req.replace_header("Sec-WebSocket-Protocol","foo,bar,,,,");
+
+    BOOST_CHECK_EQUAL( env.p.extract_subprotocols(env.req,subps), websocketpp::processor::error::make_error_code(websocketpp::processor::error::subprotocol_parse_error) );
+    BOOST_CHECK_EQUAL( subps.size(), 0 );
+}
+
+BOOST_AUTO_TEST_CASE( extension_negotiation_permessage_deflate ) {
+    processor_setup_ext env(true);
+
+    env.req.replace_header("Sec-WebSocket-Extensions",
+        "permessage-deflate; c2s_max_window_bits");
+
+    std::pair<websocketpp::lib::error_code,std::string> neg_results;
+    neg_results = env.p.negotiate_extensions(env.req);
+
+    BOOST_CHECK( !neg_results.first );
+    BOOST_CHECK_EQUAL( neg_results.second, "permessage-deflate" );
+}
+
diff --git a/extlibs/websocketpp/test/processors/processor.cpp b/extlibs/websocketpp/test/processors/processor.cpp
new file mode 100644
index 000000000..050564661
--- /dev/null
+++ b/extlibs/websocketpp/test/processors/processor.cpp
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE processors
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/processors/processor.hpp>
+#include <websocketpp/http/request.hpp>
+
+BOOST_AUTO_TEST_CASE( exact_match ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+}
+
+BOOST_AUTO_TEST_CASE( non_match ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(!websocketpp::processor::is_websocket_handshake(r));
+}
+
+BOOST_AUTO_TEST_CASE( ci_exact_match ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: UpGrAde\r\nUpgrade: WebSocket\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+}
+
+BOOST_AUTO_TEST_CASE( non_exact_match1 ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade,foo\r\nUpgrade: websocket,foo\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+}
+
+BOOST_AUTO_TEST_CASE( non_exact_match2 ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: keep-alive,Upgrade,foo\r\nUpgrade: foo,websocket,bar\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::is_websocket_handshake(r));
+}
+
+BOOST_AUTO_TEST_CASE( version_blank ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nUpgrade: websocket\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == 0);
+}
+
+BOOST_AUTO_TEST_CASE( version_7 ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 7\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == 7);
+}
+
+BOOST_AUTO_TEST_CASE( version_8 ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 8\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == 8);
+}
+
+BOOST_AUTO_TEST_CASE( version_13 ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == 13);
+}
+
+BOOST_AUTO_TEST_CASE( version_non_numeric ) {
+    websocketpp::http::parser::request r;
+
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nUpgrade: websocket\r\nSec-WebSocket-Version: abc\r\n\r\n";
+
+    r.consume(handshake.c_str(),handshake.size());
+
+    BOOST_CHECK(websocketpp::processor::get_websocket_version(r) == -1);
+}
\ No newline at end of file
diff --git a/extlibs/websocketpp/test/random/SConscript b/extlibs/websocketpp/test/random/SConscript
new file mode 100644
index 000000000..3cadc9e97
--- /dev/null
+++ b/extlibs/websocketpp/test/random/SConscript
@@ -0,0 +1,27 @@
+## random number generation unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','random','system'],env) + [platform_libs]
+
+objs = env.Object('random_none_boost.o', ["none.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('random_device_boost.o', ["random_device.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_random_none_boost', ["random_none_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_random_device_boost', ["random_device_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   objs += env_cpp11.Object('random_none_stl.o', ["none.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('random_device_stl.o', ["random_device.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_random_none_stl', ["random_none_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_random_device_stl', ["random_device_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/random/none.cpp b/extlibs/websocketpp/test/random/none.cpp
new file mode 100644
index 000000000..b27b23924
--- /dev/null
+++ b/extlibs/websocketpp/test/random/none.cpp
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE random_none
+#include <boost/test/unit_test.hpp>
+
+#include <websocketpp/common/stdint.hpp>
+#include <websocketpp/random/none.hpp>
+
+BOOST_AUTO_TEST_CASE( does_it_compile ) {
+    websocketpp::random::none::int_generator<int32_t> rng;
+
+    int32_t foo = rng();
+
+    BOOST_CHECK( foo == 0 );
+}
diff --git a/extlibs/websocketpp/test/random/random_device.cpp b/extlibs/websocketpp/test/random/random_device.cpp
new file mode 100644
index 000000000..b3ce3a5dd
--- /dev/null
+++ b/extlibs/websocketpp/test/random/random_device.cpp
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE random_device
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+
+#include <websocketpp/common/stdint.hpp>
+#include <websocketpp/random/random_device.hpp>
+#include <websocketpp/concurrency/none.hpp>
+
+BOOST_AUTO_TEST_CASE( compiles ) {
+    websocketpp::random::random_device::int_generator<int32_t,websocketpp::concurrency::none> rng;
+
+    bool e = false;
+
+    try {
+        int32_t foo = rng();
+        std::cout << foo << std::endl;
+    } catch (...) {
+        e = true;
+    }
+
+    BOOST_CHECK( e == false );
+}
diff --git a/extlibs/websocketpp/test/roles/SConscript b/extlibs/websocketpp/test/roles/SConscript
new file mode 100644
index 000000000..e86107ece
--- /dev/null
+++ b/extlibs/websocketpp/test/roles/SConscript
@@ -0,0 +1,27 @@
+## role unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system','random'],env) + [platform_libs]
+
+objs = env.Object('client_boost.o', ["client.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('server_boost.o', ["server.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_client_boost', ["client_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_server_boost', ["server_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   objs += env_cpp11.Object('client_stl.o', ["client.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('server_stl.o', ["server.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_client_stl', ["client_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_server_stl', ["server_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/roles/client.cpp b/extlibs/websocketpp/test/roles/client.cpp
new file mode 100644
index 000000000..9aab3eeb6
--- /dev/null
+++ b/extlibs/websocketpp/test/roles/client.cpp
@@ -0,0 +1,194 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE client
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+
+#include <websocketpp/random/random_device.hpp>
+
+#include <websocketpp/config/core.hpp>
+#include <websocketpp/client.hpp>
+
+#include <websocketpp/http/request.hpp>
+
+struct stub_config : public websocketpp::config::core {
+    typedef core::concurrency_type concurrency_type;
+
+    typedef core::request_type request_type;
+    typedef core::response_type response_type;
+
+    typedef core::message_type message_type;
+    typedef core::con_msg_manager_type con_msg_manager_type;
+    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef core::alog_type alog_type;
+    typedef core::elog_type elog_type;
+
+    //typedef core::rng_type rng_type;
+    typedef websocketpp::random::random_device::int_generator<uint32_t,concurrency_type> rng_type;
+
+    typedef core::transport_type transport_type;
+
+    typedef core::endpoint_base endpoint_base;
+
+    static const websocketpp::log::level elog_level = websocketpp::log::elevel::none;
+    static const websocketpp::log::level alog_level = websocketpp::log::alevel::none;
+};
+
+typedef websocketpp::client<stub_config> client;
+typedef client::connection_ptr connection_ptr;
+
+BOOST_AUTO_TEST_CASE( invalid_uri ) {
+    client c;
+    websocketpp::lib::error_code ec;
+
+    connection_ptr con = c.get_connection("foo", ec);
+
+    BOOST_CHECK_EQUAL( ec , websocketpp::error::make_error_code(websocketpp::error::invalid_uri) );
+}
+
+BOOST_AUTO_TEST_CASE( unsecure_endpoint ) {
+    client c;
+    websocketpp::lib::error_code ec;
+
+    connection_ptr con = c.get_connection("wss://localhost/", ec);
+
+    BOOST_CHECK_EQUAL( ec , websocketpp::error::make_error_code(websocketpp::error::endpoint_not_secure) );
+}
+
+BOOST_AUTO_TEST_CASE( get_connection ) {
+    client c;
+    websocketpp::lib::error_code ec;
+
+    connection_ptr con = c.get_connection("ws://localhost/", ec);
+
+    BOOST_CHECK( con );
+    BOOST_CHECK_EQUAL( con->get_host() , "localhost" );
+    BOOST_CHECK_EQUAL( con->get_port() , 80 );
+    BOOST_CHECK_EQUAL( con->get_secure() , false );
+    BOOST_CHECK_EQUAL( con->get_resource() , "/" );
+}
+
+BOOST_AUTO_TEST_CASE( connect_con ) {
+    client c;
+    websocketpp::lib::error_code ec;
+    std::stringstream out;
+    std::string o;
+
+    c.register_ostream(&out);
+
+    connection_ptr con = c.get_connection("ws://localhost/", ec);
+    c.connect(con);
+
+    o = out.str();
+    websocketpp::http::parser::request r;
+    r.consume(o.data(),o.size());
+
+    BOOST_CHECK( r.ready() );
+    BOOST_CHECK_EQUAL( r.get_method(), "GET");
+    BOOST_CHECK_EQUAL( r.get_version(), "HTTP/1.1");
+    BOOST_CHECK_EQUAL( r.get_uri(), "/");
+
+    BOOST_CHECK_EQUAL( r.get_header("Host"), "localhost");
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Version"), "13");
+    BOOST_CHECK_EQUAL( r.get_header("Connection"), "Upgrade");
+    BOOST_CHECK_EQUAL( r.get_header("Upgrade"), "websocket");
+
+    // Key is randomly generated & User-Agent will change so just check that
+    // they are not empty.
+    BOOST_CHECK_NE( r.get_header("Sec-WebSocket-Key"), "");
+    BOOST_CHECK_NE( r.get_header("User-Agent"), "" );
+
+    // connection should have written out an opening handshake request and be in
+    // the read response internal state
+
+    // TODO: more tests related to reading the HTTP response
+    std::stringstream channel2;
+    channel2 << "e\r\n\r\n";
+    channel2 >> *con;
+}
+
+BOOST_AUTO_TEST_CASE( select_subprotocol ) {
+    client c;
+    websocketpp::lib::error_code ec;
+    using websocketpp::error::make_error_code;
+
+    connection_ptr con = c.get_connection("ws://localhost/", ec);
+
+    BOOST_CHECK( con );
+
+    con->select_subprotocol("foo",ec);
+    BOOST_CHECK_EQUAL( ec , make_error_code(websocketpp::error::server_only) );
+    BOOST_CHECK_THROW( con->select_subprotocol("foo") , websocketpp::exception );
+}
+
+BOOST_AUTO_TEST_CASE( add_subprotocols_invalid ) {
+    client c;
+    websocketpp::lib::error_code ec;
+    using websocketpp::error::make_error_code;
+
+    connection_ptr con = c.get_connection("ws://localhost/", ec);
+    BOOST_CHECK( con );
+
+    con->add_subprotocol("",ec);
+    BOOST_CHECK_EQUAL( ec , make_error_code(websocketpp::error::invalid_subprotocol) );
+    BOOST_CHECK_THROW( con->add_subprotocol("") , websocketpp::exception );
+
+    con->add_subprotocol("foo,bar",ec);
+    BOOST_CHECK_EQUAL( ec , make_error_code(websocketpp::error::invalid_subprotocol) );
+    BOOST_CHECK_THROW( con->add_subprotocol("foo,bar") , websocketpp::exception );
+}
+
+BOOST_AUTO_TEST_CASE( add_subprotocols ) {
+    client c;
+    websocketpp::lib::error_code ec;
+    std::stringstream out;
+    std::string o;
+
+    c.register_ostream(&out);
+
+    connection_ptr con = c.get_connection("ws://localhost/", ec);
+    BOOST_CHECK( con );
+
+    con->add_subprotocol("foo",ec);
+    BOOST_CHECK( !ec );
+
+    BOOST_CHECK_NO_THROW( con->add_subprotocol("bar") );
+
+    c.connect(con);
+
+    o = out.str();
+    websocketpp::http::parser::request r;
+    r.consume(o.data(),o.size());
+
+    BOOST_CHECK( r.ready() );
+    BOOST_CHECK_EQUAL( r.get_header("Sec-WebSocket-Protocol"), "foo, bar");
+}
+
+
diff --git a/extlibs/websocketpp/test/roles/server.cpp b/extlibs/websocketpp/test/roles/server.cpp
new file mode 100644
index 000000000..cbe860737
--- /dev/null
+++ b/extlibs/websocketpp/test/roles/server.cpp
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE server
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+
+// Test Environment:
+// server, no TLS, no locks, iostream based transport
+#include <websocketpp/config/core.hpp>
+#include <websocketpp/server.hpp>
+
+typedef websocketpp::server<websocketpp::config::core> server;
+typedef websocketpp::config::core::message_type::ptr message_ptr;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+/*struct stub_config : public websocketpp::config::core {
+    typedef core::concurrency_type concurrency_type;
+
+    typedef core::request_type request_type;
+    typedef core::response_type response_type;
+
+    typedef core::message_type message_type;
+    typedef core::con_msg_manager_type con_msg_manager_type;
+    typedef core::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef core::alog_type alog_type;
+    typedef core::elog_type elog_type;
+
+    typedef core::rng_type rng_type;
+
+    typedef core::transport_type transport_type;
+
+    typedef core::endpoint_base endpoint_base;
+};*/
+
+/* Run server and return output test rig */
+std::string run_server_test(server& s, std::string input) {
+    server::connection_ptr con;
+    std::stringstream output;
+
+    s.register_ostream(&output);
+    s.clear_access_channels(websocketpp::log::alevel::all);
+    s.clear_error_channels(websocketpp::log::elevel::all);
+
+    con = s.get_connection();
+    con->start();
+
+    std::stringstream channel;
+
+    channel << input;
+    channel >> *con;
+
+    return output.str();
+}
+
+/* handler library*/
+void echo_func(server* s, websocketpp::connection_hdl hdl, message_ptr msg) {
+    s->send(hdl, msg->get_payload(), msg->get_opcode());
+}
+
+bool validate_func_subprotocol(server* s, std::string* out, std::string accept,
+    websocketpp::connection_hdl hdl)
+{
+    server::connection_ptr con = s->get_con_from_hdl(hdl);
+
+    std::stringstream o;
+
+    const std::vector<std::string> & protocols = con->get_requested_subprotocols();
+    std::vector<std::string>::const_iterator it;
+
+    for (it = protocols.begin(); it != protocols.end(); ++it) {
+        o << *it << ",";
+    }
+
+    *out = o.str();
+
+    if (accept != "") {
+        con->select_subprotocol(accept);
+    }
+
+    return true;
+}
+
+void open_func_subprotocol(server* s, std::string* out, websocketpp::connection_hdl hdl) {
+    server::connection_ptr con = s->get_con_from_hdl(hdl);
+
+    *out = con->get_subprotocol();
+}
+
+/* Tests */
+BOOST_AUTO_TEST_CASE( basic_websocket_request ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nServer: test\r\nUpgrade: websocket\r\n\r\n";
+
+    server s;
+    s.set_user_agent("test");
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+}
+
+BOOST_AUTO_TEST_CASE( invalid_websocket_version ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: a\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+    std::string output = "HTTP/1.1 400 Bad Request\r\nServer: test\r\n\r\n";
+
+    server s;
+    s.set_user_agent("test");
+    //s.set_message_handler(bind(&echo_func,&s,::_1,::_2));
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+}
+
+BOOST_AUTO_TEST_CASE( unimplemented_websocket_version ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 14\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\n\r\n";
+
+    std::string output = "HTTP/1.1 400 Bad Request\r\nSec-WebSocket-Version: 0,7,8,13\r\nServer: test\r\n\r\n";
+
+    server s;
+    s.set_user_agent("test");
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+}
+
+BOOST_AUTO_TEST_CASE( list_subprotocol_empty ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\nSec-WebSocket-Protocol: foo\r\n\r\n";
+
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nServer: test\r\nUpgrade: websocket\r\n\r\n";
+
+    std::string subprotocol;
+
+    server s;
+    s.set_user_agent("test");
+    s.set_open_handler(bind(&open_func_subprotocol,&s,&subprotocol,::_1));
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+    BOOST_CHECK_EQUAL(subprotocol, "");
+}
+
+BOOST_AUTO_TEST_CASE( list_subprotocol_one ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\nSec-WebSocket-Protocol: foo\r\n\r\n";
+
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nServer: test\r\nUpgrade: websocket\r\n\r\n";
+
+    std::string validate;
+    std::string open;
+
+    server s;
+    s.set_user_agent("test");
+    s.set_validate_handler(bind(&validate_func_subprotocol,&s,&validate,"",::_1));
+    s.set_open_handler(bind(&open_func_subprotocol,&s,&open,::_1));
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+    BOOST_CHECK_EQUAL(validate, "foo,");
+    BOOST_CHECK_EQUAL(open, "");
+}
+
+BOOST_AUTO_TEST_CASE( accept_subprotocol_one ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\nSec-WebSocket-Protocol: foo\r\n\r\n";
+
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nSec-WebSocket-Protocol: foo\r\nServer: test\r\nUpgrade: websocket\r\n\r\n";
+
+    std::string validate;
+    std::string open;
+
+    server s;
+    s.set_user_agent("test");
+    s.set_validate_handler(bind(&validate_func_subprotocol,&s,&validate,"foo",::_1));
+    s.set_open_handler(bind(&open_func_subprotocol,&s,&open,::_1));
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+    BOOST_CHECK_EQUAL(validate, "foo,");
+    BOOST_CHECK_EQUAL(open, "foo");
+}
+
+BOOST_AUTO_TEST_CASE( accept_subprotocol_invalid ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\nSec-WebSocket-Protocol: foo\r\n\r\n";
+
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nSec-WebSocket-Protocol: foo\r\nServer: test\r\nUpgrade: websocket\r\n\r\n";
+
+    std::string validate;
+    std::string open;
+
+    server s;
+    s.set_user_agent("test");
+    s.set_validate_handler(bind(&validate_func_subprotocol,&s,&validate,"foo2",::_1));
+    s.set_open_handler(bind(&open_func_subprotocol,&s,&open,::_1));
+
+    std::string o;
+
+    BOOST_CHECK_THROW(o = run_server_test(s,input), websocketpp::exception);
+}
+
+BOOST_AUTO_TEST_CASE( accept_subprotocol_two ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example.com\r\nSec-WebSocket-Protocol: foo, bar\r\n\r\n";
+
+    std::string output = "HTTP/1.1 101 Switching Protocols\r\nConnection: upgrade\r\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\nSec-WebSocket-Protocol: bar\r\nServer: test\r\nUpgrade: websocket\r\n\r\n";
+
+    std::string validate;
+    std::string open;
+
+    server s;
+    s.set_user_agent("test");
+    s.set_validate_handler(bind(&validate_func_subprotocol,&s,&validate,"bar",::_1));
+    s.set_open_handler(bind(&open_func_subprotocol,&s,&open,::_1));
+
+    BOOST_CHECK_EQUAL(run_server_test(s,input), output);
+    BOOST_CHECK_EQUAL(validate, "foo,bar,");
+    BOOST_CHECK_EQUAL(open, "bar");
+}
+
+/*BOOST_AUTO_TEST_CASE( user_reject_origin ) {
+    std::string input = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nOrigin: http://www.example2.com\r\n\r\n";
+    std::string output = "HTTP/1.1 403 Forbidden\r\nServer: test\r\n\r\n";
+
+    server s;
+    s.set_user_agent("test");
+
+    BOOST_CHECK(run_server_test(s,input) == output);
+}*/
diff --git a/extlibs/websocketpp/test/transport/SConscript b/extlibs/websocketpp/test/transport/SConscript
new file mode 100644
index 000000000..74ec781ef
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/SConscript
@@ -0,0 +1,24 @@
+## transport integration tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+Import('tls_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system','thread','random'],env) + [platform_libs] + [tls_libs]
+
+objs = env.Object('boost_integration.o', ["integration.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_boost_integration', ["boost_integration.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework','system'],env_cpp11) + [platform_libs] + [polyfill_libs] + [tls_libs]
+   objs += env_cpp11.Object('stl_integration.o', ["integration.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_stl_integration', ["stl_integration.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/transport/asio/SConscript b/extlibs/websocketpp/test/transport/asio/SConscript
new file mode 100644
index 000000000..6cae57c07
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/asio/SConscript
@@ -0,0 +1,28 @@
+## asio transport unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+Import('tls_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system','thread'],env) + [platform_libs] + [tls_libs]
+
+objs = env.Object('base_boost.o', ["base.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('timers_boost.o', ["timers.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_base_boost', ["base_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_timers_boost', ["timers_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework','system'],env_cpp11) + [platform_libs] + [polyfill_libs] + [tls_libs]
+   objs += env_cpp11.Object('base_stl.o', ["base.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('timers_stl.o', ["timers.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_base_stl', ["base_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_timers_stl', ["timers_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/transport/asio/base.cpp b/extlibs/websocketpp/test/transport/asio/base.cpp
new file mode 100644
index 000000000..e9f96ae32
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/asio/base.cpp
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE transport_asio_base
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+
+#include <websocketpp/transport/asio/base.hpp>
+
+BOOST_AUTO_TEST_CASE( blank_error ) {
+    websocketpp::lib::error_code ec;
+
+    BOOST_CHECK( !ec );
+}
+
+BOOST_AUTO_TEST_CASE( asio_error ) {
+    using websocketpp::transport::asio::error::make_error_code;
+    using websocketpp::transport::asio::error::general;
+
+    websocketpp::lib::error_code ec = make_error_code(general);
+
+    BOOST_CHECK( ec == general );
+    BOOST_CHECK( ec.value() == 1 );
+}
diff --git a/extlibs/websocketpp/test/transport/asio/timers.cpp b/extlibs/websocketpp/test/transport/asio/timers.cpp
new file mode 100644
index 000000000..fc17dabb4
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/asio/timers.cpp
@@ -0,0 +1,187 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE transport_asio_timers
+#include <boost/test/unit_test.hpp>
+
+#include <exception>
+#include <iostream>
+
+#include <websocketpp/common/thread.hpp>
+
+#include <websocketpp/transport/asio/endpoint.hpp>
+#include <websocketpp/transport/asio/security/tls.hpp>
+
+// Concurrency
+#include <websocketpp/concurrency/none.hpp>
+
+// HTTP
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+
+// Loggers
+#include <websocketpp/logger/stub.hpp>
+//#include <websocketpp/logger/basic.hpp>
+
+#include <boost/asio.hpp>
+
+// Accept a connection, read data, and discard until EOF
+void run_dummy_server(int port) {
+    using boost::asio::ip::tcp;
+
+    try {
+        boost::asio::io_service io_service;
+        tcp::acceptor acceptor(io_service, tcp::endpoint(tcp::v6(), port));
+        tcp::socket socket(io_service);
+
+        acceptor.accept(socket);
+        for (;;) {
+            char data[512];
+            boost::system::error_code ec;
+            socket.read_some(boost::asio::buffer(data), ec);
+            if (ec == boost::asio::error::eof) {
+                break;
+            } else if (ec) {
+                // other error
+                throw ec;
+            }
+        }
+    } catch (std::exception & e) {
+        std::cout << e.what() << std::endl;
+    } catch (boost::system::error_code & ec) {
+        std::cout << ec.message() << std::endl;
+    }
+}
+
+// Wait for the specified time period then fail the test
+void run_test_timer(long value) {
+    boost::asio::io_service ios;
+    boost::asio::deadline_timer t(ios,boost::posix_time::milliseconds(value));
+    boost::system::error_code ec;
+    t.wait(ec);
+    BOOST_FAIL( "Test timed out" );
+}
+
+struct config {
+    typedef websocketpp::concurrency::none concurrency_type;
+    //typedef websocketpp::log::basic<concurrency_type,websocketpp::log::alevel> alog_type;
+    typedef websocketpp::log::stub alog_type;
+    typedef websocketpp::log::stub elog_type;
+    typedef websocketpp::http::parser::request request_type;
+    typedef websocketpp::http::parser::response response_type;
+    typedef websocketpp::transport::asio::tls_socket::endpoint socket_type;
+
+    static const bool enable_multithreading = true;
+
+    static const long timeout_socket_pre_init = 1000;
+    static const long timeout_proxy = 1000;
+    static const long timeout_socket_post_init = 1000;
+    static const long timeout_dns_resolve = 1000;
+    static const long timeout_connect = 1000;
+    static const long timeout_socket_shutdown = 1000;
+};
+
+// Mock context that does no validation
+typedef websocketpp::lib::shared_ptr<boost::asio::ssl::context> context_ptr;
+context_ptr on_tls_init(websocketpp::connection_hdl) {
+    return context_ptr(new boost::asio::ssl::context(boost::asio::ssl::context::tlsv1));
+}
+
+// Mock connection
+struct mock_con: public websocketpp::transport::asio::connection<config> {
+    typedef websocketpp::transport::asio::connection<config> base;
+
+    mock_con(bool a, config::alog_type& b, config::elog_type& c) : base(a,b,c) {}
+
+    void start() {
+        base::init(websocketpp::lib::bind(&mock_con::handle_start,this,
+            websocketpp::lib::placeholders::_1));
+    }
+
+    void handle_start(const websocketpp::lib::error_code& ec) {
+        using websocketpp::transport::asio::socket::make_error_code;
+        using websocketpp::transport::asio::socket::error::tls_handshake_timeout;
+
+        BOOST_CHECK_EQUAL( ec, make_error_code(tls_handshake_timeout) );
+
+        base::cancel_socket();
+    }
+};
+
+typedef websocketpp::transport::asio::connection<config> con_type;
+typedef websocketpp::lib::shared_ptr<mock_con> connection_ptr;
+
+struct mock_endpoint : public websocketpp::transport::asio::endpoint<config> {
+    typedef websocketpp::transport::asio::endpoint<config> base;
+
+    mock_endpoint() {
+        alog.set_channels(websocketpp::log::alevel::all);
+        base::init_logging(&alog,&elog);
+        init_asio();
+    }
+
+    void connect(std::string u) {
+        m_con.reset(new mock_con(false,alog,elog));
+        websocketpp::uri_ptr uri(new websocketpp::uri(u));
+
+        BOOST_CHECK( uri->get_valid() );
+        BOOST_CHECK_EQUAL( base::init(m_con), websocketpp::lib::error_code() );
+
+        base::async_connect(
+            m_con,
+            uri,
+            websocketpp::lib::bind(
+                &mock_endpoint::handle_connect,
+                this,
+                m_con,
+                websocketpp::lib::placeholders::_1
+            )
+        );
+    }
+
+    void handle_connect(connection_ptr con, websocketpp::lib::error_code const & ec)
+    {
+        BOOST_CHECK( !ec );
+        con->start();
+    }
+
+    connection_ptr m_con;
+    config::alog_type alog;
+    config::elog_type elog;
+};
+
+BOOST_AUTO_TEST_CASE( tls_handshake_timeout ) {
+    websocketpp::lib::thread dummy_server(websocketpp::lib::bind(&run_dummy_server,9005));
+    websocketpp::lib::thread timer(websocketpp::lib::bind(&run_test_timer,5000));
+    dummy_server.detach();
+    timer.detach();
+
+    mock_endpoint endpoint;
+    endpoint.set_tls_init_handler(&on_tls_init);
+    endpoint.connect("wss://localhost:9005");
+    endpoint.run();
+}
diff --git a/extlibs/websocketpp/test/transport/hybi_util.cpp b/extlibs/websocketpp/test/transport/hybi_util.cpp
new file mode 100644
index 000000000..309bf377e
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/hybi_util.cpp
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE hybi_util
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+
+#include "../../src/processors/hybi_util.hpp"
+#include "../../src/network_utilities.hpp"
+
+BOOST_AUTO_TEST_CASE( circshift_0 ) {
+    if (sizeof(size_t) == 8) {
+        size_t test = 0x0123456789abcdef;
+
+        test = websocketpp::processor::hybi_util::circshift_prepared_key(test,0);
+
+        BOOST_CHECK( test == 0x0123456789abcdef);
+    } else {
+        size_t test = 0x01234567;
+
+        test = websocketpp::processor::hybi_util::circshift_prepared_key(test,0);
+
+        BOOST_CHECK( test == 0x01234567);
+    }
+}
+
+BOOST_AUTO_TEST_CASE( circshift_1 ) {
+    if (sizeof(size_t) == 8) {
+        size_t test = 0x0123456789abcdef;
+
+        test = websocketpp::processor::hybi_util::circshift_prepared_key(test,1);
+
+        BOOST_CHECK( test == 0xef0123456789abcd);
+    } else {
+        size_t test = 0x01234567;
+
+        test = websocketpp::processor::hybi_util::circshift_prepared_key(test,1);
+
+        BOOST_CHECK( test == 0x67012345);
+    }
+}
+
+BOOST_AUTO_TEST_CASE( circshift_2 ) {
+    if (sizeof(size_t) == 8) {
+        size_t test = 0x0123456789abcdef;
+
+        test = websocketpp::processor::hybi_util::circshift_prepared_key(test,2);
+
+        BOOST_CHECK( test == 0xcdef0123456789ab);
+    } else {
+        size_t test = 0x01234567;
+
+        test = websocketpp::processor::hybi_util::circshift_prepared_key(test,2);
+
+        BOOST_CHECK( test == 0x45670123);
+    }
+}
+
+BOOST_AUTO_TEST_CASE( circshift_3 ) {
+    if (sizeof(size_t) == 8) {
+        size_t test = 0x0123456789abcdef;
+
+        test = websocketpp::processor::hybi_util::circshift_prepared_key(test,3);
+
+        BOOST_CHECK( test == 0xabcdef0123456789);
+    } else {
+        size_t test = 0x01234567;
+
+        test = websocketpp::processor::hybi_util::circshift_prepared_key(test,3);
+
+        BOOST_CHECK( test == 0x23456701);
+    }
+}
diff --git a/extlibs/websocketpp/test/transport/integration.cpp b/extlibs/websocketpp/test/transport/integration.cpp
new file mode 100644
index 000000000..1d2e7e795
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/integration.cpp
@@ -0,0 +1,609 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE transport_integration
+#include <boost/test/unit_test.hpp>
+
+#include <websocketpp/common/thread.hpp>
+
+#include <websocketpp/config/core.hpp>
+#include <websocketpp/config/core_client.hpp>
+#include <websocketpp/config/asio.hpp>
+#include <websocketpp/config/asio_client.hpp>
+#include <websocketpp/config/debug_asio.hpp>
+#include <websocketpp/server.hpp>
+#include <websocketpp/client.hpp>
+
+struct config : public websocketpp::config::asio_client {
+    typedef config type;
+    typedef websocketpp::config::asio base;
+
+    typedef base::concurrency_type concurrency_type;
+
+    typedef base::request_type request_type;
+    typedef base::response_type response_type;
+
+    typedef base::message_type message_type;
+    typedef base::con_msg_manager_type con_msg_manager_type;
+    typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef base::alog_type alog_type;
+    typedef base::elog_type elog_type;
+
+    typedef base::rng_type rng_type;
+
+    struct transport_config : public base::transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::alog_type alog_type;
+        typedef type::elog_type elog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+        typedef websocketpp::transport::asio::basic_socket::endpoint
+            socket_type;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+
+    //static const websocketpp::log::level elog_level = websocketpp::log::elevel::all;
+    //static const websocketpp::log::level alog_level = websocketpp::log::alevel::all;
+
+    /// Length of time before an opening handshake is aborted
+    static const long timeout_open_handshake = 500;
+    /// Length of time before a closing handshake is aborted
+    static const long timeout_close_handshake = 500;
+    /// Length of time to wait for a pong after a ping
+    static const long timeout_pong = 500;
+};
+
+struct config_tls : public websocketpp::config::asio_tls_client {
+    typedef config type;
+    typedef websocketpp::config::asio base;
+
+    typedef base::concurrency_type concurrency_type;
+
+    typedef base::request_type request_type;
+    typedef base::response_type response_type;
+
+    typedef base::message_type message_type;
+    typedef base::con_msg_manager_type con_msg_manager_type;
+    typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef base::alog_type alog_type;
+    typedef base::elog_type elog_type;
+
+    typedef base::rng_type rng_type;
+
+    struct transport_config : public base::transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::alog_type alog_type;
+        typedef type::elog_type elog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+        typedef websocketpp::transport::asio::basic_socket::endpoint
+            socket_type;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+
+    //static const websocketpp::log::level elog_level = websocketpp::log::elevel::all;
+    //static const websocketpp::log::level alog_level = websocketpp::log::alevel::all;
+
+    /// Length of time before an opening handshake is aborted
+    static const long timeout_open_handshake = 500;
+    /// Length of time before a closing handshake is aborted
+    static const long timeout_close_handshake = 500;
+    /// Length of time to wait for a pong after a ping
+    static const long timeout_pong = 500;
+};
+
+typedef websocketpp::server<config> server;
+typedef websocketpp::client<config> client;
+
+typedef websocketpp::server<config_tls> server_tls;
+typedef websocketpp::client<config_tls> client_tls;
+
+typedef websocketpp::server<websocketpp::config::core> iostream_server;
+typedef websocketpp::client<websocketpp::config::core_client> iostream_client;
+
+using websocketpp::lib::placeholders::_1;
+using websocketpp::lib::placeholders::_2;
+using websocketpp::lib::bind;
+
+template <typename T>
+void close_after_timeout(T & e, websocketpp::connection_hdl hdl, long timeout) {
+    sleep(timeout);
+
+    websocketpp::lib::error_code ec;
+    e.close(hdl,websocketpp::close::status::normal,"",ec);
+    BOOST_CHECK(!ec);
+}
+
+void run_server(server * s, int port, bool log = false) {
+    if (log) {
+        s->set_access_channels(websocketpp::log::alevel::all);
+        s->set_error_channels(websocketpp::log::elevel::all);
+    } else {
+        s->clear_access_channels(websocketpp::log::alevel::all);
+        s->clear_error_channels(websocketpp::log::elevel::all);
+    }
+
+    s->init_asio();
+    s->set_reuse_addr(true);
+
+    s->listen(port);
+    s->start_accept();
+    s->run();
+}
+
+void run_client(client & c, std::string uri, bool log = false) {
+    if (log) {
+        c.set_access_channels(websocketpp::log::alevel::all);
+        c.set_error_channels(websocketpp::log::elevel::all);
+    } else {
+        c.clear_access_channels(websocketpp::log::alevel::all);
+        c.clear_error_channels(websocketpp::log::elevel::all);
+    }
+    websocketpp::lib::error_code ec;
+    c.init_asio(ec);
+    c.set_reuse_addr(true);
+    BOOST_CHECK(!ec);
+
+    client::connection_ptr con = c.get_connection(uri,ec);
+    BOOST_CHECK( !ec );
+    c.connect(con);
+
+    c.run();
+}
+
+void run_client_and_mark(client * c, bool * flag, websocketpp::lib::mutex * mutex) {
+    c->run();
+    BOOST_CHECK( true );
+    websocketpp::lib::lock_guard<websocketpp::lib::mutex> lock(*mutex);
+    *flag = true;
+    BOOST_CHECK( true );
+}
+
+void run_time_limited_client(client & c, std::string uri, long timeout,
+    bool log)
+{
+    if (log) {
+        c.set_access_channels(websocketpp::log::alevel::all);
+        c.set_error_channels(websocketpp::log::elevel::all);
+    } else {
+        c.clear_access_channels(websocketpp::log::alevel::all);
+        c.clear_error_channels(websocketpp::log::elevel::all);
+    }
+    c.init_asio();
+
+    websocketpp::lib::error_code ec;
+    client::connection_ptr con = c.get_connection(uri,ec);
+    BOOST_CHECK( !ec );
+    c.connect(con);
+
+    websocketpp::lib::thread tthread(websocketpp::lib::bind(
+        &close_after_timeout<client>,
+        websocketpp::lib::ref(c),
+        con->get_handle(),
+        timeout
+    ));
+    tthread.detach();
+
+    c.run();
+}
+
+void run_dummy_server(int port) {
+    using boost::asio::ip::tcp;
+
+    try {
+        boost::asio::io_service io_service;
+        tcp::acceptor acceptor(io_service, tcp::endpoint(tcp::v6(), port));
+        tcp::socket socket(io_service);
+
+        acceptor.accept(socket);
+        for (;;) {
+            char data[512];
+            boost::system::error_code ec;
+            socket.read_some(boost::asio::buffer(data), ec);
+            if (ec == boost::asio::error::eof) {
+                break;
+            } else if (ec) {
+                // other error
+                throw ec;
+            }
+        }
+    } catch (std::exception & e) {
+        std::cout << e.what() << std::endl;
+    } catch (boost::system::error_code & ec) {
+        std::cout << ec.message() << std::endl;
+    }
+}
+
+void run_dummy_client(std::string port) {
+    using boost::asio::ip::tcp;
+
+    try {
+        boost::asio::io_service io_service;
+        tcp::resolver resolver(io_service);
+        tcp::resolver::query query("localhost", port);
+        tcp::resolver::iterator iterator = resolver.resolve(query);
+        tcp::socket socket(io_service);
+
+        boost::asio::connect(socket, iterator);
+        for (;;) {
+            char data[512];
+            boost::system::error_code ec;
+            socket.read_some(boost::asio::buffer(data), ec);
+            if (ec == boost::asio::error::eof) {
+                break;
+            } else if (ec) {
+                // other error
+                throw ec;
+            }
+        }
+    } catch (std::exception & e) {
+        std::cout << e.what() << std::endl;
+    } catch (boost::system::error_code & ec) {
+        std::cout << ec.message() << std::endl;
+    }
+}
+
+bool on_ping(server * s, websocketpp::connection_hdl, std::string) {
+    s->get_alog().write(websocketpp::log::alevel::app,"got ping");
+    return false;
+}
+
+void cancel_on_open(server * s, websocketpp::connection_hdl) {
+    s->stop_listening();
+}
+
+void stop_on_close(server * s, websocketpp::connection_hdl hdl) {
+    server::connection_ptr con = s->get_con_from_hdl(hdl);
+    //BOOST_CHECK_EQUAL( con->get_local_close_code(), websocketpp::close::status::normal );
+    //BOOST_CHECK_EQUAL( con->get_remote_close_code(), websocketpp::close::status::normal );
+    s->stop();
+}
+
+template <typename T>
+void ping_on_open(T * c, std::string payload, websocketpp::connection_hdl hdl) {
+    typename T::connection_ptr con = c->get_con_from_hdl(hdl);
+    websocketpp::lib::error_code ec;
+    con->ping(payload,ec);
+    BOOST_CHECK_EQUAL(ec, websocketpp::lib::error_code());
+}
+
+void fail_on_pong(websocketpp::connection_hdl, std::string) {
+    BOOST_FAIL( "expected no pong handler" );
+}
+
+void fail_on_pong_timeout(websocketpp::connection_hdl, std::string) {
+    BOOST_FAIL( "expected no pong timeout" );
+}
+
+void req_pong(std::string expected_payload, websocketpp::connection_hdl,
+    std::string payload)
+{
+    BOOST_CHECK_EQUAL( expected_payload, payload );
+}
+
+void fail_on_open(websocketpp::connection_hdl) {
+    BOOST_FAIL( "expected no open handler" );
+}
+
+void delay(websocketpp::connection_hdl, long duration) {
+    sleep(duration);
+}
+
+template <typename T>
+void check_ec(T * c, websocketpp::lib::error_code ec,
+    websocketpp::connection_hdl hdl)
+{
+    typename T::connection_ptr con = c->get_con_from_hdl(hdl);
+    BOOST_CHECK_EQUAL( con->get_ec(), ec );
+    //BOOST_CHECK_EQUAL( con->get_local_close_code(), websocketpp::close::status::normal );
+    //BOOST_CHECK_EQUAL( con->get_remote_close_code(), websocketpp::close::status::normal );
+}
+
+template <typename T>
+void check_ec_and_stop(T * e, websocketpp::lib::error_code ec,
+    websocketpp::connection_hdl hdl)
+{
+    typename T::connection_ptr con = e->get_con_from_hdl(hdl);
+    BOOST_CHECK_EQUAL( con->get_ec(), ec );
+    //BOOST_CHECK_EQUAL( con->get_local_close_code(), websocketpp::close::status::normal );
+    //BOOST_CHECK_EQUAL( con->get_remote_close_code(), websocketpp::close::status::normal );
+    e->stop();
+}
+
+template <typename T>
+void req_pong_timeout(T * c, std::string expected_payload,
+    websocketpp::connection_hdl hdl, std::string payload)
+{
+    typename T::connection_ptr con = c->get_con_from_hdl(hdl);
+    BOOST_CHECK_EQUAL( payload, expected_payload );
+    con->close(websocketpp::close::status::normal,"");
+}
+
+template <typename T>
+void close(T * e, websocketpp::connection_hdl hdl) {
+    e->get_con_from_hdl(hdl)->close(websocketpp::close::status::normal,"");
+}
+
+// Wait for the specified time period then fail the test
+void run_test_timer(long value) {
+    sleep(value);
+    BOOST_FAIL( "Test timed out" );
+}
+
+BOOST_AUTO_TEST_CASE( pong_no_timeout ) {
+    server s;
+    client c;
+
+    s.set_close_handler(bind(&stop_on_close,&s,::_1));
+
+    // send a ping when the connection is open
+    c.set_open_handler(bind(&ping_on_open<client>,&c,"foo",::_1));
+    // require that a pong with matching payload is received
+    c.set_pong_handler(bind(&req_pong,"foo",::_1,::_2));
+    // require that a pong timeout is NOT received
+    c.set_pong_timeout_handler(bind(&fail_on_pong_timeout,::_1,::_2));
+
+    websocketpp::lib::thread sthread(websocketpp::lib::bind(&run_server,&s,9005,false));
+
+    // Run a client that closes the connection after 1 seconds
+    run_time_limited_client(c, "http://localhost:9005", 1, false);
+
+    sthread.join();
+}
+
+BOOST_AUTO_TEST_CASE( pong_timeout ) {
+    server s;
+    client c;
+
+    s.set_ping_handler(bind(&on_ping, &s,::_1,::_2));
+    s.set_close_handler(bind(&stop_on_close,&s,::_1));
+
+    c.set_fail_handler(bind(&check_ec<client>,&c,
+        websocketpp::lib::error_code(),::_1));
+
+    c.set_pong_handler(bind(&fail_on_pong,::_1,::_2));
+    c.set_open_handler(bind(&ping_on_open<client>,&c,"foo",::_1));
+    c.set_pong_timeout_handler(bind(&req_pong_timeout<client>,&c,"foo",::_1,::_2));
+    c.set_close_handler(bind(&check_ec<client>,&c,
+        websocketpp::lib::error_code(),::_1));
+
+    websocketpp::lib::thread sthread(websocketpp::lib::bind(&run_server,&s,9005,false));
+    websocketpp::lib::thread tthread(websocketpp::lib::bind(&run_test_timer,10));
+    tthread.detach();
+
+    run_client(c, "http://localhost:9005",false);
+
+    sthread.join();
+}
+
+BOOST_AUTO_TEST_CASE( client_open_handshake_timeout ) {
+    client c;
+
+    // set open handler to fail test
+    c.set_open_handler(bind(&fail_on_open,::_1));
+    // set fail hander to test for the right fail error code
+    c.set_fail_handler(bind(&check_ec<client>,&c,
+        websocketpp::error::open_handshake_timeout,::_1));
+
+    websocketpp::lib::thread sthread(websocketpp::lib::bind(&run_dummy_server,9005));
+    websocketpp::lib::thread tthread(websocketpp::lib::bind(&run_test_timer,10));
+    sthread.detach();
+    tthread.detach();
+
+    run_client(c, "http://localhost:9005");
+}
+
+BOOST_AUTO_TEST_CASE( server_open_handshake_timeout ) {
+    server s;
+
+    // set open handler to fail test
+    s.set_open_handler(bind(&fail_on_open,::_1));
+    // set fail hander to test for the right fail error code
+    s.set_fail_handler(bind(&check_ec_and_stop<server>,&s,
+        websocketpp::error::open_handshake_timeout,::_1));
+
+    websocketpp::lib::thread sthread(websocketpp::lib::bind(&run_server,&s,9005,false));
+    websocketpp::lib::thread tthread(websocketpp::lib::bind(&run_test_timer,10));
+    tthread.detach();
+
+    run_dummy_client("9005");
+
+    sthread.join();
+}
+
+BOOST_AUTO_TEST_CASE( client_self_initiated_close_handshake_timeout ) {
+    server s;
+    client c;
+
+    // on open server sleeps for longer than the timeout
+    // on open client sends close handshake
+    // client handshake timer should be triggered
+    s.set_open_handler(bind(&delay,::_1,1));
+    s.set_close_handler(bind(&stop_on_close,&s,::_1));
+
+    c.set_open_handler(bind(&close<client>,&c,::_1));
+    c.set_close_handler(bind(&check_ec<client>,&c,
+        websocketpp::error::close_handshake_timeout,::_1));
+
+    websocketpp::lib::thread sthread(websocketpp::lib::bind(&run_server,&s,9005,false));
+    websocketpp::lib::thread tthread(websocketpp::lib::bind(&run_test_timer,10));
+    tthread.detach();
+
+    run_client(c, "http://localhost:9005", false);
+
+    sthread.join();
+}
+
+BOOST_AUTO_TEST_CASE( client_peer_initiated_close_handshake_timeout ) {
+    // on open server sends close
+    // client should ack normally and then wait
+    // server leaves TCP connection open
+    // client handshake timer should be triggered
+
+    // TODO: how to make a mock server that leaves the TCP connection open?
+}
+
+BOOST_AUTO_TEST_CASE( server_self_initiated_close_handshake_timeout ) {
+    server s;
+    client c;
+
+    // on open server sends close
+    // on open client sleeps for longer than the timeout
+    // server handshake timer should be triggered
+
+    s.set_open_handler(bind(&close<server>,&s,::_1));
+    s.set_close_handler(bind(&check_ec_and_stop<server>,&s,
+        websocketpp::error::close_handshake_timeout,::_1));
+
+    c.set_open_handler(bind(&delay,::_1,1));
+
+    websocketpp::lib::thread sthread(websocketpp::lib::bind(&run_server,&s,9005,false));
+    websocketpp::lib::thread tthread(websocketpp::lib::bind(&run_test_timer,10));
+    tthread.detach();
+
+    run_client(c, "http://localhost:9005",false);
+
+    sthread.join();
+}
+
+BOOST_AUTO_TEST_CASE( client_runs_out_of_work ) {
+    client c;
+
+    websocketpp::lib::thread tthread(websocketpp::lib::bind(&run_test_timer,3));
+    tthread.detach();
+
+    websocketpp::lib::error_code ec;
+    c.init_asio(ec);
+    BOOST_CHECK(!ec);
+
+    c.run();
+
+    // This test checks that an io_service with no work ends immediately.
+    BOOST_CHECK(true);
+}
+
+
+
+
+BOOST_AUTO_TEST_CASE( client_is_perpetual ) {
+    client c;
+    bool flag = false;
+    websocketpp::lib::mutex mutex;
+
+    websocketpp::lib::error_code ec;
+    c.init_asio(ec);
+    BOOST_CHECK(!ec);
+
+    c.start_perpetual();
+
+    websocketpp::lib::thread cthread(websocketpp::lib::bind(&run_client_and_mark,&c,&flag,&mutex));
+
+    sleep(1);
+
+    {
+        // Checks that the thread hasn't exited yet
+        websocketpp::lib::lock_guard<websocketpp::lib::mutex> lock(mutex);
+        BOOST_CHECK( !flag );
+    }
+
+    c.stop_perpetual();
+
+    sleep(1);
+
+    {
+        // Checks that the thread has exited
+        websocketpp::lib::lock_guard<websocketpp::lib::mutex> lock(mutex);
+        BOOST_CHECK( flag );
+    }
+
+    cthread.join();
+}
+
+BOOST_AUTO_TEST_CASE( client_failed_connection ) {
+    client c;
+
+    run_time_limited_client(c,"http://localhost:9005", 5, false);
+}
+
+BOOST_AUTO_TEST_CASE( stop_listening ) {
+    server s;
+    client c;
+
+    // the first connection stops the server from listening
+    s.set_open_handler(bind(&cancel_on_open,&s,::_1));
+
+    // client immediately closes after opening a connection
+    c.set_open_handler(bind(&close<client>,&c,::_1));
+
+    websocketpp::lib::thread sthread(websocketpp::lib::bind(&run_server,&s,9005,false));
+    websocketpp::lib::thread tthread(websocketpp::lib::bind(&run_test_timer,5));
+    tthread.detach();
+
+    run_client(c, "http://localhost:9005",false);
+
+    sthread.join();
+}
+
+BOOST_AUTO_TEST_CASE( pause_reading ) {
+    iostream_server s;
+    std::string handshake = "GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n\r\n";
+    char buffer[2] = { char(0x81), char(0x80) };
+
+    // suppress output (it needs a place to go to avoid error but we don't care what it is)
+    std::stringstream null_output;
+    s.register_ostream(&null_output);
+
+    iostream_server::connection_ptr con = s.get_connection();
+    con->start();
+
+    // read handshake, should work
+    BOOST_CHECK_EQUAL( con->read_some(handshake.data(), handshake.length()), handshake.length());
+
+    // pause reading and try again. The first read should work, the second should return 0
+    // the first read was queued already after the handshake so it will go through because
+    // reading wasn't paused when it was queued. The byte it reads wont be enough to
+    // complete the frame so another read will be requested. This one wont actually happen
+    // because the connection is paused now.
+    con->pause_reading();
+    BOOST_CHECK_EQUAL( con->read_some(buffer, 1), 1);
+    BOOST_CHECK_EQUAL( con->read_some(buffer+1, 1), 0);
+    // resume reading and try again. Should work this time because the resume should have
+    // re-queued a read.
+    con->resume_reading();
+    BOOST_CHECK_EQUAL( con->read_some(buffer+1, 1), 1);
+}
+
+
+BOOST_AUTO_TEST_CASE( server_connection_cleanup ) {
+    server_tls s;
+}
diff --git a/extlibs/websocketpp/test/transport/iostream/SConscript b/extlibs/websocketpp/test/transport/iostream/SConscript
new file mode 100644
index 000000000..9e74c2f15
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/iostream/SConscript
@@ -0,0 +1,31 @@
+## iostream transport unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system'],env) + [platform_libs]
+
+objs = env.Object('iostream_base_boost.o', ["base.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('iostream_connection_boost.o', ["connection.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('iostream_endpoint_boost.o', ["endpoint.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_iostream_base_boost', ["iostream_base_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_iostream_connection_boost', ["iostream_connection_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_iostream_endpoint_boost', ["iostream_endpoint_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   objs += env_cpp11.Object('iostream_base_stl.o', ["base.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('iostream_connection_stl.o', ["connection.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('iostream_endpoint_stl.o', ["endpoint.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_iostream_base_stl', ["iostream_base_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_iostream_connection_stl', ["iostream_connection_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_iostream_endpoint_stl', ["iostream_endpoint_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/transport/iostream/base.cpp b/extlibs/websocketpp/test/transport/iostream/base.cpp
new file mode 100644
index 000000000..a7eefc211
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/iostream/base.cpp
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE transport_iostream_base
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+
+BOOST_AUTO_TEST_CASE( placeholder ) {}
diff --git a/extlibs/websocketpp/test/transport/iostream/connection.cpp b/extlibs/websocketpp/test/transport/iostream/connection.cpp
new file mode 100644
index 000000000..49465d6ba
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/iostream/connection.cpp
@@ -0,0 +1,575 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE transport_iostream_connection
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <cstring>
+#include <string>
+
+#include <websocketpp/common/memory.hpp>
+
+#include <websocketpp/error.hpp>
+#include <websocketpp/transport/iostream/connection.hpp>
+
+// Policies
+#include <websocketpp/concurrency/basic.hpp>
+#include <websocketpp/logger/basic.hpp>
+
+struct config {
+    typedef websocketpp::concurrency::basic concurrency_type;
+    typedef websocketpp::log::basic<concurrency_type,
+        websocketpp::log::elevel> elog_type;
+    typedef websocketpp::log::basic<concurrency_type,
+        websocketpp::log::alevel> alog_type;
+};
+
+typedef websocketpp::transport::iostream::connection<config> iostream_con;
+
+using websocketpp::transport::iostream::error::make_error_code;
+
+struct stub_con : public iostream_con {
+    typedef stub_con type;
+    typedef websocketpp::lib::shared_ptr<type> ptr;
+    typedef iostream_con::timer_ptr timer_ptr;
+
+    stub_con(bool is_server, config::alog_type & a, config::elog_type & e)
+        : iostream_con(is_server,a,e)
+        // Set the error to a known code that is unused by the library
+        // This way we can easily confirm that the handler was run at all.
+        , ec(websocketpp::error::make_error_code(websocketpp::error::test))
+        , indef_read_total(0)
+    {}
+
+    /// Get a shared pointer to this component
+    ptr get_shared() {
+        return websocketpp::lib::static_pointer_cast<type>(iostream_con::get_shared());
+    }
+
+    void write(std::string msg) {
+        iostream_con::async_write(
+            msg.data(),
+            msg.size(),
+            websocketpp::lib::bind(
+                &stub_con::handle_op,
+                type::get_shared(),
+                websocketpp::lib::placeholders::_1
+            )
+        );
+    }
+
+    void write(std::vector<websocketpp::transport::buffer> & bufs) {
+        iostream_con::async_write(
+            bufs,
+            websocketpp::lib::bind(
+                &stub_con::handle_op,
+                type::get_shared(),
+                websocketpp::lib::placeholders::_1
+            )
+        );
+    }
+
+    void async_read_at_least(size_t num_bytes, char *buf, size_t len)
+    {
+        iostream_con::async_read_at_least(
+            num_bytes,
+            buf,
+            len,
+            websocketpp::lib::bind(
+                &stub_con::handle_op,
+                type::get_shared(),
+                websocketpp::lib::placeholders::_1
+            )
+        );
+    }
+
+    void handle_op(websocketpp::lib::error_code const & e) {
+        ec = e;
+    }
+
+    void async_read_indef(size_t num_bytes, char *buf, size_t len)
+    {
+        indef_read_size = num_bytes;
+        indef_read_buf = buf;
+        indef_read_len = len;
+        
+        indef_read();
+    }
+
+    void indef_read() {
+        iostream_con::async_read_at_least(
+            indef_read_size,
+            indef_read_buf,
+            indef_read_len,
+            websocketpp::lib::bind(
+                &stub_con::handle_indef,
+                type::get_shared(),
+                websocketpp::lib::placeholders::_1,
+                websocketpp::lib::placeholders::_2
+            )
+        );
+    }
+
+    void handle_indef(websocketpp::lib::error_code const & e, size_t amt_read) {
+        ec = e;
+        indef_read_total += amt_read;
+        
+        indef_read();
+    }
+
+    void shutdown() {
+        iostream_con::async_shutdown(
+            websocketpp::lib::bind(
+                &stub_con::handle_async_shutdown,
+                type::get_shared(),
+                websocketpp::lib::placeholders::_1
+            )
+        );
+    }
+
+    void handle_async_shutdown(websocketpp::lib::error_code const & e) {
+        ec = e;
+    }
+
+    websocketpp::lib::error_code ec;
+    size_t indef_read_size;
+    char * indef_read_buf;
+    size_t indef_read_len;
+    size_t indef_read_total;
+};
+
+// Stubs
+config::alog_type alogger;
+config::elog_type elogger;
+
+BOOST_AUTO_TEST_CASE( const_methods ) {
+    iostream_con::ptr con(new iostream_con(true,alogger,elogger));
+
+    BOOST_CHECK( !con->is_secure() );
+    BOOST_CHECK_EQUAL( con->get_remote_endpoint(), "iostream transport" );
+}
+
+BOOST_AUTO_TEST_CASE( write_before_output_method_set ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    con->write("foo");
+    BOOST_CHECK( con->ec == make_error_code(websocketpp::transport::iostream::error::output_stream_required) );
+
+    std::vector<websocketpp::transport::buffer> bufs;
+    con->write(bufs);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::transport::iostream::error::output_stream_required) );
+}
+
+BOOST_AUTO_TEST_CASE( async_write_ostream ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    std::stringstream output;
+
+    con->register_ostream(&output);
+
+    con->write("foo");
+
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( output.str(), "foo" );
+}
+
+websocketpp::lib::error_code write_handler(std::string & o, websocketpp::connection_hdl, char const * buf, size_t len) {
+    o += std::string(buf,len);
+    return websocketpp::lib::error_code();
+}
+
+websocketpp::lib::error_code write_handler_error(websocketpp::connection_hdl, char const *, size_t) {
+    return make_error_code(websocketpp::transport::error::general);
+}
+
+BOOST_AUTO_TEST_CASE( async_write_handler ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    std::string output;
+
+    con->set_write_handler(websocketpp::lib::bind(
+        &write_handler,
+        websocketpp::lib::ref(output),
+        websocketpp::lib::placeholders::_1,
+        websocketpp::lib::placeholders::_2,
+        websocketpp::lib::placeholders::_3
+    ));
+    con->write("foo");
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL(output, "foo");
+}
+
+BOOST_AUTO_TEST_CASE( async_write_handler_error ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    con->set_write_handler(&write_handler_error);
+    con->write("foo");
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::transport::error::general) );
+}
+
+BOOST_AUTO_TEST_CASE( async_write_vector_0_ostream ) {
+    std::stringstream output;
+
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    con->register_ostream(&output);
+
+    std::vector<websocketpp::transport::buffer> bufs;
+
+    con->write(bufs);
+
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( output.str(), "" );
+}
+
+BOOST_AUTO_TEST_CASE( async_write_vector_0_write_handler ) {
+    std::string output;
+
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    
+    con->set_write_handler(websocketpp::lib::bind(
+        &write_handler,
+        websocketpp::lib::ref(output),
+        websocketpp::lib::placeholders::_1,
+        websocketpp::lib::placeholders::_2,
+        websocketpp::lib::placeholders::_3
+    ));
+
+    std::vector<websocketpp::transport::buffer> bufs;
+
+    con->write(bufs);
+
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( output, "" );
+}
+
+BOOST_AUTO_TEST_CASE( async_write_vector_1_ostream ) {
+    std::stringstream output;
+
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    con->register_ostream(&output);
+
+    std::vector<websocketpp::transport::buffer> bufs;
+
+    std::string foo = "foo";
+
+    bufs.push_back(websocketpp::transport::buffer(foo.data(),foo.size()));
+
+    con->write(bufs);
+
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( output.str(), "foo" );
+}
+
+BOOST_AUTO_TEST_CASE( async_write_vector_1_write_handler ) {
+    std::string output;
+
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    con->set_write_handler(websocketpp::lib::bind(
+        &write_handler,
+        websocketpp::lib::ref(output),
+        websocketpp::lib::placeholders::_1,
+        websocketpp::lib::placeholders::_2,
+        websocketpp::lib::placeholders::_3
+    ));
+
+    std::vector<websocketpp::transport::buffer> bufs;
+
+    std::string foo = "foo";
+
+    bufs.push_back(websocketpp::transport::buffer(foo.data(),foo.size()));
+
+    con->write(bufs);
+
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( output, "foo" );
+}
+
+BOOST_AUTO_TEST_CASE( async_write_vector_2_ostream ) {
+    std::stringstream output;
+
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    con->register_ostream(&output);
+
+    std::vector<websocketpp::transport::buffer> bufs;
+
+    std::string foo = "foo";
+    std::string bar = "bar";
+
+    bufs.push_back(websocketpp::transport::buffer(foo.data(),foo.size()));
+    bufs.push_back(websocketpp::transport::buffer(bar.data(),bar.size()));
+
+    con->write(bufs);
+
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( output.str(), "foobar" );
+}
+
+BOOST_AUTO_TEST_CASE( async_write_vector_2_write_handler ) {
+    std::string output;
+
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    con->set_write_handler(websocketpp::lib::bind(
+        &write_handler,
+        websocketpp::lib::ref(output),
+        websocketpp::lib::placeholders::_1,
+        websocketpp::lib::placeholders::_2,
+        websocketpp::lib::placeholders::_3
+    ));
+
+    std::vector<websocketpp::transport::buffer> bufs;
+
+    std::string foo = "foo";
+    std::string bar = "bar";
+
+    bufs.push_back(websocketpp::transport::buffer(foo.data(),foo.size()));
+    bufs.push_back(websocketpp::transport::buffer(bar.data(),bar.size()));
+
+    con->write(bufs);
+
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( output, "foobar" );
+}
+
+BOOST_AUTO_TEST_CASE( async_read_at_least_too_much ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    char buf[10];
+
+    con->async_read_at_least(11,buf,10);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::transport::iostream::error::invalid_num_bytes) );
+}
+
+BOOST_AUTO_TEST_CASE( async_read_at_least_double_read ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    char buf[10];
+
+    con->async_read_at_least(5,buf,10);
+    con->async_read_at_least(5,buf,10);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::transport::iostream::error::double_read) );
+}
+
+BOOST_AUTO_TEST_CASE( async_read_at_least ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    char buf[10];
+
+    memset(buf,'x',10);
+
+    con->async_read_at_least(5,buf,10);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+
+    std::stringstream channel;
+    channel << "abcd";
+    channel >> *con;
+    BOOST_CHECK_EQUAL( channel.tellg(), -1 );
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+
+    std::stringstream channel2;
+    channel2 << "e";
+    channel2 >> *con;
+    BOOST_CHECK_EQUAL( channel2.tellg(), -1 );
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "abcdexxxxx" );
+
+    std::stringstream channel3;
+    channel3 << "f";
+    channel3 >> *con;
+    BOOST_CHECK_EQUAL( channel3.tellg(), 0 );
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "abcdexxxxx" );
+    con->async_read_at_least(1,buf+5,5);
+    channel3 >> *con;
+    BOOST_CHECK_EQUAL( channel3.tellg(), -1 );
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "abcdefxxxx" );
+}
+
+BOOST_AUTO_TEST_CASE( async_read_at_least2 ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    char buf[10];
+
+    memset(buf,'x',10);
+
+    con->async_read_at_least(5,buf,5);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+
+    std::stringstream channel;
+    channel << "abcdefg";
+    channel >> *con;
+    BOOST_CHECK_EQUAL( channel.tellg(), 5 );
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "abcdexxxxx" );
+
+    con->async_read_at_least(1,buf+5,5);
+    channel >> *con;
+    BOOST_CHECK_EQUAL( channel.tellg(), -1 );
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "abcdefgxxx" );
+}
+
+void timer_callback_stub(websocketpp::lib::error_code const &) {}
+
+BOOST_AUTO_TEST_CASE( set_timer ) {
+   stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    stub_con::timer_ptr tp = con->set_timer(1000,timer_callback_stub);
+
+    BOOST_CHECK( !tp );
+}
+
+BOOST_AUTO_TEST_CASE( async_read_at_least_read_some ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    char buf[10];
+    memset(buf,'x',10);
+
+    con->async_read_at_least(5,buf,5);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+
+    char input[10] = "abcdefg";
+    BOOST_CHECK_EQUAL(con->read_some(input,5), 5);
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "abcdexxxxx" );
+
+    BOOST_CHECK_EQUAL(con->read_some(input+5,2), 0);
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "abcdexxxxx" );
+
+    con->async_read_at_least(1,buf+5,5);
+    BOOST_CHECK_EQUAL(con->read_some(input+5,2), 2);
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "abcdefgxxx" );
+}
+
+BOOST_AUTO_TEST_CASE( async_read_at_least_read_some_indef ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    char buf[20];
+    memset(buf,'x',20);
+
+    con->async_read_indef(5,buf,5);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+
+    // here we expect to return early from read some because the outstanding
+    // read was for 5 bytes and we were called with 10.
+    char input[11] = "aaaaabbbbb";
+    BOOST_CHECK_EQUAL(con->read_some(input,10), 5);
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "aaaaaxxxxx" );
+    BOOST_CHECK_EQUAL( con->indef_read_total, 5 );
+    
+    // A subsequent read should read 5 more because the indef read refreshes
+    // itself. The new read will start again at the beginning of the buffer.
+    BOOST_CHECK_EQUAL(con->read_some(input+5,5), 5);
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "bbbbbxxxxx" );
+    BOOST_CHECK_EQUAL( con->indef_read_total, 10 );
+}
+
+BOOST_AUTO_TEST_CASE( async_read_at_least_read_all ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    char buf[20];
+    memset(buf,'x',20);
+
+    con->async_read_indef(5,buf,5);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+
+    char input[11] = "aaaaabbbbb";
+    BOOST_CHECK_EQUAL(con->read_all(input,10), 10);
+    BOOST_CHECK( !con->ec );
+    BOOST_CHECK_EQUAL( std::string(buf,10), "bbbbbxxxxx" );
+    BOOST_CHECK_EQUAL( con->indef_read_total, 10 );
+}
+
+BOOST_AUTO_TEST_CASE( eof_flag ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    char buf[10];
+    con->async_read_at_least(5,buf,5);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+    con->eof();
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::transport::error::eof) );
+}
+
+BOOST_AUTO_TEST_CASE( fatal_error_flag ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    char buf[10];
+    con->async_read_at_least(5,buf,5);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+    con->fatal_error();
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::transport::error::pass_through) );
+}
+
+BOOST_AUTO_TEST_CASE( shutdown ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+    con->shutdown();
+    BOOST_CHECK_EQUAL( con->ec, websocketpp::lib::error_code() );
+}
+
+websocketpp::lib::error_code sd_handler(websocketpp::connection_hdl) {
+    return make_error_code(websocketpp::transport::error::general);
+}
+
+BOOST_AUTO_TEST_CASE( shutdown_handler ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+    
+    con->set_shutdown_handler(&sd_handler);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+    con->shutdown();
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::transport::error::general) );
+}
+
+BOOST_AUTO_TEST_CASE( shared_pointer_memory_cleanup ) {
+    stub_con::ptr con(new stub_con(true,alogger,elogger));
+
+    BOOST_CHECK_EQUAL(con.use_count(), 1);
+
+    char buf[10];
+    memset(buf,'x',10);
+    con->async_read_at_least(5,buf,5);
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::error::test) );
+    BOOST_CHECK_EQUAL(con.use_count(), 2);
+
+    char input[10] = "foo";
+    con->read_some(input,3);
+    BOOST_CHECK_EQUAL(con.use_count(), 2);
+
+    con->read_some(input,2);
+    BOOST_CHECK_EQUAL( std::string(buf,10), "foofoxxxxx" );
+    BOOST_CHECK_EQUAL(con.use_count(), 1);
+
+    con->async_read_at_least(5,buf,5);
+    BOOST_CHECK_EQUAL(con.use_count(), 2);
+
+    con->eof();
+    BOOST_CHECK_EQUAL( con->ec, make_error_code(websocketpp::transport::error::eof) );
+    BOOST_CHECK_EQUAL(con.use_count(), 1);
+}
+
diff --git a/extlibs/websocketpp/test/transport/iostream/endpoint.cpp b/extlibs/websocketpp/test/transport/iostream/endpoint.cpp
new file mode 100644
index 000000000..ded996788
--- /dev/null
+++ b/extlibs/websocketpp/test/transport/iostream/endpoint.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE transport_iostream_endpoint
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+
+#include <websocketpp/transport/iostream/endpoint.hpp>
+
+BOOST_AUTO_TEST_CASE( placeholder ) {}
+
+/*BOOST_AUTO_TEST_CASE( blank_error ) {
+    websocketpp::lib::error_code ec;
+
+    BOOST_CHECK( !ec );
+}*/
diff --git a/extlibs/websocketpp/test/utility/SConscript b/extlibs/websocketpp/test/utility/SConscript
new file mode 100644
index 000000000..80e9ef6c8
--- /dev/null
+++ b/extlibs/websocketpp/test/utility/SConscript
@@ -0,0 +1,40 @@
+## utility unit tests
+##
+
+Import('env')
+Import('env_cpp11')
+Import('boostlibs')
+Import('platform_libs')
+Import('polyfill_libs')
+
+env = env.Clone ()
+env_cpp11 = env_cpp11.Clone ()
+
+BOOST_LIBS = boostlibs(['unit_test_framework','system'],env) + [platform_libs]
+
+objs = env.Object('uri_boost.o', ["uri.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('utilities_boost.o', ["utilities.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('close_boost.o', ["close.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('sha1_boost.o', ["sha1.cpp"], LIBS = BOOST_LIBS)
+objs += env.Object('error_boost.o', ["error.cpp"], LIBS = BOOST_LIBS)
+prgs = env.Program('test_uri_boost', ["uri_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_utility_boost', ["utilities_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_frame', ["frame.cpp"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_close_boost', ["close_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_sha1_boost', ["sha1_boost.o"], LIBS = BOOST_LIBS)
+prgs += env.Program('test_error_boost', ["error_boost.o"], LIBS = BOOST_LIBS)
+
+if env_cpp11.has_key('WSPP_CPP11_ENABLED'):
+   BOOST_LIBS_CPP11 = boostlibs(['unit_test_framework'],env_cpp11) + [platform_libs] + [polyfill_libs]
+   objs += env_cpp11.Object('utilities_stl.o', ["utilities.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('uri_stl.o', ["uri.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('close_stl.o', ["close.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('sha1_stl.o', ["sha1.cpp"], LIBS = BOOST_LIBS_CPP11)
+   objs += env_cpp11.Object('error_stl.o', ["error.cpp"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_utility_stl', ["utilities_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_uri_stl', ["uri_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_close_stl', ["close_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_sha1_stl', ["sha1_stl.o"], LIBS = BOOST_LIBS_CPP11)
+   prgs += env_cpp11.Program('test_error_stl', ["error_stl.o"], LIBS = BOOST_LIBS_CPP11)
+
+Return('prgs')
diff --git a/extlibs/websocketpp/test/utility/close.cpp b/extlibs/websocketpp/test/utility/close.cpp
new file mode 100644
index 000000000..191f2632d
--- /dev/null
+++ b/extlibs/websocketpp/test/utility/close.cpp
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE close
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/close.hpp>
+#include <websocketpp/utilities.hpp>
+
+using namespace websocketpp;
+
+BOOST_AUTO_TEST_CASE( reserved_values ) {
+    BOOST_CHECK( !close::status::reserved(999) );
+    BOOST_CHECK( close::status::reserved(1004) );
+    BOOST_CHECK( close::status::reserved(1014) );
+    BOOST_CHECK( close::status::reserved(1016) );
+    BOOST_CHECK( close::status::reserved(2999) );
+    BOOST_CHECK( !close::status::reserved(1000) );
+}
+
+BOOST_AUTO_TEST_CASE( invalid_values ) {
+    BOOST_CHECK( close::status::invalid(0) );
+    BOOST_CHECK( close::status::invalid(999) );
+    BOOST_CHECK( !close::status::invalid(1000) );
+    BOOST_CHECK( close::status::invalid(1005) );
+    BOOST_CHECK( close::status::invalid(1006) );
+    BOOST_CHECK( close::status::invalid(1015) );
+    BOOST_CHECK( !close::status::invalid(2999) );
+    BOOST_CHECK( !close::status::invalid(3000) );
+    BOOST_CHECK( close::status::invalid(5000) );
+}
+
+BOOST_AUTO_TEST_CASE( value_extraction ) {
+    lib::error_code ec;
+    std::string payload = "oo";
+
+    // Value = 1000
+    payload[0] = 0x03;
+    payload[1] = char(0xe8);
+    BOOST_CHECK( close::extract_code(payload,ec) == close::status::normal );
+    BOOST_CHECK( !ec );
+
+    // Value = 1004
+    payload[0] = 0x03;
+    payload[1] = char(0xec);
+    BOOST_CHECK( close::extract_code(payload,ec) == 1004 );
+    BOOST_CHECK( ec == error::reserved_close_code );
+
+    // Value = 1005
+    payload[0] = 0x03;
+    payload[1] = char(0xed);
+    BOOST_CHECK( close::extract_code(payload,ec) == close::status::no_status );
+    BOOST_CHECK( ec == error::invalid_close_code );
+
+    // Value = 3000
+    payload[0] = 0x0b;
+    payload[1] = char(0xb8);
+    BOOST_CHECK( close::extract_code(payload,ec) == 3000 );
+    BOOST_CHECK( !ec );
+}
+
+BOOST_AUTO_TEST_CASE( extract_empty ) {
+    lib::error_code ec;
+    std::string payload = "";
+
+    BOOST_CHECK( close::extract_code(payload,ec) == close::status::no_status );
+    BOOST_CHECK( !ec );
+}
+
+BOOST_AUTO_TEST_CASE( extract_short ) {
+    lib::error_code ec;
+    std::string payload = "0";
+
+    BOOST_CHECK( close::extract_code(payload,ec) == close::status::protocol_error );
+    BOOST_CHECK( ec == error::bad_close_code );
+}
+
+BOOST_AUTO_TEST_CASE( extract_reason ) {
+    lib::error_code ec;
+    std::string payload = "00Foo";
+
+    BOOST_CHECK( close::extract_reason(payload,ec) == "Foo" );
+    BOOST_CHECK( !ec );
+
+    payload = "";
+    BOOST_CHECK( close::extract_reason(payload,ec) == "" );
+    BOOST_CHECK( !ec );
+
+    payload = "00";
+    BOOST_CHECK( close::extract_reason(payload,ec) == "" );
+    BOOST_CHECK( !ec );
+
+    payload = "000";
+    payload[2] = char(0xFF);
+
+    close::extract_reason(payload,ec);
+    BOOST_CHECK( ec == error::invalid_utf8 );
+}
diff --git a/extlibs/websocketpp/test/utility/error.cpp b/extlibs/websocketpp/test/utility/error.cpp
new file mode 100644
index 000000000..1379a95f4
--- /dev/null
+++ b/extlibs/websocketpp/test/utility/error.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2015, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE error
+#include <boost/test/unit_test.hpp>
+
+#include <websocketpp/error.hpp>
+
+BOOST_AUTO_TEST_CASE( constructing_exceptions ) {
+    websocketpp::lib::error_code test_ec = websocketpp::error::make_error_code(websocketpp::error::test);
+    websocketpp::lib::error_code general_ec = websocketpp::error::make_error_code(websocketpp::error::general);
+
+    websocketpp::exception b("foo");
+    websocketpp::exception c("foo",test_ec);
+    websocketpp::exception d("");
+    websocketpp::exception e("",test_ec);
+
+    BOOST_CHECK_EQUAL(b.what(),"foo");
+    BOOST_CHECK_EQUAL(b.code(),general_ec);
+
+    BOOST_CHECK_EQUAL(c.what(),"foo");
+    BOOST_CHECK_EQUAL(c.code(),test_ec);
+
+    BOOST_CHECK_EQUAL(d.what(),"Generic error");
+    BOOST_CHECK_EQUAL(d.code(),general_ec);
+
+    BOOST_CHECK_EQUAL(e.what(),"Test Error");
+    BOOST_CHECK_EQUAL(e.code(),test_ec);
+}
+
diff --git a/extlibs/websocketpp/test/utility/frame.cpp b/extlibs/websocketpp/test/utility/frame.cpp
new file mode 100644
index 000000000..879c2ef4b
--- /dev/null
+++ b/extlibs/websocketpp/test/utility/frame.cpp
@@ -0,0 +1,538 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE frame
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/frame.hpp>
+#include <websocketpp/utilities.hpp>
+
+using namespace websocketpp;
+
+BOOST_AUTO_TEST_CASE( basic_bits ) {
+    frame::basic_header h1(0x00,0x00); // all false
+    frame::basic_header h2(0xF0,0x80); // all true
+
+    // Read Values
+    BOOST_CHECK( frame::get_fin(h1) == false );
+    BOOST_CHECK( frame::get_rsv1(h1) == false );
+    BOOST_CHECK( frame::get_rsv2(h1) == false );
+    BOOST_CHECK( frame::get_rsv3(h1) == false );
+    BOOST_CHECK( frame::get_masked(h1) == false );
+
+    BOOST_CHECK( frame::get_fin(h2) == true );
+    BOOST_CHECK( frame::get_rsv1(h2) == true );
+    BOOST_CHECK( frame::get_rsv2(h2) == true );
+    BOOST_CHECK( frame::get_rsv3(h2) == true );
+    BOOST_CHECK( frame::get_masked(h2) == true );
+
+    // Set Values
+    frame::set_fin(h1,true);
+    BOOST_CHECK( h1.b0 == 0x80 );
+
+    frame::set_rsv1(h1,true);
+    BOOST_CHECK( h1.b0 == 0xC0 );
+
+    frame::set_rsv2(h1,true);
+    BOOST_CHECK( h1.b0 == 0xE0 );
+
+    frame::set_rsv3(h1,true);
+    BOOST_CHECK( h1.b0 == 0xF0 );
+
+    frame::set_masked(h1,true);
+    BOOST_CHECK( h1.b1 == 0x80 );
+}
+
+BOOST_AUTO_TEST_CASE( basic_constructors ) {
+    // Read Values
+    frame::basic_header h1(frame::opcode::TEXT,12,true,false);
+    BOOST_CHECK( frame::get_opcode(h1) == frame::opcode::TEXT );
+    BOOST_CHECK( frame::get_basic_size(h1) == 12 );
+    BOOST_CHECK( frame::get_fin(h1) == true );
+    BOOST_CHECK( frame::get_rsv1(h1) == false );
+    BOOST_CHECK( frame::get_rsv2(h1) == false );
+    BOOST_CHECK( frame::get_rsv3(h1) == false );
+    BOOST_CHECK( frame::get_masked(h1) == false );
+
+    frame::basic_header h2(frame::opcode::BINARY,0,false,false,false,true);
+    BOOST_CHECK( frame::get_opcode(h2) == frame::opcode::BINARY );
+    BOOST_CHECK( frame::get_basic_size(h2) == 0 );
+    BOOST_CHECK( frame::get_fin(h2) == false );
+    BOOST_CHECK( frame::get_rsv1(h2) == false );
+    BOOST_CHECK( frame::get_rsv2(h2) == true );
+    BOOST_CHECK( frame::get_rsv3(h2) == false );
+    BOOST_CHECK( frame::get_masked(h2) == false );
+}
+
+BOOST_AUTO_TEST_CASE( basic_size ) {
+    frame::basic_header h1(0x00,0x00); // length 0
+    frame::basic_header h2(0x00,0x01); // length 1
+    frame::basic_header h3(0x00,0x7D); // length 125
+    frame::basic_header h4(0x00,0x7E); // length 126
+    frame::basic_header h5(0x00,0x7F); // length 127
+    frame::basic_header h6(0x00,0x80); // length 0, mask bit set
+
+    BOOST_CHECK( frame::get_basic_size(h1) == 0 );
+    BOOST_CHECK( frame::get_basic_size(h2) == 1 );
+    BOOST_CHECK( frame::get_basic_size(h3) == 125 );
+    BOOST_CHECK( frame::get_basic_size(h4) == 126 );
+    BOOST_CHECK( frame::get_basic_size(h5) == 127 );
+    BOOST_CHECK( frame::get_basic_size(h6) == 0 );
+
+    /*frame::set_basic_size(h1,1);
+    BOOST_CHECK( h1.b1 == 0x01 );
+
+    frame::set_basic_size(h1,125);
+    BOOST_CHECK( h1.b1 == 0x7D );
+
+    frame::set_basic_size(h1,126);
+    BOOST_CHECK( h1.b1 == 0x7E );
+
+    frame::set_basic_size(h1,127);
+    BOOST_CHECK( h1.b1 == 0x7F );
+
+    frame::set_basic_size(h1,0);
+    BOOST_CHECK( h1.b1 == 0x00 );*/
+}
+
+BOOST_AUTO_TEST_CASE( basic_header_length ) {
+    frame::basic_header h1(0x82,0x00); // short binary frame, unmasked
+    frame::basic_header h2(0x82,0x80); // short binary frame, masked
+    frame::basic_header h3(0x82,0x7E); // medium binary frame, unmasked
+    frame::basic_header h4(0x82,0xFE); // medium binary frame, masked
+    frame::basic_header h5(0x82,0x7F); // jumbo binary frame, unmasked
+    frame::basic_header h6(0x82,0xFF); // jumbo binary frame, masked
+
+    BOOST_CHECK( frame::get_header_len(h1) == 2);
+    BOOST_CHECK( frame::get_header_len(h2) == 6);
+    BOOST_CHECK( frame::get_header_len(h3) == 4);
+    BOOST_CHECK( frame::get_header_len(h4) == 8);
+    BOOST_CHECK( frame::get_header_len(h5) == 10);
+    BOOST_CHECK( frame::get_header_len(h6) == 14);
+}
+
+BOOST_AUTO_TEST_CASE( basic_opcode ) {
+    frame::basic_header h1(0x00,0x00);
+
+    BOOST_CHECK( is_control(frame::opcode::CONTINUATION) == false);
+    BOOST_CHECK( is_control(frame::opcode::TEXT) == false);
+    BOOST_CHECK( is_control(frame::opcode::BINARY) == false);
+    BOOST_CHECK( is_control(frame::opcode::CLOSE) == true);
+    BOOST_CHECK( is_control(frame::opcode::PING) == true);
+    BOOST_CHECK( is_control(frame::opcode::PONG) == true);
+
+    BOOST_CHECK( frame::get_opcode(h1) == frame::opcode::CONTINUATION );
+}
+
+BOOST_AUTO_TEST_CASE( extended_header_basics ) {
+    frame::extended_header h1;
+    uint8_t h1_solution[12] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+    frame::extended_header h2(uint16_t(255));
+    uint8_t h2_solution[12] = {0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
+                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+    frame::extended_header h3(uint16_t(256),htonl(0x8040201));
+    uint8_t h3_solution[12] = {0x01, 0x00, 0x08, 0x04, 0x02, 0x01,
+                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+    frame::extended_header h4(uint64_t(0x0807060504030201LL));
+    uint8_t h4_solution[12] = {0x08, 0x07, 0x06, 0x05, 0x04, 0x03,
+                               0x02, 0x01, 0x00, 0x00, 0x00, 0x00};
+
+    frame::extended_header h5(uint64_t(0x0807060504030201LL),htonl(0x8040201));
+    uint8_t h5_solution[12] = {0x08, 0x07, 0x06, 0x05, 0x04, 0x03,
+                               0x02, 0x01, 0x08, 0x04, 0x02, 0x01};
+
+    BOOST_CHECK( std::equal(h1_solution,h1_solution+12,h1.bytes) );
+    BOOST_CHECK( std::equal(h2_solution,h2_solution+12,h2.bytes) );
+    BOOST_CHECK( std::equal(h3_solution,h3_solution+12,h3.bytes) );
+    BOOST_CHECK( std::equal(h4_solution,h4_solution+12,h4.bytes) );
+    BOOST_CHECK( std::equal(h5_solution,h5_solution+12,h5.bytes) );
+}
+
+BOOST_AUTO_TEST_CASE( extended_header_extractors ) {
+    frame::basic_header h1(0x00,0x7E);
+    frame::extended_header e1(uint16_t(255));
+    BOOST_CHECK( get_extended_size(e1) == 255 );
+    BOOST_CHECK( get_payload_size(h1,e1) == 255 );
+    BOOST_CHECK( get_masking_key_offset(h1) == 2 );
+    BOOST_CHECK( get_masking_key(h1,e1).i == 0 );
+
+    frame::basic_header h2(0x00,0x7F);
+    frame::extended_header e2(uint64_t(0x0807060504030201LL));
+    BOOST_CHECK( get_jumbo_size(e2) == 0x0807060504030201LL );
+    BOOST_CHECK( get_payload_size(h2,e2) == 0x0807060504030201LL );
+    BOOST_CHECK( get_masking_key_offset(h2) == 8 );
+    BOOST_CHECK( get_masking_key(h2,e2).i == 0 );
+
+    frame::basic_header h3(0x00,0xFE);
+    frame::extended_header e3(uint16_t(255),0x08040201);
+    BOOST_CHECK( get_extended_size(e3) == 255 );
+    BOOST_CHECK( get_payload_size(h3,e3) == 255 );
+    BOOST_CHECK( get_masking_key_offset(h3) == 2 );
+    BOOST_CHECK( get_masking_key(h3,e3).i == 0x08040201 );
+
+    frame::basic_header h4(0x00,0xFF);
+    frame::extended_header e4(uint64_t(0x0807060504030201LL),0x08040201);
+    BOOST_CHECK( get_jumbo_size(e4) == 0x0807060504030201LL );
+    BOOST_CHECK( get_payload_size(h4,e4) == 0x0807060504030201LL );
+    BOOST_CHECK( get_masking_key_offset(h4) == 8 );
+    BOOST_CHECK( get_masking_key(h4,e4).i == 0x08040201 );
+
+    frame::basic_header h5(0x00,0x7D);
+    frame::extended_header e5;
+    BOOST_CHECK( get_payload_size(h5,e5) == 125 );
+}
+
+BOOST_AUTO_TEST_CASE( header_preparation ) {
+    frame::basic_header h1(0x81,0xFF); //
+    frame::extended_header e1(uint64_t(0xFFFFFLL),htonl(0xD5FB70EE));
+    std::string p1 = prepare_header(h1, e1);
+    uint8_t s1[14] = {0x81, 0xFF,
+                     0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF,
+                     0xD5, 0xFB, 0x70, 0xEE};
+
+    BOOST_CHECK( p1.size() == 14);
+    BOOST_CHECK( std::equal(p1.begin(),p1.end(),reinterpret_cast<char*>(s1)) );
+
+    frame::basic_header h2(0x81,0x7E); //
+    frame::extended_header e2(uint16_t(255));
+    std::string p2 = prepare_header(h2, e2);
+    uint8_t s2[4] = {0x81, 0x7E, 0x00, 0xFF};
+
+    BOOST_CHECK( p2.size() == 4);
+    BOOST_CHECK( std::equal(p2.begin(),p2.end(),reinterpret_cast<char*>(s2)) );
+}
+
+BOOST_AUTO_TEST_CASE( prepare_masking_key ) {
+    frame::masking_key_type key;
+
+    key.i = htonl(0x12345678);
+
+    if (sizeof(size_t) == 8) {
+        BOOST_CHECK(
+            frame::prepare_masking_key(key) == lib::net::_htonll(0x1234567812345678LL)
+        );
+    } else {
+        BOOST_CHECK( frame::prepare_masking_key(key) == htonl(0x12345678) );
+    }
+}
+
+BOOST_AUTO_TEST_CASE( prepare_masking_key2 ) {
+    frame::masking_key_type key;
+
+    key.i = htonl(0xD5FB70EE);
+
+    // One call
+    if (sizeof(size_t) == 8) {
+        BOOST_CHECK(
+            frame::prepare_masking_key(key) == lib::net::_htonll(0xD5FB70EED5FB70EELL)
+        );
+    } else {
+        BOOST_CHECK( frame::prepare_masking_key(key) == htonl(0xD5FB70EE) );
+    }
+}
+
+// TODO: figure out a way to run/test both 4 and 8 byte versions.
+BOOST_AUTO_TEST_CASE( circshift ) {
+    /*if (sizeof(size_t) == 8) {
+        size_t test = 0x0123456789abcdef;
+
+        BOOST_CHECK( frame::circshift_prepared_key(test,0) == 0x0123456789abcdef);
+        BOOST_CHECK( frame::circshift_prepared_key(test,1) == 0xef0123456789abcd);
+        BOOST_CHECK( frame::circshift_prepared_key(test,2) == 0xcdef0123456789ab);
+        BOOST_CHECK( frame::circshift_prepared_key(test,3) == 0xabcdef0123456789);
+    } else {
+        size_t test = 0x01234567;
+
+        BOOST_CHECK( frame::circshift_prepared_key(test,0) == 0x01234567);
+        BOOST_CHECK( frame::circshift_prepared_key(test,1) == 0x67012345);
+        BOOST_CHECK( frame::circshift_prepared_key(test,2) == 0x45670123);
+        BOOST_CHECK( frame::circshift_prepared_key(test,3) == 0x23456701);
+    }*/
+}
+
+BOOST_AUTO_TEST_CASE( block_byte_mask ) {
+    uint8_t input[15] = {0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00, 0x00,
+                         0x00, 0x00, 0x00};
+
+    uint8_t output[15];
+
+    uint8_t masked[15] = {0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02};
+
+    frame::masking_key_type key;
+    key.c[0] = 0x00;
+    key.c[1] = 0x01;
+    key.c[2] = 0x02;
+    key.c[3] = 0x03;
+
+    byte_mask(input,input+15,output,key);
+
+    BOOST_CHECK( std::equal(output,output+15,masked) );
+}
+
+BOOST_AUTO_TEST_CASE( block_byte_mask_inplace ) {
+    uint8_t buffer[15] = {0x00, 0x00, 0x00, 0x00,
+                          0x00, 0x00, 0x00, 0x00,
+                          0x00, 0x00, 0x00, 0x00,
+                          0x00, 0x00, 0x00};
+
+    uint8_t masked[15] = {0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02};
+
+    frame::masking_key_type key;
+    key.c[0] = 0x00;
+    key.c[1] = 0x01;
+    key.c[2] = 0x02;
+    key.c[3] = 0x03;
+
+    byte_mask(buffer,buffer+15,key);
+
+    BOOST_CHECK( std::equal(buffer,buffer+15,masked) );
+}
+
+BOOST_AUTO_TEST_CASE( block_word_mask ) {
+    uint8_t input[15] =  {0x00, 0x00, 0x00, 0x00,
+                          0x00, 0x00, 0x00, 0x00,
+                          0x00, 0x00, 0x00, 0x00,
+                          0x00, 0x00, 0x00};
+
+    uint8_t output[15];
+
+    uint8_t masked[15] = {0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02};
+
+    frame::masking_key_type key;
+    key.c[0] = 0x00;
+    key.c[1] = 0x01;
+    key.c[2] = 0x02;
+    key.c[3] = 0x03;
+
+    word_mask_exact(input,output,15,key);
+
+    BOOST_CHECK( std::equal(output,output+15,masked) );
+}
+
+BOOST_AUTO_TEST_CASE( block_word_mask_inplace ) {
+    uint8_t buffer[15] = {0x00, 0x00, 0x00, 0x00,
+                          0x00, 0x00, 0x00, 0x00,
+                          0x00, 0x00, 0x00, 0x00,
+                          0x00, 0x00, 0x00};
+
+    uint8_t masked[15] = {0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02};
+
+    frame::masking_key_type key;
+    key.c[0] = 0x00;
+    key.c[1] = 0x01;
+    key.c[2] = 0x02;
+    key.c[3] = 0x03;
+
+    word_mask_exact(buffer,15,key);
+
+    BOOST_CHECK( std::equal(buffer,buffer+15,masked) );
+}
+
+BOOST_AUTO_TEST_CASE( continuous_word_mask ) {
+    uint8_t input[16];
+    uint8_t output[16];
+
+    uint8_t masked[16] = {0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x00};
+
+    frame::masking_key_type key;
+    key.c[0] = 0x00;
+    key.c[1] = 0x01;
+    key.c[2] = 0x02;
+    key.c[3] = 0x03;
+
+    // One call
+    size_t pkey,pkey_temp;
+    pkey = frame::prepare_masking_key(key);
+    std::fill_n(input,16,0x00);
+    std::fill_n(output,16,0x00);
+    frame::word_mask_circ(input,output,15,pkey);
+    BOOST_CHECK( std::equal(output,output+16,masked) );
+
+    // calls not split on word boundaries
+    pkey = frame::prepare_masking_key(key);
+    std::fill_n(input,16,0x00);
+    std::fill_n(output,16,0x00);
+
+    pkey_temp = frame::word_mask_circ(input,output,7,pkey);
+    BOOST_CHECK( std::equal(output,output+7,masked) );
+    BOOST_CHECK( pkey_temp == frame::circshift_prepared_key(pkey,3) );
+
+    pkey_temp = frame::word_mask_circ(input+7,output+7,8,pkey_temp);
+    BOOST_CHECK( std::equal(output,output+16,masked) );
+    BOOST_CHECK_EQUAL( pkey_temp, frame::circshift_prepared_key(pkey,3) );
+}
+
+BOOST_AUTO_TEST_CASE( continuous_byte_mask ) {
+    uint8_t input[16];
+    uint8_t output[16];
+
+    uint8_t masked[16] = {0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x00};
+
+    frame::masking_key_type key;
+    key.c[0] = 0x00;
+    key.c[1] = 0x01;
+    key.c[2] = 0x02;
+    key.c[3] = 0x03;
+
+    // One call
+    size_t pkey,pkey_temp;
+    pkey = frame::prepare_masking_key(key);
+    std::fill_n(input,16,0x00);
+    std::fill_n(output,16,0x00);
+    frame::byte_mask_circ(input,output,15,pkey);
+    BOOST_CHECK( std::equal(output,output+16,masked) );
+
+    // calls not split on word boundaries
+    pkey = frame::prepare_masking_key(key);
+    std::fill_n(input,16,0x00);
+    std::fill_n(output,16,0x00);
+
+    pkey_temp = frame::byte_mask_circ(input,output,7,pkey);
+    BOOST_CHECK( std::equal(output,output+7,masked) );
+    BOOST_CHECK( pkey_temp == frame::circshift_prepared_key(pkey,3) );
+
+    pkey_temp = frame::byte_mask_circ(input+7,output+7,8,pkey_temp);
+    BOOST_CHECK( std::equal(output,output+16,masked) );
+    BOOST_CHECK_EQUAL( pkey_temp, frame::circshift_prepared_key(pkey,3) );
+}
+
+BOOST_AUTO_TEST_CASE( continuous_word_mask_inplace ) {
+    uint8_t buffer[16];
+
+    uint8_t masked[16] = {0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x00};
+
+    frame::masking_key_type key;
+    key.c[0] = 0x00;
+    key.c[1] = 0x01;
+    key.c[2] = 0x02;
+    key.c[3] = 0x03;
+
+    // One call
+    size_t pkey,pkey_temp;
+    pkey = frame::prepare_masking_key(key);
+    std::fill_n(buffer,16,0x00);
+    frame::word_mask_circ(buffer,15,pkey);
+    BOOST_CHECK( std::equal(buffer,buffer+16,masked) );
+
+    // calls not split on word boundaries
+    pkey = frame::prepare_masking_key(key);
+    std::fill_n(buffer,16,0x00);
+
+    pkey_temp = frame::word_mask_circ(buffer,7,pkey);
+    BOOST_CHECK( std::equal(buffer,buffer+7,masked) );
+    BOOST_CHECK_EQUAL( pkey_temp, frame::circshift_prepared_key(pkey,3) );
+
+    pkey_temp = frame::word_mask_circ(buffer+7,8,pkey_temp);
+    BOOST_CHECK( std::equal(buffer,buffer+16,masked) );
+    BOOST_CHECK_EQUAL( pkey_temp, frame::circshift_prepared_key(pkey,3) );
+}
+
+BOOST_AUTO_TEST_CASE( continuous_byte_mask_inplace ) {
+    uint8_t buffer[16];
+
+    uint8_t masked[16] = {0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x03,
+                          0x00, 0x01, 0x02, 0x00};
+
+    frame::masking_key_type key;
+    key.c[0] = 0x00;
+    key.c[1] = 0x01;
+    key.c[2] = 0x02;
+    key.c[3] = 0x03;
+
+    // One call
+    size_t pkey,pkey_temp;
+    pkey = frame::prepare_masking_key(key);
+    std::fill_n(buffer,16,0x00);
+    frame::byte_mask_circ(buffer,15,pkey);
+    BOOST_CHECK( std::equal(buffer,buffer+16,masked) );
+
+    // calls not split on word boundaries
+    pkey = frame::prepare_masking_key(key);
+    std::fill_n(buffer,16,0x00);
+
+    pkey_temp = frame::byte_mask_circ(buffer,7,pkey);
+    BOOST_CHECK( std::equal(buffer,buffer+7,masked) );
+    BOOST_CHECK_EQUAL( pkey_temp, frame::circshift_prepared_key(pkey,3) );
+
+    pkey_temp = frame::byte_mask_circ(buffer+7,8,pkey_temp);
+    BOOST_CHECK( std::equal(buffer,buffer+16,masked) );
+    BOOST_CHECK_EQUAL( pkey_temp, frame::circshift_prepared_key(pkey,3) );
+}
+
+BOOST_AUTO_TEST_CASE( continuous_word_mask2 ) {
+    uint8_t buffer[12] = {0xA6, 0x15, 0x97, 0xB9,
+                          0x81, 0x50, 0xAC, 0xBA,
+                          0x9C, 0x1C, 0x9F, 0xF4};
+
+    uint8_t unmasked[12] = {0x48, 0x65, 0x6C, 0x6C,
+                            0x6F, 0x20, 0x57, 0x6F,
+                            0x72, 0x6C, 0x64, 0x21};
+
+    frame::masking_key_type key;
+    key.c[0] = 0xEE;
+    key.c[1] = 0x70;
+    key.c[2] = 0xFB;
+    key.c[3] = 0xD5;
+
+    // One call
+    size_t pkey;
+    pkey = frame::prepare_masking_key(key);
+    frame::word_mask_circ(buffer,12,pkey);
+    BOOST_CHECK( std::equal(buffer,buffer+12,unmasked) );
+}
diff --git a/extlibs/websocketpp/test/utility/sha1.cpp b/extlibs/websocketpp/test/utility/sha1.cpp
new file mode 100644
index 000000000..ab25f970d
--- /dev/null
+++ b/extlibs/websocketpp/test/utility/sha1.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE sha1
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/sha1/sha1.hpp>
+#include <websocketpp/utilities.hpp>
+
+BOOST_AUTO_TEST_SUITE ( sha1 )
+
+BOOST_AUTO_TEST_CASE( sha1_test_a ) {
+    unsigned char hash[20];
+    unsigned char reference[20] = {0xa9, 0x99, 0x3e, 0x36, 0x47,
+                                   0x06, 0x81, 0x6a, 0xba, 0x3e,
+                                   0x25, 0x71, 0x78, 0x50, 0xc2,
+                                   0x6c, 0x9c, 0xd0, 0xd8, 0x9d};
+
+    websocketpp::sha1::calc("abc",3,hash);
+
+    BOOST_CHECK_EQUAL_COLLECTIONS(hash, hash+20, reference, reference+20);
+}
+
+BOOST_AUTO_TEST_CASE( sha1_test_b ) {
+    unsigned char hash[20];
+    unsigned char reference[20] = {0x84, 0x98, 0x3e, 0x44, 0x1c,
+                                   0x3b, 0xd2, 0x6e, 0xba, 0xae,
+                                   0x4a, 0xa1, 0xf9, 0x51, 0x29,
+                                   0xe5, 0xe5, 0x46, 0x70, 0xf1};
+
+    websocketpp::sha1::calc(
+        "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",56,hash);
+
+    BOOST_CHECK_EQUAL_COLLECTIONS(hash, hash+20, reference, reference+20);
+}
+
+BOOST_AUTO_TEST_CASE( sha1_test_c ) {
+    std::string input;
+    unsigned char hash[20];
+    unsigned char reference[20] = {0x34, 0xaa, 0x97, 0x3c, 0xd4,
+                                   0xc4, 0xda, 0xa4, 0xf6, 0x1e,
+                                   0xeb, 0x2b, 0xdb, 0xad, 0x27,
+                                   0x31, 0x65, 0x34, 0x01, 0x6f};
+
+    for (int i = 0; i < 1000000; i++) {
+        input += 'a';
+    }
+
+    websocketpp::sha1::calc(input.c_str(),input.size(),hash);
+
+    BOOST_CHECK_EQUAL_COLLECTIONS(hash, hash+20, reference, reference+20);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/extlibs/websocketpp/test/utility/uri.cpp b/extlibs/websocketpp/test/utility/uri.cpp
new file mode 100644
index 000000000..2b0c88639
--- /dev/null
+++ b/extlibs/websocketpp/test/utility/uri.cpp
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE uri
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/uri.hpp>
+
+// Test a regular valid ws URI
+BOOST_AUTO_TEST_CASE( uri_valid ) {
+    websocketpp::uri uri("ws://localhost:9000/chat");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( !uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "ws");
+    BOOST_CHECK_EQUAL( uri.get_host(), "localhost");
+    BOOST_CHECK_EQUAL( uri.get_port(), 9000 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/chat" );
+    BOOST_CHECK_EQUAL( uri.get_query(), "" );
+}
+
+// Test a regular valid ws URI
+BOOST_AUTO_TEST_CASE( uri_valid_no_port_unsecure ) {
+    websocketpp::uri uri("ws://localhost/chat");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( !uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "ws");
+    BOOST_CHECK_EQUAL( uri.get_host(), "localhost");
+    BOOST_CHECK_EQUAL( uri.get_port(), 80 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/chat" );
+}
+
+// Valid URI with no port (secure)
+BOOST_AUTO_TEST_CASE( uri_valid_no_port_secure ) {
+    websocketpp::uri uri("wss://localhost/chat");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "wss");
+    BOOST_CHECK_EQUAL( uri.get_host(), "localhost");
+    BOOST_CHECK_EQUAL( uri.get_port(), 443 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/chat" );
+}
+
+// Valid URI with no resource
+BOOST_AUTO_TEST_CASE( uri_valid_no_resource ) {
+    websocketpp::uri uri("wss://localhost:9000");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "wss");
+    BOOST_CHECK_EQUAL( uri.get_host(), "localhost");
+    BOOST_CHECK_EQUAL( uri.get_port(), 9000 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/" );
+}
+
+// Valid URI IPv6 Literal
+BOOST_AUTO_TEST_CASE( uri_valid_ipv6_literal ) {
+    websocketpp::uri uri("wss://[::1]:9000/chat");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "wss");
+    BOOST_CHECK_EQUAL( uri.get_host(), "::1");
+    BOOST_CHECK_EQUAL( uri.get_port(), 9000 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/chat" );
+}
+
+// Valid URI with more complicated host
+BOOST_AUTO_TEST_CASE( uri_valid_2 ) {
+    websocketpp::uri uri("wss://thor-websocket.zaphoyd.net:88/");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "wss");
+    BOOST_CHECK_EQUAL( uri.get_host(), "thor-websocket.zaphoyd.net");
+    BOOST_CHECK_EQUAL( uri.get_port(), 88 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/" );
+}
+
+
+// Invalid URI (port too long)
+BOOST_AUTO_TEST_CASE( uri_invalid_long_port ) {
+    websocketpp::uri uri("wss://localhost:900000/chat");
+
+    BOOST_CHECK( !uri.get_valid() );
+}
+
+// Invalid URI (bogus scheme method)
+BOOST_AUTO_TEST_CASE( uri_invalid_scheme ) {
+    websocketpp::uri uri("foo://localhost:9000/chat");
+
+    BOOST_CHECK( !uri.get_valid() );
+}
+
+// Valid URI (http method)
+BOOST_AUTO_TEST_CASE( uri_http_scheme ) {
+    websocketpp::uri uri("http://localhost:9000/chat");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( !uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "http");
+    BOOST_CHECK_EQUAL( uri.get_host(), "localhost");
+    BOOST_CHECK_EQUAL( uri.get_port(), 9000 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/chat" );
+}
+
+// Valid URI IPv4 literal
+BOOST_AUTO_TEST_CASE( uri_valid_ipv4_literal ) {
+    websocketpp::uri uri("wss://127.0.0.1:9000/chat");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "wss");
+    BOOST_CHECK_EQUAL( uri.get_host(), "127.0.0.1");
+    BOOST_CHECK_EQUAL( uri.get_port(), 9000 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/chat" );
+}
+
+// Valid URI complicated resource path
+BOOST_AUTO_TEST_CASE( uri_valid_3 ) {
+    websocketpp::uri uri("wss://localhost:9000/chat/foo/bar");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "wss");
+    BOOST_CHECK_EQUAL( uri.get_host(), "localhost");
+    BOOST_CHECK_EQUAL( uri.get_port(), 9000 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/chat/foo/bar" );
+}
+
+// Invalid URI broken method separator
+BOOST_AUTO_TEST_CASE( uri_invalid_method_separator ) {
+    websocketpp::uri uri("wss:/localhost:9000/chat");
+
+    BOOST_CHECK( !uri.get_valid() );
+}
+
+// Invalid URI port > 65535
+BOOST_AUTO_TEST_CASE( uri_invalid_gt_16_bit_port ) {
+    websocketpp::uri uri("wss:/localhost:70000/chat");
+
+    BOOST_CHECK( !uri.get_valid() );
+}
+
+// Invalid URI includes uri fragment
+BOOST_AUTO_TEST_CASE( uri_invalid_fragment ) {
+    websocketpp::uri uri("wss:/localhost:70000/chat#foo");
+
+    BOOST_CHECK( !uri.get_valid() );
+}
+
+// Invalid URI with no brackets around IPv6 literal
+BOOST_AUTO_TEST_CASE( uri_invalid_bad_v6_literal_1 ) {
+    websocketpp::uri uri("wss://::1/chat");
+
+    BOOST_CHECK( !uri.get_valid() );
+}
+
+// Invalid URI with port and no brackets around IPv6 literal
+BOOST_AUTO_TEST_CASE( uri_invalid_bad_v6_literal_2 ) {
+    websocketpp::uri uri("wss://::1:2009/chat");
+
+    BOOST_CHECK( !uri.get_valid() );
+}
+
+// Valid URI complicated resource path with query
+BOOST_AUTO_TEST_CASE( uri_valid_4 ) {
+    websocketpp::uri uri("wss://localhost:9000/chat/foo/bar?foo=bar");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "wss" );
+    BOOST_CHECK_EQUAL( uri.get_host(), "localhost");
+    BOOST_CHECK_EQUAL( uri.get_port(), 9000 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/chat/foo/bar?foo=bar" );
+    BOOST_CHECK_EQUAL( uri.get_query(), "foo=bar" );
+}
+
+// Valid URI with a mapped v4 ipv6 literal
+BOOST_AUTO_TEST_CASE( uri_valid_v4_mapped ) {
+    websocketpp::uri uri("wss://[0000:0000:0000:0000:0000:0000:192.168.1.1]:9000/");
+
+    BOOST_CHECK( uri.get_valid() );
+    BOOST_CHECK( uri.get_secure() );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "wss" );
+    BOOST_CHECK_EQUAL( uri.get_host(), "0000:0000:0000:0000:0000:0000:192.168.1.1");
+    BOOST_CHECK_EQUAL( uri.get_port(), 9000 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/" );
+}
+
+// Valid URI with a v6 address with mixed case
+BOOST_AUTO_TEST_CASE( uri_valid_v6_mixed_case ) {
+    websocketpp::uri uri("wss://[::10aB]:9000/");
+
+    BOOST_CHECK( uri.get_valid() == true );
+    BOOST_CHECK( uri.get_secure() == true );
+    BOOST_CHECK_EQUAL( uri.get_scheme(), "wss" );
+    BOOST_CHECK_EQUAL( uri.get_host(), "::10aB");
+    BOOST_CHECK_EQUAL( uri.get_port(), 9000 );
+    BOOST_CHECK_EQUAL( uri.get_resource(), "/" );
+}
+
+// Valid URI with a v6 address with mixed case
+BOOST_AUTO_TEST_CASE( uri_invalid_no_scheme ) {
+    websocketpp::uri uri("myserver.com");
+
+    BOOST_CHECK( !uri.get_valid() );
+}
+
+// Invalid IPv6 literal
+/*BOOST_AUTO_TEST_CASE( uri_invalid_v6_nonhex ) {
+    websocketpp::uri uri("wss://[g::1]:9000/");
+
+    BOOST_CHECK( uri.get_valid() == false );
+}*/
+
+// TODO: tests for the other two constructors
diff --git a/extlibs/websocketpp/test/utility/utilities.cpp b/extlibs/websocketpp/test/utility/utilities.cpp
new file mode 100644
index 000000000..8cbb8c3cc
--- /dev/null
+++ b/extlibs/websocketpp/test/utility/utilities.cpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2011, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+//#define BOOST_TEST_DYN_LINK
+#define BOOST_TEST_MODULE utility
+#include <boost/test/unit_test.hpp>
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/utilities.hpp>
+
+BOOST_AUTO_TEST_SUITE ( utility )
+
+BOOST_AUTO_TEST_CASE( substr_found ) {
+    std::string haystack = "abc123";
+    std::string needle = "abc";
+
+    BOOST_CHECK(websocketpp::utility::ci_find_substr(haystack,needle) ==haystack.begin());
+}
+
+BOOST_AUTO_TEST_CASE( substr_found_ci ) {
+    std::string haystack = "abc123";
+    std::string needle = "aBc";
+
+    BOOST_CHECK(websocketpp::utility::ci_find_substr(haystack,needle) ==haystack.begin());
+}
+
+BOOST_AUTO_TEST_CASE( substr_not_found ) {
+    std::string haystack = "abd123";
+    std::string needle = "abcd";
+
+    BOOST_CHECK(websocketpp::utility::ci_find_substr(haystack,needle) == haystack.end());
+}
+
+BOOST_AUTO_TEST_CASE( to_lower ) {
+    std::string in = "AbCd";
+
+    BOOST_CHECK_EQUAL(websocketpp::utility::to_lower(in), "abcd");
+}
+
+BOOST_AUTO_TEST_CASE( string_replace_all ) {
+    std::string source = "foo \"bar\" baz";
+    std::string dest = "foo \\\"bar\\\" baz";
+
+    using websocketpp::utility::string_replace_all;
+    BOOST_CHECK_EQUAL(string_replace_all(source,"\"","\\\""),dest);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/extlibs/websocketpp/tutorials/broadcast_tutorial/broadcast_tutorial.md b/extlibs/websocketpp/tutorials/broadcast_tutorial/broadcast_tutorial.md
new file mode 100644
index 000000000..02e50016f
--- /dev/null
+++ b/extlibs/websocketpp/tutorials/broadcast_tutorial/broadcast_tutorial.md
@@ -0,0 +1,17 @@
+Broadcast Tutorial
+==================
+
+This tutorial will dig into some more nitty gritty details on how to build high
+scalability, high performance websocket servers for broadcast like workflows.
+
+Will go into features like:
+- minimizing work done in handlers
+- using asio thread pool mode
+- teaming multiple endpoints
+- setting accept queue depth
+- tuning compile time buffer sizes
+- prepared messages
+- flow control
+- basic operating system level tuning, particularly increasing file descriptor limits.
+- measuring performance with wsperf / autobahn
+- tuning permessage-deflate compression settings
\ No newline at end of file
diff --git a/extlibs/websocketpp/tutorials/chat_tutorial/chat_tutorial.md b/extlibs/websocketpp/tutorials/chat_tutorial/chat_tutorial.md
new file mode 100644
index 000000000..042837c6f
--- /dev/null
+++ b/extlibs/websocketpp/tutorials/chat_tutorial/chat_tutorial.md
@@ -0,0 +1,13 @@
+Chat Tutorial
+=============
+
+Goals of this tutorial:
+- Implement a realtime websocket chat server
+
+
+Server
+- Nicknames
+- Channels
+- Subprotocol
+- Origin restrictions
+- HTTP statistics page
diff --git a/extlibs/websocketpp/tutorials/utility_client/step1.cpp b/extlibs/websocketpp/tutorials/utility_client/step1.cpp
new file mode 100644
index 000000000..9c8fad9eb
--- /dev/null
+++ b/extlibs/websocketpp/tutorials/utility_client/step1.cpp
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+// **NOTE:** This file is a snapshot of the WebSocket++ utility client tutorial.
+// Additional related material can be found in the tutorials/utility_client
+// directory of the WebSocket++ repository.
+
+#include <iostream>
+#include <string>
+
+int main() {
+    bool done = false;
+    std::string input;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout 
+                << "\nCommand List:\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else {
+            std::cout << "Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
diff --git a/extlibs/websocketpp/tutorials/utility_client/step2.cpp b/extlibs/websocketpp/tutorials/utility_client/step2.cpp
new file mode 100644
index 000000000..a1e579663
--- /dev/null
+++ b/extlibs/websocketpp/tutorials/utility_client/step2.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+// **NOTE:** This file is a snapshot of the WebSocket++ utility client tutorial.
+// Additional related material can be found in the tutorials/utility_client
+// directory of the WebSocket++ repository.
+
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+#include <iostream>
+#include <string>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+int main() {
+    bool done = false;
+    std::string input;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout
+                << "\nCommand List:\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else {
+            std::cout << "Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
diff --git a/extlibs/websocketpp/tutorials/utility_client/step3.cpp b/extlibs/websocketpp/tutorials/utility_client/step3.cpp
new file mode 100644
index 000000000..82e652f10
--- /dev/null
+++ b/extlibs/websocketpp/tutorials/utility_client/step3.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+// **NOTE:** This file is a snapshot of the WebSocket++ utility client tutorial.
+// Additional related material can be found in the tutorials/utility_client
+// directory of the WebSocket++ repository.
+
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+#include <websocketpp/common/thread.hpp>
+#include <websocketpp/common/memory.hpp>
+
+#include <iostream>
+#include <string>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+class websocket_endpoint {
+public:
+    websocket_endpoint () {
+        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);
+        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);
+
+        m_endpoint.init_asio();
+        m_endpoint.start_perpetual();
+
+        m_thread = websocketpp::lib::make_shared<websocketpp::lib::thread>(&client::run, &m_endpoint);
+    }
+private:
+    client m_endpoint;
+    websocketpp::lib::shared_ptr<websocketpp::lib::thread> m_thread;
+};
+
+int main() {
+    bool done = false;
+    std::string input;
+    websocket_endpoint endpoint;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout 
+                << "\nCommand List:\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else {
+            std::cout << "Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
diff --git a/extlibs/websocketpp/tutorials/utility_client/step4.cpp b/extlibs/websocketpp/tutorials/utility_client/step4.cpp
new file mode 100644
index 000000000..73aee65a8
--- /dev/null
+++ b/extlibs/websocketpp/tutorials/utility_client/step4.cpp
@@ -0,0 +1,202 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+// **NOTE:** This file is a snapshot of the WebSocket++ utility client tutorial.
+// Additional related material can be found in the tutorials/utility_client
+// directory of the WebSocket++ repository.
+
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+#include <websocketpp/common/thread.hpp>
+#include <websocketpp/common/memory.hpp>
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <string>
+#include <sstream>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+class connection_metadata {
+public:
+    typedef websocketpp::lib::shared_ptr<connection_metadata> ptr;
+
+    connection_metadata(int id, websocketpp::connection_hdl hdl, std::string uri)
+      : m_id(id)
+      , m_hdl(hdl)
+      , m_status("Connecting")
+      , m_uri(uri)
+      , m_server("N/A")
+    {}
+
+    void on_open(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Open";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+    }
+
+    void on_fail(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Failed";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+        m_error_reason = con->get_ec().message();
+    }
+
+    friend std::ostream & operator<< (std::ostream & out, connection_metadata const & data);
+private:
+    int m_id;
+    websocketpp::connection_hdl m_hdl;
+    std::string m_status;
+    std::string m_uri;
+    std::string m_server;
+    std::string m_error_reason;
+};
+
+std::ostream & operator<< (std::ostream & out, connection_metadata const & data) {
+    out << "> URI: " << data.m_uri << "\n"
+        << "> Status: " << data.m_status << "\n"
+        << "> Remote Server: " << (data.m_server.empty() ? "None Specified" : data.m_server) << "\n"
+        << "> Error/close reason: " << (data.m_error_reason.empty() ? "N/A" : data.m_error_reason);
+
+    return out;
+}
+
+class websocket_endpoint {
+public:
+    websocket_endpoint () : m_next_id(0) {
+        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);
+        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);
+
+        m_endpoint.init_asio();
+        m_endpoint.start_perpetual();
+
+        m_thread = websocketpp::lib::make_shared<websocketpp::lib::thread>(&client::run, &m_endpoint);
+    }
+
+    int connect(std::string const & uri) {
+        websocketpp::lib::error_code ec;
+
+        client::connection_ptr con = m_endpoint.get_connection(uri, ec);
+
+        if (ec) {
+            std::cout << "> Connect initialization error: " << ec.message() << std::endl;
+            return -1;
+        }
+
+        int new_id = m_next_id++;
+        connection_metadata::ptr metadata_ptr = websocketpp::lib::make_shared<connection_metadata>(new_id, con->get_handle(), uri);
+        m_connection_list[new_id] = metadata_ptr;
+
+        con->set_open_handler(websocketpp::lib::bind(
+            &connection_metadata::on_open,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_fail_handler(websocketpp::lib::bind(
+            &connection_metadata::on_fail,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+
+        m_endpoint.connect(con);
+
+        return new_id;
+    }
+
+    connection_metadata::ptr get_metadata(int id) const {
+        con_list::const_iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            return connection_metadata::ptr();
+        } else {
+            return metadata_it->second;
+        }
+    }
+private:
+    typedef std::map<int,connection_metadata::ptr> con_list;
+
+    client m_endpoint;
+    websocketpp::lib::shared_ptr<websocketpp::lib::thread> m_thread;
+
+    con_list m_connection_list;
+    int m_next_id;
+};
+
+int main() {
+    bool done = false;
+    std::string input;
+    websocket_endpoint endpoint;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout
+                << "\nCommand List:\n"
+                << "connect <ws uri>\n"
+                << "show <connection id>\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else if (input.substr(0,7) == "connect") {
+            int id = endpoint.connect(input.substr(8));
+            if (id != -1) {
+                std::cout << "> Created connection with id " << id << std::endl;
+            }
+        } else if (input.substr(0,4) == "show") {
+            int id = atoi(input.substr(5).c_str());
+
+            connection_metadata::ptr metadata = endpoint.get_metadata(id);
+            if (metadata) {
+                std::cout << *metadata << std::endl;
+            } else {
+                std::cout << "> Unknown connection id " << id << std::endl;
+            }
+        } else {
+            std::cout << "> Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
+
+/*
+
+clang++ -std=c++11 -stdlib=libc++ -I/Users/zaphoyd/software/websocketpp/ -I/Users/zaphoyd/software/boost_1_55_0/ -D_WEBSOCKETPP_CPP11_STL_ step4.cpp /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_system.a
+
+clang++ -I/Users/zaphoyd/software/websocketpp/ -I/Users/zaphoyd/software/boost_1_55_0/ step4.cpp /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_system.a /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_thread.a /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_random.a
+
+clang++ -std=c++11 -stdlib=libc++ -I/Users/zaphoyd/Documents/websocketpp/ -I/Users/zaphoyd/Documents/boost_1_53_0_libcpp/ -D_WEBSOCKETPP_CPP11_STL_ step4.cpp /Users/zaphoyd/Documents/boost_1_53_0_libcpp/stage/lib/libboost_system.a
+
+*/
diff --git a/extlibs/websocketpp/tutorials/utility_client/step5.cpp b/extlibs/websocketpp/tutorials/utility_client/step5.cpp
new file mode 100644
index 000000000..dd9136a83
--- /dev/null
+++ b/extlibs/websocketpp/tutorials/utility_client/step5.cpp
@@ -0,0 +1,280 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+// **NOTE:** This file is a snapshot of the WebSocket++ utility client tutorial.
+// Additional related material can be found in the tutorials/utility_client
+// directory of the WebSocket++ repository.
+
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+#include <websocketpp/common/thread.hpp>
+#include <websocketpp/common/memory.hpp>
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <string>
+#include <sstream>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+class connection_metadata {
+public:
+    typedef websocketpp::lib::shared_ptr<connection_metadata> ptr;
+
+    connection_metadata(int id, websocketpp::connection_hdl hdl, std::string uri)
+      : m_id(id)
+      , m_hdl(hdl)
+      , m_status("Connecting")
+      , m_uri(uri)
+      , m_server("N/A")
+    {}
+
+    void on_open(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Open";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+    }
+
+    void on_fail(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Failed";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+        m_error_reason = con->get_ec().message();
+    }
+    
+    void on_close(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Closed";
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        std::stringstream s;
+        s << "close code: " << con->get_remote_close_code() << " (" 
+          << websocketpp::close::status::get_string(con->get_remote_close_code()) 
+          << "), close reason: " << con->get_remote_close_reason();
+        m_error_reason = s.str();
+    }
+
+    websocketpp::connection_hdl get_hdl() const {
+        return m_hdl;
+    }
+    
+    int get_id() const {
+        return m_id;
+    }
+    
+    std::string get_status() const {
+        return m_status;
+    }
+
+    friend std::ostream & operator<< (std::ostream & out, connection_metadata const & data);
+private:
+    int m_id;
+    websocketpp::connection_hdl m_hdl;
+    std::string m_status;
+    std::string m_uri;
+    std::string m_server;
+    std::string m_error_reason;
+};
+
+std::ostream & operator<< (std::ostream & out, connection_metadata const & data) {
+    out << "> URI: " << data.m_uri << "\n"
+        << "> Status: " << data.m_status << "\n"
+        << "> Remote Server: " << (data.m_server.empty() ? "None Specified" : data.m_server) << "\n"
+        << "> Error/close reason: " << (data.m_error_reason.empty() ? "N/A" : data.m_error_reason);
+
+    return out;
+}
+
+class websocket_endpoint {
+public:
+    websocket_endpoint () : m_next_id(0) {
+        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);
+        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);
+
+        m_endpoint.init_asio();
+        m_endpoint.start_perpetual();
+
+        m_thread = websocketpp::lib::make_shared<websocketpp::lib::thread>(&client::run, &m_endpoint);
+    }
+
+    ~websocket_endpoint() {
+        m_endpoint.stop_perpetual();
+        
+        for (con_list::const_iterator it = m_connection_list.begin(); it != m_connection_list.end(); ++it) {
+            if (it->second->get_status() != "Open") {
+                // Only close open connections
+                continue;
+            }
+            
+            std::cout << "> Closing connection " << it->second->get_id() << std::endl;
+            
+            websocketpp::lib::error_code ec;
+            m_endpoint.close(it->second->get_hdl(), websocketpp::close::status::going_away, "", ec);
+            if (ec) {
+                std::cout << "> Error closing connection " << it->second->get_id() << ": "  
+                          << ec.message() << std::endl;
+            }
+        }
+        
+        m_thread->join();
+    }
+
+    int connect(std::string const & uri) {
+        websocketpp::lib::error_code ec;
+
+        client::connection_ptr con = m_endpoint.get_connection(uri, ec);
+
+        if (ec) {
+            std::cout << "> Connect initialization error: " << ec.message() << std::endl;
+            return -1;
+        }
+
+        int new_id = m_next_id++;
+        connection_metadata::ptr metadata_ptr = websocketpp::lib::make_shared<connection_metadata>(new_id, con->get_handle(), uri);
+        m_connection_list[new_id] = metadata_ptr;
+
+        con->set_open_handler(websocketpp::lib::bind(
+            &connection_metadata::on_open,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_fail_handler(websocketpp::lib::bind(
+            &connection_metadata::on_fail,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_close_handler(websocketpp::lib::bind(
+            &connection_metadata::on_close,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+
+        m_endpoint.connect(con);
+
+        return new_id;
+    }
+
+    void close(int id, websocketpp::close::status::value code, std::string reason) {
+        websocketpp::lib::error_code ec;
+        
+        con_list::iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            std::cout << "> No connection found with id " << id << std::endl;
+            return;
+        }
+        
+        m_endpoint.close(metadata_it->second->get_hdl(), code, reason, ec);
+        if (ec) {
+            std::cout << "> Error initiating close: " << ec.message() << std::endl;
+        }
+    }
+
+    connection_metadata::ptr get_metadata(int id) const {
+        con_list::const_iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            return connection_metadata::ptr();
+        } else {
+            return metadata_it->second;
+        }
+    }
+private:
+    typedef std::map<int,connection_metadata::ptr> con_list;
+
+    client m_endpoint;
+    websocketpp::lib::shared_ptr<websocketpp::lib::thread> m_thread;
+
+    con_list m_connection_list;
+    int m_next_id;
+};
+
+int main() {
+    bool done = false;
+    std::string input;
+    websocket_endpoint endpoint;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout
+                << "\nCommand List:\n"
+                << "connect <ws uri>\n"
+                << "close <connection id> [<close code:default=1000>] [<close reason>]\n"
+                << "show <connection id>\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else if (input.substr(0,7) == "connect") {
+            int id = endpoint.connect(input.substr(8));
+            if (id != -1) {
+                std::cout << "> Created connection with id " << id << std::endl;
+            }
+        } else if (input.substr(0,5) == "close") {
+            std::stringstream ss(input);
+            
+            std::string cmd;
+            int id;
+            int close_code = websocketpp::close::status::normal;
+            std::string reason = "";
+            
+            ss >> cmd >> id >> close_code;
+            std::getline(ss,reason);
+            
+            endpoint.close(id, close_code, reason);
+        }  else if (input.substr(0,4) == "show") {
+            int id = atoi(input.substr(5).c_str());
+
+            connection_metadata::ptr metadata = endpoint.get_metadata(id);
+            if (metadata) {
+                std::cout << *metadata << std::endl;
+            } else {
+                std::cout << "> Unknown connection id " << id << std::endl;
+            }
+        } else {
+            std::cout << "> Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
+
+/*
+
+clang++ -std=c++11 -stdlib=libc++ -I/Users/zaphoyd/software/websocketpp/ -I/Users/zaphoyd/software/boost_1_55_0/ -D_WEBSOCKETPP_CPP11_STL_ step4.cpp /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_system.a
+
+clang++ -I/Users/zaphoyd/software/websocketpp/ -I/Users/zaphoyd/software/boost_1_55_0/ step4.cpp /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_system.a /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_thread.a /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_random.a
+
+clang++ -std=c++11 -stdlib=libc++ -I/Users/zaphoyd/Documents/websocketpp/ -I/Users/zaphoyd/Documents/boost_1_53_0_libcpp/ -D_WEBSOCKETPP_CPP11_STL_ step4.cpp /Users/zaphoyd/Documents/boost_1_53_0_libcpp/stage/lib/libboost_system.a
+
+*/
diff --git a/extlibs/websocketpp/tutorials/utility_client/step6.cpp b/extlibs/websocketpp/tutorials/utility_client/step6.cpp
new file mode 100644
index 000000000..6cd3ef50b
--- /dev/null
+++ b/extlibs/websocketpp/tutorials/utility_client/step6.cpp
@@ -0,0 +1,335 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+// **NOTE:** This file is a snapshot of the WebSocket++ utility client tutorial.
+// Additional related material can be found in the tutorials/utility_client
+// directory of the WebSocket++ repository.
+
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+#include <websocketpp/common/thread.hpp>
+#include <websocketpp/common/memory.hpp>
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <string>
+#include <sstream>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+class connection_metadata {
+public:
+    typedef websocketpp::lib::shared_ptr<connection_metadata> ptr;
+
+    connection_metadata(int id, websocketpp::connection_hdl hdl, std::string uri)
+      : m_id(id)
+      , m_hdl(hdl)
+      , m_status("Connecting")
+      , m_uri(uri)
+      , m_server("N/A")
+    {}
+
+    void on_open(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Open";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+    }
+
+    void on_fail(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Failed";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+        m_error_reason = con->get_ec().message();
+    }
+    
+    void on_close(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Closed";
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        std::stringstream s;
+        s << "close code: " << con->get_remote_close_code() << " (" 
+          << websocketpp::close::status::get_string(con->get_remote_close_code()) 
+          << "), close reason: " << con->get_remote_close_reason();
+        m_error_reason = s.str();
+    }
+
+    void on_message(websocketpp::connection_hdl, client::message_ptr msg) {
+        if (msg->get_opcode() == websocketpp::frame::opcode::text) {
+            m_messages.push_back("<< " + msg->get_payload());
+        } else {
+            m_messages.push_back("<< " + websocketpp::utility::to_hex(msg->get_payload()));
+        }
+    }
+
+    websocketpp::connection_hdl get_hdl() const {
+        return m_hdl;
+    }
+    
+    int get_id() const {
+        return m_id;
+    }
+    
+    std::string get_status() const {
+        return m_status;
+    }
+
+    void record_sent_message(std::string message) {
+        m_messages.push_back(">> " + message);
+    }
+
+    friend std::ostream & operator<< (std::ostream & out, connection_metadata const & data);
+private:
+    int m_id;
+    websocketpp::connection_hdl m_hdl;
+    std::string m_status;
+    std::string m_uri;
+    std::string m_server;
+    std::string m_error_reason;
+    std::vector<std::string> m_messages;
+};
+
+std::ostream & operator<< (std::ostream & out, connection_metadata const & data) {
+    out << "> URI: " << data.m_uri << "\n"
+        << "> Status: " << data.m_status << "\n"
+        << "> Remote Server: " << (data.m_server.empty() ? "None Specified" : data.m_server) << "\n"
+        << "> Error/close reason: " << (data.m_error_reason.empty() ? "N/A" : data.m_error_reason) << "\n";
+    out << "> Messages Processed: (" << data.m_messages.size() << ") \n";
+
+    std::vector<std::string>::const_iterator it;
+    for (it = data.m_messages.begin(); it != data.m_messages.end(); ++it) {
+        out << *it << "\n";
+    }
+
+    return out;
+}
+
+class websocket_endpoint {
+public:
+    websocket_endpoint () : m_next_id(0) {
+        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);
+        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);
+
+        m_endpoint.init_asio();
+        m_endpoint.start_perpetual();
+
+        m_thread = websocketpp::lib::make_shared<websocketpp::lib::thread>(&client::run, &m_endpoint);
+    }
+
+    ~websocket_endpoint() {
+        m_endpoint.stop_perpetual();
+        
+        for (con_list::const_iterator it = m_connection_list.begin(); it != m_connection_list.end(); ++it) {
+            if (it->second->get_status() != "Open") {
+                // Only close open connections
+                continue;
+            }
+            
+            std::cout << "> Closing connection " << it->second->get_id() << std::endl;
+            
+            websocketpp::lib::error_code ec;
+            m_endpoint.close(it->second->get_hdl(), websocketpp::close::status::going_away, "", ec);
+            if (ec) {
+                std::cout << "> Error closing connection " << it->second->get_id() << ": "  
+                          << ec.message() << std::endl;
+            }
+        }
+        
+        m_thread->join();
+    }
+
+    int connect(std::string const & uri) {
+        websocketpp::lib::error_code ec;
+
+        client::connection_ptr con = m_endpoint.get_connection(uri, ec);
+
+        if (ec) {
+            std::cout << "> Connect initialization error: " << ec.message() << std::endl;
+            return -1;
+        }
+
+        int new_id = m_next_id++;
+        connection_metadata::ptr metadata_ptr = websocketpp::lib::make_shared<connection_metadata>(new_id, con->get_handle(), uri);
+        m_connection_list[new_id] = metadata_ptr;
+
+        con->set_open_handler(websocketpp::lib::bind(
+            &connection_metadata::on_open,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_fail_handler(websocketpp::lib::bind(
+            &connection_metadata::on_fail,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_close_handler(websocketpp::lib::bind(
+            &connection_metadata::on_close,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_message_handler(websocketpp::lib::bind(
+            &connection_metadata::on_message,
+            metadata_ptr,
+            websocketpp::lib::placeholders::_1,
+            websocketpp::lib::placeholders::_2
+        ));
+
+        m_endpoint.connect(con);
+
+        return new_id;
+    }
+
+    void close(int id, websocketpp::close::status::value code, std::string reason) {
+        websocketpp::lib::error_code ec;
+        
+        con_list::iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            std::cout << "> No connection found with id " << id << std::endl;
+            return;
+        }
+        
+        m_endpoint.close(metadata_it->second->get_hdl(), code, reason, ec);
+        if (ec) {
+            std::cout << "> Error initiating close: " << ec.message() << std::endl;
+        }
+    }
+
+    void send(int id, std::string message) {
+        websocketpp::lib::error_code ec;
+        
+        con_list::iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            std::cout << "> No connection found with id " << id << std::endl;
+            return;
+        }
+        
+        m_endpoint.send(metadata_it->second->get_hdl(), message, websocketpp::frame::opcode::text, ec);
+        if (ec) {
+            std::cout << "> Error sending message: " << ec.message() << std::endl;
+            return;
+        }
+        
+        metadata_it->second->record_sent_message(message);
+    }
+
+    connection_metadata::ptr get_metadata(int id) const {
+        con_list::const_iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            return connection_metadata::ptr();
+        } else {
+            return metadata_it->second;
+        }
+    }
+private:
+    typedef std::map<int,connection_metadata::ptr> con_list;
+
+    client m_endpoint;
+    websocketpp::lib::shared_ptr<websocketpp::lib::thread> m_thread;
+
+    con_list m_connection_list;
+    int m_next_id;
+};
+
+int main() {
+    bool done = false;
+    std::string input;
+    websocket_endpoint endpoint;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout
+                << "\nCommand List:\n"
+                << "connect <ws uri>\n"
+                << "send <connection id> <message>\n"
+                << "close <connection id> [<close code:default=1000>] [<close reason>]\n"
+                << "show <connection id>\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else if (input.substr(0,7) == "connect") {
+            int id = endpoint.connect(input.substr(8));
+            if (id != -1) {
+                std::cout << "> Created connection with id " << id << std::endl;
+            }
+        } else if (input.substr(0,4) == "send") {
+            std::stringstream ss(input);
+            
+            std::string cmd;
+            int id;
+            std::string message = "";
+            
+            ss >> cmd >> id;
+            std::getline(ss,message);
+            
+            endpoint.send(id, message);
+        } else if (input.substr(0,5) == "close") {
+            std::stringstream ss(input);
+            
+            std::string cmd;
+            int id;
+            int close_code = websocketpp::close::status::normal;
+            std::string reason = "";
+            
+            ss >> cmd >> id >> close_code;
+            std::getline(ss,reason);
+            
+            endpoint.close(id, close_code, reason);
+        } else if (input.substr(0,4) == "show") {
+            int id = atoi(input.substr(5).c_str());
+
+            connection_metadata::ptr metadata = endpoint.get_metadata(id);
+            if (metadata) {
+                std::cout << *metadata << std::endl;
+            } else {
+                std::cout << "> Unknown connection id " << id << std::endl;
+            }
+        } else {
+            std::cout << "> Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
+
+/*
+
+clang++ -std=c++11 -stdlib=libc++ -I/Users/zaphoyd/software/websocketpp/ -I/Users/zaphoyd/software/boost_1_55_0/ -D_WEBSOCKETPP_CPP11_STL_ step4.cpp /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_system.a
+
+clang++ -I/Users/zaphoyd/software/websocketpp/ -I/Users/zaphoyd/software/boost_1_55_0/ step4.cpp /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_system.a /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_thread.a /Users/zaphoyd/software/boost_1_55_0/stage/lib/libboost_random.a
+
+clang++ -std=c++11 -stdlib=libc++ -I/Users/zaphoyd/Documents/websocketpp/ -I/Users/zaphoyd/Documents/boost_1_53_0_libcpp/ -D_WEBSOCKETPP_CPP11_STL_ step4.cpp /Users/zaphoyd/Documents/boost_1_53_0_libcpp/stage/lib/libboost_system.a
+
+*/
diff --git a/extlibs/websocketpp/tutorials/utility_client/utility_client.md b/extlibs/websocketpp/tutorials/utility_client/utility_client.md
new file mode 100644
index 000000000..5490f571b
--- /dev/null
+++ b/extlibs/websocketpp/tutorials/utility_client/utility_client.md
@@ -0,0 +1,856 @@
+Utility Client Example Application
+==================================
+
+Chapter 1: Initial Setup & Basics
+---------------------------------
+
+Setting up the basic types, opening and closing connections, sending and receiving messages.
+
+### Step 1
+
+A basic program loop that prompts the user for a command and then processes it. In this tutorial we will modify this program to perform tasks and retrieve data from a remote server over a WebSocket connection.
+
+#### Build
+`clang++ step1.cpp`
+
+#### Code so far
+
+*note* A code snapshot for each step is present next to this tutorial file in the git repository.
+
+```cpp
+#include <iostream>
+#include <string>
+
+int main() {
+    bool done = false;
+    std::string input;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout
+                << "\nCommand List:\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else {
+            std::cout << "Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
+```
+
+### Step 2
+
+_Add WebSocket++ includes and set up an endpoint type._
+
+WebSocket++ includes two major object types. The endpoint and the connection. The
+endpoint creates and launches new connections and maintains default settings for
+those connections. Endpoints also manage any shared network resources.
+
+The connection stores information specific to each WebSocket session.
+
+> **Note:** Once a connection is launched, there is no link between the endpoint and the connection. All default settings are copied into the new connection by the endpoint. Changing default settings on an endpoint will only affect future connections.
+Connections do not maintain a link back to their associated endpoint. Endpoints do not maintain a list of outstanding connections. If your application needs to iterate over all connections it will need to maintain a list of them itself.
+
+WebSocket++ endpoints are built by combining an endpoint role with an endpoint config. There are two different types of endpoint roles, one each for the client and server roles in a WebSocket session. This is a client tutorial so we will use the client role `websocketpp::client` which is provided by the `<websocketpp/client.hpp>` header.
+
+> ###### Terminology: Endpoint Config
+> WebSocket++ endpoints have a group of settings that may be configured at compile time via the `config` template parameter. A config is a struct that contains types and static constants that are used to produce an endpoint with specific properties. Depending on which config is being used the endpoint will have different methods available and may have additional third party dependencies.
+
+The endpoint role takes a template parameter called `config` that is used to configure the behavior of endpoint at compile time. For this example we are going to use a default config provided by the library called `asio_client`, provided by `<websocketpp/config/asio_no_tls_client.hpp>`. This is a client config that uses boost::asio to provide network transport and does not support TLS based security. Later on we will discuss how to introduce TLS based security into a WebSocket++ application, more about the other stock configs, and how to build your own custom configs.
+
+Combine a config with an endpoint role to produce a fully configured endpoint. This type will be used frequently so I would recommend a typedef here.
+
+`typedef websocketpp::client<websocketpp::config::asio_client> client`
+
+#### Build
+Adding WebSocket++ has added a few dependencies to our program that must be addressed in the build system. Firstly, the WebSocket++ and Boost library headers must be in the include search path of your build system. How exactly this is done depends on where you have the WebSocket++ headers installed and what build system you are using.
+
+In addition to the new headers, boost::asio depends on the `boost_system` shared library. This will need to be added (either as a static or dynamic) to the linker. Refer to your build environment documentation for instructions on linking to shared libraries.
+
+`clang++ step2.cpp -lboost_system`
+
+#### Code so far
+```cpp
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+#include <iostream>
+#include <string>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+int main() {
+    bool done = false;
+    std::string input;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout
+                << "\nCommand List:\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else {
+            std::cout << "Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
+
+```
+
+### Step 3
+
+_Create endpoint wrapper object that handles initialization and setting up the background thread._
+
+In order to process user input while network processing occurs in the background we are going to use a separate thread for the WebSocket++ processing loop. This leaves the main thread free to process foreground user input. In order to enable simple RAII style resource management for our thread and endpoint we will use a wrapper object that configures them both in its constructor.
+
+> ###### Terminology: websocketpp::lib namespace
+> WebSocket++ is designed to be used with a C++11 standard library. As this is not universally available in popular build systems the Boost libraries may be used as polyfills for the C++11 standard library in C++98 build environments. The `websocketpp::lib` namespace is used by the library and its associated examples to abstract away the distinctions between the two. `websocketpp::lib::shared_ptr` will evaluate to `std::shared_ptr` in a C++11 environment and `boost::shared_ptr` otherwise.
+>
+> This tutorial uses the `websocketpp::lib` wrappers because it doesn't know what the build environment of the reader is. For your applications, unless you are interested in similar portability, are free to use the boost or std versions of these types directly.
+>
+>[TODO: link to more information about websocketpp::lib namespace and C++11 setup]
+
+Within the `websocket_endpoint` constructor several things happen:
+
+First, we set the endpoint logging behavior to silent by clearing all of the access and error logging channels. [TODO: link to more information about logging]
+```cpp
+m_endpoint.clear_access_channels(websocketpp::log::alevel::all);
+m_endpoint.clear_error_channels(websocketpp::log::elevel::all);
+```
+
+Next, we initialize the transport system underlying the endpoint and set it to perpetual mode. In perpetual mode the endpoint's processing loop will not exit automatically when it has no connections. This is important because we want this endpoint to remain active while our application is running and process requests for new WebSocket connections on demand as we need them. Both of these methods are specific to the asio transport. They will not be  necessary or present in endpoints that use a non-asio config.
+```cpp
+m_endpoint.init_asio();
+m_endpoint.start_perpetual();
+```
+
+Finally, we launch a thread to run the `run` method of our client endpoint. While the endpoint is running it will process connection tasks (read and deliver incoming messages, frame and send outgoing messages, etc). Because it is running in perpetual mode, when there are no connections active it will wait for a new connection.
+```cpp
+m_thread.reset(new websocketpp::lib::thread(&client::run, &m_endpoint));
+```
+
+#### Build
+
+Now that our client endpoint template is actually instantiated a few more linker dependencies will show up. In particular, WebSocket clients require a cryptographically secure random number generator. WebSocket++ is able to use either `boost_random` or the C++11 standard library <random> for this purpose. Because this example also uses threads, if we do not have C++11 std::thread available we will need to include `boost_thread`.
+
+##### Clang (C++98 & boost)
+`clang++ step3.cpp -lboost_system -lboost_random -lboost_thread`
+
+##### Clang (C++11)
+`clang++ -std=c++0x -stdlib=libc++ step3.cpp -lboost_system -D_WEBSOCKETPP_CPP11_STL_`
+
+##### G++ (C++98 & Boost)
+`g++ step3.cpp -lboost_system -lboost_random -lboost_thread`
+
+##### G++ v4.6+ (C++11)
+`g++ -std=c++0x step3.cpp -lboost_system -D_WEBSOCKETPP_CPP11_STL_`
+
+#### Code so far
+
+```cpp
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+#include <websocketpp/common/thread.hpp>
+#include <websocketpp/common/memory.hpp>
+
+#include <iostream>
+#include <string>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+class websocket_endpoint {
+public:
+    websocket_endpoint () {
+        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);
+        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);
+
+        m_endpoint.init_asio();
+        m_endpoint.start_perpetual();
+
+        m_thread.reset(new websocketpp::lib::thread(&client::run, &m_endpoint));
+    }
+private:
+    client m_endpoint;
+    websocketpp::lib::shared_ptr<websocketpp::lib::thread> m_thread;
+};
+
+int main() {
+    bool done = false;
+    std::string input;
+    websocket_endpoint endpoint;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout
+                << "\nCommand List:\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else {
+            std::cout << "Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
+```
+
+### Step 4
+
+_Opening WebSocket connections_
+
+This step adds two new commands to utility_client. The ability to open a new connection and the ability to view information about a previously opened connection. Every connection that gets opened will be assigned an integer connection id that the user of the program can use to interact with that connection.
+
+#### New Connection Metadata Object
+
+In order to track information about each connection a `connection_metadata` object is defined. This object stores the numeric connection id and a number of fields that will be filled in as the connection is processed. Initially this includes the state of the connection (opening, open, failed, closed, etc), the original URI connected to, an identifying value from the server, and a description of the reason for connection failure/closure. Future steps will add more information to this metadata object.
+
+#### Update `websocket_endpoint`
+
+The `websocket_endpoint` object has gained some new data members and methods. It now tracks a mapping between connection IDs and their associated metadata as well as the next sequential ID number to hand out. The `connect()` method initiates a new connection. The `get_metadata` method retrieves metadata given an ID.
+
+#### The connect method
+A new WebSocket connection is initiated via a three step process. First, a connection request is created by `endpoint::get_connection(uri)`. Next, the connection request is configured. Lastly, the connection request is submitted back to the endpoint via `endpoint::connect()` which adds it to the queue of new connections to make.
+
+> ###### Terminology `connection_ptr`
+> WebSocket++ keeps track of connection related resources using a reference counted shared pointer. The type of this pointer is `endpoint::connection_ptr`. A `connection_ptr` allows direct access to information about the connection and allows changing connection settings. Because of this direct access and their internal resource management role within the library it is not safe to for end applications to use `connection_ptr` except in the specific circumstances detailed below.
+>
+> **When is it safe to use `connection_ptr`?**
+> - After `endpoint::get_connection(...)` and before `endpoint::connect()`: `get_connection` returns a `connection_ptr`. It is safe to use this pointer to configure your new connection. Once you submit the connection to `connect` you may no longer use the `connection_ptr` and should discard it immediately for optimal memory management.
+> - During a handler: WebSocket++ allows you to register hooks / callbacks / event handlers for specific events that happen during a connection's lifetime. During the invocation of one of these handlers the library guarantees that it is safe to use a `connection_ptr` for the connection associated with the currently running handler.
+
+> ###### Terminology `connection_hdl`
+> Because of the limited thread safety of the `connection_ptr` the library also provides a more flexible connection identifier, the `connection_hdl`. The `connection_hdl` has type `websocketpp::connection_hdl` and it is defined in `<websocketpp/common/connection_hdl.hpp>`. Note that unlike `connection_ptr` this is not dependent on the type or config of the endpoint. Code that simply stores or transmits `connection_hdl` but does not use them can include only the header above and can treat its hdls like values.
+>
+> Connection handles are not used directly. They are used by endpoint methods to identify the target of the desired action. For example, the endpoint method that sends a new message will take as a parameter the hdl of the connection to send the message to.
+>
+> **When is it safe to use `connection_hdl`?**
+> `connection_hdl`s may be used at any time from any thread. They may be copied and stored in containers. Deleting a hdl will not affect the connection in any way. Handles may be upgraded to a `connection_ptr` during a handler call by using `endpoint::get_con_from_hdl()`. The resulting `connection_ptr` is safe to use for the duration of that handler invocation.
+>
+> **`connection_hdl` FAQs**
+> - `connection_hdl`s are guaranteed to be unique within a program. Multiple endpoints in a single program will always create connections with unique handles.
+> - Using a `connection_hdl` with a different endpoint than the one that created its associated connection will result in undefined behavior.
+> - Using a `connection_hdl` whose associated connection has been closed or deleted is safe. The endpoint will return a specific error saying the operation couldn't be completed because the associated connection doesn't exist.
+> [TODO: more here? link to a connection_hdl FAQ elsewhere?]
+
+`websocket_endpoint::connect()` begins by calling `endpoint::get_connection()` using a uri passed as a parameter. Additionally, an error output value is passed to capture any errors that might occur during. If an error does occur an error notice is printed along with a descriptive message and the -1 / 'invalid' value is returned as the new ID.
+
+> ###### Terminology: `error handling: exceptions vs error_code`
+> WebSocket++ uses the error code system defined by the C++11 `<system_error>` library. It can optionally fall back to a similar system provided by the Boost libraries. All user facing endpoint methods that can fail take an `error_code` in an output parameter and store the error that occured there before returning. An empty/default constructed value is returned in the case of success.
+>
+> **Exception throwing varients**
+> All user facing endpoint methods that take and use an `error_code` parameter have a version that throws an exception instead. These methods are identical in function and signature except for the lack of the final ec parameter. The type of the exception thrown is `websocketpp::exception`. This type derives from `std::exception` so it can be caught by catch blocks grabbing generic `std::exception`s. The `websocketpp::exception::code()` method may be used to extract the machine readable `error_code` value from an exception.
+>
+> For clarity about error handling the utility_client example uses exclusively the exception free varients of these methods. Your application may choose to use either.
+
+If connection creation succeeds, the next sequential connection ID is generated and a `connection_metadata` object is inserted into the connection list under that ID. Initially the metadata object stores the connection ID, the `connection_hdl`, and the URI the connection was opened to.
+
+```cpp
+int new_id = m_next_id++;
+metadata_ptr metadata(new connection_metadata(new_id, con->get_handle(), uri));
+m_connection_list[new_id] = metadata;
+```
+
+Next, the connection request is configured. For this step the only configuration we will do is setting up a few default handlers. Later on we will return and demonstrate some more detailed configuration that can happen here (setting user agents, origin, proxies, custom headers, subprotocols, etc).
+
+> ###### Terminology: Registering handlers
+> WebSocket++ provides a number of execution points where you can register to have a handler run. Which of these points are available to your endpoint will depend on its config. TLS handlers will not exist on non-TLS endpoints for example. A complete list of handlers can be found at  http://www.zaphoyd.com/websocketpp/manual/reference/handler-list.
+>
+> Handlers can be registered at the endpoint level and at the connection level. Endpoint handlers are copied into new connections as they are created. Changing an endpoint handler will affect only future connections. Handlers registered at the connection level will be bound to that specific connection only.
+>
+> The signature of handler binding methods is the same for endpoints and connections. The format is: `set_*_handler(...)`. Where * is the name of the handler. For example, `set_open_handler(...)` will set the handler to be called when a new connection is open. `set_fail_handler(...)` will set the handler to be called when a connection fails to connect.
+>
+> All handlers take one argument, a callable type that can be converted to a `std::function` with the correct count and type of arguments. You can pass free functions, functors, and Lambdas with matching argument lists as handlers. In addition, you can use `std::bind` (or `boost::bind`) to register functions with non-matching argument lists. This is useful for passing additional parameters not present in the handler signature or member functions that need to carry a 'this' pointer.
+>
+> The function signature of each handler can be looked up in the list above in the manual. In general, all handlers include the `connection_hdl` identifying which connection this even is associated with as the first parameter. Some handlers (such as the message handler) include additional parameters. Most handlers have a void return value but some (`validate`, `ping`, `tls_init`) do not. The specific meanings of the return values are documented in the handler list linked above.
+
+`utility_client` registers an open and a fail handler. We will use these to track whether each connection was successfully opened or failed. If it successfully opens, we will gather some information from the opening handshake and store it with our connection metadata.
+
+In this example we are going to set connection specific handlers that are bound directly to the metadata object associated with our connection. This allows us to avoid performing a lookup in each handler to find the metadata object we plan to update which is a bit more efficient.
+
+Lets look at the parameters being sent to bind in detail:
+
+```cpp
+con->set_open_handler(websocketpp::lib::bind(
+    &connection_metadata::on_open,
+    metadata,
+    &m_endpoint,
+    websocketpp::lib::placeholders::_1
+));
+```
+
+`&connection_metadata::on_open` is the address of the `on_open` member function of the `connection_metadata` class. `metadata_ptr` is a pointer to the `connection_metadata` object associated with this class. It will be used as the object on which the `on_open` member function will be called. `&m_endpoint` is the address of the endpoint in use. This parameter will be passed as-is to the `on_open` method. Lastly, `websocketpp::lib::placeholders::_1` is a placeholder indicating that the bound function should take one additional argument to be filled in at a later time. WebSocket++ will fill in this placeholder with the `connection_hdl` when it invokes the handler.
+
+Finally, we call `endpoint::connect()` on our configured connection request and return the new connection ID.
+
+#### Handler Member Functions
+
+The open handler we registered, `connection_metadata::on_open`, sets the status metadata field to "Open" and retrieves the value of the "Server" header from the remote endpoint's HTTP response and stores it in the metadata object. Servers often set an identifying string in this header.
+
+The fail handler we registered, `connection_metadata::on_fail`, sets the status metadata field to "Failed", the server field similarly to `on_open`, and retrieves the error code describing why the connection failed. The human readable message associated with that error code is saved to the metadata object.
+
+#### New Commands
+
+Two new commands have been set up. "connect [uri]" will pass the URI to the `websocket_endpoint` connect method and report an error or the connection ID of the new connection. "show [connection id]" will retrieve and print out the metadata associated with that connection. The help text has been updated accordingly.
+
+```cpp
+} else if (input.substr(0,7) == "connect") {
+    int id = endpoint.connect(input.substr(8));
+    if (id != -1) {
+        std::cout << "> Created connection with id " << id << std::endl;
+    }
+} else if (input.substr(0,4) == "show") {
+    int id = atoi(input.substr(5).c_str());
+
+    connection_metadata::ptr metadata = endpoint.get_metadata(id);
+    if (metadata) {
+        std::cout << *metadata << std::endl;
+    } else {
+        std::cout << "> Unknown connection id " << id << std::endl;
+    }
+}
+```
+
+#### Build
+
+There are no changes to the build instructions from step 3
+
+#### Run
+
+```
+Enter Command: connect not a websocket uri
+> Connect initialization error: invalid uri
+Enter Command: show 0
+> Unknown connection id 0
+Enter Command: connect ws://echo.websocket.org
+> Created connection with id 0
+Enter Command: show 0
+> URI: ws://echo.websocket.org
+> Status: Open
+> Remote Server: Kaazing Gateway
+> Error/close reason: N/A
+Enter Command: connect ws://wikipedia.org
+> Created connection with id 1
+Enter Command: show 1
+> URI: ws://wikipedia.org
+> Status: Failed
+> Remote Server: Apache
+> Error/close reason: Invalid HTTP status.
+```
+
+#### Code so far
+
+```cpp
+#include <websocketpp/config/asio_no_tls_client.hpp>
+#include <websocketpp/client.hpp>
+
+#include <websocketpp/common/thread.hpp>
+#include <websocketpp/common/memory.hpp>
+
+#include <cstdlib>
+#include <iostream>
+#include <map>
+#include <string>
+#include <sstream>
+
+typedef websocketpp::client<websocketpp::config::asio_client> client;
+
+class connection_metadata {
+public:
+    typedef websocketpp::lib::shared_ptr<connection_metadata> ptr;
+
+    connection_metadata(int id, websocketpp::connection_hdl hdl, std::string uri)
+      : m_id(id)
+      , m_hdl(hdl)
+      , m_status("Connecting")
+      , m_uri(uri)
+      , m_server("N/A")
+    {}
+
+    void on_open(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Open";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+    }
+
+    void on_fail(client * c, websocketpp::connection_hdl hdl) {
+        m_status = "Failed";
+
+        client::connection_ptr con = c->get_con_from_hdl(hdl);
+        m_server = con->get_response_header("Server");
+        m_error_reason = con->get_ec().message();
+    }
+
+    friend std::ostream & operator<< (std::ostream & out, connection_metadata const & data);
+private:
+    int m_id;
+    websocketpp::connection_hdl m_hdl;
+    std::string m_status;
+    std::string m_uri;
+    std::string m_server;
+    std::string m_error_reason;
+};
+
+std::ostream & operator<< (std::ostream & out, connection_metadata const & data) {
+    out << "> URI: " << data.m_uri << "\n"
+        << "> Status: " << data.m_status << "\n"
+        << "> Remote Server: " << (data.m_server.empty() ? "None Specified" : data.m_server) << "\n"
+        << "> Error/close reason: " << (data.m_error_reason.empty() ? "N/A" : data.m_error_reason);
+
+    return out;
+}
+
+class websocket_endpoint {
+public:
+    websocket_endpoint () : m_next_id(0) {
+        m_endpoint.clear_access_channels(websocketpp::log::alevel::all);
+        m_endpoint.clear_error_channels(websocketpp::log::elevel::all);
+
+        m_endpoint.init_asio();
+        m_endpoint.start_perpetual();
+
+        m_thread.reset(new websocketpp::lib::thread(&client::run, &m_endpoint));
+    }
+
+    int connect(std::string const & uri) {
+        websocketpp::lib::error_code ec;
+
+        client::connection_ptr con = m_endpoint.get_connection(uri, ec);
+
+        if (ec) {
+            std::cout << "> Connect initialization error: " << ec.message() << std::endl;
+            return -1;
+        }
+
+        int new_id = m_next_id++;
+        connection_metadata::ptr metadata_ptr(new connection_metadata(new_id, con->get_handle(), uri));
+        m_connection_list[new_id] = metadata_ptr;
+
+        con->set_open_handler(websocketpp::lib::bind(
+            &connection_metadata::on_open,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+        con->set_fail_handler(websocketpp::lib::bind(
+            &connection_metadata::on_fail,
+            metadata_ptr,
+            &m_endpoint,
+            websocketpp::lib::placeholders::_1
+        ));
+
+        m_endpoint.connect(con);
+
+        return new_id;
+    }
+
+    connection_metadata::ptr get_metadata(int id) const {
+        con_list::const_iterator metadata_it = m_connection_list.find(id);
+        if (metadata_it == m_connection_list.end()) {
+            return connection_metadata::ptr();
+        } else {
+            return metadata_it->second;
+        }
+    }
+private:
+    typedef std::map<int,connection_metadata::ptr> con_list;
+
+    client m_endpoint;
+    websocketpp::lib::shared_ptr<websocketpp::lib::thread> m_thread;
+
+    con_list m_connection_list;
+    int m_next_id;
+};
+
+int main() {
+    bool done = false;
+    std::string input;
+    websocket_endpoint endpoint;
+
+    while (!done) {
+        std::cout << "Enter Command: ";
+        std::getline(std::cin, input);
+
+        if (input == "quit") {
+            done = true;
+        } else if (input == "help") {
+            std::cout
+                << "\nCommand List:\n"
+                << "connect <ws uri>\n"
+                << "show <connection id>\n"
+                << "help: Display this help text\n"
+                << "quit: Exit the program\n"
+                << std::endl;
+        } else if (input.substr(0,7) == "connect") {
+            int id = endpoint.connect(input.substr(8));
+            if (id != -1) {
+                std::cout << "> Created connection with id " << id << std::endl;
+            }
+        } else if (input.substr(0,4) == "show") {
+            int id = atoi(input.substr(5).c_str());
+
+            connection_metadata::ptr metadata = endpoint.get_metadata(id);
+            if (metadata) {
+                std::cout << *metadata << std::endl;
+            } else {
+                std::cout << "> Unknown connection id " << id << std::endl;
+            }
+        } else {
+            std::cout << "> Unrecognized Command" << std::endl;
+        }
+    }
+
+    return 0;
+}
+```
+
+### Step 5
+
+_Closing connections_
+
+This step adds a command that allows you to close a WebSocket connection and adjusts the quit command so that it cleanly closes all outstanding connections before quitting.
+
+#### Getting connection close information out of WebSocket++
+
+> ###### Terminology: WebSocket close codes & reasons
+> The WebSocket close handshake involves an exchange of optional machine readable close codes and human readable reason strings. Each endpoint sends independent close details. The codes are short integers. The reasons are UTF8 text strings of at most 125 characters. More details about valid close code ranges and the meaning of each code can be found at https://tools.ietf.org/html/rfc6455#section-7.4
+
+The `websocketpp::close::status` namespace contains named constants for all of the IANA defined close codes. It also includes free functions to determine whether a value is reserved or invalid and to convert a code to a human readable text representation.
+
+During the close handler call WebSocket++ connections offer the following methods for accessing close handshake information:
+
+- `connection::get_remote_close_code()`: Get the close code as reported by the remote endpoint
+- `connection::get_remote_close_reason()`: Get the close reason as reported by the remote endpoint
+- `connection::get_local_close_code()`: Get the close code that this endpoint sent.
+- `connection::get_local_close_reason()`: Get the close reason that this endpoint sent.
+- `connection::get_ec()`: Get a more detailed/specific WebSocket++ `error_code` indicating what library error (if any) ultimately resulted in the connection closure.
+
+*Note:* there are some special close codes that will report a code that was not actually sent on the wire. For example 1005/"no close code" indicates that the endpoint omitted a close code entirely and 1006/"abnormal close" indicates that there was a problem that resulted in the connection closing without having performed a close handshake.
+
+#### Add close handler
+
+The `connection_metadata::on_close` method is added. This method retrieves the close code and reason from the closing handshake and stores it in the local error reason field.
+
+```cpp
+void on_close(client * c, websocketpp::connection_hdl hdl) {
+    m_status = "Closed";
+    client::connection_ptr con = c->get_con_from_hdl(hdl);
+    std::stringstream s;
+    s << "close code: " << con->get_remote_close_code() << " (" 
+      << websocketpp::close::status::get_string(con->get_remote_close_code()) 
+      << "), close reason: " << con->get_remote_close_reason();
+    m_error_reason = s.str();
+}
+```
+
+Similarly to `on_open` and `on_fail`, `websocket_endpoint::connect` registers this close handler when a new connection is made.
+
+#### Add close method to `websocket_endpoint`
+
+This method starts by looking up the given connection ID in the connection list.  Next a close request is sent to the connection's handle with the specified WebSocket close code. This is done by calling `endpoint::close`. This is a thread safe method that is used to asynchronously dispatch a close signal to the connection with the given handle. When the operation is complete the connection's close handler will be triggered.
+
+```cpp
+void close(int id, websocketpp::close::status::value code) {
+    websocketpp::lib::error_code ec;
+    
+    con_list::iterator metadata_it = m_connection_list.find(id);
+    if (metadata_it == m_connection_list.end()) {
+        std::cout << "> No connection found with id " << id << std::endl;
+        return;
+    }
+    
+    m_endpoint.close(metadata_it->second->get_hdl(), code, "", ec);
+    if (ec) {
+        std::cout << "> Error initiating close: " << ec.message() << std::endl;
+    }
+}
+```
+
+#### Add close option to the command loop and help message
+
+A close option is added to the command loop. It takes a connection ID and optionally a close code and a close reason. If no code is specified the default of 1000/Normal is used. If no reason is specified, none is sent. The `endpoint::close` method will do some error checking and abort the close request if you try and send an invalid code or a reason with invalid UTF8 formatting. Reason strings longer than 125 characters will be truncated.
+
+An entry is also added to the help system to describe how the new command may be used.
+
+```cpp
+else if (input.substr(0,5) == "close") {
+    std::stringstream ss(input);
+    
+    std::string cmd;
+    int id;
+    int close_code = websocketpp::close::status::normal;
+    std::string reason = "";
+    
+    ss >> cmd >> id >> close_code;
+    std::getline(ss,reason);
+    
+    endpoint.close(id, close_code, reason);
+}
+```
+
+#### Close all outstanding connections in `websocket_endpoint` destructor
+
+Until now quitting the program left outstanding connections and the WebSocket++ network thread in a lurch. Now that we have a method of closing connections we can clean this up properly.
+
+The destructor for `websocket_endpoint` now stops perpetual mode (so the run thread exits after the last connection is closed) and iterates through the list of open connections and requests a clean close for each. Finally, the run thread is joined which causes the program to wait until those connection closes complete.
+
+```cpp
+~websocket_endpoint() {
+    m_endpoint.stop_perpetual();
+    
+    for (con_list::const_iterator it = m_connection_list.begin(); it != m_connection_list.end(); ++it) {
+        if (it->second->get_status() != "Open") {
+            // Only close open connections
+            continue;
+        }
+        
+        std::cout << "> Closing connection " << it->second->get_id() << std::endl;
+        
+        websocketpp::lib::error_code ec;
+        m_endpoint.close(it->second->get_hdl(), websocketpp::close::status::going_away, "", ec);
+        if (ec) {
+            std::cout << "> Error closing connection " << it->second->get_id() << ": "  
+                      << ec.message() << std::endl;
+        }
+    }
+    
+    m_thread->join();
+}
+```
+
+#### Build
+
+There are no changes to the build instructions from step 4
+
+#### Run
+
+```
+Enter Command: connect ws://localhost:9002
+> Created connection with id 0
+Enter Command: close 0 1001 example message
+Enter Command: show 0
+> URI: ws://localhost:9002
+> Status: Closed
+> Remote Server: WebSocket++/0.4.0
+> Error/close reason: close code: 1001 (Going away), close reason:  example message
+Enter Command: connect ws://localhost:9002
+> Created connection with id 1
+Enter Command: close 1 1006
+> Error initiating close: Invalid close code used
+Enter Command: quit
+> Closing connection 1
+```
+
+### Step 6
+
+_Sending and receiving messages_
+
+This step adds a command to send a message on a given connection and updates the show command to print a transcript of all sent and received messages for that connection.
+
+> ###### Terminology: WebSocket message types (opcodes)
+> WebSocket messages have types indicated by their opcode. The protocol currently specifies two different opcodes for data messages, text and binary. Text messages represent UTF8 text and will be validated as such. Binary messages represent raw binary bytes and are passed through directly with no validation. 
+>
+> WebSocket++ provides the values `websocketpp::frame::opcode::text` and `websocketpp::frame::opcode::binary` that can be used to direct how outgoing messages should be sent and to check how incoming messages are formatted.
+
+#### Sending Messages
+
+Messages are sent using `endpoint::send`. This is a thread safe method that may be called from anywhere to queue a message for sending on the specified connection. There are three send overloads for use with different scenarios. 
+
+Each method takes a `connection_hdl` to indicate which connection to send the message on as well as a `frame::opcode::value` to indicate which opcode to label the message as. All overloads are also available with an exception free varient that fills in a a status/error code instead of throwing.
+
+The first overload, `connection_hdl hdl, std::string const & payload, frame::opcode::value op`, takes a `std::string`. The string contents are copied into an internal buffer and can be safely modified after calling send.
+
+The second overload, `connection_hdl hdl, void const * payload, size_t len, frame::opcode::value op`, takes a void * buffer and length. The buffer contents are copied and can be safely modified after calling send.
+
+The third overload, `connection_hdl hdl, message_ptr msg`, takes a WebSocket++ `message_ptr`. This overload allows a message to be constructed in place before the call to send. It also may allow a single message buffer to be sent multiple times, including to multiple connections, without copying. Whether or not this actually happens depends on other factors such as whether compression is enabled. The contents of the message buffer may not be safely modified after being sent.
+
+> ###### Terminology: Outgoing WebSocket message queueing & flow control
+> In many configurations, such as when the Asio based transport is in use, WebSocket++ is an asynchronous system. As such the `endpoint::send` method may return before any bytes are actually written to the outgoing socket. In cases where send is called multiple times in quick succession messages may be coalesced and sent in the same operation or even the same TCP packet. When this happens the message boundaries are preserved (each call to send will produce a separate message).
+>
+> In the case of applications that call send from inside a handler this means that no messages will be written to the socket until that handler returns. If you are planning to send many messages in this manor or need a message to be written on the wire before continuing you should look into using multiple threads or the built in timer/interrupt handler functionality.
+>
+> If the outgoing socket link is slow messages may build up in this queue. You can use `connection::get_buffered_amount` to query the current size of the written message queue to decide if you want to change your sending behavior.
+
+#### Add send method to `websocket_endpoint`
+
+Like the close method, send will start by looking up the given connection ID in the connection list.  Next a send request is sent to the connection's handle with the specified WebSocket message and the text opcode. Finally, we record the sent message with our connection metadata object so later our show connection command can print a list of messages sent.
+
+```cpp
+void send(int id, std::string message) {
+    websocketpp::lib::error_code ec;
+    
+    con_list::iterator metadata_it = m_connection_list.find(id);
+    if (metadata_it == m_connection_list.end()) {
+        std::cout << "> No connection found with id " << id << std::endl;
+        return;
+    }
+    
+    m_endpoint.send(metadata_it->second->get_hdl(), message, websocketpp::frame::opcode::text, ec);
+    if (ec) {
+        std::cout << "> Error sending message: " << ec.message() << std::endl;
+        return;
+    }
+    
+    metadata_it->second->record_sent_message(message);
+}
+```
+
+#### Add send option to the command loop and help message
+
+A send option is added to the command loop. It takes a connection ID and a text message to send. An entry is also added to the help system to describe how the new command may be used.
+
+```cpp
+else if (input.substr(0,4) == "send") {
+    std::stringstream ss(input);
+        
+        std::string cmd;
+        int id;
+        std::string message = "";
+        
+        ss >> cmd >> id;
+        std::getline(ss,message);
+        
+        endpoint.send(id, message);
+}
+```
+
+#### Add glue to `connection_metadata` for storing sent messages
+
+In order to store messages sent on this connection some code is added to `connection_metadata`. This includes a new data member `std::vector<std::string> m_messages` to keep track of all messages sent and received as well as a method for adding a sent message in that list:
+
+```cpp
+void record_sent_message(std::string message) {
+    m_messages.push_back(">> " + message);
+}
+```
+
+Finally the connection metadata output operator is updated to also print a list of processed messages:
+
+```cpp
+out << "> Messages Processed: (" << data.m_messages.size() << ") \n";
+
+std::vector<std::string>::const_iterator it;
+for (it = data.m_messages.begin(); it != data.m_messages.end(); ++it) {
+    out << *it << "\n";
+}
+```
+
+#### Receiving Messages
+
+Messages are received by registering a message handler. This handler will be called once per message received and its signature is `void on_message(websocketpp::connection_hdl hdl, endpoint::message_ptr msg)`. The `connection_hdl`, like the similar parameter from the other handlers is a handle for the connection that the message was received on. The `message_ptr` is a pointer to an object that can be queried for the message payload, opcode, and other metadata. Note that the message_ptr type, as well as its underlying message type, is dependent on how your endpoint is configured and may be different for different configs.
+
+#### Add a message handler to method to `connection_metadata`
+
+The message receiving behave that we are implementing will be to collect all messages sent and received and to print them in order when the show connection command is run. The sent messages are already being added to that list. Now we add a message handler that pushes received messages to the list as well. Text messages are pushed as-is. Binary messages are first converted to printable hexadecimal format.
+
+```cpp
+void on_message(websocketpp::connection_hdl hdl, client::message_ptr msg) {
+    if (msg->get_opcode() == websocketpp::frame::opcode::text) {
+        m_messages.push_back(msg->get_payload());
+    } else {
+        m_messages.push_back(websocketpp::utility::to_hex(msg->get_payload()));
+    }
+}
+```
+
+In order to have this handler called when new messages are received we also register it with our connection. Note that unlike most other handlers, the message handler has two parameters and thus needs two placeholders.
+
+```cpp
+con->set_message_handler(websocketpp::lib::bind(
+    &connection_metadata::on_message,
+    metadata_ptr,
+    websocketpp::lib::placeholders::_1,
+    websocketpp::lib::placeholders::_2
+));
+```
+
+#### Build
+
+There are no changes to the build instructions from step 5
+
+#### Run
+
+In this example run we are connecting to the WebSocket++ example echo_server. This server will repeat any message we send back to it. You can also try testing this with the echo server at `ws://echo.websocket.org` with similar results.
+
+```
+Enter Command: connect ws://localhost:9002
+> Created connection with id 0
+Enter Command: send 0 example message
+Enter Command: show 0
+> URI: ws://localhost:9002
+> Status: Open
+> Remote Server: WebSocket++/0.4.0
+> Error/close reason: N/A
+> Messages Processed: (2)
+>>  example message
+<<  example message
+```
+
+### Step 7
+
+_Using TLS / Secure WebSockets_
+
+Chapter 2: Intermediate Features
+--------------------------------
+
+### Step 8
+
+_Intermediate level features_
+
+- Subprotocol negotiation
+- Setting and reading custom headers
+- Ping and Pong
+- Proxies?
+- Setting user agent
+- Setting Origin
+- Timers and security
+- Close behavior
+- Send one message to all connections
+
+
+### Misc stuff not sure if it should be included here or elsewhere?
+
+core websocket++ control flow.
+A handshake, followed by a split into 2 independent control strands
+- Handshake
+-- use information specified before the call to endpoint::connect to construct a WebSocket handshake request.
+-- Pass the WebSocket handshake request to the transport policy. The transport policy determines how to get these bytes to the endpoint playing the server role. Depending on which transport policy your endpoint uses this method will be different.
+-- Receive a handshake response from the underlying transport. This is parsed and checked for conformance to RFC6455. If the validation fails, the fail handler is called. Otherwise the open handler is called.
+- At this point control splits into two separate strands. One that reads new bytes from the transport policy on the incoming channle, the other that accepts new messages from the local application for framing and writing to the outgoing transport channel.
+- Read strand
+-- Read and process new bytes from transport
+-- If the bytes contain at least one complete message dispatch each message by calling the appropriate handler. This is either the message handler for data messages, or ping/pong/close handlers for each respective control message. If no handler is registered for a particular message it is ignored.
+-- Ask the transport layer for more bytes
+- Write strand
+-- Wait for messages from the application
+-- Perform error checking on message input,
+-- Frame message per RFC6455
+-- Queue message for sending
+-- Pass all outstanding messages to the transport policy for output
+-- When there are no messages left to send, return to waiting
+
+Important observations
+Handlers run in line with library processing which has several implications applications should be aware of:
diff --git a/extlibs/websocketpp/websocketpp-config.cmake.in b/extlibs/websocketpp/websocketpp-config.cmake.in
new file mode 100644
index 000000000..6afe569ea
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp-config.cmake.in
@@ -0,0 +1,7 @@
+# - Config file for the websocketpp package
+# It defines the following variables
+#  WEBSOCKETPP_FOUND - indicates that the module was found
+#  WEBSOCKETPP_INCLUDE_DIR - include directories
+
+set(WEBSOCKETPP_FOUND TRUE)
+set(WEBSOCKETPP_INCLUDE_DIR "@INSTALL_INCLUDE_DIR@")
diff --git a/extlibs/websocketpp/websocketpp-configVersion.cmake.in b/extlibs/websocketpp/websocketpp-configVersion.cmake.in
new file mode 100644
index 000000000..21f68656f
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp-configVersion.cmake.in
@@ -0,0 +1,11 @@
+set(PACKAGE_VERSION "@WEBSOCKETPP_VERSION@")
+
+# Check whether the requested PACKAGE_FIND_VERSION is compatible
+if("${PACKAGE_VERSION}" VERSION_LESS "${PACKAGE_FIND_VERSION}")
+  set(PACKAGE_VERSION_COMPATIBLE FALSE)
+else()
+  set(PACKAGE_VERSION_COMPATIBLE TRUE)
+  if ("${PACKAGE_VERSION}" VERSION_EQUAL "${PACKAGE_FIND_VERSION}")
+    set(PACKAGE_VERSION_EXACT TRUE)
+  endif()
+endif()
diff --git a/extlibs/websocketpp/websocketpp/CMakeLists.txt b/extlibs/websocketpp/websocketpp/CMakeLists.txt
new file mode 100644
index 000000000..3ea8cc1c4
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/CMakeLists.txt
@@ -0,0 +1,2 @@
+init_target("websocketpp")
+final_target ()
diff --git a/extlibs/websocketpp/websocketpp/base64/base64.hpp b/extlibs/websocketpp/websocketpp/base64/base64.hpp
new file mode 100644
index 000000000..ff1561d1c
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/base64/base64.hpp
@@ -0,0 +1,178 @@
+/*
+    ******
+    base64.hpp is a repackaging of the base64.cpp and base64.h files into a
+    single header suitable for use as a header only library. This conversion was
+    done by Peter Thorson (webmaster@zaphoyd.com) in 2012. All modifications to
+    the code are redistributed under the same license as the original, which is
+    listed below.
+    ******
+
+   base64.cpp and base64.h
+
+   Copyright (C) 2004-2008 René Nyffenegger
+
+   This source code is provided 'as-is', without any express or implied
+   warranty. In no event will the author be held liable for any damages
+   arising from the use of this software.
+
+   Permission is granted to anyone to use this software for any purpose,
+   including commercial applications, and to alter it and redistribute it
+   freely, subject to the following restrictions:
+
+   1. The origin of this source code must not be misrepresented; you must not
+      claim that you wrote the original source code. If you use this source code
+      in a product, an acknowledgment in the product documentation would be
+      appreciated but is not required.
+
+   2. Altered source versions must be plainly marked as such, and must not be
+      misrepresented as being the original source code.
+
+   3. This notice may not be removed or altered from any source distribution.
+
+   René Nyffenegger rene.nyffenegger@adp-gmbh.ch
+
+*/
+
+#ifndef _BASE64_HPP_
+#define _BASE64_HPP_
+
+#include <string>
+
+namespace websocketpp {
+
+static std::string const base64_chars =
+             "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+             "abcdefghijklmnopqrstuvwxyz"
+             "0123456789+/";
+
+/// Test whether a character is a valid base64 character
+/**
+ * @param c The character to test
+ * @return true if c is a valid base64 character
+ */
+static inline bool is_base64(unsigned char c) {
+    return (c == 43 || // +
+           (c >= 47 && c <= 57) || // /-9
+           (c >= 65 && c <= 90) || // A-Z
+           (c >= 97 && c <= 122)); // a-z
+}
+
+/// Encode a char buffer into a base64 string
+/**
+ * @param input The input data
+ * @param len The length of input in bytes
+ * @return A base64 encoded string representing input
+ */
+inline std::string base64_encode(unsigned char const * input, size_t len) {
+    std::string ret;
+    int i = 0;
+    int j = 0;
+    unsigned char char_array_3[3];
+    unsigned char char_array_4[4];
+
+    while (len--) {
+        char_array_3[i++] = *(input++);
+        if (i == 3) {
+            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) +
+                              ((char_array_3[1] & 0xf0) >> 4);
+            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) +
+                              ((char_array_3[2] & 0xc0) >> 6);
+            char_array_4[3] = char_array_3[2] & 0x3f;
+
+            for(i = 0; (i <4) ; i++) {
+                ret += base64_chars[char_array_4[i]];
+            }
+            i = 0;
+        }
+    }
+
+    if (i) {
+        for(j = i; j < 3; j++) {
+            char_array_3[j] = '\0';
+        }
+
+        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+        char_array_4[1] = ((char_array_3[0] & 0x03) << 4) +
+                          ((char_array_3[1] & 0xf0) >> 4);
+        char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) +
+                          ((char_array_3[2] & 0xc0) >> 6);
+        char_array_4[3] = char_array_3[2] & 0x3f;
+
+        for (j = 0; (j < i + 1); j++) {
+            ret += base64_chars[char_array_4[j]];
+        }
+
+        while((i++ < 3)) {
+            ret += '=';
+        }
+    }
+
+    return ret;
+}
+
+/// Encode a string into a base64 string
+/**
+ * @param input The input data
+ * @return A base64 encoded string representing input
+ */
+inline std::string base64_encode(std::string const & input) {
+    return base64_encode(
+        reinterpret_cast<const unsigned char *>(input.data()),
+        input.size()
+    );
+}
+
+/// Decode a base64 encoded string into a string of raw bytes
+/**
+ * @param input The base64 encoded input data
+ * @return A string representing the decoded raw bytes
+ */
+inline std::string base64_decode(std::string const & input) {
+    size_t in_len = input.size();
+    int i = 0;
+    int j = 0;
+    int in_ = 0;
+    unsigned char char_array_4[4], char_array_3[3];
+    std::string ret;
+
+    while (in_len-- && ( input[in_] != '=') && is_base64(input[in_])) {
+        char_array_4[i++] = input[in_]; in_++;
+        if (i ==4) {
+            for (i = 0; i <4; i++) {
+                char_array_4[i] = static_cast<unsigned char>(base64_chars.find(char_array_4[i]));
+            }
+
+            char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
+
+            for (i = 0; (i < 3); i++) {
+                ret += char_array_3[i];
+            }
+            i = 0;
+        }
+    }
+
+    if (i) {
+        for (j = i; j <4; j++)
+            char_array_4[j] = 0;
+
+        for (j = 0; j <4; j++)
+            char_array_4[j] = static_cast<unsigned char>(base64_chars.find(char_array_4[j]));
+
+        char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+        char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
+
+        for (j = 0; (j < i - 1); j++) {
+            ret += static_cast<std::string::value_type>(char_array_3[j]);
+        }
+    }
+
+    return ret;
+}
+
+} // namespace websocketpp
+
+#endif // _BASE64_HPP_
diff --git a/extlibs/websocketpp/websocketpp/client.hpp b/extlibs/websocketpp/websocketpp/client.hpp
new file mode 100644
index 000000000..8782d7e4a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/client.hpp
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CLIENT_HPP
+#define WEBSOCKETPP_CLIENT_HPP
+
+#include <websocketpp/roles/client_endpoint.hpp>
+
+#endif //WEBSOCKETPP_CLIENT_HPP
diff --git a/extlibs/websocketpp/websocketpp/close.hpp b/extlibs/websocketpp/websocketpp/close.hpp
new file mode 100644
index 000000000..f8e769436
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/close.hpp
@@ -0,0 +1,342 @@
+
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CLOSE_HPP
+#define WEBSOCKETPP_CLOSE_HPP
+
+/** \file
+ * A package of types and methods for manipulating WebSocket close codes.
+ */
+
+#include <websocketpp/error.hpp>
+#include <websocketpp/common/network.hpp>
+#include <websocketpp/common/stdint.hpp>
+#include <websocketpp/utf8_validator.hpp>
+
+#include <string>
+
+namespace websocketpp {
+/// A package of types and methods for manipulating WebSocket close codes.
+namespace close {
+/// A package of types and methods for manipulating WebSocket close status'
+namespace status {
+    /// The type of a close code value.
+    typedef uint16_t value;
+
+    /// A blank value for internal use.
+    static value const blank = 0;
+
+    /// Close the connection without a WebSocket close handshake.
+    /**
+     * This special value requests that the WebSocket connection be closed
+     * without performing the WebSocket closing handshake. This does not comply
+     * with RFC6455, but should be safe to do if necessary. This could be useful
+     * for clients that need to disconnect quickly and cannot afford the
+     * complete handshake.
+     */
+    static value const omit_handshake = 1;
+
+    /// Close the connection with a forced TCP drop.
+    /**
+     * This special value requests that the WebSocket connection be closed by
+     * forcibly dropping the TCP connection. This will leave the other side of
+     * the connection with a broken connection and some expensive timeouts. this
+     * should not be done except in extreme cases or in cases of malicious
+     * remote endpoints.
+     */
+    static value const force_tcp_drop = 2;
+
+    /// Normal closure, meaning that the purpose for which the connection was
+    /// established has been fulfilled.
+    static value const normal = 1000;
+
+    /// The endpoint was "going away", such as a server going down or a browser
+    /// navigating away from a page.
+    static value const going_away = 1001;
+
+    /// A protocol error occurred.
+    static value const protocol_error = 1002;
+
+    /// The connection was terminated because an endpoint received a type of
+    /// data it cannot accept.
+    /**
+     * (e.g., an endpoint that understands only text data MAY send this if it
+     * receives a binary message).
+     */
+    static value const unsupported_data = 1003;
+
+    /// A dummy value to indicate that no status code was received.
+    /**
+     * This value is illegal on the wire.
+     */
+    static value const no_status = 1005;
+
+    /// A dummy value to indicate that the connection was closed abnormally.
+    /**
+     * In such a case there was no close frame to extract a value from. This
+     * value is illegal on the wire.
+     */
+    static value const abnormal_close = 1006;
+
+    /// An endpoint received message data inconsistent with its type.
+    /**
+     * For example: Invalid UTF8 bytes in a text message.
+     */
+    static value const invalid_payload = 1007;
+
+    /// An endpoint received a message that violated its policy.
+    /**
+     * This is a generic status code that can be returned when there is no other
+     * more suitable status code (e.g., 1003 or 1009) or if there is a need to
+     * hide specific details about the policy.
+     */
+    static value const policy_violation = 1008;
+
+    /// An endpoint received a message too large to process.
+    static value const message_too_big = 1009;
+
+    /// A client expected the server to accept a required extension request
+    /**
+     * The list of extensions that are needed SHOULD appear in the /reason/ part
+     * of the Close frame. Note that this status code is not used by the server,
+     * because it can fail the WebSocket handshake instead.
+     */
+    static value const extension_required = 1010;
+
+    /// An endpoint encountered an unexpected condition that prevented it from
+    /// fulfilling the request.
+    static value const internal_endpoint_error = 1011;
+
+    /// Indicates that the service is restarted. A client may reconnect and if
+    /// if it chooses to do so, should reconnect using a randomized delay of
+    /// 5-30s
+    static value const service_restart = 1012;
+
+    /// Indicates that the service is experiencing overload. A client should
+    /// only connect to a different IP (when there are multiple for the target)
+    /// or reconnect to the same IP upon user action.
+    static value const try_again_later = 1013;
+
+    /// An endpoint failed to perform a TLS handshake
+    /**
+     * Designated for use in applications expecting a status code to indicate
+     * that the connection was closed due to a failure to perform a TLS
+     * handshake (e.g., the server certificate can't be verified). This value is
+     * illegal on the wire.
+     */
+    static value const tls_handshake = 1015;
+    
+    /// A generic subprotocol error
+    /**
+     * Indicates that a subprotocol error occurred. Typically this involves
+     * receiving a message that is not formatted as a valid message for the
+     * subprotocol in use.
+     */
+    static value const subprotocol_error = 3000;
+    
+    /// A invalid subprotocol data
+    /**
+     * Indicates that data was received that violated the specification of the
+     * subprotocol in use.
+     */
+    static value const invalid_subprotocol_data = 3001;
+
+    /// First value in range reserved for future protocol use
+    static value const rsv_start = 1016;
+    /// Last value in range reserved for future protocol use
+    static value const rsv_end = 2999;
+
+    /// Test whether a close code is in a reserved range
+    /**
+     * @param [in] code The code to test
+     * @return Whether or not code is reserved
+     */
+    inline bool reserved(value code) {
+        return ((code >= rsv_start && code <= rsv_end) ||
+                code == 1004 || code == 1014);
+    }
+
+    /// First value in range that is always invalid on the wire
+    static value const invalid_low = 999;
+    /// Last value in range that is always invalid on the wire
+    static value const invalid_high = 5000;
+
+    /// Test whether a close code is invalid on the wire
+    /**
+     * @param [in] code The code to test
+     * @return Whether or not code is invalid on the wire
+     */
+    inline bool invalid(value code) {
+        return (code <= invalid_low || code >= invalid_high ||
+                code == no_status || code == abnormal_close ||
+                code == tls_handshake);
+    }
+
+    /// Determine if the code represents an unrecoverable error
+    /**
+     * There is a class of errors for which once they are discovered normal
+     * WebSocket functionality can no longer occur. This function determines
+     * if a given code is one of these values. This information is used to
+     * determine if the system has the capability of waiting for a close
+     * acknowledgement or if it should drop the TCP connection immediately
+     * after sending its close frame.
+     *
+     * @param [in] code The value to test.
+     * @return True if the code represents an unrecoverable error
+     */
+    inline bool terminal(value code) {
+        return (code == protocol_error || code == invalid_payload ||
+                code == policy_violation || code == message_too_big ||
+                 code == internal_endpoint_error);
+    }
+    
+    /// Return a human readable interpretation of a WebSocket close code
+    /**
+     * See https://tools.ietf.org/html/rfc6455#section-7.4 for more details.
+     *
+     * @since 0.3.0
+     *
+     * @param [in] code The code to look up.
+     * @return A human readable interpretation of the code.
+     */
+    inline std::string get_string(value code) {
+        switch (code) {
+            case normal:
+                return "Normal close";
+            case going_away:
+                return "Going away";
+            case protocol_error:
+                return "Protocol error";
+            case unsupported_data:
+                return "Unsupported data";
+            case no_status:
+                return "No status set";
+            case abnormal_close:
+                return "Abnormal close";
+            case invalid_payload:
+                return "Invalid payload";
+            case policy_violation:
+                return "Policy violoation";
+            case message_too_big:
+                return "Message too big";
+            case extension_required:
+                return "Extension required";
+            case internal_endpoint_error:
+                return "Internal endpoint error";
+            case tls_handshake:
+                return "TLS handshake failure";
+            case subprotocol_error:
+                return "Generic subprotocol error";
+            case invalid_subprotocol_data:
+                return "Invalid subprotocol data";
+            default:
+                return "Unknown";
+        }
+    }
+} // namespace status
+
+/// Type used to convert close statuses between integer and wire representations
+union code_converter {
+    uint16_t i;
+    char c[2];
+};
+
+/// Extract a close code value from a close payload
+/**
+ * If there is no close value (ie string is empty) status::no_status is
+ * returned. If a code couldn't be extracted (usually do to a short or
+ * otherwise mangled payload) status::protocol_error is returned and the ec
+ * value is flagged as an error. Note that this case is different than the case
+ * where protocol error is received over the wire.
+ *
+ * If the value is in an invalid or reserved range ec is set accordingly.
+ *
+ * @param [in] payload Close frame payload value received over the wire.
+ * @param [out] ec Set to indicate what error occurred, if any.
+ * @return The extracted value
+ */
+inline status::value extract_code(std::string const & payload, lib::error_code
+    & ec)
+{
+    ec = lib::error_code();
+
+    if (payload.size() == 0) {
+        return status::no_status;
+    } else if (payload.size() == 1) {
+        ec = make_error_code(error::bad_close_code);
+        return status::protocol_error;
+    }
+
+    code_converter val;
+
+    val.c[0] = payload[0];
+    val.c[1] = payload[1];
+
+    status::value code(ntohs(val.i));
+
+    if (status::invalid(code)) {
+        ec = make_error_code(error::invalid_close_code);
+    }
+
+    if (status::reserved(code)) {
+        ec = make_error_code(error::reserved_close_code);
+    }
+
+    return code;
+}
+
+/// Extract the reason string from a close payload
+/**
+ * The string should be a valid UTF8 message. error::invalid_utf8 will be set if
+ * the function extracts a reason that is not valid UTF8.
+ *
+ * @param [in] payload The payload string to extract a reason from.
+ * @param [out] ec Set to indicate what error occurred, if any.
+ * @return The reason string.
+ */
+inline std::string extract_reason(std::string const & payload, lib::error_code
+    & ec)
+{
+    std::string reason = "";
+    ec = lib::error_code();
+
+    if (payload.size() > 2) {
+        reason.append(payload.begin()+2,payload.end());
+    }
+
+    if (!websocketpp::utf8_validator::validate(reason)) {
+        ec = make_error_code(error::invalid_utf8);
+    }
+
+    return reason;
+}
+
+} // namespace close
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CLOSE_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/chrono.hpp b/extlibs/websocketpp/websocketpp/common/chrono.hpp
new file mode 100644
index 000000000..c536a3652
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/chrono.hpp
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_CHRONO_HPP
+#define WEBSOCKETPP_COMMON_CHRONO_HPP
+
+#if defined _WEBSOCKETPP_CPP11_STL_ && !defined _WEBSOCKETPP_NO_CPP11_CHRONO_
+    #ifndef _WEBSOCKETPP_CPP11_CHRONO_
+        #define _WEBSOCKETPP_CPP11_CHRONO_
+    #endif
+#endif
+
+#ifdef _WEBSOCKETPP_CPP11_CHRONO_
+    #include <chrono>
+#else
+    #include <boost/chrono.hpp>
+#endif
+
+namespace websocketpp {
+namespace lib {
+
+#ifdef _WEBSOCKETPP_CPP11_CHRONO_
+    using std::chrono::system_clock;
+#else
+    using boost::chrono::system_clock;
+#endif
+
+} // namespace lib
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_COMMON_CHRONO_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/connection_hdl.hpp b/extlibs/websocketpp/websocketpp/common/connection_hdl.hpp
new file mode 100644
index 000000000..1044c88e3
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/connection_hdl.hpp
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_CONNECTION_HDL_HPP
+#define WEBSOCKETPP_COMMON_CONNECTION_HDL_HPP
+
+#include <websocketpp/common/memory.hpp>
+
+namespace websocketpp {
+
+/// A handle to uniquely identify a connection.
+/**
+ * This type uniquely identifies a connection. It is implemented as a weak
+ * pointer to the connection in question. This provides uniqueness across
+ * multiple endpoints and ensures that IDs never conflict or run out.
+ *
+ * It is safe to make copies of this handle, store those copies in containers,
+ * and use them from other threads.
+ *
+ * This handle can be upgraded to a full shared_ptr using
+ * `endpoint::get_con_from_hdl()` from within a handler fired by the connection
+ * that owns the handler.
+ */
+typedef lib::weak_ptr<void> connection_hdl;
+
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_COMMON_CONNECTION_HDL_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/cpp11.hpp b/extlibs/websocketpp/websocketpp/common/cpp11.hpp
new file mode 100644
index 000000000..6c79d644d
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/cpp11.hpp
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_CPP11_HPP
+#define WEBSOCKETPP_COMMON_CPP11_HPP
+
+/**
+ * This header sets up some constants based on the state of C++11 support
+ */
+
+// Hide clang feature detection from other compilers
+#ifndef __has_feature         // Optional of course.
+  #define __has_feature(x) 0  // Compatibility with non-clang compilers.
+#endif
+#ifndef __has_extension
+  #define __has_extension __has_feature // Compatibility with pre-3.0 compilers.
+#endif
+
+// The code below attempts to use information provided by the build system or
+// user supplied defines to selectively enable C++11 language and library
+// features. In most cases features that are targeted individually may also be
+// selectively disabled via an associated _WEBSOCKETPP_NOXXX_ define.
+
+#if defined(_WEBSOCKETPP_CPP11_STL_) || __cplusplus >= 201103L || defined(_WEBSOCKETPP_CPP11_STRICT_)
+    // This check tests for blanket c++11 coverage. It can be activated in one
+    // of three ways. Either the compiler itself reports that it is a full 
+    // C++11 compiler via the __cplusplus macro or the user/build system
+    // supplies one of the two preprocessor defines below:
+    
+    // This is defined to allow other WebSocket++ common headers to enable
+    // C++11 features when they are detected by this file rather than
+    // duplicating the above logic in every common header.
+    #define _WEBSOCKETPP_CPP11_INTERNAL_
+    
+    // _WEBSOCKETPP_CPP11_STRICT_
+    //
+    // This define reports to WebSocket++ that 100% of the language and library
+    // features of C++11 are available. Using this define on a non-C++11
+    // compiler will result in problems.
+    
+    // _WEBSOCKETPP_CPP11_STL_ 
+    //
+    // This define enables *most* C++11 options that were implemented early on
+    // by compilers. It is typically used for compilers that have many, but not
+    // all C++11 features. It should be safe to use on GCC 4.7-4.8 and perhaps
+    // earlier. 
+    #ifndef _WEBSOCKETPP_NOEXCEPT_TOKEN_
+        #define _WEBSOCKETPP_NOEXCEPT_TOKEN_ noexcept
+    #endif
+    #ifndef _WEBSOCKETPP_CONSTEXPR_TOKEN_
+        #define _WEBSOCKETPP_CONSTEXPR_TOKEN_ constexpr
+    #endif
+    #ifndef _WEBSOCKETPP_INITIALIZER_LISTS_
+        #define _WEBSOCKETPP_INITIALIZER_LISTS_
+    #endif
+    #ifndef _WEBSOCKETPP_NULLPTR_TOKEN_
+        #define _WEBSOCKETPP_NULLPTR_TOKEN_ nullptr
+    #endif
+    
+    #ifndef __GNUC__
+        // GCC as of version 4.9 (latest) does not support std::put_time yet.
+        // so ignore it
+        #define _WEBSOCKETPP_PUTTIME_
+    #endif
+#else
+    // In the absence of a blanket define, try to use compiler versions or
+    // feature testing macros to selectively enable what we can.
+
+    // Test for noexcept
+    #ifndef _WEBSOCKETPP_NOEXCEPT_TOKEN_
+        #ifdef _WEBSOCKETPP_NOEXCEPT_
+            // build system says we have noexcept
+            #define _WEBSOCKETPP_NOEXCEPT_TOKEN_ noexcept
+        #else
+            #if __has_feature(cxx_noexcept)
+                // clang feature detect says we have noexcept
+                #define _WEBSOCKETPP_NOEXCEPT_TOKEN_ noexcept
+            #else
+                // assume we don't have noexcept
+                #define _WEBSOCKETPP_NOEXCEPT_TOKEN_
+            #endif
+        #endif
+    #endif
+
+    // Test for constexpr
+    #ifndef _WEBSOCKETPP_CONSTEXPR_TOKEN_
+        #ifdef _WEBSOCKETPP_CONSTEXPR_
+            // build system says we have constexpr
+            #define _WEBSOCKETPP_CONSTEXPR_TOKEN_ constexpr
+        #else
+            #if __has_feature(cxx_constexpr)
+                // clang feature detect says we have constexpr
+                #define _WEBSOCKETPP_CONSTEXPR_TOKEN_ constexpr
+            #else
+                // assume we don't have constexpr
+                #define _WEBSOCKETPP_CONSTEXPR_TOKEN_
+            #endif
+        #endif
+    #endif
+
+    // Enable initializer lists on clang when available.
+    #if __has_feature(cxx_generalized_initializers) && !defined(_WEBSOCKETPP_INITIALIZER_LISTS_)
+        #define _WEBSOCKETPP_INITIALIZER_LISTS_
+    #endif
+    
+    // Test for nullptr
+    #ifndef _WEBSOCKETPP_NULLPTR_TOKEN_
+        #ifdef _WEBSOCKETPP_NULLPTR_
+            // build system says we have nullptr
+            #define _WEBSOCKETPP_NULLPTR_TOKEN_ nullptr
+        #else
+            #if __has_feature(cxx_nullptr)
+                // clang feature detect says we have nullptr
+                #define _WEBSOCKETPP_NULLPTR_TOKEN_ nullptr
+            #elif _MSC_VER >= 1600
+                // Visual Studio version that has nullptr
+                #define _WEBSOCKETPP_NULLPTR_TOKEN_ nullptr
+            #else
+                // assume we don't have nullptr
+                #define _WEBSOCKETPP_NULLPTR_TOKEN_ 0
+            #endif
+        #endif
+    #endif
+#endif
+
+#endif // WEBSOCKETPP_COMMON_CPP11_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/functional.hpp b/extlibs/websocketpp/websocketpp/common/functional.hpp
new file mode 100644
index 000000000..d332dd15e
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/functional.hpp
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_FUNCTIONAL_HPP
+#define WEBSOCKETPP_COMMON_FUNCTIONAL_HPP
+
+#include <websocketpp/common/cpp11.hpp>
+
+// If we've determined that we're in full C++11 mode and the user hasn't
+// explicitly disabled the use of C++11 functional header, then prefer it to
+// boost.
+#if defined _WEBSOCKETPP_CPP11_INTERNAL_ && !defined _WEBSOCKETPP_NO_CPP11_FUNCTIONAL_
+    #ifndef _WEBSOCKETPP_CPP11_FUNCTIONAL_
+        #define _WEBSOCKETPP_CPP11_FUNCTIONAL_
+    #endif
+#endif
+
+// If we're on Visual Studio 2010 or higher and haven't explicitly disabled
+// the use of C++11 functional header then prefer it to boost.
+#if defined(_MSC_VER) && _MSC_VER >= 1600 && !defined _WEBSOCKETPP_NO_CPP11_FUNCTIONAL_
+    #ifndef _WEBSOCKETPP_CPP11_FUNCTIONAL_
+        #define _WEBSOCKETPP_CPP11_FUNCTIONAL_
+    #endif
+#endif
+
+
+
+#ifdef _WEBSOCKETPP_CPP11_FUNCTIONAL_
+    #include <functional>
+#else
+    #include <boost/bind.hpp>
+    #include <boost/function.hpp>
+    #include <boost/ref.hpp>
+#endif
+
+
+
+namespace websocketpp {
+namespace lib {
+
+#ifdef _WEBSOCKETPP_CPP11_FUNCTIONAL_
+    using std::function;
+    using std::bind;
+    using std::ref;
+    namespace placeholders = std::placeholders;
+
+    // There are some cases where a C++11 compiler balks at using std::ref
+    // but a C++03 compiler using boost function requires boost::ref. As such
+    // lib::ref is not useful in these cases. Instead this macro allows the use
+    // of boost::ref in the case of a boost compile or no reference wrapper at
+    // all in the case of a C++11 compile
+    #define _WEBSOCKETPP_REF(x) x
+
+    template <typename T>
+    void clear_function(T & x) {
+        x = nullptr;
+    }
+#else
+    using boost::function;
+    using boost::bind;
+    using boost::ref;
+    namespace placeholders {
+        /// \todo this feels hacky, is there a better way?
+        using ::_1;
+        using ::_2;
+        using ::_3;
+    }
+
+    // See above definition for more details on what this is and why it exists
+    #define _WEBSOCKETPP_REF(x) boost::ref(x)
+
+    template <typename T>
+    void clear_function(T & x) {
+        x.clear();
+    }
+#endif
+
+} // namespace lib
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_COMMON_FUNCTIONAL_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/md5.hpp b/extlibs/websocketpp/websocketpp/common/md5.hpp
new file mode 100644
index 000000000..279725f45
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/md5.hpp
@@ -0,0 +1,448 @@
+/*
+  md5.hpp is a reformulation of the md5.h and md5.c code from
+  http://www.opensource.apple.com/source/cups/cups-59/cups/md5.c to allow it to
+  function as a component of a header only library. This conversion was done by
+  Peter Thorson (webmaster@zaphoyd.com) in 2012 for the WebSocket++ project. The
+  changes are released under the same license as the original (listed below)
+*/
+/*
+  Copyright (C) 1999, 2002 Aladdin Enterprises.  All rights reserved.
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  L. Peter Deutsch
+  ghost@aladdin.com
+
+ */
+/* $Id: md5.h,v 1.4 2002/04/13 19:20:28 lpd Exp $ */
+/*
+  Independent implementation of MD5 (RFC 1321).
+
+  This code implements the MD5 Algorithm defined in RFC 1321, whose
+  text is available at
+    http://www.ietf.org/rfc/rfc1321.txt
+  The code is derived from the text of the RFC, including the test suite
+  (section A.5) but excluding the rest of Appendix A.  It does not include
+  any code or documentation that is identified in the RFC as being
+  copyrighted.
+
+  The original and principal author of md5.h is L. Peter Deutsch
+  <ghost@aladdin.com>.  Other authors are noted in the change history
+  that follows (in reverse chronological order):
+
+  2002-04-13 lpd Removed support for non-ANSI compilers; removed
+    references to Ghostscript; clarified derivation from RFC 1321;
+    now handles byte order either statically or dynamically.
+  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
+  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);
+    added conditionalization for C++ compilation from Martin
+    Purschke <purschke@bnl.gov>.
+  1999-05-03 lpd Original version.
+ */
+
+#ifndef WEBSOCKETPP_COMMON_MD5_HPP
+#define WEBSOCKETPP_COMMON_MD5_HPP
+
+/*
+ * This package supports both compile-time and run-time determination of CPU
+ * byte order.  If ARCH_IS_BIG_ENDIAN is defined as 0, the code will be
+ * compiled to run only on little-endian CPUs; if ARCH_IS_BIG_ENDIAN is
+ * defined as non-zero, the code will be compiled to run only on big-endian
+ * CPUs; if ARCH_IS_BIG_ENDIAN is not defined, the code will be compiled to
+ * run on either big- or little-endian CPUs, but will run slightly less
+ * efficiently on either one than if ARCH_IS_BIG_ENDIAN is defined.
+ */
+
+#include <stddef.h>
+#include <string>
+#include <cstring>
+
+namespace websocketpp {
+/// Provides MD5 hashing functionality
+namespace md5 {
+
+typedef unsigned char md5_byte_t; /* 8-bit byte */
+typedef unsigned int md5_word_t; /* 32-bit word */
+
+/* Define the state of the MD5 Algorithm. */
+typedef struct md5_state_s {
+    md5_word_t count[2];    /* message length in bits, lsw first */
+    md5_word_t abcd[4];     /* digest buffer */
+    md5_byte_t buf[64];     /* accumulate block */
+} md5_state_t;
+
+/* Initialize the algorithm. */
+inline void md5_init(md5_state_t *pms);
+
+/* Append a string to the message. */
+inline void md5_append(md5_state_t *pms, md5_byte_t const * data, size_t nbytes);
+
+/* Finish the message and return the digest. */
+inline void md5_finish(md5_state_t *pms, md5_byte_t digest[16]);
+
+#undef ZSW_MD5_BYTE_ORDER   /* 1 = big-endian, -1 = little-endian, 0 = unknown */
+#ifdef ARCH_IS_BIG_ENDIAN
+#  define ZSW_MD5_BYTE_ORDER (ARCH_IS_BIG_ENDIAN ? 1 : -1)
+#else
+#  define ZSW_MD5_BYTE_ORDER 0
+#endif
+
+#define ZSW_MD5_T_MASK ((md5_word_t)~0)
+#define ZSW_MD5_T1 /* 0xd76aa478 */ (ZSW_MD5_T_MASK ^ 0x28955b87)
+#define ZSW_MD5_T2 /* 0xe8c7b756 */ (ZSW_MD5_T_MASK ^ 0x173848a9)
+#define ZSW_MD5_T3    0x242070db
+#define ZSW_MD5_T4 /* 0xc1bdceee */ (ZSW_MD5_T_MASK ^ 0x3e423111)
+#define ZSW_MD5_T5 /* 0xf57c0faf */ (ZSW_MD5_T_MASK ^ 0x0a83f050)
+#define ZSW_MD5_T6    0x4787c62a
+#define ZSW_MD5_T7 /* 0xa8304613 */ (ZSW_MD5_T_MASK ^ 0x57cfb9ec)
+#define ZSW_MD5_T8 /* 0xfd469501 */ (ZSW_MD5_T_MASK ^ 0x02b96afe)
+#define ZSW_MD5_T9    0x698098d8
+#define ZSW_MD5_T10 /* 0x8b44f7af */ (ZSW_MD5_T_MASK ^ 0x74bb0850)
+#define ZSW_MD5_T11 /* 0xffff5bb1 */ (ZSW_MD5_T_MASK ^ 0x0000a44e)
+#define ZSW_MD5_T12 /* 0x895cd7be */ (ZSW_MD5_T_MASK ^ 0x76a32841)
+#define ZSW_MD5_T13    0x6b901122
+#define ZSW_MD5_T14 /* 0xfd987193 */ (ZSW_MD5_T_MASK ^ 0x02678e6c)
+#define ZSW_MD5_T15 /* 0xa679438e */ (ZSW_MD5_T_MASK ^ 0x5986bc71)
+#define ZSW_MD5_T16    0x49b40821
+#define ZSW_MD5_T17 /* 0xf61e2562 */ (ZSW_MD5_T_MASK ^ 0x09e1da9d)
+#define ZSW_MD5_T18 /* 0xc040b340 */ (ZSW_MD5_T_MASK ^ 0x3fbf4cbf)
+#define ZSW_MD5_T19    0x265e5a51
+#define ZSW_MD5_T20 /* 0xe9b6c7aa */ (ZSW_MD5_T_MASK ^ 0x16493855)
+#define ZSW_MD5_T21 /* 0xd62f105d */ (ZSW_MD5_T_MASK ^ 0x29d0efa2)
+#define ZSW_MD5_T22    0x02441453
+#define ZSW_MD5_T23 /* 0xd8a1e681 */ (ZSW_MD5_T_MASK ^ 0x275e197e)
+#define ZSW_MD5_T24 /* 0xe7d3fbc8 */ (ZSW_MD5_T_MASK ^ 0x182c0437)
+#define ZSW_MD5_T25    0x21e1cde6
+#define ZSW_MD5_T26 /* 0xc33707d6 */ (ZSW_MD5_T_MASK ^ 0x3cc8f829)
+#define ZSW_MD5_T27 /* 0xf4d50d87 */ (ZSW_MD5_T_MASK ^ 0x0b2af278)
+#define ZSW_MD5_T28    0x455a14ed
+#define ZSW_MD5_T29 /* 0xa9e3e905 */ (ZSW_MD5_T_MASK ^ 0x561c16fa)
+#define ZSW_MD5_T30 /* 0xfcefa3f8 */ (ZSW_MD5_T_MASK ^ 0x03105c07)
+#define ZSW_MD5_T31    0x676f02d9
+#define ZSW_MD5_T32 /* 0x8d2a4c8a */ (ZSW_MD5_T_MASK ^ 0x72d5b375)
+#define ZSW_MD5_T33 /* 0xfffa3942 */ (ZSW_MD5_T_MASK ^ 0x0005c6bd)
+#define ZSW_MD5_T34 /* 0x8771f681 */ (ZSW_MD5_T_MASK ^ 0x788e097e)
+#define ZSW_MD5_T35    0x6d9d6122
+#define ZSW_MD5_T36 /* 0xfde5380c */ (ZSW_MD5_T_MASK ^ 0x021ac7f3)
+#define ZSW_MD5_T37 /* 0xa4beea44 */ (ZSW_MD5_T_MASK ^ 0x5b4115bb)
+#define ZSW_MD5_T38    0x4bdecfa9
+#define ZSW_MD5_T39 /* 0xf6bb4b60 */ (ZSW_MD5_T_MASK ^ 0x0944b49f)
+#define ZSW_MD5_T40 /* 0xbebfbc70 */ (ZSW_MD5_T_MASK ^ 0x4140438f)
+#define ZSW_MD5_T41    0x289b7ec6
+#define ZSW_MD5_T42 /* 0xeaa127fa */ (ZSW_MD5_T_MASK ^ 0x155ed805)
+#define ZSW_MD5_T43 /* 0xd4ef3085 */ (ZSW_MD5_T_MASK ^ 0x2b10cf7a)
+#define ZSW_MD5_T44    0x04881d05
+#define ZSW_MD5_T45 /* 0xd9d4d039 */ (ZSW_MD5_T_MASK ^ 0x262b2fc6)
+#define ZSW_MD5_T46 /* 0xe6db99e5 */ (ZSW_MD5_T_MASK ^ 0x1924661a)
+#define ZSW_MD5_T47    0x1fa27cf8
+#define ZSW_MD5_T48 /* 0xc4ac5665 */ (ZSW_MD5_T_MASK ^ 0x3b53a99a)
+#define ZSW_MD5_T49 /* 0xf4292244 */ (ZSW_MD5_T_MASK ^ 0x0bd6ddbb)
+#define ZSW_MD5_T50    0x432aff97
+#define ZSW_MD5_T51 /* 0xab9423a7 */ (ZSW_MD5_T_MASK ^ 0x546bdc58)
+#define ZSW_MD5_T52 /* 0xfc93a039 */ (ZSW_MD5_T_MASK ^ 0x036c5fc6)
+#define ZSW_MD5_T53    0x655b59c3
+#define ZSW_MD5_T54 /* 0x8f0ccc92 */ (ZSW_MD5_T_MASK ^ 0x70f3336d)
+#define ZSW_MD5_T55 /* 0xffeff47d */ (ZSW_MD5_T_MASK ^ 0x00100b82)
+#define ZSW_MD5_T56 /* 0x85845dd1 */ (ZSW_MD5_T_MASK ^ 0x7a7ba22e)
+#define ZSW_MD5_T57    0x6fa87e4f
+#define ZSW_MD5_T58 /* 0xfe2ce6e0 */ (ZSW_MD5_T_MASK ^ 0x01d3191f)
+#define ZSW_MD5_T59 /* 0xa3014314 */ (ZSW_MD5_T_MASK ^ 0x5cfebceb)
+#define ZSW_MD5_T60    0x4e0811a1
+#define ZSW_MD5_T61 /* 0xf7537e82 */ (ZSW_MD5_T_MASK ^ 0x08ac817d)
+#define ZSW_MD5_T62 /* 0xbd3af235 */ (ZSW_MD5_T_MASK ^ 0x42c50dca)
+#define ZSW_MD5_T63    0x2ad7d2bb
+#define ZSW_MD5_T64 /* 0xeb86d391 */ (ZSW_MD5_T_MASK ^ 0x14792c6e)
+
+static void md5_process(md5_state_t *pms, md5_byte_t const * data /*[64]*/) {
+    md5_word_t
+    a = pms->abcd[0], b = pms->abcd[1],
+    c = pms->abcd[2], d = pms->abcd[3];
+    md5_word_t t;
+#if ZSW_MD5_BYTE_ORDER > 0
+    /* Define storage only for big-endian CPUs. */
+    md5_word_t X[16];
+#else
+    /* Define storage for little-endian or both types of CPUs. */
+    md5_word_t xbuf[16];
+    md5_word_t const * X;
+#endif
+
+    {
+#if ZSW_MD5_BYTE_ORDER == 0
+    /*
+     * Determine dynamically whether this is a big-endian or
+     * little-endian machine, since we can use a more efficient
+     * algorithm on the latter.
+     */
+    static int const w = 1;
+
+    if (*((md5_byte_t const *)&w)) /* dynamic little-endian */
+#endif
+#if ZSW_MD5_BYTE_ORDER <= 0     /* little-endian */
+    {
+        /*
+         * On little-endian machines, we can process properly aligned
+         * data without copying it.
+         */
+        if (!((data - (md5_byte_t const *)0) & 3)) {
+        /* data are properly aligned */
+        X = (md5_word_t const *)data;
+        } else {
+        /* not aligned */
+        std::memcpy(xbuf, data, 64);
+        X = xbuf;
+        }
+    }
+#endif
+#if ZSW_MD5_BYTE_ORDER == 0
+    else            /* dynamic big-endian */
+#endif
+#if ZSW_MD5_BYTE_ORDER >= 0     /* big-endian */
+    {
+        /*
+         * On big-endian machines, we must arrange the bytes in the
+         * right order.
+         */
+        const md5_byte_t *xp = data;
+        int i;
+
+#  if ZSW_MD5_BYTE_ORDER == 0
+        X = xbuf;       /* (dynamic only) */
+#  else
+#    define xbuf X      /* (static only) */
+#  endif
+        for (i = 0; i < 16; ++i, xp += 4)
+        xbuf[i] = xp[0] + (xp[1] << 8) + (xp[2] << 16) + (xp[3] << 24);
+    }
+#endif
+    }
+
+#define ZSW_MD5_ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
+
+    /* Round 1. */
+    /* Let [abcd k s i] denote the operation
+       a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */
+#define ZSW_MD5_F(x, y, z) (((x) & (y)) | (~(x) & (z)))
+#define SET(a, b, c, d, k, s, Ti)\
+  t = a + ZSW_MD5_F(b,c,d) + X[k] + Ti;\
+  a = ZSW_MD5_ROTATE_LEFT(t, s) + b
+    /* Do the following 16 operations. */
+    SET(a, b, c, d,  0,  7,  ZSW_MD5_T1);
+    SET(d, a, b, c,  1, 12,  ZSW_MD5_T2);
+    SET(c, d, a, b,  2, 17,  ZSW_MD5_T3);
+    SET(b, c, d, a,  3, 22,  ZSW_MD5_T4);
+    SET(a, b, c, d,  4,  7,  ZSW_MD5_T5);
+    SET(d, a, b, c,  5, 12,  ZSW_MD5_T6);
+    SET(c, d, a, b,  6, 17,  ZSW_MD5_T7);
+    SET(b, c, d, a,  7, 22,  ZSW_MD5_T8);
+    SET(a, b, c, d,  8,  7,  ZSW_MD5_T9);
+    SET(d, a, b, c,  9, 12, ZSW_MD5_T10);
+    SET(c, d, a, b, 10, 17, ZSW_MD5_T11);
+    SET(b, c, d, a, 11, 22, ZSW_MD5_T12);
+    SET(a, b, c, d, 12,  7, ZSW_MD5_T13);
+    SET(d, a, b, c, 13, 12, ZSW_MD5_T14);
+    SET(c, d, a, b, 14, 17, ZSW_MD5_T15);
+    SET(b, c, d, a, 15, 22, ZSW_MD5_T16);
+#undef SET
+
+     /* Round 2. */
+     /* Let [abcd k s i] denote the operation
+          a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */
+#define ZSW_MD5_G(x, y, z) (((x) & (z)) | ((y) & ~(z)))
+#define SET(a, b, c, d, k, s, Ti)\
+  t = a + ZSW_MD5_G(b,c,d) + X[k] + Ti;\
+  a = ZSW_MD5_ROTATE_LEFT(t, s) + b
+     /* Do the following 16 operations. */
+    SET(a, b, c, d,  1,  5, ZSW_MD5_T17);
+    SET(d, a, b, c,  6,  9, ZSW_MD5_T18);
+    SET(c, d, a, b, 11, 14, ZSW_MD5_T19);
+    SET(b, c, d, a,  0, 20, ZSW_MD5_T20);
+    SET(a, b, c, d,  5,  5, ZSW_MD5_T21);
+    SET(d, a, b, c, 10,  9, ZSW_MD5_T22);
+    SET(c, d, a, b, 15, 14, ZSW_MD5_T23);
+    SET(b, c, d, a,  4, 20, ZSW_MD5_T24);
+    SET(a, b, c, d,  9,  5, ZSW_MD5_T25);
+    SET(d, a, b, c, 14,  9, ZSW_MD5_T26);
+    SET(c, d, a, b,  3, 14, ZSW_MD5_T27);
+    SET(b, c, d, a,  8, 20, ZSW_MD5_T28);
+    SET(a, b, c, d, 13,  5, ZSW_MD5_T29);
+    SET(d, a, b, c,  2,  9, ZSW_MD5_T30);
+    SET(c, d, a, b,  7, 14, ZSW_MD5_T31);
+    SET(b, c, d, a, 12, 20, ZSW_MD5_T32);
+#undef SET
+
+     /* Round 3. */
+     /* Let [abcd k s t] denote the operation
+          a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */
+#define ZSW_MD5_H(x, y, z) ((x) ^ (y) ^ (z))
+#define SET(a, b, c, d, k, s, Ti)\
+  t = a + ZSW_MD5_H(b,c,d) + X[k] + Ti;\
+  a = ZSW_MD5_ROTATE_LEFT(t, s) + b
+     /* Do the following 16 operations. */
+    SET(a, b, c, d,  5,  4, ZSW_MD5_T33);
+    SET(d, a, b, c,  8, 11, ZSW_MD5_T34);
+    SET(c, d, a, b, 11, 16, ZSW_MD5_T35);
+    SET(b, c, d, a, 14, 23, ZSW_MD5_T36);
+    SET(a, b, c, d,  1,  4, ZSW_MD5_T37);
+    SET(d, a, b, c,  4, 11, ZSW_MD5_T38);
+    SET(c, d, a, b,  7, 16, ZSW_MD5_T39);
+    SET(b, c, d, a, 10, 23, ZSW_MD5_T40);
+    SET(a, b, c, d, 13,  4, ZSW_MD5_T41);
+    SET(d, a, b, c,  0, 11, ZSW_MD5_T42);
+    SET(c, d, a, b,  3, 16, ZSW_MD5_T43);
+    SET(b, c, d, a,  6, 23, ZSW_MD5_T44);
+    SET(a, b, c, d,  9,  4, ZSW_MD5_T45);
+    SET(d, a, b, c, 12, 11, ZSW_MD5_T46);
+    SET(c, d, a, b, 15, 16, ZSW_MD5_T47);
+    SET(b, c, d, a,  2, 23, ZSW_MD5_T48);
+#undef SET
+
+     /* Round 4. */
+     /* Let [abcd k s t] denote the operation
+          a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */
+#define ZSW_MD5_I(x, y, z) ((y) ^ ((x) | ~(z)))
+#define SET(a, b, c, d, k, s, Ti)\
+  t = a + ZSW_MD5_I(b,c,d) + X[k] + Ti;\
+  a = ZSW_MD5_ROTATE_LEFT(t, s) + b
+     /* Do the following 16 operations. */
+    SET(a, b, c, d,  0,  6, ZSW_MD5_T49);
+    SET(d, a, b, c,  7, 10, ZSW_MD5_T50);
+    SET(c, d, a, b, 14, 15, ZSW_MD5_T51);
+    SET(b, c, d, a,  5, 21, ZSW_MD5_T52);
+    SET(a, b, c, d, 12,  6, ZSW_MD5_T53);
+    SET(d, a, b, c,  3, 10, ZSW_MD5_T54);
+    SET(c, d, a, b, 10, 15, ZSW_MD5_T55);
+    SET(b, c, d, a,  1, 21, ZSW_MD5_T56);
+    SET(a, b, c, d,  8,  6, ZSW_MD5_T57);
+    SET(d, a, b, c, 15, 10, ZSW_MD5_T58);
+    SET(c, d, a, b,  6, 15, ZSW_MD5_T59);
+    SET(b, c, d, a, 13, 21, ZSW_MD5_T60);
+    SET(a, b, c, d,  4,  6, ZSW_MD5_T61);
+    SET(d, a, b, c, 11, 10, ZSW_MD5_T62);
+    SET(c, d, a, b,  2, 15, ZSW_MD5_T63);
+    SET(b, c, d, a,  9, 21, ZSW_MD5_T64);
+#undef SET
+
+     /* Then perform the following additions. (That is increment each
+        of the four registers by the value it had before this block
+        was started.) */
+    pms->abcd[0] += a;
+    pms->abcd[1] += b;
+    pms->abcd[2] += c;
+    pms->abcd[3] += d;
+}
+
+void md5_init(md5_state_t *pms) {
+    pms->count[0] = pms->count[1] = 0;
+    pms->abcd[0] = 0x67452301;
+    pms->abcd[1] = /*0xefcdab89*/ ZSW_MD5_T_MASK ^ 0x10325476;
+    pms->abcd[2] = /*0x98badcfe*/ ZSW_MD5_T_MASK ^ 0x67452301;
+    pms->abcd[3] = 0x10325476;
+}
+
+void md5_append(md5_state_t *pms, md5_byte_t const * data, size_t nbytes) {
+    md5_byte_t const * p = data;
+    size_t left = nbytes;
+    int offset = (pms->count[0] >> 3) & 63;
+    md5_word_t nbits = (md5_word_t)(nbytes << 3);
+
+    if (nbytes <= 0)
+    return;
+
+    /* Update the message length. */
+    pms->count[1] += nbytes >> 29;
+    pms->count[0] += nbits;
+    if (pms->count[0] < nbits)
+    pms->count[1]++;
+
+    /* Process an initial partial block. */
+    if (offset) {
+    int copy = (offset + nbytes > 64 ? 64 - offset : static_cast<int>(nbytes));
+
+    std::memcpy(pms->buf + offset, p, copy);
+    if (offset + copy < 64)
+        return;
+    p += copy;
+    left -= copy;
+    md5_process(pms, pms->buf);
+    }
+
+    /* Process full blocks. */
+    for (; left >= 64; p += 64, left -= 64)
+    md5_process(pms, p);
+
+    /* Process a final partial block. */
+    if (left)
+    std::memcpy(pms->buf, p, left);
+}
+
+void md5_finish(md5_state_t *pms, md5_byte_t digest[16]) {
+    static md5_byte_t const pad[64] = {
+    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+    };
+    md5_byte_t data[8];
+    int i;
+
+    /* Save the length before padding. */
+    for (i = 0; i < 8; ++i)
+    data[i] = (md5_byte_t)(pms->count[i >> 2] >> ((i & 3) << 3));
+    /* Pad to 56 bytes mod 64. */
+    md5_append(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);
+    /* Append the length. */
+    md5_append(pms, data, 8);
+    for (i = 0; i < 16; ++i)
+    digest[i] = (md5_byte_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));
+}
+
+// some convenience c++ functions
+inline std::string md5_hash_string(std::string const & s) {
+    char digest[16];
+
+    md5_state_t state;
+
+    md5_init(&state);
+    md5_append(&state, (md5_byte_t const *)s.c_str(), s.size());
+    md5_finish(&state, (md5_byte_t *)digest);
+
+    std::string ret;
+    ret.resize(16);
+    std::copy(digest,digest+16,ret.begin());
+
+    return ret;
+}
+
+const char hexval[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+
+inline std::string md5_hash_hex(std::string const & input) {
+    std::string hash = md5_hash_string(input);
+    std::string hex;
+
+    for (size_t i = 0; i < hash.size(); i++) {
+        hex.push_back(hexval[((hash[i] >> 4) & 0xF)]);
+        hex.push_back(hexval[(hash[i]) & 0x0F]);
+    }
+
+    return hex;
+}
+
+} // md5
+} // websocketpp
+
+#endif // WEBSOCKETPP_COMMON_MD5_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/memory.hpp b/extlibs/websocketpp/websocketpp/common/memory.hpp
new file mode 100644
index 000000000..52cd85b57
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/memory.hpp
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_MEMORY_HPP
+#define WEBSOCKETPP_COMMON_MEMORY_HPP
+
+#include <websocketpp/common/cpp11.hpp>
+
+// If we've determined that we're in full C++11 mode and the user hasn't
+// explicitly disabled the use of C++11 memory header, then prefer it to
+// boost.
+#if defined _WEBSOCKETPP_CPP11_INTERNAL_ && !defined _WEBSOCKETPP_NO_CPP11_MEMORY_
+    #ifndef _WEBSOCKETPP_CPP11_MEMORY_
+        #define _WEBSOCKETPP_CPP11_MEMORY_
+    #endif
+#endif
+
+// If we're on Visual Studio 2010 or higher and haven't explicitly disabled
+// the use of C++11 functional header then prefer it to boost.
+#if defined(_MSC_VER) && _MSC_VER >= 1600 && !defined _WEBSOCKETPP_NO_CPP11_MEMORY_
+    #ifndef _WEBSOCKETPP_CPP11_MEMORY_
+        #define _WEBSOCKETPP_CPP11_MEMORY_
+    #endif
+#endif
+
+
+
+#ifdef _WEBSOCKETPP_CPP11_MEMORY_
+    #include <memory>
+#else
+    #include <boost/shared_ptr.hpp>
+	#include <boost/make_shared.hpp>
+    #include <boost/scoped_array.hpp>
+    #include <boost/enable_shared_from_this.hpp>
+    #include <boost/pointer_cast.hpp>
+#endif
+
+namespace websocketpp {
+namespace lib {
+
+#ifdef _WEBSOCKETPP_CPP11_MEMORY_
+    using std::shared_ptr;
+    using std::weak_ptr;
+    using std::enable_shared_from_this;
+    using std::static_pointer_cast;
+    using std::make_shared;
+
+    typedef std::unique_ptr<unsigned char[]> unique_ptr_uchar_array;
+#else
+    using boost::shared_ptr;
+    using boost::weak_ptr;
+    using boost::enable_shared_from_this;
+    using boost::static_pointer_cast;
+    using boost::make_shared;
+
+    typedef boost::scoped_array<unsigned char> unique_ptr_uchar_array;
+#endif
+
+} // namespace lib
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_COMMON_MEMORY_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/network.hpp b/extlibs/websocketpp/websocketpp/common/network.hpp
new file mode 100644
index 000000000..3f9839665
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/network.hpp
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_NETWORK_HPP
+#define WEBSOCKETPP_COMMON_NETWORK_HPP
+
+// For ntohs and htons
+#if defined(_WIN32)
+    #include <winsock2.h>
+#else
+    //#include <arpa/inet.h>
+    #include <netinet/in.h>
+#endif
+
+namespace websocketpp {
+namespace lib {
+namespace net {
+
+inline bool is_little_endian() {
+    short int val = 0x1;
+    char *ptr = reinterpret_cast<char *>(&val);
+    return (ptr[0] == 1);
+}
+
+#define TYP_INIT 0
+#define TYP_SMLE 1
+#define TYP_BIGE 2
+
+/// Convert 64 bit value to network byte order
+/**
+ * This method is prefixed to avoid conflicts with operating system level
+ * macros for this functionality.
+ *
+ * TODO: figure out if it would be beneficial to use operating system level
+ * macros for this.
+ *
+ * @param src The integer in host byte order
+ * @return src converted to network byte order
+ */
+inline uint64_t _htonll(uint64_t src) {
+    static int typ = TYP_INIT;
+    unsigned char c;
+    union {
+        uint64_t ull;
+        unsigned char c[8];
+    } x;
+    if (typ == TYP_INIT) {
+        x.ull = 0x01;
+        typ = (x.c[7] == 0x01ULL) ? TYP_BIGE : TYP_SMLE;
+    }
+    if (typ == TYP_BIGE)
+        return src;
+    x.ull = src;
+    c = x.c[0]; x.c[0] = x.c[7]; x.c[7] = c;
+    c = x.c[1]; x.c[1] = x.c[6]; x.c[6] = c;
+    c = x.c[2]; x.c[2] = x.c[5]; x.c[5] = c;
+    c = x.c[3]; x.c[3] = x.c[4]; x.c[4] = c;
+    return x.ull;
+}
+
+/// Convert 64 bit value to host byte order
+/**
+ * This method is prefixed to avoid conflicts with operating system level
+ * macros for this functionality.
+ *
+ * TODO: figure out if it would be beneficial to use operating system level
+ * macros for this.
+ *
+ * @param src The integer in network byte order
+ * @return src converted to host byte order
+ */
+inline uint64_t _ntohll(uint64_t src) {
+    return _htonll(src);
+}
+
+} // net
+} // lib
+} // websocketpp
+
+#endif // WEBSOCKETPP_COMMON_NETWORK_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/platforms.hpp b/extlibs/websocketpp/websocketpp/common/platforms.hpp
new file mode 100644
index 000000000..877985777
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/platforms.hpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_PLATFORMS_HPP
+#define WEBSOCKETPP_COMMON_PLATFORMS_HPP
+
+/**
+ * This header contains any platform specific preprocessor adjustments that
+ * don't fit somewhere else better.
+ */
+
+#if defined(_WIN32) && !defined(NOMINMAX)
+    // don't define min and max macros that conflict with std::min and std::max
+    #define NOMINMAX
+#endif
+
+// Bump up the variadic parameter max for Visual Studio 2012
+#if defined(_MSC_VER) && _MSC_VER == 1700
+    #define _VARIADIC_MAX 8
+#endif
+
+#endif // WEBSOCKETPP_COMMON_PLATFORMS_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/random.hpp b/extlibs/websocketpp/websocketpp/common/random.hpp
new file mode 100644
index 000000000..689b89479
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/random.hpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_RANDOM_DEVICE_HPP
+#define WEBSOCKETPP_COMMON_RANDOM_DEVICE_HPP
+
+#include <websocketpp/common/cpp11.hpp>
+
+// If we've determined that we're in full C++11 mode and the user hasn't
+// explicitly disabled the use of C++11 random header, then prefer it to
+// boost.
+#if defined _WEBSOCKETPP_CPP11_INTERNAL_ && !defined _WEBSOCKETPP_NO_CPP11_RANDOM_DEVICE_
+    #ifndef _WEBSOCKETPP_CPP11_RANDOM_DEVICE_
+        #define _WEBSOCKETPP_CPP11_RANDOM_DEVICE_
+    #endif
+#endif
+
+
+// If we're on Visual Studio 2010 or higher and haven't explicitly disabled
+// the use of C++11 random header then prefer it to boost.
+#if defined(_MSC_VER) && _MSC_VER >= 1600 && !defined _WEBSOCKETPP_NO_CPP11_MEMORY_
+    #ifndef _WEBSOCKETPP_CPP11_MEMORY_
+        #define _WEBSOCKETPP_CPP11_MEMORY_
+    #endif
+#endif
+
+
+
+#ifdef _WEBSOCKETPP_CPP11_RANDOM_DEVICE_
+    #include <random>
+#else
+    #include <boost/version.hpp>
+
+    #if (BOOST_VERSION/100000) == 1 && ((BOOST_VERSION/100)%1000) > 46
+        #include <boost/random/uniform_int_distribution.hpp>
+        #include <boost/random/random_device.hpp>
+    #elif (BOOST_VERSION/100000) == 1 && ((BOOST_VERSION/100)%1000) >= 43
+        #include <boost/nondet_random.hpp>
+    #else
+        // TODO: static_assert(false, "Could not find a suitable random_device")
+    #endif
+#endif
+
+namespace websocketpp {
+namespace lib {
+
+    using std::random_device;
+    using std::uniform_int_distribution;
+
+} // namespace lib
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_COMMON_RANDOM_DEVICE_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/regex.hpp b/extlibs/websocketpp/websocketpp/common/regex.hpp
new file mode 100644
index 000000000..326635de2
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/regex.hpp
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_REGEX_HPP
+#define WEBSOCKETPP_COMMON_REGEX_HPP
+
+#if defined _WEBSOCKETPP_CPP11_STL_ && !defined _WEBSOCKETPP_NO_CPP11_REGEX_
+    #ifndef _WEBSOCKETPP_CPP11_REGEX_
+        #define _WEBSOCKETPP_CPP11_REGEX_
+    #endif
+#endif
+
+#ifdef _WEBSOCKETPP_CPP11_REGEX_
+    #include <regex>
+#else
+    #include <boost/regex.hpp>
+#endif
+
+namespace websocketpp {
+namespace lib {
+
+#ifdef _WEBSOCKETPP_CPP11_REGEX_
+    using std::cmatch;
+    using std::regex;
+    using std::regex_match;
+#else
+    using boost::cmatch;
+    using boost::regex;
+    using boost::regex_match;
+#endif
+
+} // namespace lib
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_COMMON_REGEX_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/stdint.hpp b/extlibs/websocketpp/websocketpp/common/stdint.hpp
new file mode 100644
index 000000000..ec48ea75b
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/stdint.hpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_STDINT_HPP
+#define WEBSOCKETPP_COMMON_STDINT_HPP
+
+#ifndef __STDC_LIMIT_MACROS
+    #define __STDC_LIMIT_MACROS 1
+#endif
+
+#if defined (_WIN32) && defined (_MSC_VER) && (_MSC_VER < 1600)
+    #include <boost/cstdint.hpp>
+
+    using boost::int8_t;
+    using boost::int_least8_t;
+    using boost::int_fast8_t;
+    using boost::uint8_t;
+    using boost::uint_least8_t;
+    using boost::uint_fast8_t;
+
+    using boost::int16_t;
+    using boost::int_least16_t;
+    using boost::int_fast16_t;
+    using boost::uint16_t;
+    using boost::uint_least16_t;
+    using boost::uint_fast16_t;
+
+    using boost::int32_t;
+    using boost::int_least32_t;
+    using boost::int_fast32_t;
+    using boost::uint32_t;
+    using boost::uint_least32_t;
+    using boost::uint_fast32_t;
+
+    #ifndef BOOST_NO_INT64_T
+    using boost::int64_t;
+    using boost::int_least64_t;
+    using boost::int_fast64_t;
+    using boost::uint64_t;
+    using boost::uint_least64_t;
+    using boost::uint_fast64_t;
+    #endif
+    using boost::intmax_t;
+    using boost::uintmax_t;
+#else
+    #include <stdint.h>
+#endif
+
+#endif // WEBSOCKETPP_COMMON_STDINT_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/system_error.hpp b/extlibs/websocketpp/websocketpp/common/system_error.hpp
new file mode 100644
index 000000000..4abe1732f
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/system_error.hpp
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_SYSTEM_ERROR_HPP
+#define WEBSOCKETPP_COMMON_SYSTEM_ERROR_HPP
+
+
+#include <websocketpp/common/cpp11.hpp>
+
+// If we've determined that we're in full C++11 mode and the user hasn't
+// explicitly disabled the use of C++11 system_error header, then prefer it to
+// boost.
+#if defined _WEBSOCKETPP_CPP11_INTERNAL_ && !defined _WEBSOCKETPP_NO_CPP11_SYSTEM_ERROR_
+    #ifndef _WEBSOCKETPP_CPP11_SYSTEM_ERROR_
+        #define _WEBSOCKETPP_CPP11_SYSTEM_ERROR_
+    #endif
+#endif
+
+// If we're on Visual Studio 2010 or higher and haven't explicitly disabled
+// the use of C++11 system_error header then prefer it to boost.
+#if defined(_MSC_VER) && _MSC_VER >= 1600 && !defined _WEBSOCKETPP_NO_CPP11_SYSTEM_ERROR_
+    #ifndef _WEBSOCKETPP_CPP11_SYSTEM_ERROR_
+        #define _WEBSOCKETPP_CPP11_SYSTEM_ERROR_
+    #endif
+#endif
+
+
+
+#ifdef _WEBSOCKETPP_CPP11_SYSTEM_ERROR_
+    #include <system_error>
+#else
+    #include <boost/system/error_code.hpp>
+    #include <boost/system/system_error.hpp>
+#endif
+
+namespace websocketpp {
+namespace lib {
+
+#ifdef _WEBSOCKETPP_CPP11_SYSTEM_ERROR_
+    using std::error_code;
+    using std::error_category;
+    using std::error_condition;
+    using std::system_error;
+    #define _WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_ namespace std {
+    #define _WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_ }
+#else
+    using boost::system::error_code;
+    using boost::system::error_category;
+    using boost::system::error_condition;
+    using boost::system::system_error;
+    #define _WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_ namespace boost { namespace system {
+    #define _WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_ }}
+#endif
+
+} // namespace lib
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_COMMON_SYSTEM_ERROR_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/thread.hpp b/extlibs/websocketpp/websocketpp/common/thread.hpp
new file mode 100644
index 000000000..fa87396f9
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/thread.hpp
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2015, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_THREAD_HPP
+#define WEBSOCKETPP_COMMON_THREAD_HPP
+
+#include <websocketpp/common/cpp11.hpp>
+
+// If we autodetect C++11 and haven't been explicitly instructed to not use
+// C++11 threads, then set the defines that instructs the rest of this header
+// to use C++11 <thread> and <mutex>
+#if defined _WEBSOCKETPP_CPP11_INTERNAL_ && !defined _WEBSOCKETPP_NO_CPP11_THREAD_
+    // MinGW by default does not support C++11 thread/mutex so even if the
+    // internal check for C++11 passes, ignore it if we are on MinGW
+    #if (!defined(__MINGW32__) && !defined(__MINGW64__))
+        #ifndef _WEBSOCKETPP_CPP11_THREAD_
+            #define _WEBSOCKETPP_CPP11_THREAD_
+        #endif
+    #endif
+#endif
+
+#ifdef _WEBSOCKETPP_CPP11_THREAD_
+    #include <thread>
+    #include <mutex>
+    #include <condition_variable>
+#else
+    #include <boost/thread.hpp>
+    #include <boost/thread/mutex.hpp>
+    #include <boost/thread/condition_variable.hpp>
+#endif
+
+namespace websocketpp {
+namespace lib {
+
+#ifdef _WEBSOCKETPP_CPP11_THREAD_
+    using std::mutex;
+    using std::lock_guard;
+    using std::thread;
+    using std::unique_lock;
+    using std::condition_variable;
+#else
+    using boost::mutex;
+    using boost::lock_guard;
+    using boost::thread;
+    using boost::unique_lock;
+    using boost::condition_variable;
+#endif
+
+} // namespace lib
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_COMMON_THREAD_HPP
diff --git a/extlibs/websocketpp/websocketpp/common/time.hpp b/extlibs/websocketpp/websocketpp/common/time.hpp
new file mode 100644
index 000000000..571688e1b
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/common/time.hpp
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_COMMON_TIME_HPP
+#define WEBSOCKETPP_COMMON_TIME_HPP
+
+#include <ctime>
+
+namespace websocketpp {
+namespace lib {
+
+// Code in this header was inspired by the following article and includes some
+// code from the related project g2log. The g2log code is public domain licensed
+// http://kjellkod.wordpress.com/2013/01/22/exploring-c11-part-2-localtime-and-time-again/
+
+/// Thread safe cross platform localtime
+inline std::tm localtime(std::time_t const & time) {
+    std::tm tm_snapshot;
+#if (defined(__MINGW32__) || defined(__MINGW64__))
+    memcpy(&tm_snapshot, ::localtime(&time), sizeof(std::tm));
+#elif (defined(WIN32) || defined(_WIN32) || defined(__WIN32__))
+    localtime_s(&tm_snapshot, &time); 
+#else
+    localtime_r(&time, &tm_snapshot); // POSIX  
+#endif
+    return tm_snapshot;
+}
+
+} // lib
+} // websocketpp
+
+#endif // WEBSOCKETPP_COMMON_TIME_HPP
diff --git a/extlibs/websocketpp/websocketpp/concurrency/basic.hpp b/extlibs/websocketpp/websocketpp/concurrency/basic.hpp
new file mode 100644
index 000000000..1943ad77a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/concurrency/basic.hpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONCURRENCY_BASIC_HPP
+#define WEBSOCKETPP_CONCURRENCY_BASIC_HPP
+
+#include <websocketpp/common/thread.hpp>
+
+namespace websocketpp {
+namespace concurrency {
+
+/// Concurrency policy that uses std::mutex / boost::mutex
+class basic {
+public:
+    typedef lib::mutex mutex_type;
+    typedef lib::lock_guard<mutex_type> scoped_lock_type;
+};
+
+} // namespace concurrency
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONCURRENCY_BASIC_HPP
diff --git a/extlibs/websocketpp/websocketpp/concurrency/none.hpp b/extlibs/websocketpp/websocketpp/concurrency/none.hpp
new file mode 100644
index 000000000..da9aa4112
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/concurrency/none.hpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONCURRENCY_NONE_HPP
+#define WEBSOCKETPP_CONCURRENCY_NONE_HPP
+
+namespace websocketpp {
+
+/// Concurrency handling support
+namespace concurrency {
+
+/// Implementation for no-op locking primitives
+namespace none_impl {
+/// A fake mutex implementation that does nothing
+class fake_mutex {
+public:
+    fake_mutex() {}
+    ~fake_mutex() {}
+};
+
+/// A fake lock guard implementation that does nothing
+class fake_lock_guard {
+public:
+    explicit fake_lock_guard(fake_mutex) {}
+    ~fake_lock_guard() {}
+};
+} // namespace none_impl
+
+/// Stub concurrency policy that implements the interface using no-ops.
+/**
+ * This policy documents the concurrency policy interface using no-ops. It can
+ * be used as a reference or base for building a new concurrency policy. It can
+ * also be used as is to disable all locking for endpoints used in purely single
+ * threaded programs.
+ */
+class none {
+public:
+    /// The type of a mutex primitive
+    /**
+     * std::mutex is an example.
+     */
+    typedef none_impl::fake_mutex mutex_type;
+
+    /// The type of a scoped/RAII lock primitive.
+    /**
+     * The scoped lock constructor should take a mutex_type as a parameter,
+     * acquire that lock, and release it in its destructor. std::lock_guard is
+     * an example.
+     */
+    typedef none_impl::fake_lock_guard scoped_lock_type;
+};
+
+} // namespace concurrency
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONCURRENCY_ASYNC_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/asio.hpp b/extlibs/websocketpp/websocketpp/config/asio.hpp
new file mode 100644
index 000000000..d28d0fb80
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/asio.hpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_ASIO_TLS_HPP
+#define WEBSOCKETPP_CONFIG_ASIO_TLS_HPP
+
+#include <websocketpp/config/core.hpp>
+#include <websocketpp/transport/asio/endpoint.hpp>
+#include <websocketpp/transport/asio/security/tls.hpp>
+
+// Pull in non-tls config
+#include <websocketpp/config/asio_no_tls.hpp>
+
+// Define TLS config
+namespace websocketpp {
+namespace config {
+
+/// Server config with asio transport and TLS enabled
+struct asio_tls : public core {
+    typedef asio_tls type;
+    typedef core base;
+
+    typedef base::concurrency_type concurrency_type;
+
+    typedef base::request_type request_type;
+    typedef base::response_type response_type;
+
+    typedef base::message_type message_type;
+    typedef base::con_msg_manager_type con_msg_manager_type;
+    typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef base::alog_type alog_type;
+    typedef base::elog_type elog_type;
+
+    typedef base::rng_type rng_type;
+
+    struct transport_config : public base::transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::alog_type alog_type;
+        typedef type::elog_type elog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+        typedef websocketpp::transport::asio::tls_socket::endpoint socket_type;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_ASIO_TLS_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/asio_client.hpp b/extlibs/websocketpp/websocketpp/config/asio_client.hpp
new file mode 100644
index 000000000..1cb594d0a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/asio_client.hpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_ASIO_TLS_CLIENT_HPP
+#define WEBSOCKETPP_CONFIG_ASIO_TLS_CLIENT_HPP
+
+#include <websocketpp/config/core_client.hpp>
+#include <websocketpp/transport/asio/endpoint.hpp>
+#include <websocketpp/transport/asio/security/tls.hpp>
+
+// Pull in non-tls config
+#include <websocketpp/config/asio_no_tls_client.hpp>
+
+// Define TLS config
+namespace websocketpp {
+namespace config {
+
+/// Client config with asio transport and TLS enabled
+struct asio_tls_client : public core_client {
+    typedef asio_tls_client type;
+    typedef core_client base;
+
+    typedef base::concurrency_type concurrency_type;
+
+    typedef base::request_type request_type;
+    typedef base::response_type response_type;
+
+    typedef base::message_type message_type;
+    typedef base::con_msg_manager_type con_msg_manager_type;
+    typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef base::alog_type alog_type;
+    typedef base::elog_type elog_type;
+
+    typedef base::rng_type rng_type;
+
+    struct transport_config : public base::transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::alog_type alog_type;
+        typedef type::elog_type elog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+        typedef websocketpp::transport::asio::tls_socket::endpoint socket_type;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_ASIO_TLS_CLIENT_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/asio_no_tls.hpp b/extlibs/websocketpp/websocketpp/config/asio_no_tls.hpp
new file mode 100644
index 000000000..6c1357fba
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/asio_no_tls.hpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_ASIO_HPP
+#define WEBSOCKETPP_CONFIG_ASIO_HPP
+
+#include <websocketpp/config/core.hpp>
+#include <websocketpp/transport/asio/endpoint.hpp>
+
+namespace websocketpp {
+namespace config {
+
+/// Server config with asio transport and TLS disabled
+struct asio : public core {
+    typedef asio type;
+    typedef core base;
+
+    typedef base::concurrency_type concurrency_type;
+
+    typedef base::request_type request_type;
+    typedef base::response_type response_type;
+
+    typedef base::message_type message_type;
+    typedef base::con_msg_manager_type con_msg_manager_type;
+    typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef base::alog_type alog_type;
+    typedef base::elog_type elog_type;
+
+    typedef base::rng_type rng_type;
+
+    struct transport_config : public base::transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::alog_type alog_type;
+        typedef type::elog_type elog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+        typedef websocketpp::transport::asio::basic_socket::endpoint
+            socket_type;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_ASIO_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/asio_no_tls_client.hpp b/extlibs/websocketpp/websocketpp/config/asio_no_tls_client.hpp
new file mode 100644
index 000000000..6e3f7ba0e
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/asio_no_tls_client.hpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_ASIO_CLIENT_HPP
+#define WEBSOCKETPP_CONFIG_ASIO_CLIENT_HPP
+
+#include <websocketpp/config/core_client.hpp>
+#include <websocketpp/transport/asio/endpoint.hpp>
+
+namespace websocketpp {
+namespace config {
+
+/// Client config with asio transport and TLS disabled
+struct asio_client : public core_client {
+    typedef asio_client type;
+    typedef core_client base;
+
+    typedef base::concurrency_type concurrency_type;
+
+    typedef base::request_type request_type;
+    typedef base::response_type response_type;
+
+    typedef base::message_type message_type;
+    typedef base::con_msg_manager_type con_msg_manager_type;
+    typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef base::alog_type alog_type;
+    typedef base::elog_type elog_type;
+
+    typedef base::rng_type rng_type;
+
+    struct transport_config : public base::transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::alog_type alog_type;
+        typedef type::elog_type elog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+        typedef websocketpp::transport::asio::basic_socket::endpoint
+            socket_type;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_ASIO_CLIENT_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/boost_config.hpp b/extlibs/websocketpp/websocketpp/config/boost_config.hpp
new file mode 100644
index 000000000..57671ccda
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/boost_config.hpp
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+ // This header defines WebSocket++ macros for C++11 compatibility based on the 
+ // Boost.Config library. This will correctly configure most target platforms
+ // simply by including this header before any other WebSocket++ header.
+
+#ifndef WEBSOCKETPP_CONFIG_BOOST_CONFIG_HPP
+#define WEBSOCKETPP_CONFIG_BOOST_CONFIG_HPP
+
+#include <boost/config.hpp>
+
+//  _WEBSOCKETPP_CPP11_MEMORY_ and _WEBSOCKETPP_CPP11_FUNCTIONAL_ presently
+//  only work if either both or neither is defined.
+#if !defined BOOST_NO_CXX11_SMART_PTR && !defined BOOST_NO_CXX11_HDR_FUNCTIONAL
+    #define _WEBSOCKETPP_CPP11_MEMORY_
+    #define _WEBSOCKETPP_CPP11_FUNCTIONAL_
+#endif
+
+#ifdef BOOST_ASIO_HAS_STD_CHRONO
+    #define _WEBSOCKETPP_CPP11_CHRONO_
+#endif
+
+#ifndef BOOST_NO_CXX11_HDR_RANDOM
+    #define _WEBSOCKETPP_CPP11_RANDOM_DEVICE_
+#endif
+
+#ifndef BOOST_NO_CXX11_HDR_REGEX
+    #define _WEBSOCKETPP_CPP11_REGEX_
+#endif
+
+#ifndef BOOST_NO_CXX11_HDR_SYSTEM_ERROR
+    #define _WEBSOCKETPP_CPP11_SYSTEM_ERROR_
+#endif
+
+#ifndef BOOST_NO_CXX11_HDR_THREAD
+    #define _WEBSOCKETPP_CPP11_THREAD_
+#endif
+
+#ifndef BOOST_NO_CXX11_HDR_INITIALIZER_LIST
+    #define _WEBSOCKETPP_INITIALIZER_LISTS_
+#endif
+
+#define _WEBSOCKETPP_NOEXCEPT_TOKEN_  BOOST_NOEXCEPT
+#define _WEBSOCKETPP_CONSTEXPR_TOKEN_  BOOST_CONSTEXPR
+// TODO: nullptr support
+
+#endif // WEBSOCKETPP_CONFIG_BOOST_CONFIG_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/core.hpp b/extlibs/websocketpp/websocketpp/config/core.hpp
new file mode 100644
index 000000000..a95b4021d
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/core.hpp
@@ -0,0 +1,285 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_CORE_HPP
+#define WEBSOCKETPP_CONFIG_CORE_HPP
+
+// Non-Policy common stuff
+#include <websocketpp/common/platforms.hpp>
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/stdint.hpp>
+
+// Concurrency
+#include <websocketpp/concurrency/basic.hpp>
+
+// Transport
+#include <websocketpp/transport/iostream/endpoint.hpp>
+
+// HTTP
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+
+// Messages
+#include <websocketpp/message_buffer/message.hpp>
+#include <websocketpp/message_buffer/alloc.hpp>
+
+// Loggers
+#include <websocketpp/logger/basic.hpp>
+
+// RNG
+#include <websocketpp/random/none.hpp>
+
+// User stub base classes
+#include <websocketpp/endpoint_base.hpp>
+#include <websocketpp/connection_base.hpp>
+
+// Extensions
+#include <websocketpp/extensions/permessage_deflate/disabled.hpp>
+
+namespace websocketpp {
+namespace config {
+
+/// Server config with iostream transport
+struct core {
+    typedef core type;
+
+    // Concurrency policy
+    typedef websocketpp::concurrency::basic concurrency_type;
+
+    // HTTP Parser Policies
+    typedef http::parser::request request_type;
+    typedef http::parser::response response_type;
+
+    // Message Policies
+    typedef message_buffer::message<message_buffer::alloc::con_msg_manager>
+        message_type;
+    typedef message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_manager_type;
+    typedef message_buffer::alloc::endpoint_msg_manager<con_msg_manager_type>
+        endpoint_msg_manager_type;
+
+    /// Logging policies
+    typedef websocketpp::log::basic<concurrency_type,
+        websocketpp::log::elevel> elog_type;
+    typedef websocketpp::log::basic<concurrency_type,
+        websocketpp::log::alevel> alog_type;
+
+    /// RNG policies
+    typedef websocketpp::random::none::int_generator<uint32_t> rng_type;
+
+    /// Controls compile time enabling/disabling of thread syncronization
+    /// code Disabling can provide a minor performance improvement to single
+    /// threaded applications
+    static bool const enable_multithreading = true;
+
+    struct transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::elog_type elog_type;
+        typedef type::alog_type alog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+
+        /// Controls compile time enabling/disabling of thread syncronization
+        /// code Disabling can provide a minor performance improvement to single
+        /// threaded applications
+        static bool const enable_multithreading = true;
+
+        /// Default timer values (in ms)
+
+        /// Length of time to wait for socket pre-initialization
+        /**
+         * Exactly what this includes depends on the socket policy in use
+         */
+        static const long timeout_socket_pre_init = 5000;
+
+        /// Length of time to wait before a proxy handshake is aborted
+        static const long timeout_proxy = 5000;
+
+        /// Length of time to wait for socket post-initialization
+        /**
+         * Exactly what this includes depends on the socket policy in use.
+         * Often this means the TLS handshake
+         */
+        static const long timeout_socket_post_init = 5000;
+
+        /// Length of time to wait for dns resolution
+        static const long timeout_dns_resolve = 5000;
+
+        /// Length of time to wait for TCP connect
+        static const long timeout_connect = 5000;
+
+        /// Length of time to wait for socket shutdown
+        static const long timeout_socket_shutdown = 5000;
+    };
+
+    /// Transport Endpoint Component
+    typedef websocketpp::transport::iostream::endpoint<transport_config>
+        transport_type;
+
+    /// User overridable Endpoint base class
+    typedef websocketpp::endpoint_base endpoint_base;
+    /// User overridable Connection base class
+    typedef websocketpp::connection_base connection_base;
+
+    /// Default timer values (in ms)
+
+    /// Length of time before an opening handshake is aborted
+    static const long timeout_open_handshake = 5000;
+    /// Length of time before a closing handshake is aborted
+    static const long timeout_close_handshake = 5000;
+    /// Length of time to wait for a pong after a ping
+    static const long timeout_pong = 5000;
+
+    /// WebSocket Protocol version to use as a client
+    /**
+     * What version of the WebSocket Protocol to use for outgoing client
+     * connections. Setting this to a value other than 13 (RFC6455) is not
+     * recommended.
+     */
+    static const int client_version = 13; // RFC6455
+
+    /// Default static error logging channels
+    /**
+     * Which error logging channels to enable at compile time. Channels not
+     * enabled here will be unable to be selected by programs using the library.
+     * This option gives an optimizing compiler the ability to remove entirely
+     * code to test whether or not to print out log messages on a certain
+     * channel
+     *
+     * Default is all except for development/debug level errors
+     */
+    static const websocketpp::log::level elog_level =
+        websocketpp::log::elevel::all ^ websocketpp::log::elevel::devel;
+
+    /// Default static access logging channels
+    /**
+     * Which access logging channels to enable at compile time. Channels not
+     * enabled here will be unable to be selected by programs using the library.
+     * This option gives an optimizing compiler the ability to remove entirely
+     * code to test whether or not to print out log messages on a certain
+     * channel
+     *
+     * Default is all except for development/debug level access messages
+     */
+    static const websocketpp::log::level alog_level =
+        websocketpp::log::alevel::all ^ websocketpp::log::alevel::devel;
+
+    ///
+    static const size_t connection_read_buffer_size = 16384;
+
+    /// Drop connections immediately on protocol error.
+    /**
+     * Drop connections on protocol error rather than sending a close frame.
+     * Off by default. This may result in legit messages near the error being
+     * dropped as well. It may free up resources otherwise spent dealing with
+     * misbehaving clients.
+     */
+    static const bool drop_on_protocol_error = false;
+
+    /// Suppresses the return of detailed connection close information
+    /**
+     * Silence close suppresses the return of detailed connection close
+     * information during the closing handshake. This information is useful
+     * for debugging and presenting useful errors to end users but may be
+     * undesirable for security reasons in some production environments.
+     * Close reasons could be used by an attacker to confirm that the endpoint
+     * is out of resources or be used to identify the WebSocket implementation
+     * in use.
+     *
+     * Note: this will suppress *all* close codes, including those explicitly
+     * sent by local applications.
+     */
+    static const bool silent_close = false;
+
+    /// Default maximum message size
+    /**
+     * Default value for the processor's maximum message size. Maximum message size
+     * determines the point at which the library will fail a connection with the 
+     * message_too_big protocol error.
+     *
+     * The default is 32MB
+     *
+     * @since 0.3.0
+     */
+    static const size_t max_message_size = 32000000;
+    
+    /// Default maximum http body size
+    /**
+     * Default value for the http parser's maximum body size. Maximum body size
+     * determines the point at which the library will abort reading an HTTP
+     * connection with the 413/request entity too large error.
+     *
+     * The default is 32MB
+     *
+     * @since 0.5.0
+     */
+    static const size_t max_http_body_size = 32000000;
+
+    /// Global flag for enabling/disabling extensions
+    static const bool enable_extensions = true;
+
+    /// Extension specific settings:
+
+    /// permessage_compress extension
+    struct permessage_deflate_config {
+        typedef core::request_type request_type;
+
+        /// If the remote endpoint requests that we reset the compression
+        /// context after each message should we honor the request?
+        static const bool allow_disabling_context_takeover = true;
+
+        /// If the remote endpoint requests that we reduce the size of the
+        /// LZ77 sliding window size this is the lowest value that will be
+        /// allowed. Values range from 8 to 15. A value of 8 means we will
+        /// allow any possible window size. A value of 15 means do not allow
+        /// negotiation of the window size (ie require the default).
+        static const uint8_t minimum_outgoing_window_bits = 8;
+    };
+
+    typedef websocketpp::extensions::permessage_deflate::disabled
+        <permessage_deflate_config> permessage_deflate_type;
+
+    /// Autonegotiate permessage-deflate
+    /**
+     * Automatically enables the permessage-deflate extension.
+     *
+     * For clients this results in a permessage-deflate extension request being
+     * sent with every request rather than requiring it to be requested manually
+     *
+     * For servers this results in accepting the first set of extension settings
+     * requested by the client that we understand being used. The alternative is
+     * requiring the extension to be manually negotiated in `validate`. With
+     * auto-negotiate on, you may still override the auto-negotiate manually if
+     * needed.
+     */
+    //static const bool autonegotiate_compression = false;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_CORE_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/core_client.hpp b/extlibs/websocketpp/websocketpp/config/core_client.hpp
new file mode 100644
index 000000000..dadf8a4e7
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/core_client.hpp
@@ -0,0 +1,294 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_CORE_CLIENT_HPP
+#define WEBSOCKETPP_CONFIG_CORE_CLIENT_HPP
+
+// Non-Policy common stuff
+#include <websocketpp/common/platforms.hpp>
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/stdint.hpp>
+
+// Concurrency
+#ifndef _WEBSOCKETPP_NO_THREADING_
+#include <websocketpp/concurrency/basic.hpp>
+#else
+#include <websocketpp/concurrency/none.hpp>
+#endif
+
+// Transport
+#include <websocketpp/transport/iostream/endpoint.hpp>
+
+// HTTP
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+
+// Messages
+#include <websocketpp/message_buffer/message.hpp>
+#include <websocketpp/message_buffer/alloc.hpp>
+
+// Loggers
+#include <websocketpp/logger/basic.hpp>
+
+// RNG
+#include <websocketpp/random/random_device.hpp>
+
+// User stub base classes
+#include <websocketpp/endpoint_base.hpp>
+#include <websocketpp/connection_base.hpp>
+
+// Extensions
+#include <websocketpp/extensions/permessage_deflate/disabled.hpp>
+
+namespace websocketpp {
+namespace config {
+
+/// Client config with iostream transport
+struct core_client {
+    typedef core_client type;
+
+    // Concurrency policy
+#ifndef _WEBSOCKETPP_NO_THREADING_
+    typedef websocketpp::concurrency::basic concurrency_type;
+#else
+    typedef websocketpp::concurrency::none concurrency_type;
+#endif
+
+    // HTTP Parser Policies
+    typedef http::parser::request request_type;
+    typedef http::parser::response response_type;
+
+    // Message Policies
+    typedef message_buffer::message<message_buffer::alloc::con_msg_manager>
+        message_type;
+    typedef message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_manager_type;
+    typedef message_buffer::alloc::endpoint_msg_manager<con_msg_manager_type>
+        endpoint_msg_manager_type;
+
+    /// Logging policies
+    typedef websocketpp::log::basic<concurrency_type,
+        websocketpp::log::elevel> elog_type;
+    typedef websocketpp::log::basic<concurrency_type,
+        websocketpp::log::alevel> alog_type;
+
+    /// RNG policies
+    typedef websocketpp::random::random_device::int_generator<uint32_t,
+        concurrency_type> rng_type;
+
+    /// Controls compile time enabling/disabling of thread syncronization code
+    /// Disabling can provide a minor performance improvement to single threaded
+    /// applications
+    static bool const enable_multithreading = true;
+
+    struct transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::elog_type elog_type;
+        typedef type::alog_type alog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+
+        /// Controls compile time enabling/disabling of thread syncronization
+        /// code Disabling can provide a minor performance improvement to single
+        /// threaded applications
+        static bool const enable_multithreading = true;
+
+        /// Default timer values (in ms)
+
+        /// Length of time to wait for socket pre-initialization
+        /**
+         * Exactly what this includes depends on the socket policy in use
+         */
+        static const long timeout_socket_pre_init = 5000;
+
+        /// Length of time to wait before a proxy handshake is aborted
+        static const long timeout_proxy = 5000;
+
+        /// Length of time to wait for socket post-initialization
+        /**
+         * Exactly what this includes depends on the socket policy in use.
+         * Often this means the TLS handshake
+         */
+        static const long timeout_socket_post_init = 5000;
+
+        /// Length of time to wait for dns resolution
+        static const long timeout_dns_resolve = 5000;
+
+        /// Length of time to wait for TCP connect
+        static const long timeout_connect = 5000;
+
+        /// Length of time to wait for socket shutdown
+        static const long timeout_socket_shutdown = 5000;
+    };
+
+    /// Transport Endpoint Component
+    typedef websocketpp::transport::iostream::endpoint<transport_config>
+        transport_type;
+
+    /// User overridable Endpoint base class
+    typedef websocketpp::endpoint_base endpoint_base;
+    /// User overridable Connection base class
+    typedef websocketpp::connection_base connection_base;
+
+    /// Default timer values (in ms)
+
+    /// Length of time before an opening handshake is aborted
+    static const long timeout_open_handshake = 5000;
+    /// Length of time before a closing handshake is aborted
+    static const long timeout_close_handshake = 5000;
+    /// Length of time to wait for a pong after a ping
+    static const long timeout_pong = 5000;
+
+    /// WebSocket Protocol version to use as a client
+    /**
+     * What version of the WebSocket Protocol to use for outgoing client
+     * connections. Setting this to a value other than 13 (RFC6455) is not
+     * recommended.
+     */
+    static const int client_version = 13; // RFC6455
+
+    /// Default static error logging channels
+    /**
+     * Which error logging channels to enable at compile time. Channels not
+     * enabled here will be unable to be selected by programs using the library.
+     * This option gives an optimizing compiler the ability to remove entirely
+     * code to test whether or not to print out log messages on a certain
+     * channel
+     *
+     * Default is all except for development/debug level errors
+     */
+    static const websocketpp::log::level elog_level =
+        websocketpp::log::elevel::all ^ websocketpp::log::elevel::devel;
+
+    /// Default static access logging channels
+    /**
+     * Which access logging channels to enable at compile time. Channels not
+     * enabled here will be unable to be selected by programs using the library.
+     * This option gives an optimizing compiler the ability to remove entirely
+     * code to test whether or not to print out log messages on a certain
+     * channel
+     *
+     * Default is all except for development/debug level access messages
+     */
+    static const websocketpp::log::level alog_level =
+        websocketpp::log::alevel::all ^ websocketpp::log::alevel::devel;
+
+    ///
+    static const size_t connection_read_buffer_size = 16384;
+
+    /// Drop connections immediately on protocol error.
+    /**
+     * Drop connections on protocol error rather than sending a close frame.
+     * Off by default. This may result in legit messages near the error being
+     * dropped as well. It may free up resources otherwise spent dealing with
+     * misbehaving clients.
+     */
+    static const bool drop_on_protocol_error = false;
+
+    /// Suppresses the return of detailed connection close information
+    /**
+     * Silence close suppresses the return of detailed connection close
+     * information during the closing handshake. This information is useful
+     * for debugging and presenting useful errors to end users but may be
+     * undesirable for security reasons in some production environments.
+     * Close reasons could be used by an attacker to confirm that the endpoint
+     * is out of resources or be used to identify the WebSocket implementation
+     * in use.
+     *
+     * Note: this will suppress *all* close codes, including those explicitly
+     * sent by local applications.
+     */
+    static const bool silent_close = false;
+
+    /// Default maximum message size
+    /**
+     * Default value for the processor's maximum message size. Maximum message size
+     * determines the point at which the library will fail a connection with the 
+     * message_too_big protocol error.
+     *
+     * The default is 32MB
+     *
+     * @since 0.3.0
+     */
+    static const size_t max_message_size = 32000000;
+
+    /// Default maximum http body size
+    /**
+     * Default value for the http parser's maximum body size. Maximum body size
+     * determines the point at which the library will abort reading an HTTP
+     * connection with the 413/request entity too large error.
+     *
+     * The default is 32MB
+     *
+     * @since 0.5.0
+     */
+    static const size_t max_http_body_size = 32000000;
+
+    /// Global flag for enabling/disabling extensions
+    static const bool enable_extensions = true;
+
+    /// Extension specific settings:
+
+    /// permessage_deflate extension
+    struct permessage_deflate_config {
+        typedef core_client::request_type request_type;
+
+        /// If the remote endpoint requests that we reset the compression
+        /// context after each message should we honor the request?
+        static const bool allow_disabling_context_takeover = true;
+
+        /// If the remote endpoint requests that we reduce the size of the
+        /// LZ77 sliding window size this is the lowest value that will be
+        /// allowed. Values range from 8 to 15. A value of 8 means we will
+        /// allow any possible window size. A value of 15 means do not allow
+        /// negotiation of the window size (ie require the default).
+        static const uint8_t minimum_outgoing_window_bits = 8;
+    };
+
+    typedef websocketpp::extensions::permessage_deflate::disabled
+        <permessage_deflate_config> permessage_deflate_type;
+
+    /// Autonegotiate permessage-compress
+    /**
+     * Automatically enables the permessage-compress extension.
+     *
+     * For clients this results in a permessage-compress extension request being
+     * sent with every request rather than requiring it to be requested manually
+     *
+     * For servers this results in accepting the first set of extension settings
+     * requested by the client that we understand being used. The alternative is
+     * requiring the extension to be manually negotiated in `validate`. With
+     * auto-negotiate on, you may still override the auto-negotiate manually if
+     * needed.
+     */
+    //static const bool autonegotiate_compression = false;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_CORE_CLIENT_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/debug.hpp b/extlibs/websocketpp/websocketpp/config/debug.hpp
new file mode 100644
index 000000000..223f72fbb
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/debug.hpp
@@ -0,0 +1,286 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_DEBUG_HPP
+#define WEBSOCKETPP_CONFIG_DEBUG_HPP
+
+
+
+// Non-Policy common stuff
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/stdint.hpp>
+
+// Concurrency
+#include <websocketpp/concurrency/basic.hpp>
+
+// Transport
+#include <websocketpp/transport/iostream/endpoint.hpp>
+
+// HTTP
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+
+// Messages
+#include <websocketpp/message_buffer/message.hpp>
+#include <websocketpp/message_buffer/alloc.hpp>
+
+// Loggers
+#include <websocketpp/logger/basic.hpp>
+
+// RNG
+#include <websocketpp/random/none.hpp>
+
+// User stub base classes
+#include <websocketpp/endpoint_base.hpp>
+#include <websocketpp/connection_base.hpp>
+
+// Extensions
+#include <websocketpp/extensions/permessage_deflate/disabled.hpp>
+
+namespace websocketpp {
+namespace config {
+
+/// Client/Server debug config with iostream transport
+struct debug_core {
+    typedef debug_core type;
+
+    // Concurrency policy
+    typedef websocketpp::concurrency::basic concurrency_type;
+
+    // HTTP Parser Policies
+    typedef http::parser::request request_type;
+    typedef http::parser::response response_type;
+
+    // Message Policies
+    typedef message_buffer::message<message_buffer::alloc::con_msg_manager>
+        message_type;
+    typedef message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_manager_type;
+    typedef message_buffer::alloc::endpoint_msg_manager<con_msg_manager_type>
+        endpoint_msg_manager_type;
+
+    /// Logging policies
+    typedef websocketpp::log::basic<concurrency_type,
+        websocketpp::log::elevel> elog_type;
+    typedef websocketpp::log::basic<concurrency_type,
+        websocketpp::log::alevel> alog_type;
+
+    /// RNG policies
+    typedef websocketpp::random::none::int_generator<uint32_t> rng_type;
+
+    /// Controls compile time enabling/disabling of thread syncronization
+    /// code Disabling can provide a minor performance improvement to single
+    /// threaded applications
+    static bool const enable_multithreading = true;
+
+    struct transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::elog_type elog_type;
+        typedef type::alog_type alog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+
+        /// Controls compile time enabling/disabling of thread syncronization
+        /// code Disabling can provide a minor performance improvement to single
+        /// threaded applications
+        static bool const enable_multithreading = true;
+
+        /// Default timer values (in ms)
+
+        /// Length of time to wait for socket pre-initialization
+        /**
+         * Exactly what this includes depends on the socket policy in use
+         */
+        static const long timeout_socket_pre_init = 5000;
+
+        /// Length of time to wait before a proxy handshake is aborted
+        static const long timeout_proxy = 5000;
+
+        /// Length of time to wait for socket post-initialization
+        /**
+         * Exactly what this includes depends on the socket policy in use.
+         * Often this means the TLS handshake
+         */
+        static const long timeout_socket_post_init = 5000;
+
+        /// Length of time to wait for dns resolution
+        static const long timeout_dns_resolve = 5000;
+
+        /// Length of time to wait for TCP connect
+        static const long timeout_connect = 5000;
+
+        /// Length of time to wait for socket shutdown
+        static const long timeout_socket_shutdown = 5000;
+    };
+
+    /// Transport Endpoint Component
+    typedef websocketpp::transport::iostream::endpoint<transport_config>
+        transport_type;
+
+    /// User overridable Endpoint base class
+    typedef websocketpp::endpoint_base endpoint_base;
+    /// User overridable Connection base class
+    typedef websocketpp::connection_base connection_base;
+
+    /// Default timer values (in ms)
+
+    /// Length of time before an opening handshake is aborted
+    static const long timeout_open_handshake = 5000;
+    /// Length of time before a closing handshake is aborted
+    static const long timeout_close_handshake = 5000;
+    /// Length of time to wait for a pong after a ping
+    static const long timeout_pong = 5000;
+
+    /// WebSocket Protocol version to use as a client
+    /**
+     * What version of the WebSocket Protocol to use for outgoing client
+     * connections. Setting this to a value other than 13 (RFC6455) is not
+     * recommended.
+     */
+    static const int client_version = 13; // RFC6455
+
+    /// Default static error logging channels
+    /**
+     * Which error logging channels to enable at compile time. Channels not
+     * enabled here will be unable to be selected by programs using the library.
+     * This option gives an optimizing compiler the ability to remove entirely
+     * code to test whether or not to print out log messages on a certain
+     * channel
+     *
+     * Default is all except for development/debug level errors
+     */
+    static const websocketpp::log::level elog_level =
+        websocketpp::log::elevel::all;
+
+    /// Default static access logging channels
+    /**
+     * Which access logging channels to enable at compile time. Channels not
+     * enabled here will be unable to be selected by programs using the library.
+     * This option gives an optimizing compiler the ability to remove entirely
+     * code to test whether or not to print out log messages on a certain
+     * channel
+     *
+     * Default is all except for development/debug level access messages
+     */
+    static const websocketpp::log::level alog_level =
+        websocketpp::log::alevel::all;
+
+    ///
+    static const size_t connection_read_buffer_size = 16384;
+
+    /// Drop connections immediately on protocol error.
+    /**
+     * Drop connections on protocol error rather than sending a close frame.
+     * Off by default. This may result in legit messages near the error being
+     * dropped as well. It may free up resources otherwise spent dealing with
+     * misbehaving clients.
+     */
+    static const bool drop_on_protocol_error = false;
+
+    /// Suppresses the return of detailed connection close information
+    /**
+     * Silence close suppresses the return of detailed connection close
+     * information during the closing handshake. This information is useful
+     * for debugging and presenting useful errors to end users but may be
+     * undesirable for security reasons in some production environments.
+     * Close reasons could be used by an attacker to confirm that the endpoint
+     * is out of resources or be used to identify the WebSocket implementation
+     * in use.
+     *
+     * Note: this will suppress *all* close codes, including those explicitly
+     * sent by local applications.
+     */
+    static const bool silent_close = false;
+
+    /// Default maximum message size
+    /**
+     * Default value for the processor's maximum message size. Maximum message size
+     * determines the point at which the library will fail a connection with the 
+     * message_too_big protocol error.
+     *
+     * The default is 32MB
+     *
+     * @since 0.3.0
+     */
+    static const size_t max_message_size = 32000000;
+
+    /// Default maximum http body size
+    /**
+     * Default value for the http parser's maximum body size. Maximum body size
+     * determines the point at which the library will abort reading an HTTP
+     * connection with the 413/request entity too large error.
+     *
+     * The default is 32MB
+     *
+     * @since 0.5.0
+     */
+    static const size_t max_http_body_size = 32000000;
+
+    /// Global flag for enabling/disabling extensions
+    static const bool enable_extensions = true;
+
+    /// Extension specific settings:
+
+    /// permessage_compress extension
+    struct permessage_deflate_config {
+        typedef type::request_type request_type;
+
+        /// If the remote endpoint requests that we reset the compression
+        /// context after each message should we honor the request?
+        static const bool allow_disabling_context_takeover = true;
+
+        /// If the remote endpoint requests that we reduce the size of the
+        /// LZ77 sliding window size this is the lowest value that will be
+        /// allowed. Values range from 8 to 15. A value of 8 means we will
+        /// allow any possible window size. A value of 15 means do not allow
+        /// negotiation of the window size (ie require the default).
+        static const uint8_t minimum_outgoing_window_bits = 8;
+    };
+
+    typedef websocketpp::extensions::permessage_deflate::disabled
+        <permessage_deflate_config> permessage_deflate_type;
+
+    /// Autonegotiate permessage-deflate
+    /**
+     * Automatically enables the permessage-deflate extension.
+     *
+     * For clients this results in a permessage-deflate extension request being
+     * sent with every request rather than requiring it to be requested manually
+     *
+     * For servers this results in accepting the first set of extension settings
+     * requested by the client that we understand being used. The alternative is
+     * requiring the extension to be manually negotiated in `validate`. With
+     * auto-negotiate on, you may still override the auto-negotiate manually if
+     * needed.
+     */
+    //static const bool autonegotiate_compression = false;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_CORE_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/debug_asio.hpp b/extlibs/websocketpp/websocketpp/config/debug_asio.hpp
new file mode 100644
index 000000000..a57c736ce
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/debug_asio.hpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_ASIO_TLS_DEBUG_HPP
+#define WEBSOCKETPP_CONFIG_ASIO_TLS_DEBUG_HPP
+
+#include <websocketpp/config/debug.hpp>
+#include <websocketpp/transport/asio/endpoint.hpp>
+#include <websocketpp/transport/asio/security/tls.hpp>
+
+// Pull in non-tls config
+#include <websocketpp/config/debug_asio_no_tls.hpp>
+
+// Define TLS config
+namespace websocketpp {
+namespace config {
+
+/// Client/Server debug config with asio transport and TLS enabled
+struct debug_asio_tls : public debug_core {
+    typedef debug_asio_tls type;
+    typedef debug_core base;
+
+    typedef base::concurrency_type concurrency_type;
+
+    typedef base::request_type request_type;
+    typedef base::response_type response_type;
+
+    typedef base::message_type message_type;
+    typedef base::con_msg_manager_type con_msg_manager_type;
+    typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef base::alog_type alog_type;
+    typedef base::elog_type elog_type;
+
+    typedef base::rng_type rng_type;
+
+    struct transport_config : public base::transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::alog_type alog_type;
+        typedef type::elog_type elog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+        typedef websocketpp::transport::asio::tls_socket::endpoint socket_type;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_ASIO_TLS_DEBUG_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/debug_asio_no_tls.hpp b/extlibs/websocketpp/websocketpp/config/debug_asio_no_tls.hpp
new file mode 100644
index 000000000..b3dc83b49
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/debug_asio_no_tls.hpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_ASIO_DEBUG_HPP
+#define WEBSOCKETPP_CONFIG_ASIO_DEBUG_HPP
+
+#include <websocketpp/config/debug.hpp>
+#include <websocketpp/transport/asio/endpoint.hpp>
+
+namespace websocketpp {
+namespace config {
+
+/// Client/Server debug config with asio transport and TLS disabled
+struct debug_asio : public debug_core {
+    typedef debug_asio type;
+    typedef debug_core base;
+
+    typedef base::concurrency_type concurrency_type;
+
+    typedef base::request_type request_type;
+    typedef base::response_type response_type;
+
+    typedef base::message_type message_type;
+    typedef base::con_msg_manager_type con_msg_manager_type;
+    typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;
+
+    typedef base::alog_type alog_type;
+    typedef base::elog_type elog_type;
+
+    typedef base::rng_type rng_type;
+
+    struct transport_config : public base::transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::alog_type alog_type;
+        typedef type::elog_type elog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+        typedef websocketpp::transport::asio::basic_socket::endpoint
+            socket_type;
+    };
+
+    typedef websocketpp::transport::asio::endpoint<transport_config>
+        transport_type;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_ASIO_DEBUG_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/minimal_client.hpp b/extlibs/websocketpp/websocketpp/config/minimal_client.hpp
new file mode 100644
index 000000000..72528cdee
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/minimal_client.hpp
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_MINIMAL_CLIENT_HPP
+#define WEBSOCKETPP_CONFIG_MINIMAL_CLIENT_HPP
+
+#include <websocketpp/config/minimal_server.hpp>
+
+namespace websocketpp {
+namespace config {
+
+/// Client config with minimal dependencies
+/**
+ * This config strips out as many dependencies as possible. It is suitable for
+ * use as a base class for custom configs that want to implement or choose their
+ * own policies for components that even the core config includes.
+ *
+ * NOTE: this config stubs out enough that it cannot be used directly. You must
+ * supply at least a transport policy and a cryptographically secure random 
+ * number generation policy for a config based on `minimal_client` to do 
+ * anything useful.
+ *
+ * Present dependency list for minimal_server config:
+ *
+ * C++98 STL:
+ * <algorithm>
+ * <map>
+ * <sstream>
+ * <string>
+ * <vector>
+ *
+ * C++11 STL or Boost
+ * <memory>
+ * <functional>
+ * <system_error>
+ *
+ * Operating System:
+ * <stdint.h> or <boost/cstdint.hpp>
+ * <netinet/in.h> or <winsock2.h> (for ntohl.. could potentially bundle this)
+ *
+ * @since 0.4.0-dev
+ */
+typedef minimal_server minimal_client;
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_MINIMAL_CLIENT_HPP
diff --git a/extlibs/websocketpp/websocketpp/config/minimal_server.hpp b/extlibs/websocketpp/websocketpp/config/minimal_server.hpp
new file mode 100644
index 000000000..dd1aedb9d
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/config/minimal_server.hpp
@@ -0,0 +1,312 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONFIG_MINIMAL_HPP
+#define WEBSOCKETPP_CONFIG_MINIMAL_HPP
+
+// Non-Policy common stuff
+#include <websocketpp/common/platforms.hpp>
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/stdint.hpp>
+
+// Concurrency
+#include <websocketpp/concurrency/none.hpp>
+
+// Transport
+#include <websocketpp/transport/stub/endpoint.hpp>
+
+// HTTP
+#include <websocketpp/http/request.hpp>
+#include <websocketpp/http/response.hpp>
+
+// Messages
+#include <websocketpp/message_buffer/message.hpp>
+#include <websocketpp/message_buffer/alloc.hpp>
+
+// Loggers
+#include <websocketpp/logger/stub.hpp>
+
+// RNG
+#include <websocketpp/random/none.hpp>
+
+// User stub base classes
+#include <websocketpp/endpoint_base.hpp>
+#include <websocketpp/connection_base.hpp>
+
+// Extensions
+#include <websocketpp/extensions/permessage_deflate/disabled.hpp>
+
+namespace websocketpp {
+namespace config {
+
+/// Server config with minimal dependencies
+/**
+ * This config strips out as many dependencies as possible. It is suitable for
+ * use as a base class for custom configs that want to implement or choose their
+ * own policies for components that even the core config includes.
+ *
+ * NOTE: this config stubs out enough that it cannot be used directly. You must
+ * supply at least a transport policy for a config based on `minimal_server` to
+ * do anything useful.
+ *
+ * Present dependency list for minimal_server config:
+ *
+ * C++98 STL:
+ * <algorithm>
+ * <map>
+ * <sstream>
+ * <string>
+ * <vector>
+ *
+ * C++11 STL or Boost
+ * <memory>
+ * <functional>
+ * <system_error>
+ *
+ * Operating System:
+ * <stdint.h> or <boost/cstdint.hpp>
+ * <netinet/in.h> or <winsock2.h> (for ntohl.. could potentially bundle this)
+ *
+ * @since 0.4.0-dev
+ */
+struct minimal_server {
+    typedef minimal_server type;
+
+    // Concurrency policy
+    typedef websocketpp::concurrency::none concurrency_type;
+
+    // HTTP Parser Policies
+    typedef http::parser::request request_type;
+    typedef http::parser::response response_type;
+
+    // Message Policies
+    typedef message_buffer::message<message_buffer::alloc::con_msg_manager>
+        message_type;
+    typedef message_buffer::alloc::con_msg_manager<message_type>
+        con_msg_manager_type;
+    typedef message_buffer::alloc::endpoint_msg_manager<con_msg_manager_type>
+        endpoint_msg_manager_type;
+
+    /// Logging policies
+    typedef websocketpp::log::stub elog_type;
+    typedef websocketpp::log::stub alog_type;
+
+    /// RNG policies
+    typedef websocketpp::random::none::int_generator<uint32_t> rng_type;
+
+    /// Controls compile time enabling/disabling of thread syncronization
+    /// code Disabling can provide a minor performance improvement to single
+    /// threaded applications
+    static bool const enable_multithreading = true;
+
+    struct transport_config {
+        typedef type::concurrency_type concurrency_type;
+        typedef type::elog_type elog_type;
+        typedef type::alog_type alog_type;
+        typedef type::request_type request_type;
+        typedef type::response_type response_type;
+
+        /// Controls compile time enabling/disabling of thread syncronization
+        /// code Disabling can provide a minor performance improvement to single
+        /// threaded applications
+        static bool const enable_multithreading = true;
+
+        /// Default timer values (in ms)
+
+        /// Length of time to wait for socket pre-initialization
+        /**
+         * Exactly what this includes depends on the socket policy in use
+         */
+        static const long timeout_socket_pre_init = 5000;
+
+        /// Length of time to wait before a proxy handshake is aborted
+        static const long timeout_proxy = 5000;
+
+        /// Length of time to wait for socket post-initialization
+        /**
+         * Exactly what this includes depends on the socket policy in use.
+         * Often this means the TLS handshake
+         */
+        static const long timeout_socket_post_init = 5000;
+
+        /// Length of time to wait for dns resolution
+        static const long timeout_dns_resolve = 5000;
+
+        /// Length of time to wait for TCP connect
+        static const long timeout_connect = 5000;
+
+        /// Length of time to wait for socket shutdown
+        static const long timeout_socket_shutdown = 5000;
+    };
+
+    /// Transport Endpoint Component
+    typedef websocketpp::transport::stub::endpoint<transport_config>
+        transport_type;
+
+    /// User overridable Endpoint base class
+    typedef websocketpp::endpoint_base endpoint_base;
+    /// User overridable Connection base class
+    typedef websocketpp::connection_base connection_base;
+
+    /// Default timer values (in ms)
+
+    /// Length of time before an opening handshake is aborted
+    static const long timeout_open_handshake = 5000;
+    /// Length of time before a closing handshake is aborted
+    static const long timeout_close_handshake = 5000;
+    /// Length of time to wait for a pong after a ping
+    static const long timeout_pong = 5000;
+
+    /// WebSocket Protocol version to use as a client
+    /**
+     * What version of the WebSocket Protocol to use for outgoing client
+     * connections. Setting this to a value other than 13 (RFC6455) is not
+     * recommended.
+     */
+    static const int client_version = 13; // RFC6455
+
+    /// Default static error logging channels
+    /**
+     * Which error logging channels to enable at compile time. Channels not
+     * enabled here will be unable to be selected by programs using the library.
+     * This option gives an optimizing compiler the ability to remove entirely
+     * code to test whether or not to print out log messages on a certain
+     * channel
+     *
+     * Default is all except for development/debug level errors
+     */
+    static const websocketpp::log::level elog_level =
+        websocketpp::log::elevel::none;
+
+    /// Default static access logging channels
+    /**
+     * Which access logging channels to enable at compile time. Channels not
+     * enabled here will be unable to be selected by programs using the library.
+     * This option gives an optimizing compiler the ability to remove entirely
+     * code to test whether or not to print out log messages on a certain
+     * channel
+     *
+     * Default is all except for development/debug level access messages
+     */
+    static const websocketpp::log::level alog_level =
+        websocketpp::log::alevel::none;
+
+    ///
+    static const size_t connection_read_buffer_size = 16384;
+
+    /// Drop connections immediately on protocol error.
+    /**
+     * Drop connections on protocol error rather than sending a close frame.
+     * Off by default. This may result in legit messages near the error being
+     * dropped as well. It may free up resources otherwise spent dealing with
+     * misbehaving clients.
+     */
+    static const bool drop_on_protocol_error = false;
+
+    /// Suppresses the return of detailed connection close information
+    /**
+     * Silence close suppresses the return of detailed connection close
+     * information during the closing handshake. This information is useful
+     * for debugging and presenting useful errors to end users but may be
+     * undesirable for security reasons in some production environments.
+     * Close reasons could be used by an attacker to confirm that the endpoint
+     * is out of resources or be used to identify the WebSocket implementation
+     * in use.
+     *
+     * Note: this will suppress *all* close codes, including those explicitly
+     * sent by local applications.
+     */
+    static const bool silent_close = false;
+
+    /// Default maximum message size
+    /**
+     * Default value for the processor's maximum message size. Maximum message size
+     * determines the point at which the library will fail a connection with the 
+     * message_too_big protocol error.
+     *
+     * The default is 32MB
+     *
+     * @since 0.4.0-alpha1
+     */
+    static const size_t max_message_size = 32000000;
+
+    /// Default maximum http body size
+    /**
+     * Default value for the http parser's maximum body size. Maximum body size
+     * determines the point at which the library will abort reading an HTTP
+     * connection with the 413/request entity too large error.
+     *
+     * The default is 32MB
+     *
+     * @since 0.5.0
+     */
+    static const size_t max_http_body_size = 32000000;
+
+    /// Global flag for enabling/disabling extensions
+    static const bool enable_extensions = true;
+
+    /// Extension specific settings:
+
+    /// permessage_compress extension
+    struct permessage_deflate_config {
+        typedef core::request_type request_type;
+
+        /// If the remote endpoint requests that we reset the compression
+        /// context after each message should we honor the request?
+        static const bool allow_disabling_context_takeover = true;
+
+        /// If the remote endpoint requests that we reduce the size of the
+        /// LZ77 sliding window size this is the lowest value that will be
+        /// allowed. Values range from 8 to 15. A value of 8 means we will
+        /// allow any possible window size. A value of 15 means do not allow
+        /// negotiation of the window size (ie require the default).
+        static const uint8_t minimum_outgoing_window_bits = 8;
+    };
+
+    typedef websocketpp::extensions::permessage_deflate::disabled
+        <permessage_deflate_config> permessage_deflate_type;
+
+    /// Autonegotiate permessage-deflate
+    /**
+     * Automatically enables the permessage-deflate extension.
+     *
+     * For clients this results in a permessage-deflate extension request being
+     * sent with every request rather than requiring it to be requested manually
+     *
+     * For servers this results in accepting the first set of extension settings
+     * requested by the client that we understand being used. The alternative is
+     * requiring the extension to be manually negotiated in `validate`. With
+     * auto-negotiate on, you may still override the auto-negotiate manually if
+     * needed.
+     */
+    //static const bool autonegotiate_compression = false;
+};
+
+} // namespace config
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONFIG_MINIMAL_HPP
diff --git a/extlibs/websocketpp/websocketpp/connection.hpp b/extlibs/websocketpp/websocketpp/connection.hpp
new file mode 100644
index 000000000..954683279
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/connection.hpp
@@ -0,0 +1,1530 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONNECTION_HPP
+#define WEBSOCKETPP_CONNECTION_HPP
+
+#include <websocketpp/close.hpp>
+#include <websocketpp/error.hpp>
+#include <websocketpp/frame.hpp>
+
+#include <websocketpp/logger/levels.hpp>
+#include <websocketpp/processors/processor.hpp>
+#include <websocketpp/transport/base/connection.hpp>
+#include <websocketpp/http/constants.hpp>
+
+#include <websocketpp/common/connection_hdl.hpp>
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/functional.hpp>
+
+#include <queue>
+#include <sstream>
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+
+/// The type and function signature of an open handler
+/**
+ * The open handler is called once for every successful WebSocket connection
+ * attempt. Either the fail handler or the open handler will be called for each
+ * WebSocket connection attempt. HTTP Connections that did not attempt to
+ * upgrade the connection to the WebSocket protocol will trigger the http
+ * handler instead of fail/open.
+ */
+typedef lib::function<void(connection_hdl)> open_handler;
+
+/// The type and function signature of a close handler
+/**
+ * The close handler is called once for every successfully established
+ * connection after it is no longer capable of sending or receiving new messages
+ *
+ * The close handler will be called exactly once for every connection for which
+ * the open handler was called.
+ */
+typedef lib::function<void(connection_hdl)> close_handler;
+
+/// The type and function signature of a fail handler
+/**
+ * The fail handler is called once for every unsuccessful WebSocket connection
+ * attempt. Either the fail handler or the open handler will be called for each
+ * WebSocket connection attempt. HTTP Connections that did not attempt to
+ * upgrade the connection to the WebSocket protocol will trigger the http
+ * handler instead of fail/open.
+ */
+typedef lib::function<void(connection_hdl)> fail_handler;
+
+/// The type and function signature of an interrupt handler
+/**
+ * The interrupt handler is called when a connection receives an interrupt
+ * request from the application. Interrupts allow the application to trigger a
+ * handler to be run in the absense of a WebSocket level handler trigger (like
+ * a new message).
+ *
+ * This is typically used by another application thread to schedule some tasks
+ * that can only be run from within the handler chain for thread safety reasons.
+ */
+typedef lib::function<void(connection_hdl)> interrupt_handler;
+
+/// The type and function signature of a ping handler
+/**
+ * The ping handler is called when the connection receives a WebSocket ping
+ * control frame. The string argument contains the ping payload. The payload is
+ * a binary string up to 126 bytes in length. The ping handler returns a bool,
+ * true if a pong response should be sent, false if the pong response should be
+ * suppressed.
+ */
+typedef lib::function<bool(connection_hdl,std::string)> ping_handler;
+
+/// The type and function signature of a pong handler
+/**
+ * The pong handler is called when the connection receives a WebSocket pong
+ * control frame. The string argument contains the pong payload. The payload is
+ * a binary string up to 126 bytes in length.
+ */
+typedef lib::function<void(connection_hdl,std::string)> pong_handler;
+
+/// The type and function signature of a pong timeout handler
+/**
+ * The pong timeout handler is called when a ping goes unanswered by a pong for
+ * longer than the locally specified timeout period.
+ */
+typedef lib::function<void(connection_hdl,std::string)> pong_timeout_handler;
+
+/// The type and function signature of a validate handler
+/**
+ * The validate handler is called after a WebSocket handshake has been received
+ * and processed but before it has been accepted. This gives the application a
+ * chance to implement connection details specific policies for accepting
+ * connections and the ability to negotiate extensions and subprotocols.
+ *
+ * The validate handler return value indicates whether or not the connection
+ * should be accepted. Additional methods may be called during the function to
+ * set response headers, set HTTP return/error codes, etc.
+ */
+typedef lib::function<bool(connection_hdl)> validate_handler;
+
+/// The type and function signature of a http handler
+/**
+ * The http handler is called when an HTTP connection is made that does not
+ * attempt to upgrade the connection to the WebSocket protocol. This allows
+ * WebSocket++ servers to respond to these requests with regular HTTP responses.
+ *
+ * This can be used to deliver error pages & dashboards and to deliver static
+ * files such as the base HTML & JavaScript for an otherwise single page
+ * WebSocket application.
+ *
+ * Note: WebSocket++ is designed to be a high performance WebSocket server. It
+ * is not tuned to provide a full featured, high performance, HTTP web server
+ * solution. The HTTP handler is appropriate only for low volume HTTP traffic.
+ * If you expect to serve high volumes of HTTP traffic a dedicated HTTP web
+ * server is strongly recommended.
+ *
+ * The default HTTP handler will return a 426 Upgrade Required error. Custom
+ * handlers may override the response status code to deliver any type of
+ * response.
+ */
+typedef lib::function<void(connection_hdl)> http_handler;
+
+//
+typedef lib::function<void(lib::error_code const & ec, size_t bytes_transferred)> read_handler;
+typedef lib::function<void(lib::error_code const & ec)> write_frame_handler;
+
+// constants related to the default WebSocket protocol versions available
+#ifdef _WEBSOCKETPP_INITIALIZER_LISTS_ // simplified C++11 version
+    /// Container that stores the list of protocol versions supported
+    /**
+     * @todo Move this to configs to allow compile/runtime disabling or enabling
+     * of protocol versions
+     */
+    static std::vector<int> const versions_supported = {0,7,8,13};
+#else
+    /// Helper array to get around lack of initializer lists pre C++11
+    static int const helper[] = {0,7,8,13};
+    /// Container that stores the list of protocol versions supported
+    /**
+     * @todo Move this to configs to allow compile/runtime disabling or enabling
+     * of protocol versions
+     */
+    static std::vector<int> const versions_supported(helper,helper+4);
+#endif
+
+namespace session {
+namespace state {
+    // externally visible session state (states based on the RFC)
+    enum value {
+        connecting = 0,
+        open = 1,
+        closing = 2,
+        closed = 3
+    };
+} // namespace state
+
+
+namespace fail {
+namespace status {
+    enum value {
+        GOOD = 0,           // no failure yet!
+        SYSTEM = 1,         // system call returned error, check that code
+        WEBSOCKET = 2,      // websocket close codes contain error
+        UNKNOWN = 3,        // No failure information is available
+        TIMEOUT_TLS = 4,    // TLS handshake timed out
+        TIMEOUT_WS = 5      // WS handshake timed out
+    };
+} // namespace status
+} // namespace fail
+
+namespace internal_state {
+    // More granular internal states. These are used for multi-threaded
+    // connection synchronization and preventing values that are not yet or no
+    // longer available from being used.
+
+    enum value {
+        USER_INIT = 0,
+        TRANSPORT_INIT = 1,
+        READ_HTTP_REQUEST = 2,
+        WRITE_HTTP_REQUEST = 3,
+        READ_HTTP_RESPONSE = 4,
+        WRITE_HTTP_RESPONSE = 5,
+        PROCESS_HTTP_REQUEST = 6,
+        PROCESS_CONNECTION = 7
+    };
+} // namespace internal_state
+} // namespace session
+
+/// Represents an individual WebSocket connection
+template <typename config>
+class connection
+ : public config::transport_type::transport_con_type
+ , public config::connection_base
+{
+public:
+    /// Type of this connection
+    typedef connection<config> type;
+    /// Type of a shared pointer to this connection
+    typedef lib::shared_ptr<type> ptr;
+    /// Type of a weak pointer to this connection
+    typedef lib::weak_ptr<type> weak_ptr;
+
+    /// Type of the concurrency component of this connection
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of the access logging policy
+    typedef typename config::alog_type alog_type;
+    /// Type of the error logging policy
+    typedef typename config::elog_type elog_type;
+
+    /// Type of the transport component of this connection
+    typedef typename config::transport_type::transport_con_type
+        transport_con_type;
+    /// Type of a shared pointer to the transport component of this connection
+    typedef typename transport_con_type::ptr transport_con_ptr;
+
+    typedef lib::function<void(ptr)> termination_handler;
+
+    typedef typename concurrency_type::scoped_lock_type scoped_lock_type;
+    typedef typename concurrency_type::mutex_type mutex_type;
+
+    typedef typename config::request_type request_type;
+    typedef typename config::response_type response_type;
+
+    typedef typename config::message_type message_type;
+    typedef typename message_type::ptr message_ptr;
+
+    typedef typename config::con_msg_manager_type con_msg_manager_type;
+    typedef typename con_msg_manager_type::ptr con_msg_manager_ptr;
+
+    /// Type of RNG
+    typedef typename config::rng_type rng_type;
+
+    typedef processor::processor<config> processor_type;
+    typedef lib::shared_ptr<processor_type> processor_ptr;
+
+    // Message handler (needs to know message type)
+    typedef lib::function<void(connection_hdl,message_ptr)> message_handler;
+
+    /// Type of a pointer to a transport timer handle
+    typedef typename transport_con_type::timer_ptr timer_ptr;
+
+    // Misc Convenience Types
+    typedef session::internal_state::value istate_type;
+
+private:
+    enum terminate_status {
+        failed = 1,
+        closed,
+        unknown
+    };
+public:
+
+    explicit connection(bool p_is_server, std::string const & ua, alog_type& alog,
+        elog_type& elog, rng_type & rng)
+      : transport_con_type(p_is_server, alog, elog)
+      , m_handle_read_frame(lib::bind(
+            &type::handle_read_frame,
+            this,
+            lib::placeholders::_1,
+            lib::placeholders::_2
+        ))
+      , m_write_frame_handler(lib::bind(
+            &type::handle_write_frame,
+            this,
+            lib::placeholders::_1
+        ))
+      , m_user_agent(ua)
+      , m_open_handshake_timeout_dur(config::timeout_open_handshake)
+      , m_close_handshake_timeout_dur(config::timeout_close_handshake)
+      , m_pong_timeout_dur(config::timeout_pong)
+      , m_max_message_size(config::max_message_size)
+      , m_state(session::state::connecting)
+      , m_internal_state(session::internal_state::USER_INIT)
+      , m_msg_manager(new con_msg_manager_type())
+      , m_send_buffer_size(0)
+      , m_write_flag(false)
+      , m_read_flag(true)
+      , m_is_server(p_is_server)
+      , m_alog(alog)
+      , m_elog(elog)
+      , m_rng(rng)
+      , m_local_close_code(close::status::abnormal_close)
+      , m_remote_close_code(close::status::abnormal_close)
+      , m_is_http(false)
+      , m_was_clean(false)
+    {
+        m_alog.write(log::alevel::devel,"connection constructor");
+    }
+
+    /// Get a shared pointer to this component
+    ptr get_shared() {
+        return lib::static_pointer_cast<type>(transport_con_type::get_shared());
+    }
+
+    ///////////////////////////
+    // Set Handler Callbacks //
+    ///////////////////////////
+
+    /// Set open handler
+    /**
+     * The open handler is called after the WebSocket handshake is complete and
+     * the connection is considered OPEN.
+     *
+     * @param h The new open_handler
+     */
+    void set_open_handler(open_handler h) {
+        m_open_handler = h;
+    }
+
+    /// Set close handler
+    /**
+     * The close handler is called immediately after the connection is closed.
+     *
+     * @param h The new close_handler
+     */
+    void set_close_handler(close_handler h) {
+        m_close_handler = h;
+    }
+
+    /// Set fail handler
+    /**
+     * The fail handler is called whenever the connection fails while the
+     * handshake is bring processed.
+     *
+     * @param h The new fail_handler
+     */
+    void set_fail_handler(fail_handler h) {
+        m_fail_handler = h;
+    }
+
+    /// Set ping handler
+    /**
+     * The ping handler is called whenever the connection receives a ping
+     * control frame. The ping payload is included.
+     *
+     * The ping handler's return time controls whether or not a pong is
+     * sent in response to this ping. Returning false will suppress the
+     * return pong. If no ping handler is set a pong will be sent.
+     *
+     * @param h The new ping_handler
+     */
+    void set_ping_handler(ping_handler h) {
+        m_ping_handler = h;
+    }
+
+    /// Set pong handler
+    /**
+     * The pong handler is called whenever the connection receives a pong
+     * control frame. The pong payload is included.
+     *
+     * @param h The new pong_handler
+     */
+    void set_pong_handler(pong_handler h) {
+        m_pong_handler = h;
+    }
+
+    /// Set pong timeout handler
+    /**
+     * If the transport component being used supports timers, the pong timeout
+     * handler is called whenever a pong control frame is not received with the
+     * configured timeout period after the application sends a ping.
+     *
+     * The config setting `timeout_pong` controls the length of the timeout
+     * period. It is specified in milliseconds.
+     *
+     * This can be used to probe the health of the remote endpoint's WebSocket
+     * implementation. This does not guarantee that the remote application
+     * itself is still healthy but can be a useful diagnostic.
+     *
+     * Note: receipt of this callback doesn't mean the pong will never come.
+     * This functionality will not suppress delivery of the pong in question
+     * should it arrive after the timeout.
+     *
+     * @param h The new pong_timeout_handler
+     */
+    void set_pong_timeout_handler(pong_timeout_handler h) {
+        m_pong_timeout_handler = h;
+    }
+
+    /// Set interrupt handler
+    /**
+     * The interrupt handler is called whenever the connection is manually
+     * interrupted by the application.
+     *
+     * @param h The new interrupt_handler
+     */
+    void set_interrupt_handler(interrupt_handler h) {
+        m_interrupt_handler = h;
+    }
+
+    /// Set http handler
+    /**
+     * The http handler is called after an HTTP request other than a WebSocket
+     * upgrade request is received. It allows a WebSocket++ server to respond
+     * to regular HTTP requests on the same port as it processes WebSocket
+     * connections. This can be useful for hosting error messages, flash
+     * policy files, status pages, and other simple HTTP responses. It is not
+     * intended to be used as a primary web server.
+     *
+     * @param h The new http_handler
+     */
+    void set_http_handler(http_handler h) {
+        m_http_handler = h;
+    }
+
+    /// Set validate handler
+    /**
+     * The validate handler is called after a WebSocket handshake has been
+     * parsed but before a response is returned. It provides the application
+     * a chance to examine the request and determine whether or not it wants
+     * to accept the connection.
+     *
+     * Returning false from the validate handler will reject the connection.
+     * If no validate handler is present, all connections will be allowed.
+     *
+     * @param h The new validate_handler
+     */
+    void set_validate_handler(validate_handler h) {
+        m_validate_handler = h;
+    }
+
+    /// Set message handler
+    /**
+     * The message handler is called after a new message has been received.
+     *
+     * @param h The new message_handler
+     */
+    void set_message_handler(message_handler h) {
+        m_message_handler = h;
+    }
+
+    //////////////////////////////////////////
+    // Connection timeouts and other limits //
+    //////////////////////////////////////////
+
+    /// Set open handshake timeout
+    /**
+     * Sets the length of time the library will wait after an opening handshake
+     * has been initiated before cancelling it. This can be used to prevent
+     * excessive wait times for outgoing clients or excessive resource usage
+     * from broken clients or DoS attacks on servers.
+     *
+     * Connections that time out will have their fail handlers called with the
+     * open_handshake_timeout error code.
+     *
+     * The default value is specified via the compile time config value
+     * 'timeout_open_handshake'. The default value in the core config
+     * is 5000ms. A value of 0 will disable the timer entirely.
+     *
+     * To be effective, the transport you are using must support timers. See
+     * the documentation for your transport policy for details about its
+     * timer support.
+     *
+     * @param dur The length of the open handshake timeout in ms
+     */
+    void set_open_handshake_timeout(long dur) {
+        m_open_handshake_timeout_dur = dur;
+    }
+
+    /// Set close handshake timeout
+    /**
+     * Sets the length of time the library will wait after a closing handshake
+     * has been initiated before cancelling it. This can be used to prevent
+     * excessive wait times for outgoing clients or excessive resource usage
+     * from broken clients or DoS attacks on servers.
+     *
+     * Connections that time out will have their close handlers called with the
+     * close_handshake_timeout error code.
+     *
+     * The default value is specified via the compile time config value
+     * 'timeout_close_handshake'. The default value in the core config
+     * is 5000ms. A value of 0 will disable the timer entirely.
+     *
+     * To be effective, the transport you are using must support timers. See
+     * the documentation for your transport policy for details about its
+     * timer support.
+     *
+     * @param dur The length of the close handshake timeout in ms
+     */
+    void set_close_handshake_timeout(long dur) {
+        m_close_handshake_timeout_dur = dur;
+    }
+
+    /// Set pong timeout
+    /**
+     * Sets the length of time the library will wait for a pong response to a
+     * ping. This can be used as a keepalive or to detect broken  connections.
+     *
+     * Pong responses that time out will have the pong timeout handler called.
+     *
+     * The default value is specified via the compile time config value
+     * 'timeout_pong'. The default value in the core config
+     * is 5000ms. A value of 0 will disable the timer entirely.
+     *
+     * To be effective, the transport you are using must support timers. See
+     * the documentation for your transport policy for details about its
+     * timer support.
+     *
+     * @param dur The length of the pong timeout in ms
+     */
+    void set_pong_timeout(long dur) {
+        m_pong_timeout_dur = dur;
+    }
+
+    /// Get maximum message size
+    /**
+     * Get maximum message size. Maximum message size determines the point at 
+     * which the connection will fail with the message_too_big protocol error.
+     *
+     * The default is set by the endpoint that creates the connection.
+     *
+     * @since 0.3.0
+     */
+    size_t get_max_message_size() const {
+        return m_max_message_size;
+    }
+    
+    /// Set maximum message size
+    /**
+     * Set maximum message size. Maximum message size determines the point at 
+     * which the connection will fail with the message_too_big protocol error. 
+     * This value may be changed during the connection.
+     *
+     * The default is set by the endpoint that creates the connection.
+     *
+     * @since 0.3.0
+     *
+     * @param new_value The value to set as the maximum message size.
+     */
+    void set_max_message_size(size_t new_value) {
+        m_max_message_size = new_value;
+        if (m_processor) {
+            m_processor->set_max_message_size(new_value);
+        }
+    }
+    
+    /// Get maximum HTTP message body size
+    /**
+     * Get maximum HTTP message body size. Maximum message body size determines
+     * the point at which the connection will stop reading an HTTP request whose
+     * body is too large.
+     *
+     * The default is set by the endpoint that creates the connection.
+     *
+     * @since 0.5.0
+     *
+     * @return The maximum HTTP message body size
+     */
+    size_t get_max_http_body_size() const {
+        return m_request.get_max_body_size();
+    }
+    
+    /// Set maximum HTTP message body size
+    /**
+     * Set maximum HTTP message body size. Maximum message body size determines
+     * the point at which the connection will stop reading an HTTP request whose
+     * body is too large.
+     *
+     * The default is set by the endpoint that creates the connection.
+     *
+     * @since 0.5.0
+     *
+     * @param new_value The value to set as the maximum message size.
+     */
+    void set_max_http_body_size(size_t new_value) {
+        m_request.set_max_body_size(new_value);
+    }
+
+    //////////////////////////////////
+    // Uncategorized public methods //
+    //////////////////////////////////
+
+    /// Get the size of the outgoing write buffer (in payload bytes)
+    /**
+     * Retrieves the number of bytes in the outgoing write buffer that have not
+     * already been dispatched to the transport layer. This represents the bytes
+     * that are presently cancelable without uncleanly ending the websocket
+     * connection
+     *
+     * This method invokes the m_write_lock mutex
+     *
+     * @return The current number of bytes in the outgoing send buffer.
+     */
+    size_t get_buffered_amount() const;
+
+    /// DEPRECATED: use get_buffered_amount instead
+    size_t buffered_amount() const {
+        return get_buffered_amount();
+    }
+
+    ////////////////////
+    // Action Methods //
+    ////////////////////
+
+    /// Create a message and then add it to the outgoing send queue
+    /**
+     * Convenience method to send a message given a payload string and
+     * optionally an opcode. Default opcode is utf8 text.
+     *
+     * This method locks the m_write_lock mutex
+     *
+     * @param payload The payload string to generated the message with
+     *
+     * @param op The opcode to generated the message with. Default is
+     * frame::opcode::text
+     */
+    lib::error_code send(std::string const & payload, frame::opcode::value op =
+        frame::opcode::text);
+
+    /// Send a message (raw array overload)
+    /**
+     * Convenience method to send a message given a raw array and optionally an
+     * opcode. Default opcode is binary.
+     *
+     * This method locks the m_write_lock mutex
+     *
+     * @param payload A pointer to the array containing the bytes to send.
+     *
+     * @param len Length of the array.
+     *
+     * @param op The opcode to generated the message with. Default is
+     * frame::opcode::binary
+     */
+    lib::error_code send(void const * payload, size_t len, frame::opcode::value
+        op = frame::opcode::binary);
+
+    /// Add a message to the outgoing send queue
+    /**
+     * If presented with a prepared message it is added without validation or
+     * framing. If presented with an unprepared message it is validated, framed,
+     * and then added
+     *
+     * Errors are returned via an exception
+     * \todo make exception system_error rather than error_code
+     *
+     * This method invokes the m_write_lock mutex
+     *
+     * @param msg A message_ptr to the message to send.
+     */
+    lib::error_code send(message_ptr msg);
+
+    /// Asyncronously invoke handler::on_inturrupt
+    /**
+     * Signals to the connection to asyncronously invoke the on_inturrupt
+     * callback for this connection's handler once it is safe to do so.
+     *
+     * When the on_inturrupt handler callback is called it will be from
+     * within the transport event loop with all the thread safety features
+     * guaranteed by the transport to regular handlers
+     *
+     * Multiple inturrupt signals can be active at once on the same connection
+     *
+     * @return An error code
+     */
+    lib::error_code interrupt();
+    
+    /// Transport inturrupt callback
+    void handle_interrupt();
+    
+    /// Pause reading of new data
+    /**
+     * Signals to the connection to halt reading of new data. While reading is paused, 
+     * the connection will stop reading from its associated socket. In turn this will 
+     * result in TCP based flow control kicking in and slowing data flow from the remote
+     * endpoint.
+     *
+     * This is useful for applications that push new requests to a queue to be processed
+     * by another thread and need a way to signal when their request queue is full without
+     * blocking the network processing thread.
+     *
+     * Use `resume_reading()` to resume.
+     *
+     * If supported by the transport this is done asynchronously. As such reading may not
+     * stop until the current read operation completes. Typically you can expect to
+     * receive no more bytes after initiating a read pause than the size of the read 
+     * buffer.
+     *
+     * If reading is paused for this connection already nothing is changed.
+     */
+    lib::error_code pause_reading();
+
+    /// Pause reading callback
+    void handle_pause_reading();
+
+    /// Resume reading of new data
+    /**
+     * Signals to the connection to resume reading of new data after it was paused by
+     * `pause_reading()`.
+     *
+     * If reading is not paused for this connection already nothing is changed.
+     */
+    lib::error_code resume_reading();
+
+    /// Resume reading callback
+    void handle_resume_reading();
+
+    /// Send a ping
+    /**
+     * Initiates a ping with the given payload/
+     *
+     * There is no feedback directly from ping except in cases of immediately
+     * detectable errors. Feedback will be provided via on_pong or
+     * on_pong_timeout callbacks.
+     *
+     * Ping locks the m_write_lock mutex
+     *
+     * @param payload Payload to be used for the ping
+     */
+    void ping(std::string const & payload);
+
+    /// exception free variant of ping
+    void ping(std::string const & payload, lib::error_code & ec);
+
+    /// Utility method that gets called back when the ping timer expires
+    void handle_pong_timeout(std::string payload, lib::error_code const & ec);
+
+    /// Send a pong
+    /**
+     * Initiates a pong with the given payload.
+     *
+     * There is no feedback from a pong once sent.
+     *
+     * Pong locks the m_write_lock mutex
+     *
+     * @param payload Payload to be used for the pong
+     */
+    void pong(std::string const & payload);
+
+    /// exception free variant of pong
+    void pong(std::string const & payload, lib::error_code & ec);
+
+    /// Close the connection
+    /**
+     * Initiates the close handshake process.
+     *
+     * If close returns successfully the connection will be in the closing
+     * state and no additional messages may be sent. All messages sent prior
+     * to calling close will be written out before the connection is closed.
+     *
+     * If no reason is specified none will be sent. If no code is specified
+     * then no code will be sent.
+     *
+     * The handler's on_close callback will be called once the close handshake
+     * is complete.
+     *
+     * Reasons will be automatically truncated to the maximum length (123 bytes)
+     * if necessary.
+     *
+     * @param code The close code to send
+     * @param reason The close reason to send
+     */
+    void close(close::status::value const code, std::string const & reason);
+
+    /// exception free variant of close
+    void close(close::status::value const code, std::string const & reason,
+        lib::error_code & ec);
+
+    ////////////////////////////////////////////////
+    // Pass-through access to the uri information //
+    ////////////////////////////////////////////////
+
+    /// Returns the secure flag from the connection URI
+    /**
+     * This value is available after the HTTP request has been fully read and
+     * may be called from any thread.
+     *
+     * @return Whether or not the connection URI is flagged secure.
+     */
+    bool get_secure() const;
+
+    /// Returns the host component of the connection URI
+    /**
+     * This value is available after the HTTP request has been fully read and
+     * may be called from any thread.
+     *
+     * @return The host component of the connection URI
+     */
+    std::string const & get_host() const;
+
+    /// Returns the resource component of the connection URI
+    /**
+     * This value is available after the HTTP request has been fully read and
+     * may be called from any thread.
+     *
+     * @return The resource component of the connection URI
+     */
+    std::string const & get_resource() const;
+
+    /// Returns the port component of the connection URI
+    /**
+     * This value is available after the HTTP request has been fully read and
+     * may be called from any thread.
+     *
+     * @return The port component of the connection URI
+     */
+    uint16_t get_port() const;
+
+    /// Gets the connection URI
+    /**
+     * This should really only be called by internal library methods unless you
+     * really know what you are doing.
+     *
+     * @return A pointer to the connection's URI
+     */
+    uri_ptr get_uri() const;
+
+    /// Sets the connection URI
+    /**
+     * This should really only be called by internal library methods unless you
+     * really know what you are doing.
+     *
+     * @param uri The new URI to set
+     */
+    void set_uri(uri_ptr uri);
+
+    /////////////////////////////
+    // Subprotocol negotiation //
+    /////////////////////////////
+
+    /// Gets the negotated subprotocol
+    /**
+     * Retrieves the subprotocol that was negotiated during the handshake. This
+     * method is valid in the open handler and later.
+     *
+     * @return The negotiated subprotocol
+     */
+    std::string const & get_subprotocol() const;
+
+    /// Gets all of the subprotocols requested by the client
+    /**
+     * Retrieves the subprotocols that were requested during the handshake. This
+     * method is valid in the validate handler and later.
+     *
+     * @return A vector of the requested subprotocol
+     */
+    std::vector<std::string> const & get_requested_subprotocols() const;
+
+    /// Adds the given subprotocol string to the request list (exception free)
+    /**
+     * Adds a subprotocol to the list to send with the opening handshake. This
+     * may be called multiple times to request more than one. If the server
+     * supports one of these, it may choose one. If so, it will return it
+     * in it's handshake reponse and the value will be available via
+     * get_subprotocol(). Subprotocol requests should be added in order of
+     * preference.
+     *
+     * @param request The subprotocol to request
+     * @param ec A reference to an error code that will be filled in the case of
+     * errors
+     */
+    void add_subprotocol(std::string const & request, lib::error_code & ec);
+
+    /// Adds the given subprotocol string to the request list
+    /**
+     * Adds a subprotocol to the list to send with the opening handshake. This
+     * may be called multiple times to request more than one. If the server
+     * supports one of these, it may choose one. If so, it will return it
+     * in it's handshake reponse and the value will be available via
+     * get_subprotocol(). Subprotocol requests should be added in order of
+     * preference.
+     *
+     * @param request The subprotocol to request
+     */
+    void add_subprotocol(std::string const & request);
+
+    /// Select a subprotocol to use (exception free)
+    /**
+     * Indicates which subprotocol should be used for this connection. Valid
+     * only during the validate handler callback. Subprotocol selected must have
+     * been requested by the client. Consult get_requested_subprotocols() for a
+     * list of valid subprotocols.
+     *
+     * This member function is valid on server endpoints/connections only
+     *
+     * @param value The subprotocol to select
+     * @param ec A reference to an error code that will be filled in the case of
+     * errors
+     */
+    void select_subprotocol(std::string const & value, lib::error_code & ec);
+
+    /// Select a subprotocol to use
+    /**
+     * Indicates which subprotocol should be used for this connection. Valid
+     * only during the validate handler callback. Subprotocol selected must have
+     * been requested by the client. Consult get_requested_subprotocols() for a
+     * list of valid subprotocols.
+     *
+     * This member function is valid on server endpoints/connections only
+     *
+     * @param value The subprotocol to select
+     */
+    void select_subprotocol(std::string const & value);
+
+    /////////////////////////////////////////////////////////////
+    // Pass-through access to the request and response objects //
+    /////////////////////////////////////////////////////////////
+
+    /// Retrieve a request header
+    /**
+     * Retrieve the value of a header from the handshake HTTP request.
+     *
+     * @param key Name of the header to get
+     * @return The value of the header
+     */
+    std::string const & get_request_header(std::string const & key) const;
+
+    /// Retrieve a request body
+    /**
+     * Retrieve the value of the request body. This value is typically used with
+     * PUT and POST requests to upload files or other data. Only HTTP
+     * connections will ever have bodies. WebSocket connection's will always
+     * have blank bodies.
+     *
+     * @return The value of the request body.
+     */
+    std::string const & get_request_body() const;
+
+    /// Retrieve a response header
+    /**
+     * Retrieve the value of a header from the handshake HTTP request.
+     *
+     * @param key Name of the header to get
+     * @return The value of the header
+     */
+    std::string const & get_response_header(std::string const & key) const;
+
+    /// Set response status code and message
+    /**
+     * Sets the response status code to `code` and looks up the corresponding
+     * message for standard codes. Non-standard codes will be entered as Unknown
+     * use set_status(status_code::value,std::string) overload to set both
+     * values explicitly.
+     *
+     * This member function is valid only from the http() and validate() handler
+     * callbacks.
+     *
+     * @param code Code to set
+     * @param msg Message to set
+     * @see websocketpp::http::response::set_status
+     */
+    void set_status(http::status_code::value code);
+
+    /// Set response status code and message
+    /**
+     * Sets the response status code and message to independent custom values.
+     * use set_status(status_code::value) to set the code and have the standard
+     * message be automatically set.
+     *
+     * This member function is valid only from the http() and validate() handler
+     * callbacks.
+     *
+     * @param code Code to set
+     * @param msg Message to set
+     * @see websocketpp::http::response::set_status
+     */
+    void set_status(http::status_code::value code, std::string const & msg);
+
+    /// Set response body content
+    /**
+     * Set the body content of the HTTP response to the parameter string. Note
+     * set_body will also set the Content-Length HTTP header to the appropriate
+     * value. If you want the Content-Length header to be something else set it
+     * to something else after calling set_body
+     *
+     * This member function is valid only from the http() and validate() handler
+     * callbacks.
+     *
+     * @param value String data to include as the body content.
+     * @see websocketpp::http::response::set_body
+     */
+    void set_body(std::string const & value);
+
+    /// Append a header
+    /**
+     * If a header with this name already exists the value will be appended to
+     * the existing header to form a comma separated list of values. Use
+     * `connection::replace_header` to overwrite existing values.
+     *
+     * This member function is valid only from the http() and validate() handler
+     * callbacks, or to a client connection before connect has been called.
+     *
+     * @param key Name of the header to set
+     * @param val Value to add
+     * @see replace_header
+     * @see websocketpp::http::parser::append_header
+     */
+    void append_header(std::string const & key, std::string const & val);
+
+    /// Replace a header
+    /**
+     * If a header with this name already exists the old value will be replaced
+     * Use `connection::append_header` to append to a list of existing values.
+     *
+     * This member function is valid only from the http() and validate() handler
+     * callbacks, or to a client connection before connect has been called.
+     *
+     * @param key Name of the header to set
+     * @param val Value to set
+     * @see append_header
+     * @see websocketpp::http::parser::replace_header
+     */
+    void replace_header(std::string const & key, std::string const & val);
+
+    /// Remove a header
+    /**
+     * Removes a header from the response.
+     *
+     * This member function is valid only from the http() and validate() handler
+     * callbacks, or to a client connection before connect has been called.
+     *
+     * @param key The name of the header to remove
+     * @see websocketpp::http::parser::remove_header
+     */
+    void remove_header(std::string const & key);
+
+    /// Get request object
+    /**
+     * Direct access to request object. This can be used to call methods of the
+     * request object that are not part of the standard request API that
+     * connection wraps.
+     *
+     * Note use of this method involves using behavior specific to the
+     * configured HTTP policy. Such behavior may not work with alternate HTTP
+     * policies.
+     *
+     * @since 0.3.0-alpha3
+     *
+     * @return A const reference to the raw request object
+     */
+    request_type const & get_request() const {
+        return m_request;
+    }
+
+    /////////////////////////////////////////////////////////////
+    // Pass-through access to the other connection information //
+    /////////////////////////////////////////////////////////////
+
+    /// Get Connection Handle
+    /**
+     * The connection handle is a token that can be shared outside the
+     * WebSocket++ core for the purposes of identifying a connection and
+     * sending it messages.
+     *
+     * @return A handle to the connection
+     */
+    connection_hdl get_handle() const {
+        return m_connection_hdl;
+    }
+
+    /// Get whether or not this connection is part of a server or client
+    /**
+     * @return whether or not the connection is attached to a server endpoint
+     */
+    bool is_server() const {
+        return m_is_server;
+    }
+
+    /// Return the same origin policy origin value from the opening request.
+    /**
+     * This value is available after the HTTP request has been fully read and
+     * may be called from any thread.
+     *
+     * @return The connection's origin value from the opening handshake.
+     */
+    std::string const & get_origin() const;
+
+    /// Return the connection state.
+    /**
+     * Values can be connecting, open, closing, and closed
+     *
+     * @return The connection's current state.
+     */
+    session::state::value get_state() const;
+
+
+    /// Get the WebSocket close code sent by this endpoint.
+    /**
+     * @return The WebSocket close code sent by this endpoint.
+     */
+    close::status::value get_local_close_code() const {
+        return m_local_close_code;
+    }
+
+    /// Get the WebSocket close reason sent by this endpoint.
+    /**
+     * @return The WebSocket close reason sent by this endpoint.
+     */
+    std::string const & get_local_close_reason() const {
+        return m_local_close_reason;
+    }
+
+    /// Get the WebSocket close code sent by the remote endpoint.
+    /**
+     * @return The WebSocket close code sent by the remote endpoint.
+     */
+    close::status::value get_remote_close_code() const {
+        return m_remote_close_code;
+    }
+
+    /// Get the WebSocket close reason sent by the remote endpoint.
+    /**
+     * @return The WebSocket close reason sent by the remote endpoint.
+     */
+    std::string const & get_remote_close_reason() const {
+        return m_remote_close_reason;
+    }
+
+    /// Get the internal error code for a closed/failed connection
+    /**
+     * Retrieves a machine readable detailed error code indicating the reason
+     * that the connection was closed or failed. Valid only after the close or
+     * fail handler is called.
+     *
+     * @return Error code indicating the reason the connection was closed or
+     * failed
+     */
+    lib::error_code get_ec() const {
+        return m_ec;
+    }
+
+    ////////////////////////////////////////////////////////////////////////
+    // The remaining public member functions are for internal/policy use  //
+    // only. Do not call from application code unless you understand what //
+    // you are doing.                                                     //
+    ////////////////////////////////////////////////////////////////////////
+
+    /// Set Connection Handle
+    /**
+     * The connection handle is a token that can be shared outside the
+     * WebSocket++ core for the purposes of identifying a connection and
+     * sending it messages.
+     *
+     * @param hdl A connection_hdl that the connection will use to refer
+     * to itself.
+     */
+    void set_handle(connection_hdl hdl) {
+        m_connection_hdl = hdl;
+        transport_con_type::set_handle(hdl);
+    }
+
+    /// Get a message buffer
+    /**
+     * Warning: The API related to directly sending message buffers may change
+     * before the 1.0 release. If you plan to use it, please keep an eye on any
+     * breaking changes notifications in future release notes. Also if you have
+     * any feedback about usage and capabilities now is a great time to provide
+     * it.
+     *
+     * Message buffers are used to store message payloads and other message
+     * metadata.
+     *
+     * The size parameter is a hint only. Your final payload does not need to
+     * match it. There may be some performance benefits if the initial size
+     * guess is equal to or slightly higher than the final payload size.
+     *
+     * @param op The opcode for the new message
+     * @param size A hint to optimize the initial allocation of payload space.
+     * @return A new message buffer
+     */
+    message_ptr get_message(websocketpp::frame::opcode::value op, size_t size)
+        const
+    {
+        return m_msg_manager->get_message(op, size);
+    }
+
+    void start();
+
+    void read_handshake(size_t num_bytes);
+
+    void handle_read_handshake(lib::error_code const & ec,
+        size_t bytes_transferred);
+    void handle_read_http_response(lib::error_code const & ec,
+        size_t bytes_transferred);
+
+    void handle_send_http_response(lib::error_code const & ec);
+    void handle_send_http_request(lib::error_code const & ec);
+
+    void handle_open_handshake_timeout(lib::error_code const & ec);
+    void handle_close_handshake_timeout(lib::error_code const & ec);
+
+    void handle_read_frame(lib::error_code const & ec, size_t bytes_transferred);
+    void read_frame();
+
+    /// Get array of WebSocket protocol versions that this connection supports.
+    std::vector<int> const & get_supported_versions() const;
+
+    /// Sets the handler for a terminating connection. Should only be used
+    /// internally by the endpoint class.
+    void set_termination_handler(termination_handler new_handler);
+
+    void terminate(lib::error_code const & ec);
+    void handle_terminate(terminate_status tstat, lib::error_code const & ec);
+
+    /// Checks if there are frames in the send queue and if there are sends one
+    /**
+     * \todo unit tests
+     *
+     * This method locks the m_write_lock mutex
+     */
+    void write_frame();
+
+    /// Process the results of a frame write operation and start the next write
+    /**
+     * \todo unit tests
+     *
+     * This method locks the m_write_lock mutex
+     *
+     * @param terminate Whether or not to terminate the connection upon
+     * completion of this write.
+     *
+     * @param ec A status code from the transport layer, zero on success,
+     * non-zero otherwise.
+     */
+    void handle_write_frame(lib::error_code const & ec);
+protected:
+    void handle_transport_init(lib::error_code const & ec);
+
+    /// Set m_processor based on information in m_request. Set m_response
+    /// status and return an error code indicating status.
+    lib::error_code initialize_processor();
+
+    /// Perform WebSocket handshake validation of m_request using m_processor.
+    /// set m_response and return an error code indicating status.
+    lib::error_code process_handshake_request();
+private:
+    /// Completes m_response, serializes it, and sends it out on the wire.
+    void send_http_response(lib::error_code const & ec);
+
+    /// Sends an opening WebSocket connect request
+    void send_http_request();
+
+    /// Alternate path for send_http_response in error conditions
+    void send_http_response_error(lib::error_code const & ec);
+
+    /// Process control message
+    /**
+     *
+     */
+    void process_control_frame(message_ptr msg);
+
+    /// Send close acknowledgement
+    /**
+     * If no arguments are present no close code/reason will be specified.
+     *
+     * Note: the close code/reason values provided here may be overrided by
+     * other settings (such as silent close).
+     *
+     * @param code The close code to send
+     * @param reason The close reason to send
+     * @return A status code, zero on success, non-zero otherwise
+     */
+    lib::error_code send_close_ack(close::status::value code =
+        close::status::blank, std::string const & reason = "");
+
+    /// Send close frame
+    /**
+     * If no arguments are present no close code/reason will be specified.
+     *
+     * Note: the close code/reason values provided here may be overrided by
+     * other settings (such as silent close).
+     *
+     * The ack flag determines what to do in the case of a blank status and
+     * whether or not to terminate the TCP connection after sending it.
+     *
+     * @param code The close code to send
+     * @param reason The close reason to send
+     * @param ack Whether or not this is an acknowledgement close frame
+     * @return A status code, zero on success, non-zero otherwise
+     */
+    lib::error_code send_close_frame(close::status::value code =
+        close::status::blank, std::string const & reason = "", bool ack = false,
+        bool terminal = false);
+
+    /// Get a pointer to a new WebSocket protocol processor for a given version
+    /**
+     * @param version Version number of the WebSocket protocol to get a
+     * processor for. Negative values indicate invalid/unknown versions and will
+     * always return a null ptr
+     *
+     * @return A shared_ptr to a new instance of the appropriate processor or a
+     * null ptr if there is no installed processor that matches the version
+     * number.
+     */
+    processor_ptr get_processor(int version) const;
+
+    /// Add a message to the write queue
+    /**
+     * Adds a message to the write queue and updates any associated shared state
+     *
+     * Must be called while holding m_write_lock
+     *
+     * @todo unit tests
+     *
+     * @param msg The message to push
+     */
+    void write_push(message_ptr msg);
+
+    /// Pop a message from the write queue
+    /**
+     * Removes and returns a message from the write queue and updates any
+     * associated shared state.
+     *
+     * Must be called while holding m_write_lock
+     *
+     * @todo unit tests
+     *
+     * @return the message_ptr at the front of the queue
+     */
+    message_ptr write_pop();
+
+    /// Prints information about the incoming connection to the access log
+    /**
+     * Prints information about the incoming connection to the access log.
+     * Includes: connection type, websocket version, remote endpoint, user agent
+     * path, status code.
+     */
+    void log_open_result();
+
+    /// Prints information about a connection being closed to the access log
+    /**
+     * Includes: local and remote close codes and reasons
+     */
+    void log_close_result();
+
+    /// Prints information about a connection being failed to the access log
+    /**
+     * Includes: error code and message for why it was failed
+     */
+    void log_fail_result();
+    
+    /// Prints information about HTTP connections
+    /**
+     * Includes: TODO
+     */
+    void log_http_result();
+
+    /// Prints information about an arbitrary error code on the specified channel
+    template <typename error_type>
+    void log_err(log::level l, char const * msg, error_type const & ec) {
+        std::stringstream s;
+        s << msg << " error: " << ec << " (" << ec.message() << ")";
+        m_elog.write(l, s.str());
+    }
+
+    // internal handler functions
+    read_handler            m_handle_read_frame;
+    write_frame_handler     m_write_frame_handler;
+
+    // static settings
+    std::string const       m_user_agent;
+
+    /// Pointer to the connection handle
+    connection_hdl          m_connection_hdl;
+
+    /// Handler objects
+    open_handler            m_open_handler;
+    close_handler           m_close_handler;
+    fail_handler            m_fail_handler;
+    ping_handler            m_ping_handler;
+    pong_handler            m_pong_handler;
+    pong_timeout_handler    m_pong_timeout_handler;
+    interrupt_handler       m_interrupt_handler;
+    http_handler            m_http_handler;
+    validate_handler        m_validate_handler;
+    message_handler         m_message_handler;
+
+    /// constant values
+    long                    m_open_handshake_timeout_dur;
+    long                    m_close_handshake_timeout_dur;
+    long                    m_pong_timeout_dur;
+    size_t                  m_max_message_size;
+
+    /// External connection state
+    /**
+     * Lock: m_connection_state_lock
+     */
+    session::state::value   m_state;
+
+    /// Internal connection state
+    /**
+     * Lock: m_connection_state_lock
+     */
+    istate_type             m_internal_state;
+
+    mutable mutex_type      m_connection_state_lock;
+
+    /// The lock used to protect the message queue
+    /**
+     * Serializes access to the write queue as well as shared state within the
+     * processor.
+     */
+    mutex_type              m_write_lock;
+
+    // connection resources
+    char                    m_buf[config::connection_read_buffer_size];
+    size_t                  m_buf_cursor;
+    termination_handler     m_termination_handler;
+    con_msg_manager_ptr     m_msg_manager;
+    timer_ptr               m_handshake_timer;
+    timer_ptr               m_ping_timer;
+
+    /// @todo this is not memory efficient. this value is not used after the
+    /// handshake.
+    std::string m_handshake_buffer;
+
+    /// Pointer to the processor object for this connection
+    /**
+     * The processor provides functionality that is specific to the WebSocket
+     * protocol version that the client has negotiated. It also contains all of
+     * the state necessary to encode and decode the incoming and outgoing
+     * WebSocket byte streams
+     *
+     * Use of the prepare_data_frame method requires lock: m_write_lock
+     */
+    processor_ptr           m_processor;
+
+    /// Queue of unsent outgoing messages
+    /**
+     * Lock: m_write_lock
+     */
+    std::queue<message_ptr> m_send_queue;
+
+    /// Size in bytes of the outstanding payloads in the write queue
+    /**
+     * Lock: m_write_lock
+     */
+    size_t m_send_buffer_size;
+
+    /// buffer holding the various parts of the current message being writen
+    /**
+     * Lock m_write_lock
+     */
+    std::vector<transport::buffer> m_send_buffer;
+
+    /// a list of pointers to hold on to the messages being written to keep them
+    /// from going out of scope before the write is complete.
+    std::vector<message_ptr> m_current_msgs;
+
+    /// True if there is currently an outstanding transport write
+    /**
+     * Lock m_write_lock
+     */
+    bool m_write_flag;
+
+    /// True if this connection is presently reading new data
+    bool m_read_flag;
+
+    // connection data
+    request_type            m_request;
+    response_type           m_response;
+    uri_ptr                 m_uri;
+    std::string             m_subprotocol;
+
+    // connection data that might not be necessary to keep around for the life
+    // of the whole connection.
+    std::vector<std::string> m_requested_subprotocols;
+
+    bool const              m_is_server;
+    alog_type& m_alog;
+    elog_type& m_elog;
+
+    rng_type & m_rng;
+
+    // Close state
+    /// Close code that was sent on the wire by this endpoint
+    close::status::value    m_local_close_code;
+
+    /// Close reason that was sent on the wire by this endpoint
+    std::string             m_local_close_reason;
+
+    /// Close code that was received on the wire from the remote endpoint
+    close::status::value    m_remote_close_code;
+
+    /// Close reason that was received on the wire from the remote endpoint
+    std::string             m_remote_close_reason;
+
+    /// Detailed internal error code
+    lib::error_code m_ec;
+    
+    /// A flag that gets set once it is determined that the connection is an
+    /// HTTP connection and not a WebSocket one.
+    bool m_is_http;
+
+    bool m_was_clean;
+
+    /// Whether or not this endpoint initiated the closing handshake.
+    bool                    m_closed_by_me;
+
+    /// ???
+    bool                    m_failed_by_me;
+
+    /// Whether or not this endpoint initiated the drop of the TCP connection
+    bool                    m_dropped_by_me;
+};
+
+} // namespace websocketpp
+
+#include <websocketpp/impl/connection_impl.hpp>
+
+#endif // WEBSOCKETPP_CONNECTION_HPP
diff --git a/extlibs/websocketpp/websocketpp/connection_base.hpp b/extlibs/websocketpp/websocketpp/connection_base.hpp
new file mode 100644
index 000000000..2e700962f
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/connection_base.hpp
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONNECTION_BASE_HPP
+#define WEBSOCKETPP_CONNECTION_BASE_HPP
+
+namespace websocketpp {
+
+/// Stub for user supplied base class.
+class connection_base {};
+
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONNECTION_BASE_HPP
diff --git a/extlibs/websocketpp/websocketpp/endpoint.hpp b/extlibs/websocketpp/websocketpp/endpoint.hpp
new file mode 100644
index 000000000..15db1ccb3
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/endpoint.hpp
@@ -0,0 +1,619 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_ENDPOINT_HPP
+#define WEBSOCKETPP_ENDPOINT_HPP
+
+#include <websocketpp/connection.hpp>
+
+#include <websocketpp/logger/levels.hpp>
+#include <websocketpp/version.hpp>
+
+#include <string>
+
+namespace websocketpp {
+
+/// Creates and manages connections associated with a WebSocket endpoint
+template <typename connection, typename config>
+class endpoint : public config::transport_type, public config::endpoint_base {
+public:
+    // Import appropriate types from our helper class
+    // See endpoint_types for more details.
+    typedef endpoint<connection,config> type;
+
+    /// Type of the transport component of this endpoint
+    typedef typename config::transport_type transport_type;
+    /// Type of the concurrency component of this endpoint
+    typedef typename config::concurrency_type concurrency_type;
+
+    /// Type of the connections that this endpoint creates
+    typedef connection connection_type;
+    /// Shared pointer to connection_type
+    typedef typename connection_type::ptr connection_ptr;
+    /// Weak pointer to connection type
+    typedef typename connection_type::weak_ptr connection_weak_ptr;
+
+    /// Type of the transport component of the connections that this endpoint
+    /// creates
+    typedef typename transport_type::transport_con_type transport_con_type;
+    /// Type of a shared pointer to the transport component of the connections
+    /// that this endpoint creates.
+    typedef typename transport_con_type::ptr transport_con_ptr;
+
+    /// Type of message_handler
+    typedef typename connection_type::message_handler message_handler;
+    /// Type of message pointers that this endpoint uses
+    typedef typename connection_type::message_ptr message_ptr;
+
+    /// Type of error logger
+    typedef typename config::elog_type elog_type;
+    /// Type of access logger
+    typedef typename config::alog_type alog_type;
+
+    /// Type of our concurrency policy's scoped lock object
+    typedef typename concurrency_type::scoped_lock_type scoped_lock_type;
+    /// Type of our concurrency policy's mutex object
+    typedef typename concurrency_type::mutex_type mutex_type;
+
+    /// Type of RNG
+    typedef typename config::rng_type rng_type;
+
+    // TODO: organize these
+    typedef typename connection_type::termination_handler termination_handler;
+
+    explicit endpoint(bool p_is_server)
+      : m_alog(config::alog_level, log::channel_type_hint::access)
+      , m_elog(config::elog_level, log::channel_type_hint::error)
+      , m_user_agent(::websocketpp::user_agent)
+      , m_open_handshake_timeout_dur(config::timeout_open_handshake)
+      , m_close_handshake_timeout_dur(config::timeout_close_handshake)
+      , m_pong_timeout_dur(config::timeout_pong)
+      , m_max_message_size(config::max_message_size)
+      , m_max_http_body_size(config::max_http_body_size)
+      , m_is_server(p_is_server)
+    {
+        m_alog.set_channels(config::alog_level);
+        m_elog.set_channels(config::elog_level);
+
+        m_alog.write(log::alevel::devel, "endpoint constructor");
+
+        transport_type::init_logging(&m_alog, &m_elog);
+    }
+
+    /// Returns the user agent string that this endpoint will use
+    /**
+     * Returns the user agent string that this endpoint will use when creating
+     * new connections.
+     *
+     * The default value for this version is stored in websocketpp::user_agent
+     *
+     * @return The user agent string.
+     */
+    std::string get_user_agent() const {
+        scoped_lock_type guard(m_mutex);
+        return m_user_agent;
+    }
+
+    /// Sets the user agent string that this endpoint will use
+    /**
+     * Sets the identifier that this endpoint will use when creating new
+     * connections. Changing this value will only affect future connections.
+     * For client endpoints this will be sent as the "User-Agent" header in
+     * outgoing requests. For server endpoints this will be sent in the "Server"
+     * response header.
+     *
+     * Setting this value to the empty string will suppress the use of the
+     * Server and User-Agent headers. This is typically done to hide
+     * implementation details for security purposes.
+     *
+     * For best results set this before accepting or opening connections.
+     *
+     * The default value for this version is stored in websocketpp::user_agent
+     *
+     * This can be overridden on an individual connection basis by setting a
+     * custom "Server" header during the validate handler or "User-Agent"
+     * header on a connection before calling connect().
+     *
+     * @param ua The string to set the user agent to.
+     */
+    void set_user_agent(std::string const & ua) {
+        scoped_lock_type guard(m_mutex);
+        m_user_agent = ua;
+    }
+
+    /// Returns whether or not this endpoint is a server.
+    /**
+     * @return Whether or not this endpoint is a server
+     */
+    bool is_server() const {
+        return m_is_server;
+    }
+
+    /********************************/
+    /* Pass-through logging adaptor */
+    /********************************/
+
+    /// Set Access logging channel
+    /**
+     * Set the access logger's channel value. The value is a number whose
+     * interpretation depends on the logging policy in use.
+     *
+     * @param channels The channel value(s) to set
+     */
+    void set_access_channels(log::level channels) {
+        m_alog.set_channels(channels);
+    }
+
+    /// Clear Access logging channels
+    /**
+     * Clear the access logger's channel value. The value is a number whose
+     * interpretation depends on the logging policy in use.
+     *
+     * @param channels The channel value(s) to clear
+     */
+    void clear_access_channels(log::level channels) {
+        m_alog.clear_channels(channels);
+    }
+
+    /// Set Error logging channel
+    /**
+     * Set the error logger's channel value. The value is a number whose
+     * interpretation depends on the logging policy in use.
+     *
+     * @param channels The channel value(s) to set
+     */
+    void set_error_channels(log::level channels) {
+        m_elog.set_channels(channels);
+    }
+
+    /// Clear Error logging channels
+    /**
+     * Clear the error logger's channel value. The value is a number whose
+     * interpretation depends on the logging policy in use.
+     *
+     * @param channels The channel value(s) to clear
+     */
+    void clear_error_channels(log::level channels) {
+        m_elog.clear_channels(channels);
+    }
+
+    /// Get reference to access logger
+    /**
+     * @return A reference to the access logger
+     */
+    alog_type & get_alog() {
+        return m_alog;
+    }
+
+    /// Get reference to error logger
+    /**
+     * @return A reference to the error logger
+     */
+    elog_type & get_elog() {
+        return m_elog;
+    }
+
+    /*************************/
+    /* Set Handler functions */
+    /*************************/
+
+    void set_open_handler(open_handler h) {
+        m_alog.write(log::alevel::devel,"set_open_handler");
+        scoped_lock_type guard(m_mutex);
+        m_open_handler = h;
+    }
+    void set_close_handler(close_handler h) {
+        m_alog.write(log::alevel::devel,"set_close_handler");
+        scoped_lock_type guard(m_mutex);
+        m_close_handler = h;
+    }
+    void set_fail_handler(fail_handler h) {
+        m_alog.write(log::alevel::devel,"set_fail_handler");
+        scoped_lock_type guard(m_mutex);
+        m_fail_handler = h;
+    }
+    void set_ping_handler(ping_handler h) {
+        m_alog.write(log::alevel::devel,"set_ping_handler");
+        scoped_lock_type guard(m_mutex);
+        m_ping_handler = h;
+    }
+    void set_pong_handler(pong_handler h) {
+        m_alog.write(log::alevel::devel,"set_pong_handler");
+        scoped_lock_type guard(m_mutex);
+        m_pong_handler = h;
+    }
+    void set_pong_timeout_handler(pong_timeout_handler h) {
+        m_alog.write(log::alevel::devel,"set_pong_timeout_handler");
+        scoped_lock_type guard(m_mutex);
+        m_pong_timeout_handler = h;
+    }
+    void set_interrupt_handler(interrupt_handler h) {
+        m_alog.write(log::alevel::devel,"set_interrupt_handler");
+        scoped_lock_type guard(m_mutex);
+        m_interrupt_handler = h;
+    }
+    void set_http_handler(http_handler h) {
+        m_alog.write(log::alevel::devel,"set_http_handler");
+        scoped_lock_type guard(m_mutex);
+        m_http_handler = h;
+    }
+    void set_validate_handler(validate_handler h) {
+        m_alog.write(log::alevel::devel,"set_validate_handler");
+        scoped_lock_type guard(m_mutex);
+        m_validate_handler = h;
+    }
+    void set_message_handler(message_handler h) {
+        m_alog.write(log::alevel::devel,"set_message_handler");
+        scoped_lock_type guard(m_mutex);
+        m_message_handler = h;
+    }
+
+    //////////////////////////////////////////
+    // Connection timeouts and other limits //
+    //////////////////////////////////////////
+
+    /// Set open handshake timeout
+    /**
+     * Sets the length of time the library will wait after an opening handshake
+     * has been initiated before cancelling it. This can be used to prevent
+     * excessive wait times for outgoing clients or excessive resource usage
+     * from broken clients or DoS attacks on servers.
+     *
+     * Connections that time out will have their fail handlers called with the
+     * open_handshake_timeout error code.
+     *
+     * The default value is specified via the compile time config value
+     * 'timeout_open_handshake'. The default value in the core config
+     * is 5000ms. A value of 0 will disable the timer entirely.
+     *
+     * To be effective, the transport you are using must support timers. See
+     * the documentation for your transport policy for details about its
+     * timer support.
+     *
+     * @param dur The length of the open handshake timeout in ms
+     */
+    void set_open_handshake_timeout(long dur) {
+        scoped_lock_type guard(m_mutex);
+        m_open_handshake_timeout_dur = dur;
+    }
+
+    /// Set close handshake timeout
+    /**
+     * Sets the length of time the library will wait after a closing handshake
+     * has been initiated before cancelling it. This can be used to prevent
+     * excessive wait times for outgoing clients or excessive resource usage
+     * from broken clients or DoS attacks on servers.
+     *
+     * Connections that time out will have their close handlers called with the
+     * close_handshake_timeout error code.
+     *
+     * The default value is specified via the compile time config value
+     * 'timeout_close_handshake'. The default value in the core config
+     * is 5000ms. A value of 0 will disable the timer entirely.
+     *
+     * To be effective, the transport you are using must support timers. See
+     * the documentation for your transport policy for details about its
+     * timer support.
+     *
+     * @param dur The length of the close handshake timeout in ms
+     */
+    void set_close_handshake_timeout(long dur) {
+        scoped_lock_type guard(m_mutex);
+        m_close_handshake_timeout_dur = dur;
+    }
+
+    /// Set pong timeout
+    /**
+     * Sets the length of time the library will wait for a pong response to a
+     * ping. This can be used as a keepalive or to detect broken  connections.
+     *
+     * Pong responses that time out will have the pong timeout handler called.
+     *
+     * The default value is specified via the compile time config value
+     * 'timeout_pong'. The default value in the core config
+     * is 5000ms. A value of 0 will disable the timer entirely.
+     *
+     * To be effective, the transport you are using must support timers. See
+     * the documentation for your transport policy for details about its
+     * timer support.
+     *
+     * @param dur The length of the pong timeout in ms
+     */
+    void set_pong_timeout(long dur) {
+        scoped_lock_type guard(m_mutex);
+        m_pong_timeout_dur = dur;
+    }
+
+    /// Get default maximum message size
+    /**
+     * Get the default maximum message size that will be used for new 
+     * connections created by this endpoint. The maximum message size determines
+     * the point at which the connection will fail a connection with the 
+     * message_too_big protocol error.
+     *
+     * The default is set by the max_message_size value from the template config
+     *
+     * @since 0.3.0
+     */
+    size_t get_max_message_size() const {
+        return m_max_message_size;
+    }
+    
+    /// Set default maximum message size
+    /**
+     * Set the default maximum message size that will be used for new 
+     * connections created by this endpoint. Maximum message size determines the
+     * point at which the connection will fail a connection with the
+     * message_too_big protocol error.
+     *
+     * The default is set by the max_message_size value from the template config
+     *
+     * @since 0.3.0
+     *
+     * @param new_value The value to set as the maximum message size.
+     */
+    void set_max_message_size(size_t new_value) {
+        m_max_message_size = new_value;
+    }
+
+    /// Get maximum HTTP message body size
+    /**
+     * Get maximum HTTP message body size. Maximum message body size determines
+     * the point at which the connection will stop reading an HTTP request whose
+     * body is too large.
+     *
+     * The default is set by the max_http_body_size value from the template
+     * config
+     *
+     * @since 0.5.0
+     *
+     * @return The maximum HTTP message body size
+     */
+    size_t get_max_http_body_size() const {
+        return m_max_http_body_size;
+    }
+    
+    /// Set maximum HTTP message body size
+    /**
+     * Set maximum HTTP message body size. Maximum message body size determines
+     * the point at which the connection will stop reading an HTTP request whose
+     * body is too large.
+     *
+     * The default is set by the max_http_body_size value from the template
+     * config
+     *
+     * @since 0.5.1
+     *
+     * @param new_value The value to set as the maximum message size.
+     */
+    void set_max_http_body_size(size_t new_value) {
+        m_max_http_body_size = new_value;
+    }
+
+    /*************************************/
+    /* Connection pass through functions */
+    /*************************************/
+
+    /**
+     * These functions act as adaptors to their counterparts in connection. They
+     * can produce one additional type of error, the bad_connection error, that
+     * indicates that the conversion from connection_hdl to connection_ptr
+     * failed due to the connection not existing anymore. Each method has a
+     * default and an exception free varient.
+     */
+
+    void interrupt(connection_hdl hdl, lib::error_code & ec);
+    void interrupt(connection_hdl hdl);
+
+    /// Pause reading of new data (exception free)
+    /**
+     * Signals to the connection to halt reading of new data. While reading is 
+     * paused, the connection will stop reading from its associated socket. In
+     * turn this will result in TCP based flow control kicking in and slowing
+     * data flow from the remote endpoint.
+     *
+     * This is useful for applications that push new requests to a queue to be 
+     * processed by another thread and need a way to signal when their request
+     * queue is full without blocking the network processing thread.
+     *
+     * Use `resume_reading()` to resume.
+     *
+     * If supported by the transport this is done asynchronously. As such
+     * reading may not stop until the current read operation completes. 
+     * Typically you can expect to receive no more bytes after initiating a read
+     * pause than the size of the read buffer.
+     *
+     * If reading is paused for this connection already nothing is changed.
+     */
+    void pause_reading(connection_hdl hdl, lib::error_code & ec);
+    
+    /// Pause reading of new data
+    void pause_reading(connection_hdl hdl);
+
+    /// Resume reading of new data (exception free)
+    /**
+     * Signals to the connection to resume reading of new data after it was 
+     * paused by `pause_reading()`.
+     *
+     * If reading is not paused for this connection already nothing is changed.
+     */
+    void resume_reading(connection_hdl hdl, lib::error_code & ec);
+
+    /// Resume reading of new data
+    void resume_reading(connection_hdl hdl);
+
+    /// Create a message and add it to the outgoing send queue (exception free)
+    /**
+     * Convenience method to send a message given a payload string and an opcode
+     *
+     * @param [in] hdl The handle identifying the connection to send via.
+     * @param [in] payload The payload string to generated the message with
+     * @param [in] op The opcode to generated the message with.
+     * @param [out] ec A code to fill in for errors
+     */
+    void send(connection_hdl hdl, std::string const & payload,
+        frame::opcode::value op, lib::error_code & ec);
+    /// Create a message and add it to the outgoing send queue
+    /**
+     * Convenience method to send a message given a payload string and an opcode
+     *
+     * @param [in] hdl The handle identifying the connection to send via.
+     * @param [in] payload The payload string to generated the message with
+     * @param [in] op The opcode to generated the message with.
+     * @param [out] ec A code to fill in for errors
+     */
+    void send(connection_hdl hdl, std::string const & payload,
+        frame::opcode::value op);
+
+    void send(connection_hdl hdl, void const * payload, size_t len,
+        frame::opcode::value op, lib::error_code & ec);
+    void send(connection_hdl hdl, void const * payload, size_t len,
+        frame::opcode::value op);
+
+    void send(connection_hdl hdl, message_ptr msg, lib::error_code & ec);
+    void send(connection_hdl hdl, message_ptr msg);
+
+    void close(connection_hdl hdl, close::status::value const code,
+        std::string const & reason, lib::error_code & ec);
+    void close(connection_hdl hdl, close::status::value const code,
+        std::string const & reason);
+
+    /// Send a ping to a specific connection
+    /**
+     * @since 0.3.0-alpha3
+     *
+     * @param [in] hdl The connection_hdl of the connection to send to.
+     * @param [in] payload The payload string to send.
+     * @param [out] ec A reference to an error code to fill in
+     */
+    void ping(connection_hdl hdl, std::string const & payload,
+        lib::error_code & ec);
+    /// Send a ping to a specific connection
+    /**
+     * Exception variant of `ping`
+     *
+     * @since 0.3.0-alpha3
+     *
+     * @param [in] hdl The connection_hdl of the connection to send to.
+     * @param [in] payload The payload string to send.
+     */
+    void ping(connection_hdl hdl, std::string const & payload);
+
+    /// Send a pong to a specific connection
+    /**
+     * @since 0.3.0-alpha3
+     *
+     * @param [in] hdl The connection_hdl of the connection to send to.
+     * @param [in] payload The payload string to send.
+     * @param [out] ec A reference to an error code to fill in
+     */
+    void pong(connection_hdl hdl, std::string const & payload,
+        lib::error_code & ec);
+    /// Send a pong to a specific connection
+    /**
+     * Exception variant of `pong`
+     *
+     * @since 0.3.0-alpha3
+     *
+     * @param [in] hdl The connection_hdl of the connection to send to.
+     * @param [in] payload The payload string to send.
+     */
+    void pong(connection_hdl hdl, std::string const & payload);
+
+    /// Retrieves a connection_ptr from a connection_hdl (exception free)
+    /**
+     * Converting a weak pointer to shared_ptr is not thread safe because the
+     * pointer could be deleted at any time.
+     *
+     * NOTE: This method may be called by handler to upgrade its handle to a
+     * full connection_ptr. That full connection may then be used safely for the
+     * remainder of the handler body. get_con_from_hdl and the resulting
+     * connection_ptr are NOT safe to use outside the handler loop.
+     *
+     * @param hdl The connection handle to translate
+     *
+     * @return the connection_ptr. May be NULL if the handle was invalid.
+     */
+    connection_ptr get_con_from_hdl(connection_hdl hdl, lib::error_code & ec) {
+        scoped_lock_type lock(m_mutex);
+        connection_ptr con = lib::static_pointer_cast<connection_type>(
+            hdl.lock());
+        if (!con) {
+            ec = error::make_error_code(error::bad_connection);
+        }
+        return con;
+    }
+
+    /// Retrieves a connection_ptr from a connection_hdl (exception version)
+    connection_ptr get_con_from_hdl(connection_hdl hdl) {
+        lib::error_code ec;
+        connection_ptr con = this->get_con_from_hdl(hdl,ec);
+        if (ec) {
+            throw exception(ec);
+        }
+        return con;
+    }
+protected:
+    connection_ptr create_connection();
+
+    alog_type m_alog;
+    elog_type m_elog;
+private:
+    // dynamic settings
+    std::string                 m_user_agent;
+
+    open_handler                m_open_handler;
+    close_handler               m_close_handler;
+    fail_handler                m_fail_handler;
+    ping_handler                m_ping_handler;
+    pong_handler                m_pong_handler;
+    pong_timeout_handler        m_pong_timeout_handler;
+    interrupt_handler           m_interrupt_handler;
+    http_handler                m_http_handler;
+    validate_handler            m_validate_handler;
+    message_handler             m_message_handler;
+
+    long                        m_open_handshake_timeout_dur;
+    long                        m_close_handshake_timeout_dur;
+    long                        m_pong_timeout_dur;
+    size_t                      m_max_message_size;
+    size_t                      m_max_http_body_size;
+
+    rng_type m_rng;
+
+    // static settings
+    bool const                  m_is_server;
+
+    // endpoint state
+    mutable mutex_type          m_mutex;
+};
+
+} // namespace websocketpp
+
+#include <websocketpp/impl/endpoint_impl.hpp>
+
+#endif // WEBSOCKETPP_ENDPOINT_HPP
diff --git a/extlibs/websocketpp/websocketpp/endpoint_base.hpp b/extlibs/websocketpp/websocketpp/endpoint_base.hpp
new file mode 100644
index 000000000..1ad1a44dc
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/endpoint_base.hpp
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_ENDPOINT_BASE_HPP
+#define WEBSOCKETPP_ENDPOINT_BASE_HPP
+
+namespace websocketpp {
+
+/// Stub for user supplied base class.
+class endpoint_base {};
+
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_ENDPOINT_BASE_HPP
diff --git a/extlibs/websocketpp/websocketpp/error.hpp b/extlibs/websocketpp/websocketpp/error.hpp
new file mode 100644
index 000000000..81fff8733
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/error.hpp
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_ERROR_HPP
+#define WEBSOCKETPP_ERROR_HPP
+
+#include <exception>
+#include <string>
+#include <utility>
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/system_error.hpp>
+
+namespace websocketpp {
+
+/// Combination error code / string type for returning two values
+typedef std::pair<lib::error_code,std::string> err_str_pair;
+
+/// Library level error codes
+namespace error {
+enum value {
+    /// Catch-all library error
+    general = 1,
+
+    /// send attempted when endpoint write queue was full
+    send_queue_full,
+
+    /// Attempted an operation using a payload that was improperly formatted
+    /// ex: invalid UTF8 encoding on a text message.
+    payload_violation,
+
+    /// Attempted to open a secure connection with an insecure endpoint
+    endpoint_not_secure,
+
+    /// Attempted an operation that required an endpoint that is no longer
+    /// available. This is usually because the endpoint went out of scope
+    /// before a connection that it created.
+    endpoint_unavailable,
+
+    /// An invalid uri was supplied
+    invalid_uri,
+
+    /// The endpoint is out of outgoing message buffers
+    no_outgoing_buffers,
+
+    /// The endpoint is out of incoming message buffers
+    no_incoming_buffers,
+
+    /// The connection was in the wrong state for this operation
+    invalid_state,
+
+    /// Unable to parse close code
+    bad_close_code,
+
+    /// Close code is in a reserved range
+    reserved_close_code,
+
+    /// Close code is invalid
+    invalid_close_code,
+
+    /// Invalid UTF-8
+    invalid_utf8,
+
+    /// Invalid subprotocol
+    invalid_subprotocol,
+
+    /// An operation was attempted on a connection that did not exist or was
+    /// already deleted.
+    bad_connection,
+
+    /// Unit testing utility error code
+    test,
+
+    /// Connection creation attempted failed
+    con_creation_failed,
+
+    /// Selected subprotocol was not requested by the client
+    unrequested_subprotocol,
+
+    /// Attempted to use a client specific feature on a server endpoint
+    client_only,
+
+    /// Attempted to use a server specific feature on a client endpoint
+    server_only,
+
+    /// HTTP connection ended
+    http_connection_ended,
+
+    /// WebSocket opening handshake timed out
+    open_handshake_timeout,
+
+    /// WebSocket close handshake timed out
+    close_handshake_timeout,
+
+    /// Invalid port in URI
+    invalid_port,
+
+    /// An async accept operation failed because the underlying transport has been
+    /// requested to not listen for new connections anymore.
+    async_accept_not_listening,
+
+    /// The requested operation was canceled
+    operation_canceled,
+
+    /// Connection rejected
+    rejected,
+
+    /// Upgrade Required. This happens if an HTTP request is made to a
+    /// WebSocket++ server that doesn't implement an http handler
+    upgrade_required,
+
+    /// Invalid WebSocket protocol version
+    invalid_version,
+
+    /// Unsupported WebSocket protocol version
+    unsupported_version,
+
+    /// HTTP parse error
+    http_parse_error
+}; // enum value
+
+
+class category : public lib::error_category {
+public:
+    category() {}
+
+    char const * name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case error::general:
+                return "Generic error";
+            case error::send_queue_full:
+                return "send queue full";
+            case error::payload_violation:
+                return "payload violation";
+            case error::endpoint_not_secure:
+                return "endpoint not secure";
+            case error::endpoint_unavailable:
+                return "endpoint not available";
+            case error::invalid_uri:
+                return "invalid uri";
+            case error::no_outgoing_buffers:
+                return "no outgoing message buffers";
+            case error::no_incoming_buffers:
+                return "no incoming message buffers";
+            case error::invalid_state:
+                return "invalid state";
+            case error::bad_close_code:
+                return "Unable to extract close code";
+            case error::invalid_close_code:
+                return "Extracted close code is in an invalid range";
+            case error::reserved_close_code:
+                return "Extracted close code is in a reserved range";
+            case error::invalid_utf8:
+                return "Invalid UTF-8";
+            case error::invalid_subprotocol:
+                return "Invalid subprotocol";
+            case error::bad_connection:
+                return "Bad Connection";
+            case error::test:
+                return "Test Error";
+            case error::con_creation_failed:
+                return "Connection creation attempt failed";
+            case error::unrequested_subprotocol:
+                return "Selected subprotocol was not requested by the client";
+            case error::client_only:
+                return "Feature not available on server endpoints";
+            case error::server_only:
+                return "Feature not available on client endpoints";
+            case error::http_connection_ended:
+                return "HTTP connection ended";
+            case error::open_handshake_timeout:
+                return "The opening handshake timed out";
+            case error::close_handshake_timeout:
+                return "The closing handshake timed out";
+            case error::invalid_port:
+                return "Invalid URI port";
+            case error::async_accept_not_listening:
+                return "Async Accept not listening";
+            case error::operation_canceled:
+                return "Operation canceled";
+            case error::rejected:
+                return "Connection rejected";
+            case error::upgrade_required:
+                return "Upgrade required";
+            case error::invalid_version:
+                return "Invalid version";
+            case error::unsupported_version:
+                return "Unsupported version";
+            case error::http_parse_error:
+                return "HTTP parse error";
+            default:
+                return "Unknown";
+        }
+    }
+};
+
+inline const lib::error_category& get_category() {
+    static category instance;
+    return instance;
+}
+
+inline lib::error_code make_error_code(error::value e) {
+    return lib::error_code(static_cast<int>(e), get_category());
+}
+
+} // namespace error
+} // namespace websocketpp
+
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_
+template<> struct is_error_code_enum<websocketpp::error::value>
+{
+    static bool const value = true;
+};
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_
+
+namespace websocketpp {
+
+class exception : public std::exception {
+public:
+    exception(std::string const & msg, lib::error_code ec = make_error_code(error::general))
+      : m_msg(msg.empty() ? ec.message() : msg), m_code(ec)
+    {}
+
+    explicit exception(lib::error_code ec)
+      : m_code(ec)
+    {}
+
+    ~exception() throw() {}
+
+    virtual char const * what() const throw() {
+        return m_msg.c_str();
+    }
+
+    lib::error_code code() const throw() {
+        return m_code;
+    }
+
+    std::string m_msg;
+    lib::error_code m_code;
+};
+
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_ERROR_HPP
diff --git a/extlibs/websocketpp/websocketpp/extensions/extension.hpp b/extlibs/websocketpp/websocketpp/extensions/extension.hpp
new file mode 100644
index 000000000..4d2ba745d
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/extensions/extension.hpp
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_EXTENSION_HPP
+#define WEBSOCKETPP_EXTENSION_HPP
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/system_error.hpp>
+
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+
+/**
+ * Some generic information about extensions
+ *
+ * Each extension object has an implemented flag. It can be retrieved by calling
+ * is_implemented(). This compile time flag indicates whether or not the object
+ * in question actually implements the extension or if it is a placeholder stub
+ *
+ * Each extension object also has an enabled flag. It can be retrieved by
+ * calling is_enabled(). This runtime flag indicates whether or not the
+ * extension has been negotiated for this connection.
+ */
+namespace extensions {
+
+namespace error {
+enum value {
+    /// Catch all
+    general = 1,
+
+    /// Extension disabled
+    disabled
+};
+
+class category : public lib::error_category {
+public:
+    category() {}
+
+    const char *name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp.extension";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case general:
+                return "Generic extension error";
+            case disabled:
+                return "Use of methods from disabled extension";
+            default:
+                return "Unknown permessage-compress error";
+        }
+    }
+};
+
+inline const lib::error_category& get_category() {
+    static category instance;
+    return instance;
+}
+
+inline lib::error_code make_error_code(error::value e) {
+    return lib::error_code(static_cast<int>(e), get_category());
+}
+
+} // namespace error
+} // namespace extensions
+} // namespace websocketpp
+
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_
+template<> struct is_error_code_enum
+    <websocketpp::extensions::error::value>
+{
+    static const bool value = true;
+};
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_
+
+#endif // WEBSOCKETPP_EXTENSION_HPP
diff --git a/extlibs/websocketpp/websocketpp/extensions/permessage_deflate/disabled.hpp b/extlibs/websocketpp/websocketpp/extensions/permessage_deflate/disabled.hpp
new file mode 100644
index 000000000..c76bf9364
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/extensions/permessage_deflate/disabled.hpp
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_EXTENSION_PERMESSAGE_DEFLATE_DISABLED_HPP
+#define WEBSOCKETPP_EXTENSION_PERMESSAGE_DEFLATE_DISABLED_HPP
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/system_error.hpp>
+
+#include <websocketpp/http/constants.hpp>
+#include <websocketpp/extensions/extension.hpp>
+
+#include <map>
+#include <string>
+#include <utility>
+
+namespace websocketpp {
+namespace extensions {
+namespace permessage_deflate {
+
+/// Stub class for use when disabling permessage_deflate extension
+/**
+ * This class is a stub that implements the permessage_deflate interface
+ * with minimal dependencies. It is used to disable permessage_deflate
+ * functionality at compile time without loading any unnecessary code.
+ */
+template <typename config>
+class disabled {
+    typedef std::pair<lib::error_code,std::string> err_str_pair;
+
+public:
+    /// Negotiate extension
+    /**
+     * The disabled extension always fails the negotiation with a disabled 
+     * error.
+     *
+     * @param offer Attribute from client's offer
+     * @return Status code and value to return to remote endpoint
+     */
+    err_str_pair negotiate(http::attribute_list const &) {
+        return make_pair(make_error_code(error::disabled),std::string());
+    }
+
+    /// Returns true if the extension is capable of providing
+    /// permessage_deflate functionality
+    bool is_implemented() const {
+        return false;
+    }
+
+    /// Returns true if permessage_deflate functionality is active for this
+    /// connection
+    bool is_enabled() const {
+        return false;
+    }
+
+    /// Compress bytes
+    /**
+     * @param [in] in String to compress
+     * @param [out] out String to append compressed bytes to
+     * @return Error or status code
+     */
+    lib::error_code compress(std::string const &, std::string &) {
+        return make_error_code(error::disabled);
+    }
+
+    /// Decompress bytes
+    /**
+     * @param buf Byte buffer to decompress
+     * @param len Length of buf
+     * @param out String to append decompressed bytes to
+     * @return Error or status code
+     */
+    lib::error_code decompress(uint8_t const *, size_t, std::string &) {
+        return make_error_code(error::disabled);
+    }
+};
+
+} // namespace permessage_deflate
+} // namespace extensions
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_EXTENSION_PERMESSAGE_DEFLATE_DISABLED_HPP
diff --git a/extlibs/websocketpp/websocketpp/extensions/permessage_deflate/enabled.hpp b/extlibs/websocketpp/websocketpp/extensions/permessage_deflate/enabled.hpp
new file mode 100644
index 000000000..73b9b3072
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/extensions/permessage_deflate/enabled.hpp
@@ -0,0 +1,725 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_PROCESSOR_EXTENSION_PERMESSAGEDEFLATE_HPP
+#define WEBSOCKETPP_PROCESSOR_EXTENSION_PERMESSAGEDEFLATE_HPP
+
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/common/platforms.hpp>
+#include <websocketpp/common/system_error.hpp>
+#include <websocketpp/error.hpp>
+
+#include <websocketpp/extensions/extension.hpp>
+
+#include "zlib.h"
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+namespace extensions {
+
+/// Implementation of the draft permessage-deflate WebSocket extension
+/**
+ * ### permessage-deflate interface
+ *
+ * **is_implemented**\n
+ * `bool is_implemented()`\n
+ * Returns whether or not the object implements the extension or not
+ *
+ * **is_enabled**\n
+ * `bool is_enabled()`\n
+ * Returns whether or not the extension was negotiated for the current
+ * connection
+ *
+ * **generate_offer**\n
+ * `std::string generate_offer() const`\n
+ * Create an extension offer string based on local policy
+ *
+ * **validate_response**\n
+ * `lib::error_code validate_response(http::attribute_list const & response)`\n
+ * Negotiate the parameters of extension use
+ *
+ * **negotiate**\n
+ * `err_str_pair negotiate(http::attribute_list const & attributes)`\n
+ * Negotiate the parameters of extension use
+ *
+ * **compress**\n
+ * `lib::error_code compress(std::string const & in, std::string & out)`\n
+ * Compress the bytes in `in` and append them to `out`
+ *
+ * **decompress**\n
+ * `lib::error_code decompress(uint8_t const * buf, size_t len, std::string &
+ * out)`\n
+ * Decompress `len` bytes from `buf` and append them to string `out`
+ */
+namespace permessage_deflate {
+
+/// Permessage deflate error values
+namespace error {
+enum value {
+    /// Catch all
+    general = 1,
+
+    /// Invalid extension attributes
+    invalid_attributes,
+
+    /// Invalid extension attribute value
+    invalid_attribute_value,
+
+    /// Invalid megotiation mode
+    invalid_mode,
+
+    /// Unsupported extension attributes
+    unsupported_attributes,
+
+    /// Invalid value for max_window_bits
+    invalid_max_window_bits,
+
+    /// ZLib Error
+    zlib_error,
+
+    /// Uninitialized
+    uninitialized,
+};
+
+/// Permessage-deflate error category
+class category : public lib::error_category {
+public:
+    category() {}
+
+    char const * name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp.extension.permessage-deflate";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case general:
+                return "Generic permessage-compress error";
+            case invalid_attributes:
+                return "Invalid extension attributes";
+            case invalid_attribute_value:
+                return "Invalid extension attribute value";
+            case invalid_mode:
+                return "Invalid permessage-deflate negotiation mode";
+            case unsupported_attributes:
+                return "Unsupported extension attributes";
+            case invalid_max_window_bits:
+                return "Invalid value for max_window_bits";
+            case zlib_error:
+                return "A zlib function returned an error";
+            case uninitialized:
+                return "Object must be initialized before use";
+            default:
+                return "Unknown permessage-compress error";
+        }
+    }
+};
+
+/// Get a reference to a static copy of the permessage-deflate error category
+lib::error_category const & get_category() {
+    static category instance;
+    return instance;
+}
+
+/// Create an error code in the permessage-deflate category
+lib::error_code make_error_code(error::value e) {
+    return lib::error_code(static_cast<int>(e), get_category());
+}
+
+} // namespace error
+} // namespace permessage_deflate
+} // namespace extensions
+} // namespace websocketpp
+
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_
+template<> struct is_error_code_enum
+    <websocketpp::extensions::permessage_deflate::error::value>
+{
+    static bool const value = true;
+};
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_
+namespace websocketpp {
+namespace extensions {
+namespace permessage_deflate {
+
+/// Default value for s2c_max_window_bits as defined by RFC6455
+static uint8_t const default_s2c_max_window_bits = 15;
+/// Minimum value for s2c_max_window_bits as defined by RFC6455
+static uint8_t const min_s2c_max_window_bits = 8;
+/// Maximum value for s2c_max_window_bits as defined by RFC6455
+static uint8_t const max_s2c_max_window_bits = 15;
+
+/// Default value for c2s_max_window_bits as defined by RFC6455
+static uint8_t const default_c2s_max_window_bits = 15;
+/// Minimum value for c2s_max_window_bits as defined by RFC6455
+static uint8_t const min_c2s_max_window_bits = 8;
+/// Maximum value for c2s_max_window_bits as defined by RFC6455
+static uint8_t const max_c2s_max_window_bits = 15;
+
+namespace mode {
+enum value {
+    /// Accept any value the remote endpoint offers
+    accept = 1,
+    /// Decline any value the remote endpoint offers. Insist on defaults.
+    decline,
+    /// Use the largest value common to both offers
+    largest,
+    /// Use the smallest value common to both offers
+    smallest
+};
+} // namespace mode
+
+template <typename config>
+class enabled {
+public:
+    enabled()
+      : m_enabled(false)
+      , m_s2c_no_context_takeover(false)
+      , m_c2s_no_context_takeover(false)
+      , m_s2c_max_window_bits(15)
+      , m_c2s_max_window_bits(15)
+      , m_s2c_max_window_bits_mode(mode::accept)
+      , m_c2s_max_window_bits_mode(mode::accept)
+      , m_initialized(false)
+      , m_compress_buffer_size(16384)
+    {
+        m_dstate.zalloc = Z_NULL;
+        m_dstate.zfree = Z_NULL;
+        m_dstate.opaque = Z_NULL;
+
+        m_istate.zalloc = Z_NULL;
+        m_istate.zfree = Z_NULL;
+        m_istate.opaque = Z_NULL;
+        m_istate.avail_in = 0;
+        m_istate.next_in = Z_NULL;
+    }
+
+    ~enabled() {
+        if (!m_initialized) {
+            return;
+        }
+
+        int ret = deflateEnd(&m_dstate);
+
+        if (ret != Z_OK) {
+            //std::cout << "error cleaning up zlib compression state"
+            //          << std::endl;
+        }
+
+        ret = inflateEnd(&m_istate);
+
+        if (ret != Z_OK) {
+            //std::cout << "error cleaning up zlib decompression state"
+            //          << std::endl;
+        }
+    }
+
+    /// Initialize zlib state
+    /**
+     *
+     * @todo memory level, strategy, etc are hardcoded
+     * @todo server detection is hardcoded
+     */
+    lib::error_code init() {
+        uint8_t deflate_bits;
+        uint8_t inflate_bits;
+
+        if (true /*is_server*/) {
+            deflate_bits = m_s2c_max_window_bits;
+            inflate_bits = m_c2s_max_window_bits;
+        } else {
+            deflate_bits = m_c2s_max_window_bits;
+            inflate_bits = m_s2c_max_window_bits;
+        }
+
+        int ret = deflateInit2(
+            &m_dstate,
+            Z_DEFAULT_COMPRESSION,
+            Z_DEFLATED,
+            -1*deflate_bits,
+            8, // memory level 1-9
+            /*Z_DEFAULT_STRATEGY*/Z_FIXED
+        );
+
+        if (ret != Z_OK) {
+            return make_error_code(error::zlib_error);
+        }
+
+        ret = inflateInit2(
+            &m_istate,
+            -1*inflate_bits
+        );
+
+        if (ret != Z_OK) {
+            return make_error_code(error::zlib_error);
+        }
+
+        m_compress_buffer.reset(new unsigned char[m_compress_buffer_size]);
+        m_initialized = true;
+        return lib::error_code();
+    }
+
+    /// Test if this object implements the permessage-deflate specification
+    /**
+     * Because this object does implieent it, it will always return true.
+     *
+     * @return Whether or not this object implements permessage-deflate
+     */
+    bool is_implemented() const {
+        return true;
+    }
+
+    /// Test if the extension was negotiated for this connection
+    /**
+     * Retrieves whether or not this extension is in use based on the initial
+     * handshake extension negotiations.
+     *
+     * @return Whether or not the extension is in use
+     */
+    bool is_enabled() const {
+        return m_enabled;
+    }
+
+    /// Reset server's outgoing LZ77 sliding window for each new message
+    /**
+     * Enabling this setting will cause the server's compressor to reset the
+     * compression state (the LZ77 sliding window) for every message. This
+     * means that the compressor will not look back to patterns in previous
+     * messages to improve compression. This will reduce the compression
+     * efficiency for large messages somewhat and small messages drastically.
+     *
+     * This option may reduce server compressor memory usage and client
+     * decompressor memory usage.
+     * @todo Document to what extent memory usage will be reduced
+     *
+     * For clients, this option is dependent on server support. Enabling it
+     * via this method does not guarantee that it will be successfully
+     * negotiated, only that it will be requested.
+     *
+     * For servers, no client support is required. Enabling this option on a
+     * server will result in its use. The server will signal to clients that
+     * the option will be in use so they can optimize resource usage if they
+     * are able.
+     */
+    void enable_s2c_no_context_takeover() {
+        m_s2c_no_context_takeover = true;
+    }
+
+    /// Reset client's outgoing LZ77 sliding window for each new message
+    /**
+     * Enabling this setting will cause the client's compressor to reset the
+     * compression state (the LZ77 sliding window) for every message. This
+     * means that the compressor will not look back to patterns in previous
+     * messages to improve compression. This will reduce the compression
+     * efficiency for large messages somewhat and small messages drastically.
+     *
+     * This option may reduce client compressor memory usage and server
+     * decompressor memory usage.
+     * @todo Document to what extent memory usage will be reduced
+     *
+     * This option is supported by all compliant clients and servers. Enabling
+     * it via either endpoint should be sufficient to ensure it is used.
+     */
+    void enable_c2s_no_context_takeover() {
+        m_c2s_no_context_takeover = true;
+    }
+
+    /// Limit server LZ77 sliding window size
+    /**
+     * The bits setting is the base 2 logarithm of the maximum window size that
+     * the server must use to compress outgoing messages. The permitted range
+     * is 8 to 15 inclusive. 8 represents a 256 byte window and 15 a 32KiB
+     * window. The default setting is 15.
+     *
+     * Mode Options:
+     * - accept: Accept whatever the remote endpoint offers.
+     * - decline: Decline any offers to deviate from the defaults
+     * - largest: Accept largest window size acceptable to both endpoints
+     * - smallest: Accept smallest window size acceptiable to both endpoints
+     *
+     * This setting is dependent on server support. A client requesting this
+     * setting may be rejected by the server or have the exact value used
+     * adjusted by the server. A server may unilaterally set this value without
+     * client support.
+     *
+     * @param bits The size to request for the outgoing window size
+     * @param mode The mode to use for negotiating this parameter
+     * @return A status code
+     */
+    lib::error_code set_s2c_max_window_bits(uint8_t bits, mode::value mode) {
+        if (bits < min_s2c_max_window_bits || bits > max_s2c_max_window_bits) {
+            return error::make_error_code(error::invalid_max_window_bits);
+        }
+        m_s2c_max_window_bits = bits;
+        m_s2c_max_window_bits_mode = mode;
+
+        return lib::error_code();
+    }
+
+    /// Limit client LZ77 sliding window size
+    /**
+     * The bits setting is the base 2 logarithm of the window size that the
+     * client must use to compress outgoing messages. The permitted range is 8
+     * to 15 inclusive. 8 represents a 256 byte window and 15 a 32KiB window.
+     * The default setting is 15.
+     *
+     * Mode Options:
+     * - accept: Accept whatever the remote endpoint offers.
+     * - decline: Decline any offers to deviate from the defaults
+     * - largest: Accept largest window size acceptable to both endpoints
+     * - smallest: Accept smallest window size acceptiable to both endpoints
+     *
+     * This setting is dependent on client support. A client may limit its own
+     * outgoing window size unilaterally. A server may only limit the client's
+     * window size if the remote client supports that feature.
+     *
+     * @param bits The size to request for the outgoing window size
+     * @param mode The mode to use for negotiating this parameter
+     * @return A status code
+     */
+    lib::error_code set_c2s_max_window_bits(uint8_t bits, mode::value mode) {
+        if (bits < min_c2s_max_window_bits || bits > max_c2s_max_window_bits) {
+            return error::make_error_code(error::invalid_max_window_bits);
+        }
+        m_c2s_max_window_bits = bits;
+        m_c2s_max_window_bits_mode = mode;
+
+        return lib::error_code();
+    }
+
+    /// Generate extension offer
+    /**
+     * Creates an offer string to include in the Sec-WebSocket-Extensions
+     * header of outgoing client requests.
+     *
+     * @return A WebSocket extension offer string for this extension
+     */
+    std::string generate_offer() const {
+        return "";
+    }
+
+    /// Validate extension response
+    /**
+     * Confirm that the server has negotiated settings compatible with our
+     * original offer and apply those settings to the extension state.
+     *
+     * @param response The server response attribute list to validate
+     * @return Validation error or 0 on success
+     */
+    lib::error_code validate_offer(http::attribute_list const &) {
+        return make_error_code(error::general);
+    }
+
+    /// Negotiate extension
+    /**
+     * Confirm that the client's extension negotiation offer has settings
+     * compatible with local policy. If so, generate a reply and apply those
+     * settings to the extension state.
+     *
+     * @param offer Attribute from client's offer
+     * @return Status code and value to return to remote endpoint
+     */
+    err_str_pair negotiate(http::attribute_list const & offer) {
+        err_str_pair ret;
+
+        http::attribute_list::const_iterator it;
+        for (it = offer.begin(); it != offer.end(); ++it) {
+            if (it->first == "s2c_no_context_takeover") {
+                negotiate_s2c_no_context_takeover(it->second,ret.first);
+            } else if (it->first == "c2s_no_context_takeover") {
+                negotiate_c2s_no_context_takeover(it->second,ret.first);
+            } else if (it->first == "s2c_max_window_bits") {
+                negotiate_s2c_max_window_bits(it->second,ret.first);
+            } else if (it->first == "c2s_max_window_bits") {
+                negotiate_c2s_max_window_bits(it->second,ret.first);
+            } else {
+                ret.first = make_error_code(error::invalid_attributes);
+            }
+
+            if (ret.first) {
+                break;
+            }
+        }
+
+        if (ret.first == lib::error_code()) {
+            m_enabled = true;
+            ret.second = generate_response();
+        }
+
+        return ret;
+    }
+
+    /// Compress bytes
+    /**
+     * @param [in] in String to compress
+     * @param [out] out String to append compressed bytes to
+     * @return Error or status code
+     */
+    lib::error_code compress(std::string const & in, std::string & out) {
+        if (!m_initialized) {
+            return make_error_code(error::uninitialized);
+        }
+
+        size_t output;
+
+        m_dstate.avail_out = m_compress_buffer_size;
+        m_dstate.next_in = (unsigned char *)(const_cast<char *>(in.data()));
+
+        do {
+            // Output to local buffer
+            m_dstate.avail_out = m_compress_buffer_size;
+            m_dstate.next_out = m_compress_buffer.get();
+
+            deflate(&m_dstate, Z_SYNC_FLUSH);
+
+            output = m_compress_buffer_size - m_dstate.avail_out;
+
+            out.append((char *)(m_compress_buffer.get()),output);
+        } while (m_dstate.avail_out == 0);
+
+        return lib::error_code();
+    }
+
+    /// Decompress bytes
+    /**
+     * @param buf Byte buffer to decompress
+     * @param len Length of buf
+     * @param out String to append decompressed bytes to
+     * @return Error or status code
+     */
+    lib::error_code decompress(uint8_t const * buf, size_t len, std::string &
+        out)
+    {
+        if (!m_initialized) {
+            return make_error_code(error::uninitialized);
+        }
+
+        int ret;
+
+        m_istate.avail_in = len;
+        m_istate.next_in = const_cast<unsigned char *>(buf);
+
+        do {
+            m_istate.avail_out = m_compress_buffer_size;
+            m_istate.next_out = m_compress_buffer.get();
+
+            ret = inflate(&m_istate, Z_SYNC_FLUSH);
+
+            if (ret == Z_NEED_DICT || ret == Z_DATA_ERROR || ret == Z_MEM_ERROR) {
+                return make_error_code(error::zlib_error);
+            }
+
+            out.append(
+                reinterpret_cast<char *>(m_compress_buffer.get()),
+                m_compress_buffer_size - m_istate.avail_out
+            );
+        } while (m_istate.avail_out == 0);
+
+        return lib::error_code();
+    }
+private:
+    /// Generate negotiation response
+    /**
+     * @return Generate extension negotiation reponse string to send to client
+     */
+    std::string generate_response() {
+        std::string ret = "permessage-deflate";
+
+        if (m_s2c_no_context_takeover) {
+            ret += "; s2c_no_context_takeover";
+        }
+
+        if (m_c2s_no_context_takeover) {
+            ret += "; c2s_no_context_takeover";
+        }
+
+        if (m_s2c_max_window_bits < default_s2c_max_window_bits) {
+            std::stringstream s;
+            s << int(m_s2c_max_window_bits);
+            ret += "; s2c_max_window_bits="+s.str();
+        }
+
+        if (m_c2s_max_window_bits < default_c2s_max_window_bits) {
+            std::stringstream s;
+            s << int(m_c2s_max_window_bits);
+            ret += "; c2s_max_window_bits="+s.str();
+        }
+
+        return ret;
+    }
+
+    /// Negotiate s2c_no_context_takeover attribute
+    /**
+     * @param [in] value The value of the attribute from the offer
+     * @param [out] ec A reference to the error code to return errors via
+     */
+    void negotiate_s2c_no_context_takeover(std::string const & value,
+        lib::error_code & ec)
+    {
+        if (!value.empty()) {
+            ec = make_error_code(error::invalid_attribute_value);
+            return;
+        }
+
+        m_s2c_no_context_takeover = true;
+    }
+
+    /// Negotiate c2s_no_context_takeover attribute
+    /**
+     * @param [in] value The value of the attribute from the offer
+     * @param [out] ec A reference to the error code to return errors via
+     */
+    void negotiate_c2s_no_context_takeover(std::string const & value,
+        lib::error_code & ec)
+    {
+        if (!value.empty()) {
+            ec = make_error_code(error::invalid_attribute_value);
+            return;
+        }
+
+        m_c2s_no_context_takeover = true;
+    }
+
+    /// Negotiate s2c_max_window_bits attribute
+    /**
+     * When this method starts, m_s2c_max_window_bits will contain the server's
+     * preferred value and m_s2c_max_window_bits_mode will contain the mode the
+     * server wants to use to for negotiation. `value` contains the value the
+     * client requested that we use.
+     *
+     * options:
+     * - decline (refuse to use the attribute)
+     * - accept (use whatever the client says)
+     * - largest (use largest possible value)
+     * - smallest (use smallest possible value)
+     *
+     * @param [in] value The value of the attribute from the offer
+     * @param [out] ec A reference to the error code to return errors via
+     */
+    void negotiate_s2c_max_window_bits(std::string const & value,
+        lib::error_code & ec)
+    {
+        uint8_t bits = uint8_t(atoi(value.c_str()));
+
+        if (bits < min_s2c_max_window_bits || bits > max_s2c_max_window_bits) {
+            ec = make_error_code(error::invalid_attribute_value);
+            m_s2c_max_window_bits = default_s2c_max_window_bits;
+            return;
+        }
+
+        switch (m_s2c_max_window_bits_mode) {
+            case mode::decline:
+                m_s2c_max_window_bits = default_s2c_max_window_bits;
+                break;
+            case mode::accept:
+                m_s2c_max_window_bits = bits;
+                break;
+            case mode::largest:
+                m_s2c_max_window_bits = (std::min)(bits,m_s2c_max_window_bits);
+                break;
+            case mode::smallest:
+                m_s2c_max_window_bits = min_s2c_max_window_bits;
+                break;
+            default:
+                ec = make_error_code(error::invalid_mode);
+                m_s2c_max_window_bits = default_s2c_max_window_bits;
+        }
+    }
+
+    /// Negotiate c2s_max_window_bits attribute
+    /**
+     * When this method starts, m_c2s_max_window_bits and m_c2s_max_window_mode
+     * will contain the server's preferred values for window size and
+     * negotiation mode.
+     *
+     * options:
+     * - decline (refuse to use the attribute)
+     * - accept (use whatever the client says)
+     * - largest (use largest possible value)
+     * - smallest (use smallest possible value)
+     *
+     * @param [in] value The value of the attribute from the offer
+     * @param [out] ec A reference to the error code to return errors via
+     */
+    void negotiate_c2s_max_window_bits(std::string const & value,
+            lib::error_code & ec)
+    {
+        uint8_t bits = uint8_t(atoi(value.c_str()));
+
+        if (value.empty()) {
+            bits = default_c2s_max_window_bits;
+        } else if (bits < min_c2s_max_window_bits ||
+                   bits > max_c2s_max_window_bits)
+        {
+            ec = make_error_code(error::invalid_attribute_value);
+            m_c2s_max_window_bits = default_c2s_max_window_bits;
+            return;
+        }
+
+        switch (m_c2s_max_window_bits_mode) {
+            case mode::decline:
+                m_c2s_max_window_bits = default_c2s_max_window_bits;
+                break;
+            case mode::accept:
+                m_c2s_max_window_bits = bits;
+                break;
+            case mode::largest:
+                m_c2s_max_window_bits = std::min(bits,m_c2s_max_window_bits);
+                break;
+            case mode::smallest:
+                m_c2s_max_window_bits = min_c2s_max_window_bits;
+                break;
+            default:
+                ec = make_error_code(error::invalid_mode);
+                m_c2s_max_window_bits = default_c2s_max_window_bits;
+        }
+    }
+
+    bool m_enabled;
+    bool m_s2c_no_context_takeover;
+    bool m_c2s_no_context_takeover;
+    uint8_t m_s2c_max_window_bits;
+    uint8_t m_c2s_max_window_bits;
+    mode::value m_s2c_max_window_bits_mode;
+    mode::value m_c2s_max_window_bits_mode;
+
+    bool m_initialized;
+    size_t m_compress_buffer_size;
+    lib::unique_ptr_uchar_array m_compress_buffer;
+    z_stream m_dstate;
+    z_stream m_istate;
+};
+
+} // namespace permessage_deflate
+} // namespace extensions
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_PROCESSOR_EXTENSION_PERMESSAGEDEFLATE_HPP
diff --git a/extlibs/websocketpp/websocketpp/frame.hpp b/extlibs/websocketpp/websocketpp/frame.hpp
new file mode 100644
index 000000000..8a173375a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/frame.hpp
@@ -0,0 +1,861 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_FRAME_HPP
+#define WEBSOCKETPP_FRAME_HPP
+
+#include <algorithm>
+#include <string>
+
+#include <websocketpp/common/system_error.hpp>
+#include <websocketpp/common/network.hpp>
+
+#include <websocketpp/utilities.hpp>
+
+namespace websocketpp {
+/// Data structures and utility functions for manipulating WebSocket frames
+/**
+ * namespace frame provides a number of data structures and utility functions
+ * for reading, writing, and manipulating binary encoded WebSocket frames.
+ */
+namespace frame {
+
+/// Minimum length of a WebSocket frame header.
+static unsigned int const BASIC_HEADER_LENGTH = 2;
+/// Maximum length of a WebSocket header
+static unsigned int const MAX_HEADER_LENGTH = 14;
+/// Maximum length of the variable portion of the WebSocket header
+static unsigned int const MAX_EXTENDED_HEADER_LENGTH = 12;
+
+/// Two byte conversion union
+union uint16_converter {
+    uint16_t i;
+    uint8_t  c[2];
+};
+
+/// Four byte conversion union
+union uint32_converter {
+    uint32_t i;
+    uint8_t c[4];
+};
+
+/// Eight byte conversion union
+union uint64_converter {
+    uint64_t i;
+    uint8_t  c[8];
+};
+
+/// Constants and utility functions related to WebSocket opcodes
+/**
+ * WebSocket Opcodes are 4 bits. See RFC6455 section 5.2.
+ */
+namespace opcode {
+    enum value {
+        continuation = 0x0,
+        text = 0x1,
+        binary = 0x2,
+        rsv3 = 0x3,
+        rsv4 = 0x4,
+        rsv5 = 0x5,
+        rsv6 = 0x6,
+        rsv7 = 0x7,
+        close = 0x8,
+        ping = 0x9,
+        pong = 0xA,
+        control_rsvb = 0xB,
+        control_rsvc = 0xC,
+        control_rsvd = 0xD,
+        control_rsve = 0xE,
+        control_rsvf = 0xF,
+
+        CONTINUATION = 0x0,
+        TEXT = 0x1,
+        BINARY = 0x2,
+        RSV3 = 0x3,
+        RSV4 = 0x4,
+        RSV5 = 0x5,
+        RSV6 = 0x6,
+        RSV7 = 0x7,
+        CLOSE = 0x8,
+        PING = 0x9,
+        PONG = 0xA,
+        CONTROL_RSVB = 0xB,
+        CONTROL_RSVC = 0xC,
+        CONTROL_RSVD = 0xD,
+        CONTROL_RSVE = 0xE,
+        CONTROL_RSVF = 0xF
+    };
+
+    /// Check if an opcode is reserved
+    /**
+     * @param v The opcode to test.
+     * @return Whether or not the opcode is reserved.
+     */
+    inline bool reserved(value v) {
+        return (v >= rsv3 && v <= rsv7) ||
+               (v >= control_rsvb && v <= control_rsvf);
+    }
+
+    /// Check if an opcode is invalid
+    /**
+     * Invalid opcodes are negative or require greater than 4 bits to store.
+     *
+     * @param v The opcode to test.
+     * @return Whether or not the opcode is invalid.
+     */
+    inline bool invalid(value v) {
+        return (v > 0xF || v < 0);
+    }
+
+    /// Check if an opcode is for a control frame
+    /**
+     * @param v The opcode to test.
+     * @return Whether or not the opcode is a control opcode.
+     */
+    inline bool is_control(value v) {
+        return v >= 0x8;
+    }
+}
+
+/// Constants related to frame and payload limits
+namespace limits {
+    /// Minimum length of a WebSocket frame header.
+    static unsigned int const basic_header_length = 2;
+
+    /// Maximum length of a WebSocket header
+    static unsigned int const max_header_length = 14;
+
+    /// Maximum length of the variable portion of the WebSocket header
+    static unsigned int const max_extended_header_length = 12;
+
+    /// Maximum size of a basic WebSocket payload
+    static uint8_t const payload_size_basic = 125;
+
+    /// Maximum size of an extended WebSocket payload (basic payload = 126)
+    static uint16_t const payload_size_extended = 0xFFFF; // 2^16, 65535
+
+    /// Maximum size of a jumbo WebSocket payload (basic payload = 127)
+    static uint64_t const payload_size_jumbo = 0x7FFFFFFFFFFFFFFFLL;//2^63
+
+    /// Maximum size of close frame reason
+    /**
+     * This is payload_size_basic - 2 bytes (as first two bytes are used for
+     * the close code
+     */
+    static uint8_t const close_reason_size = 123;
+}
+
+
+// masks for fields in the basic header
+static uint8_t const BHB0_OPCODE = 0x0F;
+static uint8_t const BHB0_RSV3 = 0x10;
+static uint8_t const BHB0_RSV2 = 0x20;
+static uint8_t const BHB0_RSV1 = 0x40;
+static uint8_t const BHB0_FIN = 0x80;
+
+static uint8_t const BHB1_PAYLOAD = 0x7F;
+static uint8_t const BHB1_MASK = 0x80;
+
+static uint8_t const payload_size_code_16bit = 0x7E; // 126
+static uint8_t const payload_size_code_64bit = 0x7F; // 127
+
+typedef uint32_converter masking_key_type;
+
+/// The constant size component of a WebSocket frame header
+struct basic_header {
+    basic_header() : b0(0x00),b1(0x00) {}
+
+    basic_header(uint8_t p0, uint8_t p1) : b0(p0), b1(p1) {}
+
+    basic_header(opcode::value op, uint64_t size, bool fin, bool mask,
+        bool rsv1 = false, bool rsv2 = false, bool rsv3 = false) : b0(0x00),
+        b1(0x00)
+    {
+        if (fin) {
+            b0 |= BHB0_FIN;
+        }
+        if (rsv1) {
+            b0 |= BHB0_RSV1;
+        }
+        if (rsv2) {
+            b0 |= BHB0_RSV2;
+        }
+        if (rsv3) {
+            b0 |= BHB0_RSV3;
+        }
+        b0 |= (op & BHB0_OPCODE);
+
+        if (mask) {
+            b1 |= BHB1_MASK;
+        }
+
+        uint8_t basic_value;
+
+        if (size <= limits::payload_size_basic) {
+            basic_value = static_cast<uint8_t>(size);
+        } else if (size <= limits::payload_size_extended) {
+            basic_value = payload_size_code_16bit;
+        } else {
+            basic_value = payload_size_code_64bit;
+        }
+
+
+        b1 |= basic_value;
+    }
+
+    uint8_t b0;
+    uint8_t b1;
+};
+
+/// The variable size component of a WebSocket frame header
+struct extended_header {
+    extended_header() {
+        std::fill_n(this->bytes,MAX_EXTENDED_HEADER_LENGTH,0x00);
+    }
+
+    extended_header(uint64_t payload_size) {
+        std::fill_n(this->bytes,MAX_EXTENDED_HEADER_LENGTH,0x00);
+
+        copy_payload(payload_size);
+    }
+
+    extended_header(uint64_t payload_size, uint32_t masking_key) {
+        std::fill_n(this->bytes,MAX_EXTENDED_HEADER_LENGTH,0x00);
+
+        // Copy payload size
+        int offset = copy_payload(payload_size);
+
+        // Copy Masking Key
+        uint32_converter temp32;
+        temp32.i = masking_key;
+        std::copy(temp32.c,temp32.c+4,bytes+offset);
+    }
+
+    uint8_t bytes[MAX_EXTENDED_HEADER_LENGTH];
+private:
+    int copy_payload(uint64_t payload_size) {
+        int payload_offset = 0;
+
+        if (payload_size <= limits::payload_size_basic) {
+            payload_offset = 8;
+        } else if (payload_size <= limits::payload_size_extended) {
+            payload_offset = 6;
+        }
+
+        uint64_converter temp64;
+        temp64.i = lib::net::_htonll(payload_size);
+        std::copy(temp64.c+payload_offset,temp64.c+8,bytes);
+
+        return 8-payload_offset;
+    }
+};
+
+bool get_fin(basic_header const &h);
+void set_fin(basic_header &h, bool value);
+bool get_rsv1(basic_header const &h);
+void set_rsv1(basic_header &h, bool value);
+bool get_rsv2(basic_header const &h);
+void set_rsv2(basic_header &h, bool value);
+bool get_rsv3(basic_header const &h);
+void set_rsv3(basic_header &h, bool value);
+opcode::value get_opcode(basic_header const &h);
+bool get_masked(basic_header const &h);
+void set_masked(basic_header &h, bool value);
+uint8_t get_basic_size(basic_header const &);
+size_t get_header_len(basic_header const &);
+unsigned int get_masking_key_offset(basic_header const &);
+
+std::string write_header(basic_header const &, extended_header const &);
+masking_key_type get_masking_key(basic_header const &, extended_header const &);
+uint16_t get_extended_size(extended_header const &);
+uint64_t get_jumbo_size(extended_header const &);
+uint64_t get_payload_size(basic_header const &, extended_header const &);
+
+size_t prepare_masking_key(masking_key_type const & key);
+size_t circshift_prepared_key(size_t prepared_key, size_t offset);
+
+// Functions for performing xor based masking and unmasking
+template <typename input_iter, typename output_iter>
+void byte_mask(input_iter b, input_iter e, output_iter o, masking_key_type
+    const & key, size_t key_offset = 0);
+template <typename iter_type>
+void byte_mask(iter_type b, iter_type e, masking_key_type const & key,
+    size_t key_offset = 0);
+void word_mask_exact(uint8_t * input, uint8_t * output, size_t length,
+    masking_key_type const & key);
+void word_mask_exact(uint8_t * data, size_t length, masking_key_type const &
+    key);
+size_t word_mask_circ(uint8_t * input, uint8_t * output, size_t length,
+    size_t prepared_key);
+size_t word_mask_circ(uint8_t * data, size_t length, size_t prepared_key);
+
+/// Check whether the frame's FIN bit is set.
+/**
+ * @param [in] h The basic header to extract from.
+ * @return True if the header's fin bit is set.
+ */
+inline bool get_fin(basic_header const & h) {
+    return ((h.b0 & BHB0_FIN) == BHB0_FIN);
+}
+
+/// Set the frame's FIN bit
+/**
+ * @param [out] h Header to set.
+ * @param [in] value Value to set it to.
+ */
+inline void set_fin(basic_header & h, bool value) {
+    h.b0 = (value ? h.b0 | BHB0_FIN : h.b0 & ~BHB0_FIN);
+}
+
+/// check whether the frame's RSV1 bit is set
+/**
+ * @param [in] h The basic header to extract from.
+ * @return True if the header's RSV1 bit is set.
+ */
+inline bool get_rsv1(const basic_header &h) {
+    return ((h.b0 & BHB0_RSV1) == BHB0_RSV1);
+}
+
+/// Set the frame's RSV1 bit
+/**
+ * @param [out] h Header to set.
+ * @param [in] value Value to set it to.
+ */
+inline void set_rsv1(basic_header &h, bool value) {
+    h.b0 = (value ? h.b0 | BHB0_RSV1 : h.b0 & ~BHB0_RSV1);
+}
+
+/// check whether the frame's RSV2 bit is set
+/**
+ * @param [in] h The basic header to extract from.
+ * @return True if the header's RSV2 bit is set.
+ */
+inline bool get_rsv2(const basic_header &h) {
+    return ((h.b0 & BHB0_RSV2) == BHB0_RSV2);
+}
+
+/// Set the frame's RSV2 bit
+/**
+ * @param [out] h Header to set.
+ * @param [in] value Value to set it to.
+ */
+inline void set_rsv2(basic_header &h, bool value) {
+    h.b0 = (value ? h.b0 | BHB0_RSV2 : h.b0 & ~BHB0_RSV2);
+}
+
+/// check whether the frame's RSV3 bit is set
+/**
+ * @param [in] h The basic header to extract from.
+ * @return True if the header's RSV3 bit is set.
+ */
+inline bool get_rsv3(const basic_header &h) {
+    return ((h.b0 & BHB0_RSV3) == BHB0_RSV3);
+}
+
+/// Set the frame's RSV3 bit
+/**
+ * @param [out] h Header to set.
+ * @param [in] value Value to set it to.
+ */
+inline void set_rsv3(basic_header &h, bool value) {
+    h.b0 = (value ? h.b0 | BHB0_RSV3 : h.b0 & ~BHB0_RSV3);
+}
+
+/// Extract opcode from basic header
+/**
+ * @param [in] h The basic header to extract from.
+ * @return The opcode value of the header.
+ */
+inline opcode::value get_opcode(const basic_header &h) {
+    return opcode::value(h.b0 & BHB0_OPCODE);
+}
+
+/// check whether the frame is masked
+/**
+ * @param [in] h The basic header to extract from.
+ * @return True if the header mask bit is set.
+ */
+inline bool get_masked(basic_header const & h) {
+    return ((h.b1 & BHB1_MASK) == BHB1_MASK);
+}
+
+/// Set the frame's MASK bit
+/**
+ * @param [out] h Header to set.
+ * @param value Value to set it to.
+ */
+inline void set_masked(basic_header & h, bool value) {
+    h.b1 = (value ? h.b1 | BHB1_MASK : h.b1 & ~BHB1_MASK);
+}
+
+/// Extracts the raw payload length specified in the basic header
+/**
+ * A basic WebSocket frame header contains a 7 bit value that represents the
+ * payload size. There are two reserved values that are used to indicate that
+ * the actual payload size will not fit in 7 bits and that the full payload
+ * size is included in a separate field. The values are as follows:
+ *
+ * PAYLOAD_SIZE_CODE_16BIT (0x7E) indicates that the actual payload is less
+ * than 16 bit
+ *
+ * PAYLOAD_SIZE_CODE_64BIT (0x7F) indicates that the actual payload is less
+ * than 63 bit
+ *
+ * @param [in] h Basic header to read value from.
+ * @return The exact size encoded in h.
+ */
+inline uint8_t get_basic_size(const basic_header &h) {
+    return h.b1 & BHB1_PAYLOAD;
+}
+
+/// Calculates the full length of the header based on the first bytes.
+/**
+ * A WebSocket frame header always has at least two bytes. Encoded within the
+ * first two bytes is all the information necessary to calculate the full
+ * (variable) header length. get_header_len() calculates the full header
+ * length for the given two byte basic header.
+ *
+ * @param h Basic frame header to extract size from.
+ * @return Full length of the extended header.
+ */
+inline size_t get_header_len(basic_header const & h) {
+    // TODO: check extensions?
+
+    // masking key offset represents the space used for the extended length
+    // fields
+    size_t size = BASIC_HEADER_LENGTH + get_masking_key_offset(h);
+
+    // If the header is masked there is a 4 byte masking key
+    if (get_masked(h)) {
+        size += 4;
+    }
+
+    return size;
+}
+
+/// Calculate the offset location of the masking key within the extended header
+/**
+ * Calculate the offset location of the masking key within the extended header
+ * using information from its corresponding basic header
+ *
+ * @param h Corresponding basic header to calculate from.
+ *
+ * @return byte offset of the first byte of the masking key
+ */
+inline unsigned int get_masking_key_offset(const basic_header &h) {
+    if (get_basic_size(h) == payload_size_code_16bit) {
+        return 2;
+    } else if (get_basic_size(h) == payload_size_code_64bit) {
+        return 8;
+    } else {
+        return 0;
+    }
+}
+
+/// Generate a properly sized contiguous string that encodes a full frame header
+/**
+ * Copy the basic header h and extended header e into a properly sized
+ * contiguous frame header string for the purposes of writing out to the wire.
+ *
+ * @param h The basic header to include
+ * @param e The extended header to include
+ *
+ * @return A contiguous string containing h and e
+ */
+inline std::string prepare_header(const basic_header &h, const
+    extended_header &e)
+{
+    std::string ret;
+
+    ret.push_back(char(h.b0));
+    ret.push_back(char(h.b1));
+    ret.append(
+        reinterpret_cast<const char*>(e.bytes),
+        get_header_len(h)-BASIC_HEADER_LENGTH
+    );
+
+    return ret;
+}
+
+/// Extract the masking key from a frame header
+/**
+ * Note that while read and written as an integer at times, this value is not
+ * an integer and should never be interpreted as one. Big and little endian
+ * machines will generate and store masking keys differently without issue as
+ * long as the integer values remain irrelivant.
+ *
+ * @param h The basic header to extract from
+ * @param e The extended header to extract from
+ *
+ * @return The masking key as an integer.
+ */
+inline masking_key_type get_masking_key(const basic_header &h, const
+    extended_header &e)
+{
+    masking_key_type temp32;
+
+    if (!get_masked(h)) {
+        temp32.i = 0;
+    } else {
+        unsigned int offset = get_masking_key_offset(h);
+        std::copy(e.bytes+offset,e.bytes+offset+4,temp32.c);
+    }
+
+    return temp32;
+}
+
+/// Extract the extended size field from an extended header
+/**
+ * It is the responsibility of the caller to verify that e is a valid extended
+ * header. This function assumes that e contains an extended payload size.
+ *
+ * @param e The extended header to extract from
+ *
+ * @return The size encoded in the extended header in host byte order
+ */
+inline uint16_t get_extended_size(const extended_header &e) {
+    uint16_converter temp16;
+    std::copy(e.bytes,e.bytes+2,temp16.c);
+    return ntohs(temp16.i);
+}
+
+/// Extract the jumbo size field from an extended header
+/**
+ * It is the responsibility of the caller to verify that e is a valid extended
+ * header. This function assumes that e contains a jumbo payload size.
+ *
+ * @param e The extended header to extract from
+ *
+ * @return The size encoded in the extended header in host byte order
+ */
+inline uint64_t get_jumbo_size(const extended_header &e) {
+    uint64_converter temp64;
+    std::copy(e.bytes,e.bytes+8,temp64.c);
+    return lib::net::_ntohll(temp64.i);
+}
+
+/// Extract the full payload size field from a WebSocket header
+/**
+ * It is the responsibility of the caller to verify that h and e together
+ * represent a valid WebSocket frame header. This function assumes only that h
+ * and e are valid. It uses information in the basic header to determine where
+ * to look for the payload_size
+ *
+ * @param h The basic header to extract from
+ * @param e The extended header to extract from
+ *
+ * @return The size encoded in the combined header in host byte order.
+ */
+inline uint64_t get_payload_size(const basic_header &h, const
+    extended_header &e)
+{
+    uint8_t val = get_basic_size(h);
+
+    if (val <= limits::payload_size_basic) {
+        return val;
+    } else if (val == payload_size_code_16bit) {
+        return get_extended_size(e);
+    } else {
+        return get_jumbo_size(e);
+    }
+}
+
+/// Extract a masking key into a value the size of a machine word.
+/**
+ * Machine word size must be 4 or 8.
+ *
+ * @param key Masking key to extract from
+ *
+ * @return prepared key as a machine word
+ */
+inline size_t prepare_masking_key(const masking_key_type& key) {
+    size_t low_bits = static_cast<size_t>(key.i);
+
+    if (sizeof(size_t) == 8) {
+        uint64_t high_bits = static_cast<size_t>(key.i);
+        return static_cast<size_t>((high_bits << 32) | low_bits);
+    } else {
+        return low_bits;
+    }
+}
+
+/// circularly shifts the supplied prepared masking key by offset bytes
+/**
+ * Prepared_key must be the output of prepare_masking_key with the associated
+ * restrictions on the machine word size. offset must be greater than or equal
+ * to zero and less than sizeof(size_t).
+ */
+inline size_t circshift_prepared_key(size_t prepared_key, size_t offset) {
+    if (lib::net::is_little_endian()) {
+        size_t temp = prepared_key << (sizeof(size_t)-offset)*8;
+        return (prepared_key >> offset*8) | temp;
+    } else {
+        size_t temp = prepared_key >> (sizeof(size_t)-offset)*8;
+        return (prepared_key << offset*8) | temp;
+    }
+}
+
+/// Byte by byte mask/unmask
+/**
+ * Iterator based byte by byte masking and unmasking for WebSocket payloads.
+ * Performs masking in place using the supplied key offset by the supplied
+ * offset number of bytes.
+ *
+ * This function is simple and can be done in place on input with arbitrary
+ * lengths and does not vary based on machine word size. It is slow.
+ *
+ * @param b Beginning iterator to start masking
+ *
+ * @param e Ending iterator to end masking
+ *
+ * @param o Beginning iterator to store masked results
+ *
+ * @param key 32 bit key to mask with.
+ *
+ * @param key_offset offset value to start masking at.
+ */
+template <typename input_iter, typename output_iter>
+void byte_mask(input_iter first, input_iter last, output_iter result,
+    masking_key_type const & key, size_t key_offset)
+{
+    size_t key_index = key_offset%4;
+    while (first != last) {
+        *result = *first ^ key.c[key_index++];
+        key_index %= 4;
+        ++result;
+        ++first;
+    }
+}
+
+/// Byte by byte mask/unmask (in place)
+/**
+ * Iterator based byte by byte masking and unmasking for WebSocket payloads.
+ * Performs masking in place using the supplied key offset by the supplied
+ * offset number of bytes.
+ *
+ * This function is simple and can be done in place on input with arbitrary
+ * lengths and does not vary based on machine word size. It is slow.
+ *
+ * @param b Beginning iterator to start masking
+ *
+ * @param e Ending iterator to end masking
+ *
+ * @param key 32 bit key to mask with.
+ *
+ * @param key_offset offset value to start masking at.
+ */
+template <typename iter_type>
+void byte_mask(iter_type b, iter_type e, masking_key_type const & key,
+    size_t key_offset)
+{
+    byte_mask(b,e,b,key,key_offset);
+}
+
+/// Exact word aligned mask/unmask
+/**
+ * Balanced combination of byte by byte and circular word by word masking.
+ * Best used to mask complete messages at once. Has much higher setup costs than
+ * word_mask_circ but works with exact sized buffers.
+ *
+ * Buffer based word by word masking and unmasking for WebSocket payloads.
+ * Masking is done in word by word chunks with the remainder not divisible by
+ * the word size done byte by byte.
+ *
+ * input and output must both be at least length bytes. Exactly length bytes
+ * will be written.
+ *
+ * @param input buffer to mask or unmask
+ *
+ * @param output buffer to store the output. May be the same as input.
+ *
+ * @param length length of data buffer
+ *
+ * @param key Masking key to use
+ */
+inline void word_mask_exact(uint8_t* input, uint8_t* output, size_t length,
+    const masking_key_type& key)
+{
+    size_t prepared_key = prepare_masking_key(key);
+    size_t n = length/sizeof(size_t);
+    size_t* input_word = reinterpret_cast<size_t*>(input);
+    size_t* output_word = reinterpret_cast<size_t*>(output);
+
+    for (size_t i = 0; i < n; i++) {
+        output_word[i] = input_word[i] ^ prepared_key;
+    }
+
+    for (size_t i = n*sizeof(size_t); i < length; i++) {
+        output[i] = input[i] ^ key.c[i%4];
+    }
+}
+
+/// Exact word aligned mask/unmask (in place)
+/**
+ * In place version of word_mask_exact
+ *
+ * @see word_mask_exact
+ *
+ * @param data buffer to read and write from
+ *
+ * @param length length of data buffer
+ *
+ * @param key Masking key to use
+ */
+inline void word_mask_exact(uint8_t* data, size_t length, const
+    masking_key_type& key)
+{
+    word_mask_exact(data,data,length,key);
+}
+
+/// Circular word aligned mask/unmask
+/**
+ * Performs a circular mask/unmask in word sized chunks using pre-prepared keys
+ * that store state between calls. Best for providing streaming masking or
+ * unmasking of small chunks at a time of a larger message. Requires that the
+ * underlying allocated size of the data buffer be a multiple of the word size.
+ * Data in the buffer after `length` will be overwritten only with the same
+ * values that were originally present.
+ *
+ * Buffer based word by word masking and unmasking for WebSocket payloads.
+ * Performs masking in place using the supplied key. Casts the data buffer to
+ * an array of size_t's and performs masking word by word. The underlying
+ * buffer size must be a muliple of the word size.
+ *
+ * word_mask returns a copy of prepared_key circularly shifted based on the
+ * length value. The returned value may be fed back into word_mask when more
+ * data is available.
+ *
+ * input and output must both have length at least:
+ *    ceil(length/sizeof(size_t))*sizeof(size_t)
+ * Exactly that many bytes will be written, although only exactly length bytes
+ * will be changed (trailing bytes will be replaced without masking)
+ *
+ * @param data Character buffer to mask
+ *
+ * @param length Length of data
+ *
+ * @param prepared_key Prepared key to use.
+ *
+ * @return the prepared_key shifted to account for the input length
+ */
+inline size_t word_mask_circ(uint8_t * input, uint8_t * output, size_t length,
+    size_t prepared_key)
+{
+    size_t n = length / sizeof(size_t); // whole words
+    size_t l = length - (n * sizeof(size_t)); // remaining bytes
+    size_t * input_word = reinterpret_cast<size_t *>(input);
+    size_t * output_word = reinterpret_cast<size_t *>(output);
+
+    // mask word by word
+    for (size_t i = 0; i < n; i++) {
+        output_word[i] = input_word[i] ^ prepared_key;
+    }
+
+    // mask partial word at the end
+    size_t start = length - l;
+    uint8_t * byte_key = reinterpret_cast<uint8_t *>(&prepared_key);
+    for (size_t i = 0; i < l; ++i) {
+        output[start+i] = input[start+i] ^ byte_key[i];
+    }
+
+    return circshift_prepared_key(prepared_key,l);
+}
+
+/// Circular word aligned mask/unmask (in place)
+/**
+ * In place version of word_mask_circ
+ *
+ * @see word_mask_circ
+ *
+ * @param data Character buffer to read from and write to
+ *
+ * @param length Length of data
+ *
+ * @param prepared_key Prepared key to use.
+ *
+ * @return the prepared_key shifted to account for the input length
+ */
+inline size_t word_mask_circ(uint8_t* data, size_t length, size_t prepared_key){
+    return word_mask_circ(data,data,length,prepared_key);
+}
+
+/// Circular byte aligned mask/unmask
+/**
+ * Performs a circular mask/unmask in byte sized chunks using pre-prepared keys
+ * that store state between calls. Best for providing streaming masking or
+ * unmasking of small chunks at a time of a larger message. Requires that the
+ * underlying allocated size of the data buffer be a multiple of the word size.
+ * Data in the buffer after `length` will be overwritten only with the same
+ * values that were originally present.
+ *
+ * word_mask returns a copy of prepared_key circularly shifted based on the
+ * length value. The returned value may be fed back into byte_mask when more
+ * data is available.
+ *
+ * @param data Character buffer to mask
+ *
+ * @param length Length of data
+ *
+ * @param prepared_key Prepared key to use.
+ *
+ * @return the prepared_key shifted to account for the input length
+ */
+inline size_t byte_mask_circ(uint8_t * input, uint8_t * output, size_t length,
+    size_t prepared_key)
+{
+    uint32_converter key;
+    key.i = prepared_key;
+
+    for (size_t i = 0; i < length; ++i) {
+        output[i] = input[i] ^ key.c[i % 4];
+    }
+
+    return circshift_prepared_key(prepared_key,length % 4);
+}
+
+/// Circular byte aligned mask/unmask (in place)
+/**
+ * In place version of byte_mask_circ
+ *
+ * @see byte_mask_circ
+ *
+ * @param data Character buffer to read from and write to
+ *
+ * @param length Length of data
+ *
+ * @param prepared_key Prepared key to use.
+ *
+ * @return the prepared_key shifted to account for the input length
+ */
+inline size_t byte_mask_circ(uint8_t* data, size_t length, size_t prepared_key){
+    return byte_mask_circ(data,data,length,prepared_key);
+}
+
+} // namespace frame
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_FRAME_HPP
diff --git a/extlibs/websocketpp/websocketpp/http/constants.hpp b/extlibs/websocketpp/websocketpp/http/constants.hpp
new file mode 100644
index 000000000..10e726d0b
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/http/constants.hpp
@@ -0,0 +1,308 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef HTTP_CONSTANTS_HPP
+#define HTTP_CONSTANTS_HPP
+
+#include <exception>
+#include <map>
+#include <string>
+#include <vector>
+#include <utility>
+
+namespace websocketpp {
+/// HTTP handling support
+namespace http {
+    /// The type of an HTTP attribute list
+    /**
+     * The attribute list is an unordered key/value map. Encoded attribute
+     * values are delimited by semicolons.
+     */
+    typedef std::map<std::string,std::string> attribute_list;
+
+    /// The type of an HTTP parameter list
+    /**
+     * The parameter list is an ordered pairing of a parameter and its
+     * associated attribute list. Encoded parameter values are delimited by
+     * commas.
+     */
+    typedef std::vector< std::pair<std::string,attribute_list> > parameter_list;
+
+    /// Literal value of the HTTP header delimiter
+    static char const header_delimiter[] = "\r\n";
+
+    /// Literal value of the HTTP header separator
+    static char const header_separator[] = ":";
+
+    /// Literal value of an empty header
+    static std::string const empty_header = "";
+
+    /// Maximum size in bytes before rejecting an HTTP header as too big.
+    size_t const max_header_size = 16000;
+    
+    /// Default Maximum size in bytes for HTTP message bodies.
+    size_t const max_body_size = 32000000;
+
+    /// Number of bytes to use for temporary istream read buffers
+    size_t const istream_buffer = 512;
+
+    /// invalid HTTP token characters
+    /**
+     * 0x00 - 0x32, 0x7f-0xff
+     * ( ) < > @ , ; : \ " / [ ] ? = { }
+     */
+    static char const header_token[] = {
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..0f
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 10..1f
+        0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0, // 20..2f
+        1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0, // 30..3f
+        0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 40..4f
+        1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1, // 50..5f
+        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 60..6f
+        1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0, // 70..7f
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 80..8f
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 90..9f
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // a0..af
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // b0..bf
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // c0..cf
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // d0..df
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // e0..ef
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // f0..ff
+    };
+
+    /// Is the character a token
+    inline bool is_token_char(unsigned char c) {
+        return (header_token[c] == 1);
+    }
+
+    /// Is the character a non-token
+    inline bool is_not_token_char(unsigned char c) {
+        return !header_token[c];
+    }
+
+    /// Is the character whitespace
+    /**
+     * whitespace is space (32) or horizontal tab (9)
+     */
+    inline bool is_whitespace_char(unsigned char c) {
+        return (c == 9 || c == 32);
+    }
+
+    /// Is the character non-whitespace
+    inline bool is_not_whitespace_char(unsigned char c) {
+        return (c != 9 && c != 32);
+    }
+
+    /// HTTP Status codes
+    namespace status_code {
+        enum value {
+            uninitialized = 0,
+
+            continue_code = 100,
+            switching_protocols = 101,
+
+            ok = 200,
+            created = 201,
+            accepted = 202,
+            non_authoritative_information = 203,
+            no_content = 204,
+            reset_content = 205,
+            partial_content = 206,
+
+            multiple_choices = 300,
+            moved_permanently = 301,
+            found = 302,
+            see_other = 303,
+            not_modified = 304,
+            use_proxy = 305,
+            temporary_redirect = 307,
+
+            bad_request = 400,
+            unauthorized = 401,
+            payment_required = 402,
+            forbidden = 403,
+            not_found = 404,
+            method_not_allowed = 405,
+            not_acceptable = 406,
+            proxy_authentication_required = 407,
+            request_timeout = 408,
+            conflict = 409,
+            gone = 410,
+            length_required = 411,
+            precondition_failed = 412,
+            request_entity_too_large = 413,
+            request_uri_too_long = 414,
+            unsupported_media_type = 415,
+            request_range_not_satisfiable = 416,
+            expectation_failed = 417,
+            im_a_teapot = 418,
+            upgrade_required = 426,
+            precondition_required = 428,
+            too_many_requests = 429,
+            request_header_fields_too_large = 431,
+
+            internal_server_error = 500,
+            not_implemented = 501,
+            bad_gateway = 502,
+            service_unavailable = 503,
+            gateway_timeout = 504,
+            http_version_not_supported = 505,
+            not_extended = 510,
+            network_authentication_required = 511
+        };
+
+        // TODO: should this be inline?
+        inline std::string get_string(value c) {
+            switch (c) {
+                case uninitialized:
+                    return "Uninitialized";
+                case continue_code:
+                    return "Continue";
+                case switching_protocols:
+                    return "Switching Protocols";
+                case ok:
+                    return "OK";
+                case created:
+                    return "Created";
+                case accepted:
+                    return "Accepted";
+                case non_authoritative_information:
+                    return "Non Authoritative Information";
+                case no_content:
+                    return "No Content";
+                case reset_content:
+                    return "Reset Content";
+                case partial_content:
+                    return "Partial Content";
+                case multiple_choices:
+                    return "Multiple Choices";
+                case moved_permanently:
+                    return "Moved Permanently";
+                case found:
+                    return "Found";
+                case see_other:
+                    return "See Other";
+                case not_modified:
+                    return "Not Modified";
+                case use_proxy:
+                    return "Use Proxy";
+                case temporary_redirect:
+                    return "Temporary Redirect";
+                case bad_request:
+                    return "Bad Request";
+                case unauthorized:
+                    return "Unauthorized";
+                case payment_required:
+                    return "Payment Required";
+                case forbidden:
+                    return "Forbidden";
+                case not_found:
+                    return "Not Found";
+                case method_not_allowed:
+                    return "Method Not Allowed";
+                case not_acceptable:
+                    return "Not Acceptable";
+                case proxy_authentication_required:
+                    return "Proxy Authentication Required";
+                case request_timeout:
+                    return "Request Timeout";
+                case conflict:
+                    return "Conflict";
+                case gone:
+                    return "Gone";
+                case length_required:
+                    return "Length Required";
+                case precondition_failed:
+                    return "Precondition Failed";
+                case request_entity_too_large:
+                    return "Request Entity Too Large";
+                case request_uri_too_long:
+                    return "Request-URI Too Long";
+                case unsupported_media_type:
+                    return "Unsupported Media Type";
+                case request_range_not_satisfiable:
+                    return "Requested Range Not Satisfiable";
+                case expectation_failed:
+                    return "Expectation Failed";
+                case im_a_teapot:
+                    return "I'm a teapot";
+                case upgrade_required:
+                    return "Upgrade Required";
+                case precondition_required:
+                    return "Precondition Required";
+                case too_many_requests:
+                    return "Too Many Requests";
+                case request_header_fields_too_large:
+                    return "Request Header Fields Too Large";
+                case internal_server_error:
+                    return "Internal Server Error";
+                case not_implemented:
+                    return "Not Implemented";
+                case bad_gateway:
+                    return "Bad Gateway";
+                case service_unavailable:
+                    return "Service Unavailable";
+                case gateway_timeout:
+                    return "Gateway Timeout";
+                case http_version_not_supported:
+                    return "HTTP Version Not Supported";
+                case not_extended:
+                    return "Not Extended";
+                case network_authentication_required:
+                    return "Network Authentication Required";
+                default:
+                    return "Unknown";
+            }
+        }
+    }
+
+    class exception : public std::exception {
+    public:
+        exception(const std::string& log_msg,
+                  status_code::value error_code,
+                  const std::string& error_msg = "",
+                  const std::string& body = "")
+          : m_msg(log_msg)
+          , m_error_msg(error_msg)
+          , m_body(body)
+          , m_error_code(error_code) {}
+
+        ~exception() throw() {}
+
+        virtual const char* what() const throw() {
+            return m_msg.c_str();
+        }
+
+        std::string         m_msg;
+        std::string         m_error_msg;
+        std::string         m_body;
+        status_code::value  m_error_code;
+    };
+}
+}
+
+#endif // HTTP_CONSTANTS_HPP
diff --git a/extlibs/websocketpp/websocketpp/http/impl/parser.hpp b/extlibs/websocketpp/websocketpp/http/impl/parser.hpp
new file mode 100644
index 000000000..92799a406
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/http/impl/parser.hpp
@@ -0,0 +1,196 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef HTTP_PARSER_IMPL_HPP
+#define HTTP_PARSER_IMPL_HPP
+
+#include <algorithm>
+#include <cstdlib>
+#include <istream>
+#include <sstream>
+#include <string>
+
+namespace websocketpp {
+namespace http {
+namespace parser {
+
+inline void parser::set_version(std::string const & version) {
+    m_version = version;
+}
+
+inline std::string const & parser::get_header(std::string const & key) const {
+    header_list::const_iterator h = m_headers.find(key);
+
+    if (h == m_headers.end()) {
+        return empty_header;
+    } else {
+        return h->second;
+    }
+}
+
+inline bool parser::get_header_as_plist(std::string const & key,
+    parameter_list & out) const
+{
+    header_list::const_iterator it = m_headers.find(key);
+
+    if (it == m_headers.end() || it->second.size() == 0) {
+        return false;
+    }
+
+    return this->parse_parameter_list(it->second,out);
+}
+
+inline void parser::append_header(std::string const & key, std::string const &
+    val)
+{
+    if (std::find_if(key.begin(),key.end(),is_not_token_char) != key.end()) {
+        throw exception("Invalid header name",status_code::bad_request);
+    }
+
+    if (this->get_header(key) == "") {
+        m_headers[key] = val;
+    } else {
+        m_headers[key] += ", " + val;
+    }
+}
+
+inline void parser::replace_header(std::string const & key, std::string const &
+    val)
+{
+    m_headers[key] = val;
+}
+
+inline void parser::remove_header(std::string const & key) {
+    m_headers.erase(key);
+}
+
+inline void parser::set_body(std::string const & value) {
+    if (value.size() == 0) {
+        remove_header("Content-Length");
+        m_body = "";
+        return;
+    }
+
+    // TODO: should this method respect the max size? If so how should errors
+    // be indicated?
+
+    std::stringstream len;
+    len << value.size();
+    replace_header("Content-Length", len.str());
+    m_body = value;
+}
+
+inline bool parser::parse_parameter_list(std::string const & in,
+    parameter_list & out) const
+{
+    if (in.size() == 0) {
+        return false;
+    }
+
+    std::string::const_iterator it;
+    it = extract_parameters(in.begin(),in.end(),out);
+    return (it == in.begin());
+}
+
+inline bool parser::prepare_body() {
+    if (get_header("Content-Length") != "") {
+        std::string const & cl_header = get_header("Content-Length");
+        char * end;
+        
+        // TODO: not 100% sure what the compatibility of this method is. Also,
+        // I believe this will only work up to 32bit sizes. Is there a need for
+        // > 4GiB HTTP payloads?
+        m_body_bytes_needed = std::strtoul(cl_header.c_str(),&end,10);
+        
+        if (m_body_bytes_needed > m_body_bytes_max) {
+            throw exception("HTTP message body too large",
+                status_code::request_entity_too_large);
+        }
+        
+        m_body_encoding = body_encoding::plain;
+        return true;
+    } else if (get_header("Transfer-Encoding") == "chunked") {
+        // TODO
+        //m_body_encoding = body_encoding::chunked;
+        return false;
+    } else {
+        return false;
+    }
+}
+
+inline size_t parser::process_body(char const * buf, size_t len) {
+    if (m_body_encoding == body_encoding::plain) {
+        size_t processed = (std::min)(m_body_bytes_needed,len);
+        m_body.append(buf,processed);
+        m_body_bytes_needed -= processed;
+        return processed;
+    } else if (m_body_encoding == body_encoding::chunked) {
+        // TODO: 
+        throw exception("Unexpected body encoding",
+            status_code::internal_server_error);
+    } else {
+        throw exception("Unexpected body encoding",
+            status_code::internal_server_error);
+    }
+}
+
+inline void parser::process_header(std::string::iterator begin,
+    std::string::iterator end)
+{
+    std::string::iterator cursor = std::search(
+        begin,
+        end,
+        header_separator,
+        header_separator + sizeof(header_separator) - 1
+    );
+
+    if (cursor == end) {
+        throw exception("Invalid header line",status_code::bad_request);
+    }
+
+    append_header(strip_lws(std::string(begin,cursor)),
+                  strip_lws(std::string(cursor+sizeof(header_separator)-1,end)));
+}
+
+inline std::string parser::raw_headers() const {
+    std::stringstream raw;
+
+    header_list::const_iterator it;
+    for (it = m_headers.begin(); it != m_headers.end(); it++) {
+        raw << it->first << ": " << it->second << "\r\n";
+    }
+
+    return raw.str();
+}
+
+
+
+} // namespace parser
+} // namespace http
+} // namespace websocketpp
+
+#endif // HTTP_PARSER_IMPL_HPP
diff --git a/extlibs/websocketpp/websocketpp/http/impl/request.hpp b/extlibs/websocketpp/websocketpp/http/impl/request.hpp
new file mode 100644
index 000000000..5da936f04
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/http/impl/request.hpp
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef HTTP_PARSER_REQUEST_IMPL_HPP
+#define HTTP_PARSER_REQUEST_IMPL_HPP
+
+#include <algorithm>
+#include <sstream>
+#include <string>
+
+#include <websocketpp/http/parser.hpp>
+
+namespace websocketpp {
+namespace http {
+namespace parser {
+
+inline size_t request::consume(char const * buf, size_t len) {
+    size_t bytes_processed;
+    
+    if (m_ready) {return 0;}
+    
+    if (m_body_bytes_needed > 0) {
+        bytes_processed = process_body(buf,len);
+        if (body_ready()) {
+            m_ready = true;
+        }
+        return bytes_processed;
+    }
+
+    // copy new header bytes into buffer
+    m_buf->append(buf,len);
+
+    // Search for delimiter in buf. If found read until then. If not read all
+    std::string::iterator begin = m_buf->begin();
+    std::string::iterator end;
+
+    for (;;) {
+        // search for line delimiter
+        end = std::search(
+            begin,
+            m_buf->end(),
+            header_delimiter,
+            header_delimiter+sizeof(header_delimiter)-1
+        );
+        
+        m_header_bytes += (end-begin+sizeof(header_delimiter));
+        
+        if (m_header_bytes > max_header_size) {
+            // exceeded max header size
+            throw exception("Maximum header size exceeded.",
+                status_code::request_header_fields_too_large);
+        }
+
+        if (end == m_buf->end()) {
+            // we are out of bytes. Discard the processed bytes and copy the
+            // remaining unprecessed bytes to the beginning of the buffer
+            std::copy(begin,end,m_buf->begin());
+            m_buf->resize(static_cast<std::string::size_type>(end-begin));
+            m_header_bytes -= m_buf->size();
+
+            return len;
+        }
+
+        //the range [begin,end) now represents a line to be processed.
+        if (end-begin == 0) {
+            // we got a blank line
+            if (m_method.empty() || get_header("Host") == "") {
+                throw exception("Incomplete Request",status_code::bad_request);
+            }
+
+            bytes_processed = (
+                len - static_cast<std::string::size_type>(m_buf->end()-end)
+                    + sizeof(header_delimiter) - 1
+            );
+
+            // frees memory used temporarily during request parsing
+            m_buf.reset();
+
+            // if this was not an upgrade request and has a content length
+            // continue capturing content-length bytes and expose them as a 
+            // request body.
+            
+            if (prepare_body()) {
+                bytes_processed += process_body(buf+bytes_processed,len-bytes_processed);
+                if (body_ready()) {
+                    m_ready = true;
+                }
+                return bytes_processed;
+            } else {
+                m_ready = true;
+
+                // return number of bytes processed (starting bytes - bytes left)
+                return bytes_processed;
+            }
+        } else {
+            if (m_method.empty()) {
+                this->process(begin,end);
+            } else {
+                this->process_header(begin,end);
+            }
+        }
+
+        begin = end+(sizeof(header_delimiter)-1);
+    }
+}
+
+inline std::string request::raw() const {
+    // TODO: validation. Make sure all required fields have been set?
+    std::stringstream ret;
+
+    ret << m_method << " " << m_uri << " " << get_version() << "\r\n";
+    ret << raw_headers() << "\r\n" << m_body;
+
+    return ret.str();
+}
+
+inline std::string request::raw_head() const {
+    // TODO: validation. Make sure all required fields have been set?
+    std::stringstream ret;
+
+    ret << m_method << " " << m_uri << " " << get_version() << "\r\n";
+    ret << raw_headers() << "\r\n";
+
+    return ret.str();
+}
+
+inline void request::set_method(std::string const & method) {
+    if (std::find_if(method.begin(),method.end(),is_not_token_char) != method.end()) {
+        throw exception("Invalid method token.",status_code::bad_request);
+    }
+
+    m_method = method;
+}
+
+inline void request::set_uri(std::string const & uri) {
+    // TODO: validation?
+    m_uri = uri;
+}
+
+inline void request::process(std::string::iterator begin, std::string::iterator
+    end)
+{
+    std::string::iterator cursor_start = begin;
+    std::string::iterator cursor_end = std::find(begin,end,' ');
+
+    if (cursor_end == end) {
+        throw exception("Invalid request line1",status_code::bad_request);
+    }
+
+    set_method(std::string(cursor_start,cursor_end));
+
+    cursor_start = cursor_end+1;
+    cursor_end = std::find(cursor_start,end,' ');
+
+    if (cursor_end == end) {
+        throw exception("Invalid request line2",status_code::bad_request);
+    }
+
+    set_uri(std::string(cursor_start,cursor_end));
+    set_version(std::string(cursor_end+1,end));
+}
+
+} // namespace parser
+} // namespace http
+} // namespace websocketpp
+
+#endif // HTTP_PARSER_REQUEST_IMPL_HPP
diff --git a/extlibs/websocketpp/websocketpp/http/impl/response.hpp b/extlibs/websocketpp/websocketpp/http/impl/response.hpp
new file mode 100644
index 000000000..653d1be36
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/http/impl/response.hpp
@@ -0,0 +1,266 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef HTTP_PARSER_RESPONSE_IMPL_HPP
+#define HTTP_PARSER_RESPONSE_IMPL_HPP
+
+#include <algorithm>
+#include <istream>
+#include <sstream>
+#include <string>
+
+#include <websocketpp/http/parser.hpp>
+
+namespace websocketpp {
+namespace http {
+namespace parser {
+
+inline size_t response::consume(char const * buf, size_t len) {
+    if (m_state == DONE) {return 0;}
+
+    if (m_state == BODY) {
+        return this->process_body(buf,len);
+    }
+
+    // copy new header bytes into buffer
+    m_buf->append(buf,len);
+
+    // Search for delimiter in buf. If found read until then. If not read all
+    std::string::iterator begin = m_buf->begin();
+    std::string::iterator end = begin;
+
+
+    for (;;) {
+        // search for delimiter
+        end = std::search(
+            begin,
+            m_buf->end(),
+            header_delimiter,
+            header_delimiter + sizeof(header_delimiter) - 1
+        );
+
+        m_header_bytes += (end-begin+sizeof(header_delimiter));
+        
+        if (m_header_bytes > max_header_size) {
+            // exceeded max header size
+            throw exception("Maximum header size exceeded.",
+                status_code::request_header_fields_too_large);
+        }
+
+        if (end == m_buf->end()) {
+            // we are out of bytes. Discard the processed bytes and copy the
+            // remaining unprecessed bytes to the beginning of the buffer
+            std::copy(begin,end,m_buf->begin());
+            m_buf->resize(static_cast<std::string::size_type>(end-begin));
+
+            m_read += len;
+            m_header_bytes -= m_buf->size();
+
+            return len;
+        }
+
+        //the range [begin,end) now represents a line to be processed.
+
+        if (end-begin == 0) {
+            // we got a blank line
+            if (m_state == RESPONSE_LINE) {
+                throw exception("Incomplete Request",status_code::bad_request);
+            }
+
+            // TODO: grab content-length
+            std::string length = get_header("Content-Length");
+
+            if (length == "") {
+                // no content length found, read indefinitely
+                m_read = 0;
+            } else {
+                std::istringstream ss(length);
+
+                if ((ss >> m_read).fail()) {
+                    throw exception("Unable to parse Content-Length header",
+                                    status_code::bad_request);
+                }
+            }
+
+            m_state = BODY;
+
+            // calc header bytes processed (starting bytes - bytes left)
+            size_t read = (
+                len - static_cast<std::string::size_type>(m_buf->end() - end)
+                + sizeof(header_delimiter) - 1
+            );
+
+            // if there were bytes left process them as body bytes
+            if (read < len) {
+                read += this->process_body(buf+read,(len-read));
+            }
+
+            // frees memory used temporarily during header parsing
+            m_buf.reset();
+
+            return read;
+        } else {
+            if (m_state == RESPONSE_LINE) {
+                this->process(begin,end);
+                m_state = HEADERS;
+            } else {
+                this->process_header(begin,end);
+            }
+        }
+
+        begin = end+(sizeof(header_delimiter) - 1);
+    }
+}
+
+inline size_t response::consume(std::istream & s) {
+    char buf[istream_buffer];
+    size_t bytes_read;
+    size_t bytes_processed;
+    size_t total = 0;
+
+    while (s.good()) {
+        s.getline(buf,istream_buffer);
+        bytes_read = static_cast<size_t>(s.gcount());
+
+        if (s.fail() || s.eof()) {
+            bytes_processed = this->consume(buf,bytes_read);
+            total += bytes_processed;
+
+            if (bytes_processed != bytes_read) {
+                // problem
+                break;
+            }
+        } else if (s.bad()) {
+            // problem
+            break;
+        } else {
+            // the delimiting newline was found. Replace the trailing null with
+            // the newline that was discarded, since our raw consume function
+            // expects the newline to be be there.
+            buf[bytes_read-1] = '\n';
+            bytes_processed = this->consume(buf,bytes_read);
+            total += bytes_processed;
+
+            if (bytes_processed != bytes_read) {
+                // problem
+                break;
+            }
+        }
+    }
+
+    return total;
+}
+
+inline std::string response::raw() const {
+    // TODO: validation. Make sure all required fields have been set?
+
+    std::stringstream ret;
+
+    ret << get_version() << " " << m_status_code << " " << m_status_msg;
+    ret << "\r\n" << raw_headers() << "\r\n";
+
+    ret << m_body;
+
+    return ret.str();
+}
+
+inline void response::set_status(status_code::value code) {
+    // TODO: validation?
+    m_status_code = code;
+    m_status_msg = get_string(code);
+}
+
+inline void response::set_status(status_code::value code, std::string const &
+    msg)
+{
+    // TODO: validation?
+    m_status_code = code;
+    m_status_msg = msg;
+}
+
+inline void response::process(std::string::iterator begin,
+    std::string::iterator end)
+{
+    std::string::iterator cursor_start = begin;
+    std::string::iterator cursor_end = std::find(begin,end,' ');
+
+    if (cursor_end == end) {
+        throw exception("Invalid response line",status_code::bad_request);
+    }
+
+    set_version(std::string(cursor_start,cursor_end));
+
+    cursor_start = cursor_end+1;
+    cursor_end = std::find(cursor_start,end,' ');
+
+    if (cursor_end == end) {
+        throw exception("Invalid request line",status_code::bad_request);
+    }
+
+    int code;
+
+    std::istringstream ss(std::string(cursor_start,cursor_end));
+
+    if ((ss >> code).fail()) {
+        throw exception("Unable to parse response code",status_code::bad_request);
+    }
+
+    set_status(status_code::value(code),std::string(cursor_end+1,end));
+}
+
+inline size_t response::process_body(char const * buf, size_t len) {
+    // If no content length was set then we read forever and never set m_ready
+    if (m_read == 0) {
+        //m_body.append(buf,len);
+        //return len;
+        m_state = DONE;
+        return 0;
+    }
+
+    // Otherwise m_read is the number of bytes left.
+    size_t to_read;
+
+    if (len >= m_read) {
+        // if we have more bytes than we need read, read only the amount needed
+        // then set done state
+        to_read = m_read;
+        m_state = DONE;
+    } else {
+        // we need more bytes than are available, read them all
+        to_read = len;
+    }
+
+    m_body.append(buf,to_read);
+    m_read -= to_read;
+    return to_read;
+}
+
+} // namespace parser
+} // namespace http
+} // namespace websocketpp
+
+#endif // HTTP_PARSER_RESPONSE_IMPL_HPP
diff --git a/extlibs/websocketpp/websocketpp/http/parser.hpp b/extlibs/websocketpp/websocketpp/http/parser.hpp
new file mode 100644
index 000000000..c66da6cee
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/http/parser.hpp
@@ -0,0 +1,615 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef HTTP_PARSER_HPP
+#define HTTP_PARSER_HPP
+
+#include <algorithm>
+#include <map>
+#include <string>
+#include <utility>
+
+#include <websocketpp/utilities.hpp>
+#include <websocketpp/http/constants.hpp>
+
+namespace websocketpp {
+namespace http {
+namespace parser {
+
+namespace state {
+    enum value {
+        method,
+        resource,
+        version,
+        headers
+    };
+}
+
+namespace body_encoding {
+    enum value {
+        unknown,
+        plain,
+        chunked
+    };
+}
+
+typedef std::map<std::string, std::string, utility::ci_less > header_list;
+
+/// Read and return the next token in the stream
+/**
+ * Read until a non-token character is found and then return the token and
+ * iterator to the next character to read
+ *
+ * @param begin An iterator to the beginning of the sequence
+ * @param end An iterator to the end of the sequence
+ * @return A pair containing the token and an iterator to the next character in
+ * the stream
+ */
+template <typename InputIterator>
+std::pair<std::string,InputIterator> extract_token(InputIterator begin,
+    InputIterator end)
+{
+    InputIterator it = std::find_if(begin,end,&is_not_token_char);
+    return std::make_pair(std::string(begin,it),it);
+}
+
+/// Read and return the next quoted string in the stream
+/**
+ * Read a double quoted string starting at `begin`. The quotes themselves are
+ * stripped. The quoted value is returned along with an iterator to the next
+ * character to read
+ *
+ * @param begin An iterator to the beginning of the sequence
+ * @param end An iterator to the end of the sequence
+ * @return A pair containing the string read and an iterator to the next
+ * character in the stream
+ */
+template <typename InputIterator>
+std::pair<std::string,InputIterator> extract_quoted_string(InputIterator begin,
+    InputIterator end)
+{
+    std::string s;
+
+    if (end == begin) {
+        return std::make_pair(s,begin);
+    }
+
+    if (*begin != '"') {
+        return std::make_pair(s,begin);
+    }
+
+    InputIterator cursor = begin+1;
+    InputIterator marker = cursor;
+
+    cursor = std::find(cursor,end,'"');
+
+    while (cursor != end) {
+        // either this is the end or a quoted string
+        if (*(cursor-1) == '\\') {
+            s.append(marker,cursor-1);
+            s.append(1,'"');
+            ++cursor;
+            marker = cursor;
+        } else {
+            s.append(marker,cursor);
+            ++cursor;
+            return std::make_pair(s,cursor);
+        }
+
+        cursor = std::find(cursor,end,'"');
+    }
+
+    return std::make_pair("",begin);
+}
+
+/// Read and discard one unit of linear whitespace
+/**
+ * Read one unit of linear white space and return the iterator to the character
+ * afterwards. If `begin` is returned, no whitespace was extracted.
+ *
+ * @param begin An iterator to the beginning of the sequence
+ * @param end An iterator to the end of the sequence
+ * @return An iterator to the character after the linear whitespace read
+ */
+template <typename InputIterator>
+InputIterator extract_lws(InputIterator begin, InputIterator end) {
+    InputIterator it = begin;
+
+    // strip leading CRLF
+    if (end-begin > 2 && *begin == '\r' && *(begin+1) == '\n' &&
+        is_whitespace_char(static_cast<unsigned char>(*(begin+2))))
+    {
+        it+=3;
+    }
+
+    it = std::find_if(it,end,&is_not_whitespace_char);
+    return it;
+}
+
+/// Read and discard linear whitespace
+/**
+ * Read linear white space until a non-lws character is read and return an
+ * iterator to that character. If `begin` is returned, no whitespace was
+ * extracted.
+ *
+ * @param begin An iterator to the beginning of the sequence
+ * @param end An iterator to the end of the sequence
+ * @return An iterator to the character after the linear whitespace read
+ */
+template <typename InputIterator>
+InputIterator extract_all_lws(InputIterator begin, InputIterator end) {
+    InputIterator old_it;
+    InputIterator new_it = begin;
+
+    do {
+        // Pull value from previous iteration
+        old_it = new_it;
+
+        // look ahead another pass
+        new_it = extract_lws(old_it,end);
+    } while (new_it != end && old_it != new_it);
+
+    return new_it;
+}
+
+/// Extract HTTP attributes
+/**
+ * An http attributes list is a semicolon delimited list of key value pairs in
+ * the format: *( ";" attribute "=" value ) where attribute is a token and value
+ * is a token or quoted string.
+ *
+ * Attributes extracted are appended to the supplied attributes list
+ * `attributes`.
+ *
+ * @param [in] begin An iterator to the beginning of the sequence
+ * @param [in] end An iterator to the end of the sequence
+ * @param [out] attributes A reference to the attributes list to append
+ * attribute/value pairs extracted to
+ * @return An iterator to the character after the last atribute read
+ */
+template <typename InputIterator>
+InputIterator extract_attributes(InputIterator begin, InputIterator end,
+    attribute_list & attributes)
+{
+    InputIterator cursor;
+    bool first = true;
+
+    if (begin == end) {
+        return begin;
+    }
+
+    cursor = begin;
+    std::pair<std::string,InputIterator> ret;
+
+    while (cursor != end) {
+        std::string name;
+
+        cursor = http::parser::extract_all_lws(cursor,end);
+        if (cursor == end) {
+            break;
+        }
+
+        if (first) {
+            // ignore this check for the very first pass
+            first = false;
+        } else {
+            if (*cursor == ';') {
+                // advance past the ';'
+                ++cursor;
+            } else {
+                // non-semicolon in this position indicates end end of the
+                // attribute list, break and return.
+                break;
+            }
+        }
+
+        cursor = http::parser::extract_all_lws(cursor,end);
+        ret = http::parser::extract_token(cursor,end);
+
+        if (ret.first == "") {
+            // error: expected a token
+            return begin;
+        } else {
+            name = ret.first;
+            cursor = ret.second;
+        }
+
+        cursor = http::parser::extract_all_lws(cursor,end);
+        if (cursor == end || *cursor != '=') {
+            // if there is an equals sign, read the attribute value. Otherwise
+            // record a blank value and continue
+            attributes[name] = "";
+            continue;
+        }
+
+        // advance past the '='
+        ++cursor;
+
+        cursor = http::parser::extract_all_lws(cursor,end);
+        if (cursor == end) {
+            // error: expected a token or quoted string
+            return begin;
+        }
+
+        ret = http::parser::extract_quoted_string(cursor,end);
+        if (ret.second != cursor) {
+            attributes[name] = ret.first;
+            cursor = ret.second;
+            continue;
+        }
+
+        ret = http::parser::extract_token(cursor,end);
+        if (ret.first == "") {
+            // error : expected token or quoted string
+            return begin;
+        } else {
+            attributes[name] = ret.first;
+            cursor = ret.second;
+        }
+    }
+
+    return cursor;
+}
+
+/// Extract HTTP parameters
+/**
+ * An http parameters list is a comma delimited list of tokens followed by
+ * optional semicolon delimited attributes lists.
+ *
+ * Parameters extracted are appended to the supplied parameters list
+ * `parameters`.
+ *
+ * @param [in] begin An iterator to the beginning of the sequence
+ * @param [in] end An iterator to the end of the sequence
+ * @param [out] parameters A reference to the parameters list to append
+ * paramter values extracted to
+ * @return An iterator to the character after the last parameter read
+ */
+template <typename InputIterator>
+InputIterator extract_parameters(InputIterator begin, InputIterator end,
+    parameter_list &parameters)
+{
+    InputIterator cursor;
+
+    if (begin == end) {
+        // error: expected non-zero length range
+        return begin;
+    }
+
+    cursor = begin;
+    std::pair<std::string,InputIterator> ret;
+
+    /**
+     * LWS
+     * token
+     * LWS
+     * *(";" method-param)
+     * LWS
+     * ,=loop again
+     */
+    while (cursor != end) {
+        std::string parameter_name;
+        attribute_list attributes;
+
+        // extract any stray whitespace
+        cursor = http::parser::extract_all_lws(cursor,end);
+        if (cursor == end) {break;}
+
+        ret = http::parser::extract_token(cursor,end);
+
+        if (ret.first == "") {
+            // error: expected a token
+            return begin;
+        } else {
+            parameter_name = ret.first;
+            cursor = ret.second;
+        }
+
+        // Safe break point, insert parameter with blank attributes and exit
+        cursor = http::parser::extract_all_lws(cursor,end);
+        if (cursor == end) {
+            //parameters[parameter_name] = attributes;
+            parameters.push_back(std::make_pair(parameter_name,attributes));
+            break;
+        }
+
+        // If there is an attribute list, read it in
+        if (*cursor == ';') {
+            InputIterator acursor;
+
+            ++cursor;
+            acursor = http::parser::extract_attributes(cursor,end,attributes);
+
+            if (acursor == cursor) {
+                // attribute extraction ended in syntax error
+                return begin;
+            }
+
+            cursor = acursor;
+        }
+
+        // insert parameter into output list
+        //parameters[parameter_name] = attributes;
+        parameters.push_back(std::make_pair(parameter_name,attributes));
+
+        cursor = http::parser::extract_all_lws(cursor,end);
+        if (cursor == end) {break;}
+
+        // if next char is ',' then read another parameter, else stop
+        if (*cursor != ',') {
+            break;
+        }
+
+        // advance past comma
+        ++cursor;
+
+        if (cursor == end) {
+            // expected more bytes after a comma
+            return begin;
+        }
+    }
+
+    return cursor;
+}
+
+inline std::string strip_lws(std::string const & input) {
+    std::string::const_iterator begin = extract_all_lws(input.begin(),input.end());
+    if (begin == input.end()) {
+        return std::string();
+    }
+    std::string::const_reverse_iterator end = extract_all_lws(input.rbegin(),input.rend());
+
+    return std::string(begin,end.base());
+}
+
+/// Base HTTP parser
+/**
+ * Includes methods and data elements common to all types of HTTP messages such
+ * as headers, versions, bodies, etc.
+ */
+class parser {
+public:
+    parser()
+      : m_header_bytes(0)
+      , m_body_bytes_needed(0)
+      , m_body_bytes_max(max_body_size)
+      , m_body_encoding(body_encoding::unknown) {}
+    
+    /// Get the HTTP version string
+    /**
+     * @return The version string for this parser
+     */
+    std::string const & get_version() const {
+        return m_version;
+    }
+
+    /// Set HTTP parser Version
+    /**
+     * Input should be in format: HTTP/x.y where x and y are positive integers.
+     * @todo Does this method need any validation?
+     *
+     * @param [in] version The value to set the HTTP version to.
+     */
+    void set_version(std::string const & version);
+
+    /// Get the value of an HTTP header
+    /**
+     * @todo Make this method case insensitive.
+     *
+     * @param [in] key The name/key of the header to get.
+     * @return The value associated with the given HTTP header key.
+     */
+    std::string const & get_header(std::string const & key) const;
+
+    /// Extract an HTTP parameter list from a parser header.
+    /**
+     * If the header requested doesn't exist or exists and is empty the
+     * parameter list is valid (but empty).
+     *
+     * @param [in] key The name/key of the HTTP header to use as input.
+     * @param [out] out The parameter list to store extracted parameters in.
+     * @return Whether or not the input was a valid parameter list.
+     */
+    bool get_header_as_plist(std::string const & key, parameter_list & out)
+        const;
+
+    /// Append a value to an existing HTTP header
+    /**
+     * This method will set the value of the HTTP header `key` with the
+     * indicated value. If a header with the name `key` already exists, `val`
+     * will be appended to the existing value.
+     *
+     * @todo Make this method case insensitive.
+     * @todo Should there be any restrictions on which keys are allowed?
+     * @todo Exception free varient
+     *
+     * @see replace_header
+     *
+     * @param [in] key The name/key of the header to append to.
+     * @param [in] val The value to append.
+     */
+    void append_header(std::string const & key, std::string const & val);
+
+    /// Set a value for an HTTP header, replacing an existing value
+    /**
+     * This method will set the value of the HTTP header `key` with the
+     * indicated value. If a header with the name `key` already exists, `val`
+     * will replace the existing value.
+     *
+     * @todo Make this method case insensitive.
+     * @todo Should there be any restrictions on which keys are allowed?
+     * @todo Exception free varient
+     *
+     * @see append_header
+     *
+     * @param [in] key The name/key of the header to append to.
+     * @param [in] val The value to append.
+     */
+    void replace_header(std::string const & key, std::string const & val);
+
+    /// Remove a header from the parser
+    /**
+     * Removes the header entirely from the parser. This is different than
+     * setting the value of the header to blank.
+     *
+     * @todo Make this method case insensitive.
+     *
+     * @param [in] key The name/key of the header to remove.
+     */
+    void remove_header(std::string const & key);
+
+    /// Get HTTP body
+    /**
+     * Gets the body of the HTTP object
+     *
+     * @return The body of the HTTP message.
+     */
+    std::string const & get_body() const {
+        return m_body;
+    }
+
+    /// Set body content
+    /**
+     * Set the body content of the HTTP response to the parameter string. Note
+     * set_body will also set the Content-Length HTTP header to the appropriate
+     * value. If you want the Content-Length header to be something else, do so
+     * via replace_header("Content-Length") after calling set_body()
+     *
+     * @param value String data to include as the body content.
+     */
+    void set_body(std::string const & value);
+
+    /// Get body size limit
+    /**
+     * Retrieves the maximum number of bytes to parse & buffer before canceling
+     * a request.
+     *
+     * @since 0.5.0
+     *
+     * @return The maximum length of a message body.
+     */
+    size_t get_max_body_size() const {
+        return m_body_bytes_max;
+    }
+
+    /// Set body size limit
+    /**
+     * Set the maximum number of bytes to parse and buffer before canceling a
+     * request.
+     *
+     * @since 0.5.0
+     *
+     * @param value The size to set the max body length to.
+     */
+    void set_max_body_size(size_t value) {
+        m_body_bytes_max = value;
+    }
+
+    /// Extract an HTTP parameter list from a string.
+    /**
+     * @param [in] in The input string.
+     * @param [out] out The parameter list to store extracted parameters in.
+     * @return Whether or not the input was a valid parameter list.
+     */
+    bool parse_parameter_list(std::string const & in, parameter_list & out)
+        const;
+protected:
+    /// Process a header line
+    /**
+     * @todo Update this method to be exception free.
+     *
+     * @param [in] begin An iterator to the beginning of the sequence.
+     * @param [in] end An iterator to the end of the sequence.
+     */
+    void process_header(std::string::iterator begin, std::string::iterator end);
+
+    /// Prepare the parser to begin parsing body data
+    /**
+     * Inspects headers to determine if the message has a body that needs to be
+     * read. If so, sets up the necessary state, otherwise returns false. If
+     * this method returns true and loading the message body is desired call
+     * `process_body` until it returns zero bytes or an error.
+     *
+     * Must not be called until after all headers have been processed.
+     *
+     * @since 0.5.0
+     *
+     * @return True if more bytes are needed to load the body, false otherwise.
+     */
+    bool prepare_body();
+
+    /// Process body data
+    /**
+     * Parses body data.
+     *
+     * @since 0.5.0
+     *
+     * @param [in] begin An iterator to the beginning of the sequence.
+     * @param [in] end An iterator to the end of the sequence.
+     * @return The number of bytes processed
+     */
+    size_t process_body(char const * buf, size_t len);
+
+    /// Check if the parser is done parsing the body
+    /**
+     * Behavior before a call to `prepare_body` is undefined.
+     *
+     * @since 0.5.0
+     *
+     * @return True if the message body has been completed loaded.
+     */
+    bool body_ready() const {
+        return (m_body_bytes_needed == 0);
+    }
+
+    /// Generate and return the HTTP headers as a string
+    /**
+     * Each headers will be followed by the \r\n sequence including the last one.
+     * A second \r\n sequence (blank header) is not appended by this method
+     *
+     * @return The HTTP headers as a string.
+     */
+    std::string raw_headers() const;
+
+    std::string m_version;
+    header_list m_headers;
+    
+    size_t                  m_header_bytes;
+    
+    std::string             m_body;
+    size_t                  m_body_bytes_needed;
+    size_t                  m_body_bytes_max;
+    body_encoding::value    m_body_encoding;
+};
+
+} // namespace parser
+} // namespace http
+} // namespace websocketpp
+
+#include <websocketpp/http/impl/parser.hpp>
+
+#endif // HTTP_PARSER_HPP
diff --git a/extlibs/websocketpp/websocketpp/http/request.hpp b/extlibs/websocketpp/websocketpp/http/request.hpp
new file mode 100644
index 000000000..3355c99b8
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/http/request.hpp
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef HTTP_PARSER_REQUEST_HPP
+#define HTTP_PARSER_REQUEST_HPP
+
+#include <string>
+
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/http/parser.hpp>
+
+namespace websocketpp {
+namespace http {
+namespace parser {
+
+/// Stores, parses, and manipulates HTTP requests
+/**
+ * http::request provides the following functionality for working with HTTP
+ * requests.
+ *
+ * - Initialize request via manually setting each element
+ * - Initialize request via reading raw bytes and parsing
+ * - Once initialized, access individual parsed elements
+ * - Once initialized, read entire request as raw bytes
+ */
+class request : public parser {
+public:
+    typedef request type;
+    typedef lib::shared_ptr<type> ptr;
+
+    request()
+      : m_buf(lib::make_shared<std::string>())
+      , m_ready(false) {}
+
+    /// Process bytes in the input buffer
+    /**
+     * Process up to len bytes from input buffer buf. Returns the number of
+     * bytes processed. Bytes left unprocessed means bytes left over after the
+     * final header delimiters.
+     *
+     * Consume is a streaming processor. It may be called multiple times on one
+     * request and the full headers need not be available before processing can
+     * begin. If the end of the request was reached during this call to consume
+     * the ready flag will be set. Further calls to consume once ready will be
+     * ignored.
+     *
+     * Consume will throw an http::exception in the case of an error. Typical
+     * error reasons include malformed requests, incomplete requests, and max
+     * header size being reached.
+     *
+     * @param buf Pointer to byte buffer
+     * @param len Size of byte buffer
+     * @return Number of bytes processed.
+     */
+    size_t consume(char const * buf, size_t len);
+
+    /// Returns whether or not the request is ready for reading.
+    bool ready() const {
+        return m_ready;
+    }
+
+    /// Returns the full raw request (including the body)
+    std::string raw() const;
+    
+    /// Returns the raw request headers only (similar to an HTTP HEAD request)
+    std::string raw_head() const;
+
+    /// Set the HTTP method. Must be a valid HTTP token
+    void set_method(std::string const & method);
+
+    /// Return the request method
+    std::string const & get_method() const {
+        return m_method;
+    }
+
+    /// Set the HTTP uri. Must be a valid HTTP uri
+    void set_uri(std::string const & uri);
+
+    /// Return the requested URI
+    std::string const & get_uri() const {
+        return m_uri;
+    }
+
+private:
+    /// Helper function for message::consume. Process request line
+    void process(std::string::iterator begin, std::string::iterator end);
+
+    lib::shared_ptr<std::string>    m_buf;
+    std::string                     m_method;
+    std::string                     m_uri;
+    bool                            m_ready;
+};
+
+} // namespace parser
+} // namespace http
+} // namespace websocketpp
+
+#include <websocketpp/http/impl/request.hpp>
+
+#endif // HTTP_PARSER_REQUEST_HPP
diff --git a/extlibs/websocketpp/websocketpp/http/response.hpp b/extlibs/websocketpp/websocketpp/http/response.hpp
new file mode 100644
index 000000000..e724a3d3a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/http/response.hpp
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef HTTP_PARSER_RESPONSE_HPP
+#define HTTP_PARSER_RESPONSE_HPP
+
+#include <iostream>
+#include <string>
+
+#include <websocketpp/http/parser.hpp>
+
+namespace websocketpp {
+namespace http {
+namespace parser {
+
+/// Stores, parses, and manipulates HTTP responses
+/**
+ * http::response provides the following functionality for working with HTTP
+ * responses.
+ *
+ * - Initialize response via manually setting each element
+ * - Initialize response via reading raw bytes and parsing
+ * - Once initialized, access individual parsed elements
+ * - Once initialized, read entire response as raw bytes
+ *
+ * http::response checks for header completeness separately from the full
+ * response. Once the header is complete, the Content-Length header is read to
+ * determine when to stop reading body bytes. If no Content-Length is present
+ * ready() will never return true. It is the responsibility of the caller to
+ * consume to determine when the response is complete (ie when the connection
+ * terminates, or some other metric).
+ */
+class response : public parser {
+public:
+    typedef response type;
+    typedef lib::shared_ptr<type> ptr;
+
+    response()
+      : m_read(0)
+      , m_buf(lib::make_shared<std::string>())
+      , m_status_code(status_code::uninitialized)
+      , m_state(RESPONSE_LINE) {}
+
+    /// Process bytes in the input buffer
+    /**
+     * Process up to len bytes from input buffer buf. Returns the number of
+     * bytes processed. Bytes left unprocessed means bytes left over after the
+     * final header delimiters.
+     *
+     * Consume is a streaming processor. It may be called multiple times on one
+     * response and the full headers need not be available before processing can
+     * begin. If the end of the response was reached during this call to consume
+     * the ready flag will be set. Further calls to consume once ready will be
+     * ignored.
+     *
+     * Consume will throw an http::exception in the case of an error. Typical
+     * error reasons include malformed responses, incomplete responses, and max
+     * header size being reached.
+     *
+     * @param buf Pointer to byte buffer
+     * @param len Size of byte buffer
+     * @return Number of bytes processed.
+     */
+    size_t consume(char const * buf, size_t len);
+
+    /// Process bytes in the input buffer (istream version)
+    /**
+     * Process bytes from istream s. Returns the number of bytes processed. 
+     * Bytes left unprocessed means bytes left over after the final header
+     * delimiters.
+     *
+     * Consume is a streaming processor. It may be called multiple times on one
+     * response and the full headers need not be available before processing can
+     * begin. If the end of the response was reached during this call to consume
+     * the ready flag will be set. Further calls to consume once ready will be
+     * ignored.
+     *
+     * Consume will throw an http::exception in the case of an error. Typical
+     * error reasons include malformed responses, incomplete responses, and max
+     * header size being reached.
+     *
+     * @param buf Pointer to byte buffer
+     * @param len Size of byte buffer
+     * @return Number of bytes processed.
+     */
+    size_t consume(std::istream & s);
+
+    /// Returns true if the response is ready.
+    /**
+     * @note will never return true if the content length header is not present
+     */
+    bool ready() const {
+        return m_state == DONE;
+    }
+
+    /// Returns true if the response headers are fully parsed.
+    bool headers_ready() const {
+        return (m_state == BODY || m_state == DONE);
+    }
+
+    /// Returns the full raw response
+    std::string raw() const;
+
+    /// Set response status code and message
+    /**
+     * Sets the response status code to `code` and looks up the corresponding
+     * message for standard codes. Non-standard codes will be entered as Unknown
+     * use set_status(status_code::value,std::string) overload to set both
+     * values explicitly.
+     *
+     * @param code Code to set
+     * @param msg Message to set
+     */
+    void set_status(status_code::value code);
+
+    /// Set response status code and message
+    /**
+     * Sets the response status code and message to independent custom values.
+     * use set_status(status_code::value) to set the code and have the standard
+     * message be automatically set.
+     *
+     * @param code Code to set
+     * @param msg Message to set
+     */
+    void set_status(status_code::value code, std::string const & msg);
+
+    /// Return the response status code
+    status_code::value get_status_code() const {
+        return m_status_code;
+    }
+
+    /// Return the response status message
+    const std::string& get_status_msg() const {
+        return m_status_msg;
+    }
+private:
+    /// Helper function for consume. Process response line
+    void process(std::string::iterator begin, std::string::iterator end);
+
+    /// Helper function for processing body bytes
+    size_t process_body(char const * buf, size_t len);
+
+    enum state {
+        RESPONSE_LINE = 0,
+        HEADERS = 1,
+        BODY = 2,
+        DONE = 3
+    };
+
+    std::string                     m_status_msg;
+    size_t                          m_read;
+    lib::shared_ptr<std::string>    m_buf;
+    status_code::value              m_status_code;
+    state                           m_state;
+
+};
+
+} // namespace parser
+} // namespace http
+} // namespace websocketpp
+
+#include <websocketpp/http/impl/response.hpp>
+
+#endif // HTTP_PARSER_RESPONSE_HPP
diff --git a/extlibs/websocketpp/websocketpp/impl/connection_impl.hpp b/extlibs/websocketpp/websocketpp/impl/connection_impl.hpp
new file mode 100644
index 000000000..55832d01a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/impl/connection_impl.hpp
@@ -0,0 +1,2267 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CONNECTION_IMPL_HPP
+#define WEBSOCKETPP_CONNECTION_IMPL_HPP
+
+#include <websocketpp/processors/hybi00.hpp>
+#include <websocketpp/processors/hybi07.hpp>
+#include <websocketpp/processors/hybi08.hpp>
+#include <websocketpp/processors/hybi13.hpp>
+
+#include <websocketpp/processors/processor.hpp>
+
+#include <websocketpp/common/platforms.hpp>
+#include <websocketpp/common/system_error.hpp>
+
+#include <algorithm>
+#include <exception>
+#include <sstream>
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace websocketpp {
+
+namespace istate = session::internal_state;
+
+template <typename config>
+void connection<config>::set_termination_handler(
+    termination_handler new_handler)
+{
+    m_alog.write(log::alevel::devel,
+        "connection set_termination_handler");
+
+    //scoped_lock_type lock(m_connection_state_lock);
+
+    m_termination_handler = new_handler;
+}
+
+template <typename config>
+std::string const & connection<config>::get_origin() const {
+    //scoped_lock_type lock(m_connection_state_lock);
+    return m_processor->get_origin(m_request);
+}
+
+template <typename config>
+size_t connection<config>::get_buffered_amount() const {
+    //scoped_lock_type lock(m_connection_state_lock);
+    return m_send_buffer_size;
+}
+
+template <typename config>
+session::state::value connection<config>::get_state() const {
+    //scoped_lock_type lock(m_connection_state_lock);
+    return m_state;
+}
+
+template <typename config>
+lib::error_code connection<config>::send(std::string const & payload,
+    frame::opcode::value op)
+{
+    message_ptr msg = m_msg_manager->get_message(op,payload.size());
+    msg->append_payload(payload);
+
+    return send(msg);
+}
+
+template <typename config>
+lib::error_code connection<config>::send(void const * payload, size_t len,
+    frame::opcode::value op)
+{
+    message_ptr msg = m_msg_manager->get_message(op,len);
+    msg->append_payload(payload,len);
+
+    return send(msg);
+}
+
+template <typename config>
+lib::error_code connection<config>::send(typename config::message_type::ptr msg)
+{
+    if (m_alog.static_test(log::alevel::devel)) {
+        m_alog.write(log::alevel::devel,"connection send");
+    }
+
+    {
+        scoped_lock_type lock(m_connection_state_lock);
+        if (m_state != session::state::open) {
+           return error::make_error_code(error::invalid_state);
+        }
+    }
+
+    message_ptr outgoing_msg;
+    bool needs_writing = false;
+
+    if (msg->get_prepared()) {
+        outgoing_msg = msg;
+
+        scoped_lock_type lock(m_write_lock);
+        write_push(outgoing_msg);
+        needs_writing = !m_write_flag && !m_send_queue.empty();
+    } else {
+        outgoing_msg = m_msg_manager->get_message();
+
+        if (!outgoing_msg) {
+            return error::make_error_code(error::no_outgoing_buffers);
+        }
+
+        scoped_lock_type lock(m_write_lock);
+        lib::error_code ec = m_processor->prepare_data_frame(msg,outgoing_msg);
+
+        if (ec) {
+            return ec;
+        }
+
+        write_push(outgoing_msg);
+        needs_writing = !m_write_flag && !m_send_queue.empty();
+    }
+
+    if (needs_writing) {
+        transport_con_type::dispatch(lib::bind(
+            &type::write_frame,
+            type::get_shared()
+        ));
+    }
+
+    return lib::error_code();
+}
+
+template <typename config>
+void connection<config>::ping(std::string const& payload, lib::error_code& ec) {
+    if (m_alog.static_test(log::alevel::devel)) {
+        m_alog.write(log::alevel::devel,"connection ping");
+    }
+
+    {
+        scoped_lock_type lock(m_connection_state_lock);
+        if (m_state != session::state::open) {
+            std::stringstream ss;
+            ss << "connection::ping called from invalid state " << m_state;
+            m_alog.write(log::alevel::devel,ss.str());
+            ec = error::make_error_code(error::invalid_state);
+            return;
+        }
+    }
+
+    message_ptr msg = m_msg_manager->get_message();
+    if (!msg) {
+        ec = error::make_error_code(error::no_outgoing_buffers);
+        return;
+    }
+
+    ec = m_processor->prepare_ping(payload,msg);
+    if (ec) {return;}
+
+    // set ping timer if we are listening for one
+    if (m_pong_timeout_handler) {
+        // Cancel any existing timers
+        if (m_ping_timer) {
+            m_ping_timer->cancel();
+        }
+
+        if (m_pong_timeout_dur > 0) {
+            m_ping_timer = transport_con_type::set_timer(
+                m_pong_timeout_dur,
+                lib::bind(
+                    &type::handle_pong_timeout,
+                    type::get_shared(),
+                    payload,
+                    lib::placeholders::_1
+                )
+            );
+        }
+
+        if (!m_ping_timer) {
+            // Our transport doesn't support timers
+            m_elog.write(log::elevel::warn,"Warning: a pong_timeout_handler is \
+                set but the transport in use does not support timeouts.");
+        }
+    }
+
+    bool needs_writing = false;
+    {
+        scoped_lock_type lock(m_write_lock);
+        write_push(msg);
+        needs_writing = !m_write_flag && !m_send_queue.empty();
+    }
+
+    if (needs_writing) {
+        transport_con_type::dispatch(lib::bind(
+            &type::write_frame,
+            type::get_shared()
+        ));
+    }
+
+    ec = lib::error_code();
+}
+
+template<typename config>
+void connection<config>::ping(std::string const & payload) {
+    lib::error_code ec;
+    ping(payload,ec);
+    if (ec) {
+        throw exception(ec);
+    }
+}
+
+template<typename config>
+void connection<config>::handle_pong_timeout(std::string payload,
+    lib::error_code const & ec)
+{
+    if (ec) {
+        if (ec == transport::error::operation_aborted) {
+            // ignore, this is expected
+            return;
+        }
+
+        m_elog.write(log::elevel::devel,"pong_timeout error: "+ec.message());
+        return;
+    }
+
+    if (m_pong_timeout_handler) {
+        m_pong_timeout_handler(m_connection_hdl,payload);
+    }
+}
+
+template <typename config>
+void connection<config>::pong(std::string const& payload, lib::error_code& ec) {
+    if (m_alog.static_test(log::alevel::devel)) {
+        m_alog.write(log::alevel::devel,"connection pong");
+    }
+
+    {
+        scoped_lock_type lock(m_connection_state_lock);
+        if (m_state != session::state::open) {
+            std::stringstream ss;
+            ss << "connection::pong called from invalid state " << m_state;
+            m_alog.write(log::alevel::devel,ss.str());
+            ec = error::make_error_code(error::invalid_state);
+            return;
+        }
+    }
+
+    message_ptr msg = m_msg_manager->get_message();
+    if (!msg) {
+        ec = error::make_error_code(error::no_outgoing_buffers);
+        return;
+    }
+
+    ec = m_processor->prepare_pong(payload,msg);
+    if (ec) {return;}
+
+    bool needs_writing = false;
+    {
+        scoped_lock_type lock(m_write_lock);
+        write_push(msg);
+        needs_writing = !m_write_flag && !m_send_queue.empty();
+    }
+
+    if (needs_writing) {
+        transport_con_type::dispatch(lib::bind(
+            &type::write_frame,
+            type::get_shared()
+        ));
+    }
+
+    ec = lib::error_code();
+}
+
+template<typename config>
+void connection<config>::pong(std::string const & payload) {
+    lib::error_code ec;
+    pong(payload,ec);
+    if (ec) {
+        throw exception(ec);
+    }
+}
+
+template <typename config>
+void connection<config>::close(close::status::value const code,
+    std::string const & reason, lib::error_code & ec)
+{
+    if (m_alog.static_test(log::alevel::devel)) {
+        m_alog.write(log::alevel::devel,"connection close");
+    }
+
+    // Truncate reason to maximum size allowable in a close frame.
+    std::string tr(reason,0,std::min<size_t>(reason.size(),
+        frame::limits::close_reason_size));
+
+    scoped_lock_type lock(m_connection_state_lock);
+
+    if (m_state != session::state::open) {
+       ec = error::make_error_code(error::invalid_state);
+       return;
+    }
+
+    ec = this->send_close_frame(code,tr,false,close::status::terminal(code));
+}
+
+template<typename config>
+void connection<config>::close(close::status::value const code,
+    std::string const & reason)
+{
+    lib::error_code ec;
+    close(code,reason,ec);
+    if (ec) {
+        throw exception(ec);
+    }
+}
+
+/// Trigger the on_interrupt handler
+/**
+ * This is thread safe if the transport is thread safe
+ */
+template <typename config>
+lib::error_code connection<config>::interrupt() {
+    m_alog.write(log::alevel::devel,"connection connection::interrupt");
+    return transport_con_type::interrupt(
+        lib::bind(
+            &type::handle_interrupt,
+            type::get_shared()
+        )
+    );
+}
+
+
+template <typename config>
+void connection<config>::handle_interrupt() {
+    if (m_interrupt_handler) {
+        m_interrupt_handler(m_connection_hdl);
+    }
+}
+
+template <typename config>
+lib::error_code connection<config>::pause_reading() {
+    m_alog.write(log::alevel::devel,"connection connection::pause_reading");
+    return transport_con_type::dispatch(
+        lib::bind(
+            &type::handle_pause_reading,
+            type::get_shared()
+        )
+    );
+}
+
+/// Pause reading handler. Not safe to call directly
+template <typename config>
+void connection<config>::handle_pause_reading() {
+    m_alog.write(log::alevel::devel,"connection connection::handle_pause_reading");
+    m_read_flag = false;
+}
+
+template <typename config>
+lib::error_code connection<config>::resume_reading() {
+    m_alog.write(log::alevel::devel,"connection connection::resume_reading");
+    return transport_con_type::dispatch(
+        lib::bind(
+            &type::handle_resume_reading,
+            type::get_shared()
+        )
+    );
+}
+
+/// Resume reading helper method. Not safe to call directly
+template <typename config>
+void connection<config>::handle_resume_reading() {
+   m_read_flag = true;
+   read_frame();
+}
+
+
+
+
+
+
+
+
+
+
+
+template <typename config>
+bool connection<config>::get_secure() const {
+    //scoped_lock_type lock(m_connection_state_lock);
+    return m_uri->get_secure();
+}
+
+template <typename config>
+std::string const & connection<config>::get_host() const {
+    //scoped_lock_type lock(m_connection_state_lock);
+    return m_uri->get_host();
+}
+
+template <typename config>
+std::string const & connection<config>::get_resource() const {
+    //scoped_lock_type lock(m_connection_state_lock);
+    return m_uri->get_resource();
+}
+
+template <typename config>
+uint16_t connection<config>::get_port() const {
+    //scoped_lock_type lock(m_connection_state_lock);
+    return m_uri->get_port();
+}
+
+template <typename config>
+uri_ptr connection<config>::get_uri() const {
+    //scoped_lock_type lock(m_connection_state_lock);
+    return m_uri;
+}
+
+template <typename config>
+void connection<config>::set_uri(uri_ptr uri) {
+    //scoped_lock_type lock(m_connection_state_lock);
+    m_uri = uri;
+}
+
+
+
+
+
+
+template <typename config>
+std::string const & connection<config>::get_subprotocol() const {
+    return m_subprotocol;
+}
+
+template <typename config>
+std::vector<std::string> const &
+connection<config>::get_requested_subprotocols() const {
+    return m_requested_subprotocols;
+}
+
+template <typename config>
+void connection<config>::add_subprotocol(std::string const & value,
+    lib::error_code & ec)
+{
+    if (m_is_server) {
+        ec = error::make_error_code(error::client_only);
+        return;
+    }
+
+    // If the value is empty or has a non-RFC2616 token character it is invalid.
+    if (value.empty() || std::find_if(value.begin(),value.end(),
+                                      http::is_not_token_char) != value.end())
+    {
+        ec = error::make_error_code(error::invalid_subprotocol);
+        return;
+    }
+
+    m_requested_subprotocols.push_back(value);
+}
+
+template <typename config>
+void connection<config>::add_subprotocol(std::string const & value) {
+    lib::error_code ec;
+    this->add_subprotocol(value,ec);
+    if (ec) {
+        throw exception(ec);
+    }
+}
+
+
+template <typename config>
+void connection<config>::select_subprotocol(std::string const & value,
+    lib::error_code & ec)
+{
+    if (!m_is_server) {
+        ec = error::make_error_code(error::server_only);
+        return;
+    }
+
+    if (value.empty()) {
+        ec = lib::error_code();
+        return;
+    }
+
+    std::vector<std::string>::iterator it;
+
+    it = std::find(m_requested_subprotocols.begin(),
+                   m_requested_subprotocols.end(),
+                   value);
+
+    if (it == m_requested_subprotocols.end()) {
+        ec = error::make_error_code(error::unrequested_subprotocol);
+        return;
+    }
+
+    m_subprotocol = value;
+}
+
+template <typename config>
+void connection<config>::select_subprotocol(std::string const & value) {
+    lib::error_code ec;
+    this->select_subprotocol(value,ec);
+    if (ec) {
+        throw exception(ec);
+    }
+}
+
+
+template <typename config>
+std::string const &
+connection<config>::get_request_header(std::string const & key) const {
+    return m_request.get_header(key);
+}
+
+template <typename config>
+std::string const &
+connection<config>::get_request_body() const {
+    return m_request.get_body();
+}
+
+template <typename config>
+std::string const &
+connection<config>::get_response_header(std::string const & key) const {
+    return m_response.get_header(key);
+}
+
+template <typename config>
+void connection<config>::set_status(http::status_code::value code)
+{
+    if (m_internal_state != istate::PROCESS_HTTP_REQUEST) {
+        throw exception("Call to set_status from invalid state",
+                      error::make_error_code(error::invalid_state));
+    }
+    m_response.set_status(code);
+}
+template <typename config>
+void connection<config>::set_status(http::status_code::value code,
+    std::string const & msg)
+{
+    if (m_internal_state != istate::PROCESS_HTTP_REQUEST) {
+        throw exception("Call to set_status from invalid state",
+                      error::make_error_code(error::invalid_state));
+    }
+
+    m_response.set_status(code,msg);
+}
+template <typename config>
+void connection<config>::set_body(std::string const & value) {
+    if (m_internal_state != istate::PROCESS_HTTP_REQUEST) {
+        throw exception("Call to set_status from invalid state",
+                      error::make_error_code(error::invalid_state));
+    }
+
+    m_response.set_body(value);
+}
+
+template <typename config>
+void connection<config>::append_header(std::string const & key,
+    std::string const & val)
+{
+    if (m_is_server) {
+        if (m_internal_state == istate::PROCESS_HTTP_REQUEST) {
+            // we are setting response headers for an incoming server connection
+            m_response.append_header(key,val);
+        } else {
+            throw exception("Call to append_header from invalid state",
+                      error::make_error_code(error::invalid_state));
+        }
+    } else {
+        if (m_internal_state == istate::USER_INIT) {
+            // we are setting initial headers for an outgoing client connection
+            m_request.append_header(key,val);
+        } else {
+            throw exception("Call to append_header from invalid state",
+                      error::make_error_code(error::invalid_state));
+        }
+    }
+}
+template <typename config>
+void connection<config>::replace_header(std::string const & key,
+    std::string const & val)
+{
+    if (m_is_server) {
+        if (m_internal_state == istate::PROCESS_HTTP_REQUEST) {
+            // we are setting response headers for an incoming server connection
+            m_response.replace_header(key,val);
+        } else {
+            throw exception("Call to replace_header from invalid state",
+                        error::make_error_code(error::invalid_state));
+        }
+    } else {
+        if (m_internal_state == istate::USER_INIT) {
+            // we are setting initial headers for an outgoing client connection
+            m_request.replace_header(key,val);
+        } else {
+            throw exception("Call to replace_header from invalid state",
+                        error::make_error_code(error::invalid_state));
+        }
+    }
+}
+template <typename config>
+void connection<config>::remove_header(std::string const & key)
+{
+    if (m_is_server) {
+        if (m_internal_state == istate::PROCESS_HTTP_REQUEST) {
+            // we are setting response headers for an incoming server connection
+            m_response.remove_header(key);
+        } else {
+            throw exception("Call to remove_header from invalid state",
+                        error::make_error_code(error::invalid_state));
+        }
+    } else {
+        if (m_internal_state == istate::USER_INIT) {
+            // we are setting initial headers for an outgoing client connection
+            m_request.remove_header(key);
+        } else {
+            throw exception("Call to remove_header from invalid state",
+                        error::make_error_code(error::invalid_state));
+        }
+    }
+}
+
+
+
+
+
+
+/******** logic thread ********/
+
+template <typename config>
+void connection<config>::start() {
+    m_alog.write(log::alevel::devel,"connection start");
+
+    if (m_internal_state != istate::USER_INIT) {
+        m_alog.write(log::alevel::devel,"Start called in invalid state");
+        this->terminate(error::make_error_code(error::invalid_state));
+        return;
+    }
+
+    m_internal_state = istate::TRANSPORT_INIT;
+
+    // Depending on how the transport implements init this function may return
+    // immediately and call handle_transport_init later or call
+    // handle_transport_init from this function.
+    transport_con_type::init(
+        lib::bind(
+            &type::handle_transport_init,
+            type::get_shared(),
+            lib::placeholders::_1
+        )
+    );
+}
+
+template <typename config>
+void connection<config>::handle_transport_init(lib::error_code const & ec) {
+    m_alog.write(log::alevel::devel,"connection handle_transport_init");
+
+    lib::error_code ecm = ec;
+
+    if (m_internal_state != istate::TRANSPORT_INIT) {
+        m_alog.write(log::alevel::devel,
+          "handle_transport_init must be called from transport init state");
+        ecm = error::make_error_code(error::invalid_state);
+    }
+
+    if (ecm) {
+        std::stringstream s;
+        s << "handle_transport_init received error: "<< ecm.message();
+        m_elog.write(log::elevel::rerror,s.str());
+
+        this->terminate(ecm);
+        return;
+    }
+
+    // At this point the transport is ready to read and write bytes.
+    if (m_is_server) {
+        m_internal_state = istate::READ_HTTP_REQUEST;
+        this->read_handshake(1);
+    } else {
+        // We are a client. Set the processor to the version specified in the
+        // config file and send a handshake request.
+        m_internal_state = istate::WRITE_HTTP_REQUEST;
+        m_processor = get_processor(config::client_version);
+        this->send_http_request();
+    }
+}
+
+template <typename config>
+void connection<config>::read_handshake(size_t num_bytes) {
+    m_alog.write(log::alevel::devel,"connection read");
+
+    if (m_open_handshake_timeout_dur > 0) {
+        m_handshake_timer = transport_con_type::set_timer(
+            m_open_handshake_timeout_dur,
+            lib::bind(
+                &type::handle_open_handshake_timeout,
+                type::get_shared(),
+                lib::placeholders::_1
+            )
+        );
+    }
+
+    transport_con_type::async_read_at_least(
+        num_bytes,
+        m_buf,
+        config::connection_read_buffer_size,
+        lib::bind(
+            &type::handle_read_handshake,
+            type::get_shared(),
+            lib::placeholders::_1,
+            lib::placeholders::_2
+        )
+    );
+}
+
+// All exit paths for this function need to call send_http_response() or submit
+// a new read request with this function as the handler.
+template <typename config>
+void connection<config>::handle_read_handshake(lib::error_code const & ec,
+    size_t bytes_transferred)
+{
+    m_alog.write(log::alevel::devel,"connection handle_read_handshake");
+
+    lib::error_code ecm = ec;
+
+    if (!ecm) {
+        scoped_lock_type lock(m_connection_state_lock);
+        
+        if (m_state == session::state::connecting) {
+             if (m_internal_state != istate::READ_HTTP_REQUEST) {
+                ecm = error::make_error_code(error::invalid_state);
+             }
+        } else if (m_state == session::state::closed) {
+            // The connection was canceled while the response was being sent,
+            // usually by the handshake timer. This is basically expected
+            // (though hopefully rare) and there is nothing we can do so ignore.
+            m_alog.write(log::alevel::devel,
+                "handle_read_handshake invoked after connection was closed");
+            return;
+        } else {
+            ecm = error::make_error_code(error::invalid_state);
+        }
+    }
+
+    if (ecm) {
+        if (ecm == transport::error::eof && m_state == session::state::closed) {
+            // we expect to get eof if the connection is closed already
+            m_alog.write(log::alevel::devel,
+                    "got (expected) eof/state error from closed con");
+            return;
+        }
+        
+        log_err(log::elevel::rerror,"handle_read_handshake",ecm);
+        this->terminate(ecm);
+        return;
+    }
+
+    // Boundaries checking. TODO: How much of this should be done?
+    if (bytes_transferred > config::connection_read_buffer_size) {
+        m_elog.write(log::elevel::fatal,"Fatal boundaries checking error.");
+        this->terminate(make_error_code(error::general));
+        return;
+    }
+
+    size_t bytes_processed = 0;
+    try {
+        bytes_processed = m_request.consume(m_buf,bytes_transferred);
+    } catch (http::exception &e) {
+        // All HTTP exceptions will result in this request failing and an error
+        // response being returned. No more bytes will be read in this con.
+        m_response.set_status(e.m_error_code,e.m_error_msg);
+        this->send_http_response_error(error::make_error_code(error::http_parse_error));
+        return;
+    }
+
+    // More paranoid boundaries checking.
+    // TODO: Is this overkill?
+    if (bytes_processed > bytes_transferred) {
+        m_elog.write(log::elevel::fatal,"Fatal boundaries checking error.");
+        this->terminate(make_error_code(error::general));
+        return;
+    }
+
+    if (m_alog.static_test(log::alevel::devel)) {
+        std::stringstream s;
+        s << "bytes_transferred: " << bytes_transferred
+          << " bytes, bytes processed: " << bytes_processed << " bytes";
+        m_alog.write(log::alevel::devel,s.str());
+    }
+
+    if (m_request.ready()) {
+        lib::error_code processor_ec = this->initialize_processor();
+        if (processor_ec) {
+            this->send_http_response_error(processor_ec);
+            return;
+        }
+
+        if (m_processor && m_processor->get_version() == 0) {
+            // Version 00 has an extra requirement to read some bytes after the
+            // handshake
+            if (bytes_transferred-bytes_processed >= 8) {
+                m_request.replace_header(
+                    "Sec-WebSocket-Key3",
+                    std::string(m_buf+bytes_processed,m_buf+bytes_processed+8)
+                );
+                bytes_processed += 8;
+            } else {
+                // TODO: need more bytes
+                m_alog.write(log::alevel::devel,"short key3 read");
+                m_response.set_status(http::status_code::internal_server_error);
+                this->send_http_response_error(processor::error::make_error_code(processor::error::short_key3));
+                return;
+            }
+        }
+
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,m_request.raw());
+            if (m_request.get_header("Sec-WebSocket-Key3") != "") {
+                m_alog.write(log::alevel::devel,
+                    utility::to_hex(m_request.get_header("Sec-WebSocket-Key3")));
+            }
+        }
+
+        // The remaining bytes in m_buf are frame data. Copy them to the
+        // beginning of the buffer and note the length. They will be read after
+        // the handshake completes and before more bytes are read.
+        std::copy(m_buf+bytes_processed,m_buf+bytes_transferred,m_buf);
+        m_buf_cursor = bytes_transferred-bytes_processed;
+
+
+        m_internal_state = istate::PROCESS_HTTP_REQUEST;
+        
+        // We have the complete request. Process it.
+        lib::error_code handshake_ec = this->process_handshake_request();
+        this->send_http_response(handshake_ec);
+    } else {
+        // read at least 1 more byte
+        transport_con_type::async_read_at_least(
+            1,
+            m_buf,
+            config::connection_read_buffer_size,
+            lib::bind(
+                &type::handle_read_handshake,
+                type::get_shared(),
+                lib::placeholders::_1,
+                lib::placeholders::_2
+            )
+        );
+    }
+}
+
+// send_http_response requires the request to be fully read and the connection
+// to be in the PROCESS_HTTP_REQUEST state. In some cases we can detect errors
+// before the request is fully read (specifically at a point where we aren't
+// sure if the hybi00 key3 bytes need to be read). This method sets the correct
+// state and calls send_http_response
+template <typename config>
+void connection<config>::send_http_response_error(lib::error_code const & ec) {
+    if (m_internal_state != istate::READ_HTTP_REQUEST) {
+        m_alog.write(log::alevel::devel,
+            "send_http_response_error called in invalid state");
+        this->terminate(error::make_error_code(error::invalid_state));
+        return;
+    }
+    
+    m_internal_state = istate::PROCESS_HTTP_REQUEST;
+    
+    this->send_http_response(ec);
+}
+
+// All exit paths for this function need to call send_http_response() or submit
+// a new read request with this function as the handler.
+template <typename config>
+void connection<config>::handle_read_frame(lib::error_code const & ec,
+    size_t bytes_transferred)
+{
+    //m_alog.write(log::alevel::devel,"connection handle_read_frame");
+
+    lib::error_code ecm = ec;
+
+    if (!ecm && m_internal_state != istate::PROCESS_CONNECTION) {
+        ecm = error::make_error_code(error::invalid_state);
+    }
+
+    if (ecm) {
+        log::level echannel = log::elevel::rerror;
+        
+        if (ecm == transport::error::eof) {
+            if (m_state == session::state::closed) {
+                // we expect to get eof if the connection is closed already
+                // just ignore it
+                m_alog.write(log::alevel::devel,"got eof from closed con");
+                return;
+            } else if (m_state == session::state::closing && !m_is_server) {
+                // If we are a client we expect to get eof in the closing state,
+                // this is a signal to terminate our end of the connection after
+                // the closing handshake
+                terminate(lib::error_code());
+                return;
+            }
+        } else if (ecm == error::invalid_state) {
+            // In general, invalid state errors in the closed state are the
+            // result of handlers that were in the system already when the state
+            // changed and should be ignored as they pose no problems and there
+            // is nothing useful that we can do about them.
+            if (m_state == session::state::closed) {
+                m_alog.write(log::alevel::devel,
+                    "handle_read_frame: got invalid istate in closed state");
+                return;
+            }
+        } else if (ecm == transport::error::tls_short_read) {
+            if (m_state == session::state::closed) {
+                // We expect to get a TLS short read if we try to read after the
+                // connection is closed. If this happens ignore and exit the
+                // read frame path.
+                terminate(lib::error_code());
+                return;
+            }
+            echannel = log::elevel::rerror;
+        } else if (ecm == transport::error::action_after_shutdown) {
+            echannel = log::elevel::info;
+        }
+        
+        log_err(echannel, "handle_read_frame", ecm);
+        this->terminate(ecm);
+        return;
+    }
+
+    // Boundaries checking. TODO: How much of this should be done?
+    /*if (bytes_transferred > config::connection_read_buffer_size) {
+        m_elog.write(log::elevel::fatal,"Fatal boundaries checking error");
+        this->terminate(make_error_code(error::general));
+        return;
+    }*/
+
+    size_t p = 0;
+
+    if (m_alog.static_test(log::alevel::devel)) {
+        std::stringstream s;
+        s << "p = " << p << " bytes transferred = " << bytes_transferred;
+        m_alog.write(log::alevel::devel,s.str());
+    }
+
+    while (p < bytes_transferred) {
+        if (m_alog.static_test(log::alevel::devel)) {
+            std::stringstream s;
+            s << "calling consume with " << bytes_transferred-p << " bytes";
+            m_alog.write(log::alevel::devel,s.str());
+        }
+
+        lib::error_code consume_ec;
+
+        p += m_processor->consume(
+            reinterpret_cast<uint8_t*>(m_buf)+p,
+            bytes_transferred-p,
+            consume_ec
+        );
+
+        if (m_alog.static_test(log::alevel::devel)) {
+            std::stringstream s;
+            s << "bytes left after consume: " << bytes_transferred-p;
+            m_alog.write(log::alevel::devel,s.str());
+        }
+        if (consume_ec) {
+            log_err(log::elevel::rerror, "consume", consume_ec);
+
+            if (config::drop_on_protocol_error) {
+                this->terminate(consume_ec);
+                return;
+            } else {
+                lib::error_code close_ec;
+                this->close(
+                    processor::error::to_ws(consume_ec),
+                    consume_ec.message(),
+                    close_ec
+                );
+
+                if (close_ec) {
+                    log_err(log::elevel::fatal, "Protocol error close frame ", close_ec);
+                    this->terminate(close_ec);
+                    return;
+                }
+            }
+            return;
+        }
+
+        if (m_processor->ready()) {
+            if (m_alog.static_test(log::alevel::devel)) {
+                std::stringstream s;
+                s << "Complete message received. Dispatching";
+                m_alog.write(log::alevel::devel,s.str());
+            }
+
+            message_ptr msg = m_processor->get_message();
+
+            if (!msg) {
+                m_alog.write(log::alevel::devel, "null message from m_processor");
+            } else if (!is_control(msg->get_opcode())) {
+                // data message, dispatch to user
+                if (m_state != session::state::open) {
+                    m_elog.write(log::elevel::warn, "got non-close frame while closing");
+                } else if (m_message_handler) {
+                    m_message_handler(m_connection_hdl, msg);
+                }
+            } else {
+                process_control_frame(msg);
+            }
+        }
+    }
+
+    read_frame();
+}
+
+/// Issue a new transport read unless reading is paused.
+template <typename config>
+void connection<config>::read_frame() {
+    if (!m_read_flag) {
+        return;
+    }
+    
+    transport_con_type::async_read_at_least(
+        // std::min wont work with undefined static const values.
+        // TODO: is there a more elegant way to do this?
+        // Need to determine if requesting 1 byte or the exact number of bytes
+        // is better here. 1 byte lets us be a bit more responsive at a
+        // potential expense of additional runs through handle_read_frame
+        /*(m_processor->get_bytes_needed() > config::connection_read_buffer_size ?
+         config::connection_read_buffer_size : m_processor->get_bytes_needed())*/
+        1,
+        m_buf,
+        config::connection_read_buffer_size,
+        m_handle_read_frame
+    );
+}
+
+template <typename config>
+lib::error_code connection<config>::initialize_processor() {
+    m_alog.write(log::alevel::devel,"initialize_processor");
+
+    // if it isn't a websocket handshake nothing to do.
+    if (!processor::is_websocket_handshake(m_request)) {
+        return lib::error_code();
+    }
+
+    int version = processor::get_websocket_version(m_request);
+
+    if (version < 0) {
+        m_alog.write(log::alevel::devel, "BAD REQUEST: can't determine version");
+        m_response.set_status(http::status_code::bad_request);
+        return error::make_error_code(error::invalid_version);
+    }
+
+    m_processor = get_processor(version);
+
+    // if the processor is not null we are done
+    if (m_processor) {
+        return lib::error_code();
+    }
+
+    // We don't have a processor for this version. Return bad request
+    // with Sec-WebSocket-Version header filled with values we do accept
+    m_alog.write(log::alevel::devel, "BAD REQUEST: no processor for version");
+    m_response.set_status(http::status_code::bad_request);
+
+    std::stringstream ss;
+    std::string sep = "";
+    std::vector<int>::const_iterator it;
+    for (it = versions_supported.begin(); it != versions_supported.end(); it++)
+    {
+        ss << sep << *it;
+        sep = ",";
+    }
+
+    m_response.replace_header("Sec-WebSocket-Version",ss.str());
+    return error::make_error_code(error::unsupported_version);
+}
+
+template <typename config>
+lib::error_code connection<config>::process_handshake_request() {
+    m_alog.write(log::alevel::devel,"process handshake request");
+
+    if (!processor::is_websocket_handshake(m_request)) {
+        // this is not a websocket handshake. Process as plain HTTP
+        m_alog.write(log::alevel::devel,"HTTP REQUEST");
+
+        // extract URI from request
+        m_uri = processor::get_uri_from_host(
+            m_request,
+            (transport_con_type::is_secure() ? "https" : "http")
+        );
+
+        if (!m_uri->get_valid()) {
+            m_alog.write(log::alevel::devel, "Bad request: failed to parse uri");
+            m_response.set_status(http::status_code::bad_request);
+            return error::make_error_code(error::invalid_uri);
+        }
+
+        if (m_http_handler) {
+            m_is_http = true;
+            m_http_handler(m_connection_hdl);
+            if (m_state == session::state::closed) {
+                return error::make_error_code(error::http_connection_ended);
+            }
+        } else {
+            set_status(http::status_code::upgrade_required);
+            return error::make_error_code(error::upgrade_required);
+        }
+
+        return lib::error_code();
+    }
+
+    lib::error_code ec = m_processor->validate_handshake(m_request);
+
+    // Validate: make sure all required elements are present.
+    if (ec){
+        // Not a valid handshake request
+        m_alog.write(log::alevel::devel, "Bad request " + ec.message());
+        m_response.set_status(http::status_code::bad_request);
+        return ec;
+    }
+
+    // Read extension parameters and set up values necessary for the end user
+    // to complete extension negotiation.
+    std::pair<lib::error_code,std::string> neg_results;
+    neg_results = m_processor->negotiate_extensions(m_request);
+
+    if (neg_results.first) {
+        // There was a fatal error in extension parsing that should result in
+        // a failed connection attempt.
+        m_alog.write(log::alevel::devel, "Bad request: " + neg_results.first.message());
+        m_response.set_status(http::status_code::bad_request);
+        return neg_results.first;
+    } else {
+        // extension negotiation succeeded, set response header accordingly
+        // we don't send an empty extensions header because it breaks many
+        // clients.
+        if (neg_results.second.size() > 0) {
+            m_response.replace_header("Sec-WebSocket-Extensions",
+                neg_results.second);
+        }
+    }
+
+    // extract URI from request
+    m_uri = m_processor->get_uri(m_request);
+
+
+    if (!m_uri->get_valid()) {
+        m_alog.write(log::alevel::devel, "Bad request: failed to parse uri");
+        m_response.set_status(http::status_code::bad_request);
+        return error::make_error_code(error::invalid_uri);
+    }
+
+    // extract subprotocols
+    lib::error_code subp_ec = m_processor->extract_subprotocols(m_request,
+        m_requested_subprotocols);
+
+    if (subp_ec) {
+        // should we do anything?
+    }
+
+    // Ask application to validate the connection
+    if (!m_validate_handler || m_validate_handler(m_connection_hdl)) {
+        m_response.set_status(http::status_code::switching_protocols);
+
+        // Write the appropriate response headers based on request and
+        // processor version
+        ec = m_processor->process_handshake(m_request,m_subprotocol,m_response);
+
+        if (ec) {
+            std::stringstream s;
+            s << "Processing error: " << ec << "(" << ec.message() << ")";
+            m_alog.write(log::alevel::devel, s.str());
+
+            m_response.set_status(http::status_code::internal_server_error);
+            return ec;
+        }
+    } else {
+        // User application has rejected the handshake
+        m_alog.write(log::alevel::devel, "USER REJECT");
+
+        // Use Bad Request if the user handler did not provide a more
+        // specific http response error code.
+        // TODO: is there a better default?
+        if (m_response.get_status_code() == http::status_code::uninitialized) {
+            m_response.set_status(http::status_code::bad_request);
+        }
+        
+        return error::make_error_code(error::rejected);
+    }
+
+    return lib::error_code();
+}
+
+template <typename config>
+void connection<config>::send_http_response(lib::error_code const & ec) {
+    m_alog.write(log::alevel::devel,"connection send_http_response");
+
+    if (ec == error::make_error_code(error::http_connection_ended)) {
+        m_alog.write(log::alevel::http,"An HTTP handler took over the connection.");
+        return;
+    }
+
+    if (m_response.get_status_code() == http::status_code::uninitialized) {
+        m_response.set_status(http::status_code::internal_server_error);
+        m_ec = error::make_error_code(error::general);
+    } else {
+        m_ec = ec;
+    }
+
+    m_response.set_version("HTTP/1.1");
+
+    // Set server header based on the user agent settings
+    if (m_response.get_header("Server") == "") {
+        if (!m_user_agent.empty()) {
+            m_response.replace_header("Server",m_user_agent);
+        } else {
+            m_response.remove_header("Server");
+        }
+    }
+
+    // have the processor generate the raw bytes for the wire (if it exists)
+    if (m_processor) {
+        m_handshake_buffer = m_processor->get_raw(m_response);
+    } else {
+        // a processor wont exist for raw HTTP responses.
+        m_handshake_buffer = m_response.raw();
+    }
+
+    if (m_alog.static_test(log::alevel::devel)) {
+        m_alog.write(log::alevel::devel,"Raw Handshake response:\n"+m_handshake_buffer);
+        if (m_response.get_header("Sec-WebSocket-Key3") != "") {
+            m_alog.write(log::alevel::devel,
+                utility::to_hex(m_response.get_header("Sec-WebSocket-Key3")));
+        }
+    }
+
+    // write raw bytes
+    transport_con_type::async_write(
+        m_handshake_buffer.data(),
+        m_handshake_buffer.size(),
+        lib::bind(
+            &type::handle_send_http_response,
+            type::get_shared(),
+            lib::placeholders::_1
+        )
+    );
+}
+
+template <typename config>
+void connection<config>::handle_send_http_response(lib::error_code const & ec) {
+    m_alog.write(log::alevel::devel,"handle_send_http_response");
+
+    lib::error_code ecm = ec;
+
+    if (!ecm) {
+        scoped_lock_type lock(m_connection_state_lock);
+        
+        if (m_state == session::state::connecting) {
+             if (m_internal_state != istate::PROCESS_HTTP_REQUEST) {
+                ecm = error::make_error_code(error::invalid_state);
+             }
+        } else if (m_state == session::state::closed) {
+            // The connection was canceled while the response was being sent,
+            // usually by the handshake timer. This is basically expected
+            // (though hopefully rare) and there is nothing we can do so ignore.
+            m_alog.write(log::alevel::devel,
+                "handle_send_http_response invoked after connection was closed");
+            return;
+        } else {
+            ecm = error::make_error_code(error::invalid_state);
+        }
+    }
+
+    if (ecm) {
+        if (ecm == transport::error::eof && m_state == session::state::closed) {
+            // we expect to get eof if the connection is closed already
+            m_alog.write(log::alevel::devel,
+                    "got (expected) eof/state error from closed con");
+            return;
+        }
+        
+        log_err(log::elevel::rerror,"handle_send_http_response",ecm);
+        this->terminate(ecm);
+        return;
+    }
+
+    if (m_handshake_timer) {
+        m_handshake_timer->cancel();
+        m_handshake_timer.reset();
+    }
+
+    if (m_response.get_status_code() != http::status_code::switching_protocols)
+    {
+        /*if (m_processor || m_ec == error::http_parse_error || 
+            m_ec == error::invalid_version || m_ec == error::unsupported_version
+            || m_ec == error::upgrade_required)
+        {*/
+        if (!m_is_http) {
+            std::stringstream s;
+            s << "Handshake ended with HTTP error: "
+              << m_response.get_status_code();
+            m_elog.write(log::elevel::rerror,s.str());
+        } else {
+            // if this was not a websocket connection, we have written
+            // the expected response and the connection can be closed.
+            
+            this->log_http_result();
+            
+            if (m_ec) {
+                m_alog.write(log::alevel::devel,
+                    "got to writing HTTP results with m_ec set: "+m_ec.message());
+            }
+            m_ec = make_error_code(error::http_connection_ended);
+        }        
+        
+        this->terminate(m_ec);
+        return;
+    }
+
+    this->log_open_result();
+
+    m_internal_state = istate::PROCESS_CONNECTION;
+    m_state = session::state::open;
+
+    if (m_open_handler) {
+        m_open_handler(m_connection_hdl);
+    }
+
+    this->handle_read_frame(lib::error_code(), m_buf_cursor);
+}
+
+template <typename config>
+void connection<config>::send_http_request() {
+    m_alog.write(log::alevel::devel,"connection send_http_request");
+
+    // TODO: origin header?
+
+    // Have the protocol processor fill in the appropriate fields based on the
+    // selected client version
+    if (m_processor) {
+        lib::error_code ec;
+        ec = m_processor->client_handshake_request(m_request,m_uri,
+            m_requested_subprotocols);
+
+        if (ec) {
+            log_err(log::elevel::fatal,"Internal library error: Processor",ec);
+            return;
+        }
+    } else {
+        m_elog.write(log::elevel::fatal,"Internal library error: missing processor");
+        return;
+    }
+
+    // Unless the user has overridden the user agent, send generic WS++ UA.
+    if (m_request.get_header("User-Agent") == "") {
+        if (!m_user_agent.empty()) {
+            m_request.replace_header("User-Agent",m_user_agent);
+        } else {
+            m_request.remove_header("User-Agent");
+        }
+    }
+
+    m_handshake_buffer = m_request.raw();
+
+    if (m_alog.static_test(log::alevel::devel)) {
+        m_alog.write(log::alevel::devel,"Raw Handshake request:\n"+m_handshake_buffer);
+    }
+
+    if (m_open_handshake_timeout_dur > 0) {
+        m_handshake_timer = transport_con_type::set_timer(
+            m_open_handshake_timeout_dur,
+            lib::bind(
+                &type::handle_open_handshake_timeout,
+                type::get_shared(),
+                lib::placeholders::_1
+            )
+        );
+    }
+
+    transport_con_type::async_write(
+        m_handshake_buffer.data(),
+        m_handshake_buffer.size(),
+        lib::bind(
+            &type::handle_send_http_request,
+            type::get_shared(),
+            lib::placeholders::_1
+        )
+    );
+}
+
+template <typename config>
+void connection<config>::handle_send_http_request(lib::error_code const & ec) {
+    m_alog.write(log::alevel::devel,"handle_send_http_request");
+
+    lib::error_code ecm = ec;
+
+    if (!ecm) {
+        scoped_lock_type lock(m_connection_state_lock);
+        
+        if (m_state == session::state::connecting) {
+             if (m_internal_state != istate::WRITE_HTTP_REQUEST) {
+                ecm = error::make_error_code(error::invalid_state);
+             } else {
+                m_internal_state = istate::READ_HTTP_RESPONSE;
+             }
+        } else if (m_state == session::state::closed) {
+            // The connection was canceled while the response was being sent,
+            // usually by the handshake timer. This is basically expected
+            // (though hopefully rare) and there is nothing we can do so ignore.
+            m_alog.write(log::alevel::devel,
+                "handle_send_http_request invoked after connection was closed");
+            return;
+        } else {
+            ecm = error::make_error_code(error::invalid_state);
+        }
+    }
+
+    if (ecm) {
+        if (ecm == transport::error::eof && m_state == session::state::closed) {
+            // we expect to get eof if the connection is closed already
+            m_alog.write(log::alevel::devel,
+                    "got (expected) eof/state error from closed con");
+            return;
+        }
+        
+        log_err(log::elevel::rerror,"handle_send_http_request",ecm);
+        this->terminate(ecm);
+        return;
+    }
+
+    transport_con_type::async_read_at_least(
+        1,
+        m_buf,
+        config::connection_read_buffer_size,
+        lib::bind(
+            &type::handle_read_http_response,
+            type::get_shared(),
+            lib::placeholders::_1,
+            lib::placeholders::_2
+        )
+    );
+}
+
+template <typename config>
+void connection<config>::handle_read_http_response(lib::error_code const & ec,
+    size_t bytes_transferred)
+{
+    m_alog.write(log::alevel::devel,"handle_read_http_response");
+
+    lib::error_code ecm = ec;
+
+    if (!ecm) {
+        scoped_lock_type lock(m_connection_state_lock);
+        
+        if (m_state == session::state::connecting) {
+            if (m_internal_state != istate::READ_HTTP_RESPONSE) {
+                ecm = error::make_error_code(error::invalid_state);
+            }
+        } else if (m_state == session::state::closed) {
+            // The connection was canceled while the response was being sent,
+            // usually by the handshake timer. This is basically expected
+            // (though hopefully rare) and there is nothing we can do so ignore.
+            m_alog.write(log::alevel::devel,
+                "handle_read_http_response invoked after connection was closed");
+            return;
+        } else {
+            ecm = error::make_error_code(error::invalid_state);
+        }
+    }
+
+    if (ecm) {
+        if (ecm == transport::error::eof && m_state == session::state::closed) {
+            // we expect to get eof if the connection is closed already
+            m_alog.write(log::alevel::devel,
+                    "got (expected) eof/state error from closed con");
+            return;
+        }
+        
+        log_err(log::elevel::rerror,"handle_read_http_response",ecm);
+        this->terminate(ecm);
+        return;
+    }
+    
+    size_t bytes_processed = 0;
+    // TODO: refactor this to use error codes rather than exceptions
+    try {
+        bytes_processed = m_response.consume(m_buf,bytes_transferred);
+    } catch (http::exception & e) {
+        m_elog.write(log::elevel::rerror,
+            std::string("error in handle_read_http_response: ")+e.what());
+        this->terminate(make_error_code(error::general));
+        return;
+    }
+
+    m_alog.write(log::alevel::devel,std::string("Raw response: ")+m_response.raw());
+
+    if (m_response.headers_ready()) {
+        if (m_handshake_timer) {
+            m_handshake_timer->cancel();
+            m_handshake_timer.reset();
+        }
+
+        lib::error_code validate_ec = m_processor->validate_server_handshake_response(
+            m_request,
+            m_response
+        );
+        if (validate_ec) {
+            log_err(log::elevel::rerror,"Server handshake response",validate_ec);
+            this->terminate(validate_ec);
+            return;
+        }
+
+        // response is valid, connection can now be assumed to be open      
+        m_internal_state = istate::PROCESS_CONNECTION;
+        m_state = session::state::open;
+
+        this->log_open_result();
+
+        if (m_open_handler) {
+            m_open_handler(m_connection_hdl);
+        }
+
+        // The remaining bytes in m_buf are frame data. Copy them to the
+        // beginning of the buffer and note the length. They will be read after
+        // the handshake completes and before more bytes are read.
+        std::copy(m_buf+bytes_processed,m_buf+bytes_transferred,m_buf);
+        m_buf_cursor = bytes_transferred-bytes_processed;
+
+        this->handle_read_frame(lib::error_code(), m_buf_cursor);
+    } else {
+        transport_con_type::async_read_at_least(
+            1,
+            m_buf,
+            config::connection_read_buffer_size,
+            lib::bind(
+                &type::handle_read_http_response,
+                type::get_shared(),
+                lib::placeholders::_1,
+                lib::placeholders::_2
+            )
+        );
+    }
+}
+
+template <typename config>
+void connection<config>::handle_open_handshake_timeout(
+    lib::error_code const & ec)
+{
+    if (ec == transport::error::operation_aborted) {
+        m_alog.write(log::alevel::devel,"open handshake timer cancelled");
+    } else if (ec) {
+        m_alog.write(log::alevel::devel,
+            "open handle_open_handshake_timeout error: "+ec.message());
+        // TODO: ignore or fail here?
+    } else {
+        m_alog.write(log::alevel::devel,"open handshake timer expired");
+        terminate(make_error_code(error::open_handshake_timeout));
+    }
+}
+
+template <typename config>
+void connection<config>::handle_close_handshake_timeout(
+    lib::error_code const & ec)
+{
+    if (ec == transport::error::operation_aborted) {
+        m_alog.write(log::alevel::devel,"asio close handshake timer cancelled");
+    } else if (ec) {
+        m_alog.write(log::alevel::devel,
+            "asio open handle_close_handshake_timeout error: "+ec.message());
+        // TODO: ignore or fail here?
+    } else {
+        m_alog.write(log::alevel::devel, "asio close handshake timer expired");
+        terminate(make_error_code(error::close_handshake_timeout));
+    }
+}
+
+template <typename config>
+void connection<config>::terminate(lib::error_code const & ec) {
+    if (m_alog.static_test(log::alevel::devel)) {
+        m_alog.write(log::alevel::devel,"connection terminate");
+    }
+
+    // Cancel close handshake timer
+    if (m_handshake_timer) {
+        m_handshake_timer->cancel();
+        m_handshake_timer.reset();
+    }
+
+    terminate_status tstat = unknown;
+    if (ec) {
+        m_ec = ec;
+        m_local_close_code = close::status::abnormal_close;
+        m_local_close_reason = ec.message();
+    }
+
+    // TODO: does this need a mutex?
+    if (m_state == session::state::connecting) {
+        m_state = session::state::closed;
+        tstat = failed;
+        
+        // Log fail result here before socket is shut down and we can't get
+        // the remote address, etc anymore
+        if (m_ec != error::http_connection_ended) {
+            log_fail_result();
+        }
+    } else if (m_state != session::state::closed) {
+        m_state = session::state::closed;
+        tstat = closed;
+    } else {
+        m_alog.write(log::alevel::devel,
+            "terminate called on connection that was already terminated");
+        return;
+    }
+
+    // TODO: choose between shutdown and close based on error code sent
+
+    transport_con_type::async_shutdown(
+        lib::bind(
+            &type::handle_terminate,
+            type::get_shared(),
+            tstat,
+            lib::placeholders::_1
+        )
+    );
+}
+
+template <typename config>
+void connection<config>::handle_terminate(terminate_status tstat,
+    lib::error_code const & ec)
+{
+    if (m_alog.static_test(log::alevel::devel)) {
+        m_alog.write(log::alevel::devel,"connection handle_terminate");
+    }
+
+    if (ec) {
+        // there was an error actually shutting down the connection
+        log_err(log::elevel::devel,"handle_terminate",ec);
+    }
+
+    // clean shutdown
+    if (tstat == failed) {
+        if (m_ec != error::http_connection_ended) {
+            if (m_fail_handler) {
+                m_fail_handler(m_connection_hdl);
+            }
+        }
+    } else if (tstat == closed) {
+        if (m_close_handler) {
+            m_close_handler(m_connection_hdl);
+        }
+        log_close_result();
+    } else {
+        m_elog.write(log::elevel::rerror,"Unknown terminate_status");
+    }
+
+    // call the termination handler if it exists
+    // if it exists it might (but shouldn't) refer to a bad memory location.
+    // If it does, we don't care and should catch and ignore it.
+    if (m_termination_handler) {
+        try {
+            m_termination_handler(type::get_shared());
+        } catch (std::exception const & e) {
+            m_elog.write(log::elevel::warn,
+                std::string("termination_handler call failed. Reason was: ")+e.what());
+        }
+    }
+}
+
+template <typename config>
+void connection<config>::write_frame() {
+    //m_alog.write(log::alevel::devel,"connection write_frame");
+
+    {
+        scoped_lock_type lock(m_write_lock);
+
+        // Check the write flag. If true, there is an outstanding transport
+        // write already. In this case we just return. The write handler will
+        // start a new write if the write queue isn't empty. If false, we set
+        // the write flag and proceed to initiate a transport write.
+        if (m_write_flag) {
+            return;
+        }
+
+        // pull off all the messages that are ready to write.
+        // stop if we get a message marked terminal
+        message_ptr next_message = write_pop();
+        while (next_message) {
+            m_current_msgs.push_back(next_message);
+            if (!next_message->get_terminal()) {
+                next_message = write_pop();
+            } else {
+                next_message = message_ptr();
+            }
+        }
+        
+        if (m_current_msgs.empty()) {
+            // there was nothing to send
+            return;
+        } else {
+            // At this point we own the next messages to be sent and are
+            // responsible for holding the write flag until they are 
+            // successfully sent or there is some error
+            m_write_flag = true;
+        }
+    }
+
+    typename std::vector<message_ptr>::iterator it;
+    for (it = m_current_msgs.begin(); it != m_current_msgs.end(); ++it) {
+        std::string const & header = (*it)->get_header();
+        std::string const & payload = (*it)->get_payload();
+
+        m_send_buffer.push_back(transport::buffer(header.c_str(),header.size()));
+        m_send_buffer.push_back(transport::buffer(payload.c_str(),payload.size()));   
+    }
+
+    // Print detailed send stats if those log levels are enabled
+    if (m_alog.static_test(log::alevel::frame_header)) {
+    if (m_alog.dynamic_test(log::alevel::frame_header)) {
+        std::stringstream general,header,payload;
+        
+        general << "Dispatching write containing " << m_current_msgs.size()
+                <<" message(s) containing ";
+        header << "Header Bytes: \n";
+        payload << "Payload Bytes: \n";
+        
+        size_t hbytes = 0;
+        size_t pbytes = 0;
+        
+        for (size_t i = 0; i < m_current_msgs.size(); i++) {
+            hbytes += m_current_msgs[i]->get_header().size();
+            pbytes += m_current_msgs[i]->get_payload().size();
+
+            
+            header << "[" << i << "] (" 
+                   << m_current_msgs[i]->get_header().size() << ") " 
+                   << utility::to_hex(m_current_msgs[i]->get_header()) << "\n";
+
+            if (m_alog.static_test(log::alevel::frame_payload)) {
+            if (m_alog.dynamic_test(log::alevel::frame_payload)) {
+                payload << "[" << i << "] (" 
+                        << m_current_msgs[i]->get_payload().size() << ") ["<<m_current_msgs[i]->get_opcode()<<"] "
+                        << (m_current_msgs[i]->get_opcode() == frame::opcode::text ? 
+                                m_current_msgs[i]->get_payload() : 
+                                utility::to_hex(m_current_msgs[i]->get_payload())
+                           ) 
+                        << "\n";
+            }
+            }  
+        }
+        
+        general << hbytes << " header bytes and " << pbytes << " payload bytes";
+        
+        m_alog.write(log::alevel::frame_header,general.str());
+        m_alog.write(log::alevel::frame_header,header.str());
+        m_alog.write(log::alevel::frame_payload,payload.str());
+    }
+    }
+
+    transport_con_type::async_write(
+        m_send_buffer,
+        m_write_frame_handler
+    );
+}
+
+template <typename config>
+void connection<config>::handle_write_frame(lib::error_code const & ec)
+{
+    if (m_alog.static_test(log::alevel::devel)) {
+        m_alog.write(log::alevel::devel,"connection handle_write_frame");
+    }
+
+    bool terminal = m_current_msgs.back()->get_terminal();
+
+    m_send_buffer.clear();
+    m_current_msgs.clear();
+    // TODO: recycle instead of deleting
+
+    if (ec) {
+        log_err(log::elevel::fatal,"handle_write_frame",ec);
+        this->terminate(ec);
+        return;
+    }
+
+    if (terminal) {
+        this->terminate(lib::error_code());
+        return;
+    }
+
+    bool needs_writing = false;
+    {
+        scoped_lock_type lock(m_write_lock);
+
+        // release write flag
+        m_write_flag = false;
+
+        needs_writing = !m_send_queue.empty();
+    }
+
+    if (needs_writing) {
+        transport_con_type::dispatch(lib::bind(
+            &type::write_frame,
+            type::get_shared()
+        ));
+    }
+}
+
+template <typename config>
+std::vector<int> const & connection<config>::get_supported_versions() const
+{
+    return versions_supported;
+}
+
+template <typename config>
+void connection<config>::process_control_frame(typename config::message_type::ptr msg)
+{
+    m_alog.write(log::alevel::devel,"process_control_frame");
+
+    frame::opcode::value op = msg->get_opcode();
+    lib::error_code ec;
+
+    std::stringstream s;
+    s << "Control frame received with opcode " << op;
+    m_alog.write(log::alevel::control,s.str());
+
+    if (m_state == session::state::closed) {
+        m_elog.write(log::elevel::warn,"got frame in state closed");
+        return;
+    }
+    if (op != frame::opcode::CLOSE && m_state != session::state::open) {
+        m_elog.write(log::elevel::warn,"got non-close frame in state closing");
+        return;
+    }
+
+    if (op == frame::opcode::PING) {
+        bool should_reply = true;
+
+        if (m_ping_handler) {
+            should_reply = m_ping_handler(m_connection_hdl, msg->get_payload());
+        }
+
+        if (should_reply) {
+            this->pong(msg->get_payload(),ec);
+            if (ec) {
+                log_err(log::elevel::devel,"Failed to send response pong",ec);
+            }
+        }
+    } else if (op == frame::opcode::PONG) {
+        if (m_pong_handler) {
+            m_pong_handler(m_connection_hdl, msg->get_payload());
+        }
+        if (m_ping_timer) {
+            m_ping_timer->cancel();
+        }
+    } else if (op == frame::opcode::CLOSE) {
+        m_alog.write(log::alevel::devel,"got close frame");
+        // record close code and reason somewhere
+
+        m_remote_close_code = close::extract_code(msg->get_payload(),ec);
+        if (ec) {
+            s.str("");
+            if (config::drop_on_protocol_error) {
+                s << "Received invalid close code " << m_remote_close_code
+                  << " dropping connection per config.";
+                m_elog.write(log::elevel::devel,s.str());
+                this->terminate(ec);
+            } else {
+                s << "Received invalid close code " << m_remote_close_code
+                  << " sending acknowledgement and closing";
+                m_elog.write(log::elevel::devel,s.str());
+                ec = send_close_ack(close::status::protocol_error,
+                    "Invalid close code");
+                if (ec) {
+                    log_err(log::elevel::devel,"send_close_ack",ec);
+                }
+            }
+            return;
+        }
+
+        m_remote_close_reason = close::extract_reason(msg->get_payload(),ec);
+        if (ec) {
+            if (config::drop_on_protocol_error) {
+                m_elog.write(log::elevel::devel,
+                    "Received invalid close reason. Dropping connection per config");
+                this->terminate(ec);
+            } else {
+                m_elog.write(log::elevel::devel,
+                    "Received invalid close reason. Sending acknowledgement and closing");
+                ec = send_close_ack(close::status::protocol_error,
+                    "Invalid close reason");
+                if (ec) {
+                    log_err(log::elevel::devel,"send_close_ack",ec);
+                }
+            }
+            return;
+        }
+
+        if (m_state == session::state::open) {
+            s.str("");
+            s << "Received close frame with code " << m_remote_close_code
+              << " and reason " << m_remote_close_reason;
+            m_alog.write(log::alevel::devel,s.str());
+
+            ec = send_close_ack();
+            if (ec) {
+                log_err(log::elevel::devel,"send_close_ack",ec);
+            }
+        } else if (m_state == session::state::closing && !m_was_clean) {
+            // ack of our close
+            m_alog.write(log::alevel::devel, "Got acknowledgement of close");
+
+            m_was_clean = true;
+
+            // If we are a server terminate the connection now. Clients should
+            // leave the connection open to give the server an opportunity to
+            // initiate the TCP close. The client's timer will handle closing
+            // its side of the connection if the server misbehaves.
+            //
+            // TODO: different behavior if the underlying transport doesn't
+            // support timers?
+            if (m_is_server) {
+                terminate(lib::error_code());
+            }
+        } else {
+            // spurious, ignore
+            m_elog.write(log::elevel::devel, "Got close frame in wrong state");
+        }
+    } else {
+        // got an invalid control opcode
+        m_elog.write(log::elevel::devel, "Got control frame with invalid opcode");
+        // initiate protocol error shutdown
+    }
+}
+
+template <typename config>
+lib::error_code connection<config>::send_close_ack(close::status::value code,
+    std::string const & reason)
+{
+    return send_close_frame(code,reason,true,m_is_server);
+}
+
+template <typename config>
+lib::error_code connection<config>::send_close_frame(close::status::value code,
+    std::string const & reason, bool ack, bool terminal)
+{
+    m_alog.write(log::alevel::devel,"send_close_frame");
+
+    // check for special codes
+
+    // If silent close is set, respect it and blank out close information
+    // Otherwise use whatever has been specified in the parameters. If
+    // parameters specifies close::status::blank then determine what to do
+    // based on whether or not this is an ack. If it is not an ack just
+    // send blank info. If it is an ack then echo the close information from
+    // the remote endpoint.
+    if (config::silent_close) {
+        m_alog.write(log::alevel::devel,"closing silently");
+        m_local_close_code = close::status::no_status;
+        m_local_close_reason = "";
+    } else if (code != close::status::blank) {
+        m_alog.write(log::alevel::devel,"closing with specified codes");
+        m_local_close_code = code;
+        m_local_close_reason = reason;
+    } else if (!ack) {
+        m_alog.write(log::alevel::devel,"closing with no status code");
+        m_local_close_code = close::status::no_status;
+        m_local_close_reason = "";
+    } else if (m_remote_close_code == close::status::no_status) {
+        m_alog.write(log::alevel::devel,
+            "acknowledging a no-status close with normal code");
+        m_local_close_code = close::status::normal;
+        m_local_close_reason = "";
+    } else {
+        m_alog.write(log::alevel::devel,"acknowledging with remote codes");
+        m_local_close_code = m_remote_close_code;
+        m_local_close_reason = m_remote_close_reason;
+    }
+
+    std::stringstream s;
+    s << "Closing with code: " << m_local_close_code << ", and reason: "
+      << m_local_close_reason;
+    m_alog.write(log::alevel::devel,s.str());
+
+    message_ptr msg = m_msg_manager->get_message();
+    if (!msg) {
+        return error::make_error_code(error::no_outgoing_buffers);
+    }
+
+    lib::error_code ec = m_processor->prepare_close(m_local_close_code,
+        m_local_close_reason,msg);
+    if (ec) {
+        return ec;
+    }
+
+    // Messages flagged terminal will result in the TCP connection being dropped
+    // after the message has been written. This is typically used when servers
+    // send an ack and when any endpoint encounters a protocol error
+    if (terminal) {
+        msg->set_terminal(true);
+    }
+
+    m_state = session::state::closing;
+
+    if (ack) {
+        m_was_clean = true;
+    }
+
+    // Start a timer so we don't wait forever for the acknowledgement close
+    // frame
+    if (m_close_handshake_timeout_dur > 0) {
+        m_handshake_timer = transport_con_type::set_timer(
+            m_close_handshake_timeout_dur,
+            lib::bind(
+                &type::handle_close_handshake_timeout,
+                type::get_shared(),
+                lib::placeholders::_1
+            )
+        );
+    }
+
+    bool needs_writing = false;
+    {
+        scoped_lock_type lock(m_write_lock);
+        write_push(msg);
+        needs_writing = !m_write_flag && !m_send_queue.empty();
+    }
+
+    if (needs_writing) {
+        transport_con_type::dispatch(lib::bind(
+            &type::write_frame,
+            type::get_shared()
+        ));
+    }
+
+    return lib::error_code();
+}
+
+template <typename config>
+typename connection<config>::processor_ptr
+connection<config>::get_processor(int version) const {
+    // TODO: allow disabling certain versions
+    
+    processor_ptr p;
+    
+    switch (version) {
+        case 0:
+            p = lib::make_shared<processor::hybi00<config> >(
+                transport_con_type::is_secure(),
+                m_is_server,
+                m_msg_manager
+            );
+            break;
+        case 7:
+            p = lib::make_shared<processor::hybi07<config> >(
+                transport_con_type::is_secure(),
+                m_is_server,
+                m_msg_manager,
+                lib::ref(m_rng)
+            );
+            break;
+        case 8:
+            p = lib::make_shared<processor::hybi08<config> >(
+                transport_con_type::is_secure(),
+                m_is_server,
+                m_msg_manager,
+                lib::ref(m_rng)
+            );
+            break;
+        case 13:
+            p = lib::make_shared<processor::hybi13<config> >(
+                transport_con_type::is_secure(),
+                m_is_server,
+                m_msg_manager,
+                lib::ref(m_rng)
+            );
+            break;
+        default:
+            return p;
+    }
+    
+    // Settings not configured by the constructor
+    p->set_max_message_size(m_max_message_size);
+    
+    return p;
+}
+
+template <typename config>
+void connection<config>::write_push(typename config::message_type::ptr msg)
+{
+    if (!msg) {
+        return;
+    }
+
+    m_send_buffer_size += msg->get_payload().size();
+    m_send_queue.push(msg);
+
+    if (m_alog.static_test(log::alevel::devel)) {
+        std::stringstream s;
+        s << "write_push: message count: " << m_send_queue.size()
+          << " buffer size: " << m_send_buffer_size;
+        m_alog.write(log::alevel::devel,s.str());
+    }
+}
+
+template <typename config>
+typename config::message_type::ptr connection<config>::write_pop()
+{
+    message_ptr msg;
+
+    if (m_send_queue.empty()) {
+        return msg;
+    }
+
+    msg = m_send_queue.front();
+
+    m_send_buffer_size -= msg->get_payload().size();
+    m_send_queue.pop();
+
+    if (m_alog.static_test(log::alevel::devel)) {
+        std::stringstream s;
+        s << "write_pop: message count: " << m_send_queue.size()
+          << " buffer size: " << m_send_buffer_size;
+        m_alog.write(log::alevel::devel,s.str());
+    }
+    return msg;
+}
+
+template <typename config>
+void connection<config>::log_open_result()
+{
+    std::stringstream s;
+
+    int version;
+    if (!processor::is_websocket_handshake(m_request)) {
+        version = -1;
+    } else {
+        version = processor::get_websocket_version(m_request);
+    }
+
+    // Connection Type
+    s << (version == -1 ? "HTTP" : "WebSocket") << " Connection ";
+
+    // Remote endpoint address
+    s << transport_con_type::get_remote_endpoint() << " ";
+
+    // Version string if WebSocket
+    if (version != -1) {
+        s << "v" << version << " ";
+    }
+
+    // User Agent
+    std::string ua = m_request.get_header("User-Agent");
+    if (ua == "") {
+        s << "\"\" ";
+    } else {
+        // check if there are any quotes in the user agent
+        s << "\"" << utility::string_replace_all(ua,"\"","\\\"") << "\" ";
+    }
+
+    // URI
+    s << (m_uri ? m_uri->get_resource() : "NULL") << " ";
+
+    // Status code
+    s << m_response.get_status_code();
+
+    m_alog.write(log::alevel::connect,s.str());
+}
+
+template <typename config>
+void connection<config>::log_close_result()
+{
+    std::stringstream s;
+
+    s << "Disconnect "
+      << "close local:[" << m_local_close_code
+      << (m_local_close_reason == "" ? "" : ","+m_local_close_reason)
+      << "] remote:[" << m_remote_close_code
+      << (m_remote_close_reason == "" ? "" : ","+m_remote_close_reason) << "]";
+
+    m_alog.write(log::alevel::disconnect,s.str());
+}
+
+template <typename config>
+void connection<config>::log_fail_result()
+{
+    std::stringstream s;
+    
+    int version = processor::get_websocket_version(m_request);
+
+    // Connection Type
+    s << "WebSocket Connection ";
+
+    // Remote endpoint address & WebSocket version
+    s << transport_con_type::get_remote_endpoint();
+    if (version < 0) {
+        s << " -";
+    } else {
+        s << " v" << version;
+    }
+
+    // User Agent
+    std::string ua = m_request.get_header("User-Agent");
+    if (ua == "") {
+        s << " \"\" ";
+    } else {
+        // check if there are any quotes in the user agent
+        s << " \"" << utility::string_replace_all(ua,"\"","\\\"") << "\" ";
+    }
+
+    // URI
+    s << (m_uri ? m_uri->get_resource() : "-");
+
+    // HTTP Status code
+    s  << " " << m_response.get_status_code();
+    
+    // WebSocket++ error code & reason
+    s << " " << m_ec << " " << m_ec.message();
+
+    m_alog.write(log::alevel::fail,s.str());
+}
+
+template <typename config>
+void connection<config>::log_http_result() {
+    std::stringstream s;
+
+    if (processor::is_websocket_handshake(m_request)) {
+        m_alog.write(log::alevel::devel,"Call to log_http_result for WebSocket");
+        return;
+    }  
+
+    // Connection Type
+    s << (m_request.get_header("host") == "" ? "-" : m_request.get_header("host"))
+      << " " << transport_con_type::get_remote_endpoint()
+      << " \"" << m_request.get_method() 
+      << " " << (m_uri ? m_uri->get_resource() : "-") 
+      << " " << m_request.get_version() << "\" " << m_response.get_status_code()
+      << " " << m_response.get_body().size();
+    
+    // User Agent
+    std::string ua = m_request.get_header("User-Agent");
+    if (ua == "") {
+        s << " \"\" ";
+    } else {
+        // check if there are any quotes in the user agent
+        s << " \"" << utility::string_replace_all(ua,"\"","\\\"") << "\" ";
+    }
+
+    m_alog.write(log::alevel::http,s.str());
+}
+
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_CONNECTION_IMPL_HPP
diff --git a/extlibs/websocketpp/websocketpp/impl/endpoint_impl.hpp b/extlibs/websocketpp/websocketpp/impl/endpoint_impl.hpp
new file mode 100644
index 000000000..5895199a0
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/impl/endpoint_impl.hpp
@@ -0,0 +1,255 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_ENDPOINT_IMPL_HPP
+#define WEBSOCKETPP_ENDPOINT_IMPL_HPP
+
+#include <string>
+
+namespace websocketpp {
+
+template <typename connection, typename config>
+typename endpoint<connection,config>::connection_ptr
+endpoint<connection,config>::create_connection() {
+    m_alog.write(log::alevel::devel,"create_connection");
+    //scoped_lock_type lock(m_state_lock);
+
+    /*if (m_state == STOPPING || m_state == STOPPED) {
+        return connection_ptr();
+    }*/
+
+    //scoped_lock_type guard(m_mutex);
+    // Create a connection on the heap and manage it using a shared pointer
+    connection_ptr con = lib::make_shared<connection_type>(m_is_server,
+        m_user_agent, lib::ref(m_alog), lib::ref(m_elog), lib::ref(m_rng));
+
+    connection_weak_ptr w(con);
+
+    // Create a weak pointer on the heap using that shared_ptr.
+    // Cast that weak pointer to void* and manage it using another shared_ptr
+    // connection_hdl hdl(reinterpret_cast<void*>(new connection_weak_ptr(con)));
+
+    con->set_handle(w);
+
+    // Copy default handlers from the endpoint
+    con->set_open_handler(m_open_handler);
+    con->set_close_handler(m_close_handler);
+    con->set_fail_handler(m_fail_handler);
+    con->set_ping_handler(m_ping_handler);
+    con->set_pong_handler(m_pong_handler);
+    con->set_pong_timeout_handler(m_pong_timeout_handler);
+    con->set_interrupt_handler(m_interrupt_handler);
+    con->set_http_handler(m_http_handler);
+    con->set_validate_handler(m_validate_handler);
+    con->set_message_handler(m_message_handler);
+
+    if (m_open_handshake_timeout_dur != config::timeout_open_handshake) {
+        con->set_open_handshake_timeout(m_open_handshake_timeout_dur);
+    }
+    if (m_close_handshake_timeout_dur != config::timeout_close_handshake) {
+        con->set_close_handshake_timeout(m_close_handshake_timeout_dur);
+    }
+    if (m_pong_timeout_dur != config::timeout_pong) {
+        con->set_pong_timeout(m_pong_timeout_dur);
+    }
+    if (m_max_message_size != config::max_message_size) {
+        con->set_max_message_size(m_max_message_size);
+    }
+    con->set_max_http_body_size(m_max_http_body_size);
+
+    lib::error_code ec;
+
+    ec = transport_type::init(con);
+    if (ec) {
+        m_elog.write(log::elevel::fatal,ec.message());
+        return connection_ptr();
+    }
+
+    return con;
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::interrupt(connection_hdl hdl, lib::error_code & ec)
+{
+    connection_ptr con = get_con_from_hdl(hdl,ec);
+    if (ec) {return;}
+
+    m_alog.write(log::alevel::devel,"Interrupting connection");
+
+    ec = con->interrupt();
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::interrupt(connection_hdl hdl) {
+    lib::error_code ec;
+    interrupt(hdl,ec);
+    if (ec) { throw exception(ec); }
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::pause_reading(connection_hdl hdl, lib::error_code & ec)
+{
+    connection_ptr con = get_con_from_hdl(hdl,ec);
+    if (ec) {return;}
+
+    ec = con->pause_reading();
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::pause_reading(connection_hdl hdl) {
+    lib::error_code ec;
+    pause_reading(hdl,ec);
+    if (ec) { throw exception(ec); }
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::resume_reading(connection_hdl hdl, lib::error_code & ec)
+{
+    connection_ptr con = get_con_from_hdl(hdl,ec);
+    if (ec) {return;}
+
+    ec = con->resume_reading();
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::resume_reading(connection_hdl hdl) {
+    lib::error_code ec;
+    resume_reading(hdl,ec);
+    if (ec) { throw exception(ec); }
+}
+
+
+
+template <typename connection, typename config>
+void endpoint<connection,config>::send(connection_hdl hdl, std::string const & payload,
+    frame::opcode::value op, lib::error_code & ec)
+{
+    connection_ptr con = get_con_from_hdl(hdl,ec);
+    if (ec) {return;}
+
+    ec = con->send(payload,op);
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::send(connection_hdl hdl, std::string const & payload,
+    frame::opcode::value op)
+{
+    lib::error_code ec;
+    send(hdl,payload,op,ec);
+    if (ec) { throw exception(ec); }
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::send(connection_hdl hdl, void const * payload,
+    size_t len, frame::opcode::value op, lib::error_code & ec)
+{
+    connection_ptr con = get_con_from_hdl(hdl,ec);
+    if (ec) {return;}
+    ec = con->send(payload,len,op);
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::send(connection_hdl hdl, void const * payload,
+    size_t len, frame::opcode::value op)
+{
+    lib::error_code ec;
+    send(hdl,payload,len,op,ec);
+    if (ec) { throw exception(ec); }
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::send(connection_hdl hdl, message_ptr msg,
+    lib::error_code & ec)
+{
+    connection_ptr con = get_con_from_hdl(hdl,ec);
+    if (ec) {return;}
+    ec = con->send(msg);
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::send(connection_hdl hdl, message_ptr msg) {
+    lib::error_code ec;
+    send(hdl,msg,ec);
+    if (ec) { throw exception(ec); }
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::close(connection_hdl hdl, close::status::value
+    const code, std::string const & reason,
+    lib::error_code & ec)
+{
+    connection_ptr con = get_con_from_hdl(hdl,ec);
+    if (ec) {return;}
+    con->close(code,reason,ec);
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::close(connection_hdl hdl, close::status::value
+    const code, std::string const & reason)
+{
+    lib::error_code ec;
+    close(hdl,code,reason,ec);
+    if (ec) { throw exception(ec); }
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::ping(connection_hdl hdl, std::string const &
+    payload, lib::error_code & ec)
+{
+    connection_ptr con = get_con_from_hdl(hdl,ec);
+    if (ec) {return;}
+    con->ping(payload,ec);
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::ping(connection_hdl hdl, std::string const & payload)
+{
+    lib::error_code ec;
+    ping(hdl,payload,ec);
+    if (ec) { throw exception(ec); }
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::pong(connection_hdl hdl, std::string const & payload,
+    lib::error_code & ec)
+{
+    connection_ptr con = get_con_from_hdl(hdl,ec);
+    if (ec) {return;}
+    con->pong(payload,ec);
+}
+
+template <typename connection, typename config>
+void endpoint<connection,config>::pong(connection_hdl hdl, std::string const & payload)
+{
+    lib::error_code ec;
+    pong(hdl,payload,ec);
+    if (ec) { throw exception(ec); }
+}
+
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_ENDPOINT_IMPL_HPP
diff --git a/extlibs/websocketpp/websocketpp/impl/utilities_impl.hpp b/extlibs/websocketpp/websocketpp/impl/utilities_impl.hpp
new file mode 100644
index 000000000..6f86e22f5
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/impl/utilities_impl.hpp
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_UTILITIES_IMPL_HPP
+#define WEBSOCKETPP_UTILITIES_IMPL_HPP
+
+#include <algorithm>
+#include <string>
+
+namespace websocketpp {
+namespace utility {
+
+inline std::string to_lower(std::string const & in) {
+    std::string out = in;
+    std::transform(out.begin(),out.end(),out.begin(),::tolower);
+    return out;
+}
+
+inline std::string to_hex(std::string const & input) {
+    std::string output;
+    std::string hex = "0123456789ABCDEF";
+
+    for (size_t i = 0; i < input.size(); i++) {
+        output += hex[(input[i] & 0xF0) >> 4];
+        output += hex[input[i] & 0x0F];
+        output += " ";
+    }
+
+    return output;
+}
+
+inline std::string to_hex(uint8_t const * input, size_t length) {
+    std::string output;
+    std::string hex = "0123456789ABCDEF";
+
+    for (size_t i = 0; i < length; i++) {
+        output += hex[(input[i] & 0xF0) >> 4];
+        output += hex[input[i] & 0x0F];
+        output += " ";
+    }
+
+    return output;
+}
+
+inline std::string to_hex(const char* input,size_t length) {
+    return to_hex(reinterpret_cast<const uint8_t*>(input),length);
+}
+
+inline std::string string_replace_all(std::string subject, std::string const &
+    search, std::string const & replace)
+{
+    size_t pos = 0;
+    while((pos = subject.find(search, pos)) != std::string::npos) {
+         subject.replace(pos, search.length(), replace);
+         pos += replace.length();
+    }
+    return subject;
+}
+
+} // namespace utility
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_UTILITIES_IMPL_HPP
diff --git a/extlibs/websocketpp/websocketpp/logger/basic.hpp b/extlibs/websocketpp/websocketpp/logger/basic.hpp
new file mode 100644
index 000000000..95099a834
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/logger/basic.hpp
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_LOGGER_BASIC_HPP
+#define WEBSOCKETPP_LOGGER_BASIC_HPP
+
+/* Need a way to print a message to the log
+ *
+ * - timestamps
+ * - channels
+ * - thread safe
+ * - output to stdout or file
+ * - selective output channels, both compile time and runtime
+ * - named channels
+ * - ability to test whether a log message will be printed at compile time
+ *
+ */
+
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/stdint.hpp>
+#include <websocketpp/common/time.hpp>
+
+#include <ctime>
+#include <iostream>
+#include <iomanip>
+#include <string>
+
+namespace websocketpp {
+namespace log {
+
+/// Basic logger that outputs to an ostream
+template <typename concurrency, typename names>
+class basic {
+public:
+    basic<concurrency,names>(channel_type_hint::value h =
+        channel_type_hint::access)
+      : m_static_channels(0xffffffff)
+      , m_dynamic_channels(0)
+      , m_out(h == channel_type_hint::error ? &std::cerr : &std::cout) {}
+
+    basic<concurrency,names>(std::ostream * out)
+      : m_static_channels(0xffffffff)
+      , m_dynamic_channels(0)
+      , m_out(out) {}
+
+    basic<concurrency,names>(level c, channel_type_hint::value h =
+        channel_type_hint::access)
+      : m_static_channels(c)
+      , m_dynamic_channels(0)
+      , m_out(h == channel_type_hint::error ? &std::cerr : &std::cout) {}
+
+    basic<concurrency,names>(level c, std::ostream * out)
+      : m_static_channels(c)
+      , m_dynamic_channels(0)
+      , m_out(out) {}
+
+    void set_ostream(std::ostream * out = &std::cout) {
+        m_out = out;
+    }
+
+    void set_channels(level channels) {
+        if (channels == names::none) {
+            clear_channels(names::all);
+            return;
+        }
+
+        scoped_lock_type lock(m_lock);
+        m_dynamic_channels |= (channels & m_static_channels);
+    }
+
+    void clear_channels(level channels) {
+        scoped_lock_type lock(m_lock);
+        m_dynamic_channels &= ~channels;
+    }
+
+    /// Write a string message to the given channel
+    /**
+     * @param channel The channel to write to
+     * @param msg The message to write
+     */
+    void write(level channel, std::string const & msg) {
+        scoped_lock_type lock(m_lock);
+        if (!this->dynamic_test(channel)) { return; }
+        *m_out << "[" << timestamp << "] "
+                  << "[" << names::channel_name(channel) << "] "
+                  << msg << "\n";
+        m_out->flush();
+    }
+
+    /// Write a cstring message to the given channel
+    /**
+     * @param channel The channel to write to
+     * @param msg The message to write
+     */
+    void write(level channel, char const * msg) {
+        scoped_lock_type lock(m_lock);
+        if (!this->dynamic_test(channel)) { return; }
+        *m_out << "[" << timestamp << "] "
+                  << "[" << names::channel_name(channel) << "] "
+                  << msg << "\n";
+        m_out->flush();
+    }
+
+    _WEBSOCKETPP_CONSTEXPR_TOKEN_ bool static_test(level channel) const {
+        return ((channel & m_static_channels) != 0);
+    }
+
+    bool dynamic_test(level channel) {
+        return ((channel & m_dynamic_channels) != 0);
+    }
+
+protected:
+    typedef typename concurrency::scoped_lock_type scoped_lock_type;
+    typedef typename concurrency::mutex_type mutex_type;
+    mutex_type m_lock;
+
+private:
+    // The timestamp does not include the time zone, because on Windows with the
+    // default registry settings, the time zone would be written out in full,
+    // which would be obnoxiously verbose.
+    //
+    // TODO: find a workaround for this or make this format user settable
+    static std::ostream & timestamp(std::ostream & os) {
+        std::time_t t = std::time(NULL);
+        std::tm lt = lib::localtime(t);
+        #ifdef _WEBSOCKETPP_PUTTIME_
+            return os << std::put_time(&lt,"%Y-%m-%d %H:%M:%S");
+        #else // Falls back to strftime, which requires a temporary copy of the string.
+            char buffer[20];
+            size_t result = std::strftime(buffer,sizeof(buffer),"%Y-%m-%d %H:%M:%S",&lt);
+            return os << (result == 0 ? "Unknown" : buffer);
+        #endif
+    }
+
+    level const m_static_channels;
+    level m_dynamic_channels;
+    std::ostream * m_out;
+};
+
+} // log
+} // websocketpp
+
+#endif // WEBSOCKETPP_LOGGER_BASIC_HPP
diff --git a/extlibs/websocketpp/websocketpp/logger/levels.hpp b/extlibs/websocketpp/websocketpp/logger/levels.hpp
new file mode 100644
index 000000000..cd7ccd690
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/logger/levels.hpp
@@ -0,0 +1,203 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_LOGGER_LEVELS_HPP
+#define WEBSOCKETPP_LOGGER_LEVELS_HPP
+
+#include <websocketpp/common/stdint.hpp>
+
+namespace websocketpp {
+namespace log {
+
+/// Type of a channel package
+typedef uint32_t level;
+
+/// Package of values for hinting at the nature of a given logger.
+/**
+ * Used by the library to signal to the logging class a hint that it can use to
+ * set itself up. For example, the `access` hint indicates that it is an access
+ * log that might be suitable for being printed to an access log file or to cout
+ * whereas `error` might be suitable for an error log file or cerr. 
+ */
+struct channel_type_hint {
+    /// Type of a channel type hint value
+    typedef uint32_t value;
+    
+    /// No information
+    static value const none = 0;
+    /// Access log
+    static value const access = 1;
+    /// Error log
+    static value const error = 2;
+};
+
+/// Package of log levels for logging errors
+struct elevel {
+    /// Special aggregate value representing "no levels"
+    static level const none = 0x0;
+    /// Low level debugging information (warning: very chatty)
+    static level const devel = 0x1;
+    /// Information about unusual system states or other minor internal library
+    /// problems, less chatty than devel.
+    static level const library = 0x2;
+    /// Information about minor configuration problems or additional information
+    /// about other warnings.
+    static level const info = 0x4;
+    /// Information about important problems not severe enough to terminate
+    /// connections.
+    static level const warn = 0x8;
+    /// Recoverable error. Recovery may mean cleanly closing the connection with
+    /// an appropriate error code to the remote endpoint.
+    static level const rerror = 0x10;
+    /// Unrecoverable error. This error will trigger immediate unclean
+    /// termination of the connection or endpoint.
+    static level const fatal = 0x20;
+    /// Special aggregate value representing "all levels"
+    static level const all = 0xffffffff;
+
+    /// Get the textual name of a channel given a channel id
+    /**
+     * The id must be that of a single channel. Passing an aggregate channel
+     * package results in undefined behavior.
+     *
+     * @param channel The channel id to look up.
+     *
+     * @return The name of the specified channel.
+     */
+    static char const * channel_name(level channel) {
+        switch(channel) {
+            case devel:
+                return "devel";
+            case library:
+                return "library";
+            case info:
+                return "info";
+            case warn:
+                return "warning";
+            case rerror:
+                return "error";
+            case fatal:
+                return "fatal";
+            default:
+                return "unknown";
+        }
+    }
+};
+
+/// Package of log levels for logging access events
+struct alevel {
+    /// Special aggregate value representing "no levels"
+    static level const none = 0x0;
+    /// Information about new connections
+    /**
+     * One line for each new connection that includes a host of information
+     * including: the remote address, websocket version, requested resource,
+     * http code, remote user agent
+     */
+    static level const connect = 0x1;
+    /// One line for each closed connection. Includes closing codes and reasons.
+    static level const disconnect = 0x2;
+    /// One line per control frame
+    static level const control = 0x4;
+    /// One line per frame, includes the full frame header
+    static level const frame_header = 0x8;
+    /// One line per frame, includes the full message payload (warning: chatty)
+    static level const frame_payload = 0x10;
+    /// Reserved
+    static level const message_header = 0x20;
+    /// Reserved
+    static level const message_payload = 0x40;
+    /// Reserved
+    static level const endpoint = 0x80;
+    /// Extra information about opening handshakes
+    static level const debug_handshake = 0x100;
+    /// Extra information about closing handshakes
+    static level const debug_close = 0x200;
+    /// Development messages (warning: very chatty)
+    static level const devel = 0x400;
+    /// Special channel for application specific logs. Not used by the library.
+    static level const app = 0x800;
+    /// Access related to HTTP requests
+    static level const http = 0x1000;
+    /// One line for each failed WebSocket connection with details
+    static level const fail = 0x2000;
+    /// Aggregate package representing the commonly used core access channels
+    /// Connect, Disconnect, Fail, and HTTP
+    static level const access_core = 0x00003003;
+    /// Special aggregate value representing "all levels"
+    static level const all = 0xffffffff;
+
+    /// Get the textual name of a channel given a channel id
+    /**
+     * Get the textual name of a channel given a channel id. The id must be that
+     * of a single channel. Passing an aggregate channel package results in
+     * undefined behavior.
+     *
+     * @param channel The channelid to look up.
+     *
+     * @return The name of the specified channel.
+     */
+    static char const * channel_name(level channel) {
+        switch(channel) {
+            case connect:
+                return "connect";
+            case disconnect:
+                return "disconnect";
+            case control:
+                return "control";
+            case frame_header:
+                return "frame_header";
+            case frame_payload:
+                return "frame_payload";
+            case message_header:
+                return "message_header";
+            case message_payload:
+                return "message_payload";
+            case endpoint:
+                return "endpoint";
+            case debug_handshake:
+                return "debug_handshake";
+            case debug_close:
+                return "debug_close";
+            case devel:
+                return "devel";
+            case app:
+                return "application";
+            case http:
+                return "http";
+            case fail:
+                return "fail";
+            default:
+                return "unknown";
+        }
+    }
+};
+
+} // logger
+} // websocketpp
+
+#endif //WEBSOCKETPP_LOGGER_LEVELS_HPP
diff --git a/extlibs/websocketpp/websocketpp/logger/stub.hpp b/extlibs/websocketpp/websocketpp/logger/stub.hpp
new file mode 100644
index 000000000..2db6da7df
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/logger/stub.hpp
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_LOGGER_STUB_HPP
+#define WEBSOCKETPP_LOGGER_STUB_HPP
+
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/common/cpp11.hpp>
+
+#include <string>
+
+namespace websocketpp {
+namespace log {
+
+/// Stub logger that ignores all input
+class stub {
+public:
+    /// Construct the logger
+    /**
+     * @param hint A channel type specific hint for how to construct the logger
+     */
+    explicit stub(channel_type_hint::value) {}
+
+    /// Construct the logger
+    /**
+     * @param default_channels A set of channels to statically enable
+     * @param hint A channel type specific hint for how to construct the logger
+     */
+    stub(level, channel_type_hint::value) {}
+    _WEBSOCKETPP_CONSTEXPR_TOKEN_ stub() {}
+
+    /// Dynamically enable the given list of channels
+    /**
+     * All operations on the stub logger are no-ops and all arguments are
+     * ignored
+     *
+     * @param channels The package of channels to enable
+     */
+    void set_channels(level) {}
+
+    /// Dynamically disable the given list of channels
+    /**
+     * All operations on the stub logger are no-ops and all arguments are
+     * ignored
+     *
+     * @param channels The package of channels to disable
+     */
+    void clear_channels(level) {}
+
+    /// Write a string message to the given channel
+    /**
+     * Writing on the stub logger is a no-op and all arguments are ignored
+     *
+     * @param channel The channel to write to
+     * @param msg The message to write
+     */
+    void write(level, std::string const &) {}
+
+    /// Write a cstring message to the given channel
+    /**
+     * Writing on the stub logger is a no-op and all arguments are ignored
+     *
+     * @param channel The channel to write to
+     * @param msg The message to write
+     */
+    void write(level, char const *) {}
+
+    /// Test whether a channel is statically enabled
+    /**
+     * The stub logger has no channels so all arguments are ignored and
+     * `static_test` always returns false.
+     *
+     * @param channel The package of channels to test
+     */
+    _WEBSOCKETPP_CONSTEXPR_TOKEN_ bool static_test(level) const {
+        return false;
+    }
+
+    /// Test whether a channel is dynamically enabled
+    /**
+     * The stub logger has no channels so all arguments are ignored and
+     * `dynamic_test` always returns false.
+     *
+     * @param channel The package of channels to test
+     */
+    bool dynamic_test(level) {
+        return false;
+    }
+};
+
+} // log
+} // websocketpp
+
+#endif // WEBSOCKETPP_LOGGER_STUB_HPP
diff --git a/extlibs/websocketpp/websocketpp/logger/syslog.hpp b/extlibs/websocketpp/websocketpp/logger/syslog.hpp
new file mode 100644
index 000000000..513abee4a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/logger/syslog.hpp
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * The initial version of this logging policy was contributed to the WebSocket++
+ * project by Tom Hughes.
+ */
+
+#ifndef WEBSOCKETPP_LOGGER_SYSLOG_HPP
+#define WEBSOCKETPP_LOGGER_SYSLOG_HPP
+
+#include <syslog.h>
+
+#include <websocketpp/logger/basic.hpp>
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/logger/levels.hpp>
+
+namespace websocketpp {
+namespace log {
+
+/// Basic logger that outputs to syslog
+template <typename concurrency, typename names>
+class syslog : public basic<concurrency, names> {
+public:
+    typedef basic<concurrency, names> base;
+
+    /// Construct the logger
+    /**
+     * @param hint A channel type specific hint for how to construct the logger
+     */
+    syslog<concurrency,names>(channel_type_hint::value hint =
+        channel_type_hint::access)
+      : basic<concurrency,names>(hint), m_channel_type_hint(hint) {}
+
+    /// Construct the logger
+    /**
+     * @param channels A set of channels to statically enable
+     * @param hint A channel type specific hint for how to construct the logger
+     */
+    syslog<concurrency,names>(level channels, channel_type_hint::value hint =
+        channel_type_hint::access)
+      : basic<concurrency,names>(channels, hint), m_channel_type_hint(hint) {}
+
+    /// Write a string message to the given channel
+    /**
+     * @param channel The channel to write to
+     * @param msg The message to write
+     */
+    void write(level channel, std::string const & msg) {
+        write(channel, msg.c_str());
+    }
+
+    /// Write a cstring message to the given channel
+    /**
+     * @param channel The channel to write to
+     * @param msg The message to write
+     */
+    void write(level channel, char const * msg) {
+        scoped_lock_type lock(base::m_lock);
+        if (!this->dynamic_test(channel)) { return; }
+        ::syslog(syslog_priority(channel), "[%s] %s",
+            names::channel_name(channel), msg);
+    }
+private:
+    typedef typename base::scoped_lock_type scoped_lock_type;
+
+    /// The default level is used for all access logs and any error logs that
+    /// don't trivially map to one of the standard syslog levels.
+    static int const default_level = LOG_INFO;
+
+    /// retrieve the syslog priority code given a WebSocket++ channel
+    /**
+     * @param channel The level to look up
+     * @return The syslog level associated with `channel`
+     */
+    int syslog_priority(level channel) const {
+        if (m_channel_type_hint == channel_type_hint::access) {
+            return syslog_priority_access(channel);
+        } else {
+            return syslog_priority_error(channel);
+        }
+    }
+
+    /// retrieve the syslog priority code given a WebSocket++ error channel
+    /**
+     * @param channel The level to look up
+     * @return The syslog level associated with `channel`
+     */
+    int syslog_priority_error(level channel) const {
+        switch (channel) {
+            case elevel::devel:
+                return LOG_DEBUG;
+            case elevel::library:
+                return LOG_DEBUG;
+            case elevel::info:
+                return LOG_INFO;
+            case elevel::warn:
+                return LOG_WARNING;
+            case elevel::rerror:
+                return LOG_ERR;
+            case elevel::fatal:
+                return LOG_CRIT;
+            default:
+                return default_level;
+        }
+    }
+
+    /// retrieve the syslog priority code given a WebSocket++ access channel
+    /**
+     * @param channel The level to look up
+     * @return The syslog level associated with `channel`
+     */
+    _WEBSOCKETPP_CONSTEXPR_TOKEN_ int syslog_priority_access(level) const {
+        return default_level;
+    }
+
+    channel_type_hint::value m_channel_type_hint;
+};
+
+} // log
+} // websocketpp
+
+#endif // WEBSOCKETPP_LOGGER_SYSLOG_HPP
diff --git a/extlibs/websocketpp/websocketpp/message_buffer/alloc.hpp b/extlibs/websocketpp/websocketpp/message_buffer/alloc.hpp
new file mode 100644
index 000000000..75d89766a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/message_buffer/alloc.hpp
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_MESSAGE_BUFFER_ALLOC_HPP
+#define WEBSOCKETPP_MESSAGE_BUFFER_ALLOC_HPP
+
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/frame.hpp>
+
+namespace websocketpp {
+namespace message_buffer {
+namespace alloc {
+
+/// A connection message manager that allocates a new message for each
+/// request.
+template <typename message>
+class con_msg_manager
+  : public lib::enable_shared_from_this<con_msg_manager<message> >
+{
+public:
+    typedef con_msg_manager<message> type;
+    typedef lib::shared_ptr<con_msg_manager> ptr;
+    typedef lib::weak_ptr<con_msg_manager> weak_ptr;
+
+    typedef typename message::ptr message_ptr;
+
+    /// Get an empty message buffer
+    /**
+     * @return A shared pointer to an empty new message
+     */
+    message_ptr get_message() {
+        return message_ptr(lib::make_shared<message>(type::shared_from_this()));
+    }
+
+    /// Get a message buffer with specified size and opcode
+    /**
+     * @param op The opcode to use
+     * @param size Minimum size in bytes to request for the message payload.
+     *
+     * @return A shared pointer to a new message with specified size.
+     */
+    message_ptr get_message(frame::opcode::value op,size_t size) {
+        return message_ptr(lib::make_shared<message>(type::shared_from_this(),op,size));
+    }
+
+    /// Recycle a message
+    /**
+     * This method shouldn't be called. If it is, return false to indicate an
+     * error. The rest of the method recycle chain should notice this and free
+     * the memory.
+     *
+     * @param msg The message to be recycled.
+     *
+     * @return true if the message was successfully recycled, false otherwse.
+     */
+    bool recycle(message *) {
+        return false;
+    }
+};
+
+/// An endpoint message manager that allocates a new manager for each
+/// connection.
+template <typename con_msg_manager>
+class endpoint_msg_manager {
+public:
+    typedef typename con_msg_manager::ptr con_msg_man_ptr;
+
+    /// Get a pointer to a connection message manager
+    /**
+     * @return A pointer to the requested connection message manager.
+     */
+    con_msg_man_ptr get_manager() const {
+        return con_msg_man_ptr(lib::make_shared<con_msg_manager>());
+    }
+};
+
+} // namespace alloc
+} // namespace message_buffer
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_MESSAGE_BUFFER_ALLOC_HPP
diff --git a/extlibs/websocketpp/websocketpp/message_buffer/message.hpp b/extlibs/websocketpp/websocketpp/message_buffer/message.hpp
new file mode 100644
index 000000000..b127ee254
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/message_buffer/message.hpp
@@ -0,0 +1,340 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_MESSAGE_BUFFER_MESSAGE_HPP
+#define WEBSOCKETPP_MESSAGE_BUFFER_MESSAGE_HPP
+
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/frame.hpp>
+
+#include <string>
+
+namespace websocketpp {
+namespace message_buffer {
+
+/* # message:
+ * object that stores a message while it is being sent or received. Contains
+ * the message payload itself, the message header, the extension data, and the
+ * opcode.
+ *
+ * # connection_message_manager:
+ * An object that manages all of the message_buffers associated with a given
+ * connection. Implements the get_message_buffer(size) method that returns
+ * a message buffer at least size bytes long.
+ *
+ * Message buffers are reference counted with shared ownership semantics. Once
+ * requested from the manager the requester and it's associated downstream code
+ * may keep a pointer to the message indefinitely at a cost of extra resource
+ * usage. Once the reference count drops to the point where the manager is the
+ * only reference the messages is recycled using whatever method is implemented
+ * in the manager.
+ *
+ * # endpoint_message_manager:
+ * An object that manages connection_message_managers. Implements the
+ * get_message_manager() method. This is used once by each connection to
+ * request the message manager that they are supposed to use to manage message
+ * buffers for their own use.
+ *
+ * TYPES OF CONNECTION_MESSAGE_MANAGERS
+ * - allocate a message with the exact size every time one is requested
+ * - maintain a pool of pre-allocated messages and return one when needed.
+ *   Recycle previously used messages back into the pool
+ *
+ * TYPES OF ENDPOINT_MESSAGE_MANAGERS
+ *  - allocate a new connection manager for each connection. Message pools
+ *    become connection specific. This increases memory usage but improves
+ *    concurrency.
+ *  - allocate a single connection manager and share a pointer to it with all
+ *    connections created by this endpoint. The message pool will be shared
+ *    among all connections, improving memory usage and performance at the cost
+ *    of reduced concurrency
+ */
+
+
+/// Represents a buffer for a single WebSocket message.
+/**
+ *
+ *
+ */
+template <template<class> class con_msg_manager>
+class message {
+public:
+    typedef lib::shared_ptr<message> ptr;
+
+    typedef con_msg_manager<message> con_msg_man_type;
+    typedef typename con_msg_man_type::ptr con_msg_man_ptr;
+    typedef typename con_msg_man_type::weak_ptr con_msg_man_weak_ptr;
+
+    /// Construct an empty message
+    /**
+     * Construct an empty message
+     */
+    message(const con_msg_man_ptr manager)
+      : m_manager(manager)
+      , m_prepared(false)
+      , m_fin(true)
+      , m_terminal(false)
+      , m_compressed(false) {}
+
+    /// Construct a message and fill in some values
+    /**
+     *
+     */
+    message(const con_msg_man_ptr manager, frame::opcode::value op, size_t size = 128)
+      : m_manager(manager)
+      , m_opcode(op)
+      , m_prepared(false)
+      , m_fin(true)
+      , m_terminal(false)
+      , m_compressed(false)
+    {
+        m_payload.reserve(size);
+    }
+
+    /// Return whether or not the message has been prepared for sending
+    /**
+     * The prepared flag indicates that the message has been prepared by a
+     * websocket protocol processor and is ready to be written to the wire.
+     *
+     * @return whether or not the message has been prepared for sending
+     */
+    bool get_prepared() const {
+        return m_prepared;
+    }
+
+    /// Set or clear the flag that indicates that the message has been prepared
+    /**
+     * This flag should not be set by end user code without a very good reason.
+     *
+     * @param value The value to set the prepared flag to
+     */
+    void set_prepared(bool value) {
+        m_prepared = value;
+    }
+
+    /// Return whether or not the message is flagged as compressed
+    /**
+     * @return whether or not the message is/should be compressed
+     */
+    bool get_compressed() const {
+        return m_compressed;
+    }
+
+    /// Set or clear the compression flag
+    /**
+     * The compression flag is used to indicate whether or not the message is
+     * or should be compressed. Compression is not guaranteed. Both endpoints
+     * must support a compression extension and the connection must have had
+     * that extension negotiated in its handshake.
+     *
+     * @param value The value to set the compressed flag to
+     */
+    void set_compressed(bool value) {
+        m_compressed = value;
+    }
+
+    /// Get whether or not the message is terminal
+    /**
+     * Messages can be flagged as terminal, which results in the connection
+     * being close after they are written rather than the implementation going
+     * on to the next message in the queue. This is typically used internally
+     * for close messages only.
+     *
+     * @return Whether or not this message is marked terminal
+     */
+    bool get_terminal() const {
+        return m_terminal;
+    }
+
+    /// Set the terminal flag
+    /**
+     * This flag should not be set by end user code without a very good reason.
+     *
+     * @see get_terminal()
+     *
+     * @param value The value to set the terminal flag to.
+     */
+    void set_terminal(bool value) {
+        m_terminal = value;
+    }
+    /// Read the fin bit
+    /**
+     * A message with the fin bit set will be sent as the last message of its
+     * sequence. A message with the fin bit cleared will require subsequent
+     * frames of opcode continuation until one of them has the fin bit set.
+     *
+     * The remote end likely will not deliver any bytes until the frame with the fin
+     * bit set has been received.
+     *
+     * @return Whether or not the fin bit is set
+     */
+    bool get_fin() const {
+        return m_fin;
+    }
+
+    /// Set the fin bit
+    /**
+     * @see get_fin for a more detailed explaination of the fin bit
+     *
+     * @param value The value to set the fin bit to.
+     */
+    void set_fin(bool value) {
+        m_fin = value;
+    }
+
+    /// Return the message opcode
+    frame::opcode::value get_opcode() const {
+        return m_opcode;
+    }
+
+    /// Set the opcode
+    void set_opcode(frame::opcode::value op) {
+        m_opcode = op;
+    }
+
+    /// Return the prepared frame header
+    /**
+     * This value is typically set by a websocket protocol processor
+     * and shouldn't be tampered with.
+     */
+    std::string const & get_header() const {
+        return m_header;
+    }
+
+    /// Set prepared frame header
+    /**
+     * Under normal circumstances this should not be called by end users
+     *
+     * @param header A string to set the header to.
+     */
+    void set_header(std::string const & header) {
+        m_header = header;
+    }
+
+    std::string const & get_extension_data() const {
+        return m_extension_data;
+    }
+
+    /// Get a reference to the payload string
+    /**
+     * @return A const reference to the message's payload string
+     */
+    std::string const & get_payload() const {
+        return m_payload;
+    }
+
+    /// Get a non-const reference to the payload string
+    /**
+     * @return A reference to the message's payload string
+     */
+    std::string & get_raw_payload() {
+        return m_payload;
+    }
+
+    /// Set payload data
+    /**
+     * Set the message buffer's payload to the given value.
+     *
+     * @param payload A string to set the payload to.
+     */
+    void set_payload(std::string const & payload) {
+        m_payload = payload;
+    }
+
+    /// Set payload data
+    /**
+     * Set the message buffer's payload to the given value.
+     *
+     * @param payload A pointer to a data array to set to.
+     * @param len The length of new payload in bytes.
+     */
+    void set_payload(void const * payload, size_t len) {
+        m_payload.reserve(len);
+        char const * pl = static_cast<char const *>(payload);
+        m_payload.assign(pl, pl + len);
+    }
+
+    /// Append payload data
+    /**
+     * Append data to the message buffer's payload.
+     *
+     * @param payload A string containing the data array to append.
+     */
+    void append_payload(std::string const & payload) {
+        m_payload.append(payload);
+    }
+
+    /// Append payload data
+    /**
+     * Append data to the message buffer's payload.
+     *
+     * @param payload A pointer to a data array to append
+     * @param len The length of payload in bytes
+     */
+    void append_payload(void const * payload, size_t len) {
+        m_payload.reserve(m_payload.size()+len);
+        m_payload.append(static_cast<char const *>(payload),len);
+    }
+
+    /// Recycle the message
+    /**
+     * A request to recycle this message was received. Forward that request to
+     * the connection message manager for processing. Errors and exceptions
+     * from the manager's recycle member function should be passed back up the
+     * call chain. The caller to message::recycle will deal with them.
+     *
+     * Recycle must *only* be called by the message shared_ptr's destructor.
+     * Once recycled successfully, ownership of the memory has been passed to
+     * another system and must not be accessed again.
+     *
+     * @return true if the message was successfully recycled, false otherwise.
+     */
+    bool recycle() {
+        con_msg_man_ptr shared = m_manager.lock();
+
+        if (shared) {
+            return shared->recycle(this);
+        } else {
+            return false;
+        }
+    }
+private:
+    con_msg_man_weak_ptr        m_manager;
+    std::string                 m_header;
+    std::string                 m_extension_data;
+    std::string                 m_payload;
+    frame::opcode::value        m_opcode;
+    bool                        m_prepared;
+    bool                        m_fin;
+    bool                        m_terminal;
+    bool                        m_compressed;
+};
+
+} // namespace message_buffer
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_MESSAGE_BUFFER_MESSAGE_HPP
diff --git a/extlibs/websocketpp/websocketpp/message_buffer/pool.hpp b/extlibs/websocketpp/websocketpp/message_buffer/pool.hpp
new file mode 100644
index 000000000..3af9e02a2
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/message_buffer/pool.hpp
@@ -0,0 +1,229 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_MESSAGE_BUFFER_ALLOC_HPP
+#define WEBSOCKETPP_MESSAGE_BUFFER_ALLOC_HPP
+
+#include <websocketpp/common/memory.hpp>
+
+#include <string>
+
+namespace websocketpp {
+namespace message_buffer {
+
+/* # message:
+ * object that stores a message while it is being sent or received. Contains
+ * the message payload itself, the message header, the extension data, and the
+ * opcode.
+ *
+ * # connection_message_manager:
+ * An object that manages all of the message_buffers associated with a given
+ * connection. Implements the get_message_buffer(size) method that returns
+ * a message buffer at least size bytes long.
+ *
+ * Message buffers are reference counted with shared ownership semantics. Once
+ * requested from the manager the requester and it's associated downstream code
+ * may keep a pointer to the message indefinitely at a cost of extra resource
+ * usage. Once the reference count drops to the point where the manager is the
+ * only reference the messages is recycled using whatever method is implemented
+ * in the manager.
+ *
+ * # endpoint_message_manager:
+ * An object that manages connection_message_managers. Implements the
+ * get_message_manager() method. This is used once by each connection to
+ * request the message manager that they are supposed to use to manage message
+ * buffers for their own use.
+ *
+ * TYPES OF CONNECTION_MESSAGE_MANAGERS
+ * - allocate a message with the exact size every time one is requested
+ * - maintain a pool of pre-allocated messages and return one when needed.
+ *   Recycle previously used messages back into the pool
+ *
+ * TYPES OF ENDPOINT_MESSAGE_MANAGERS
+ *  - allocate a new connection manager for each connection. Message pools
+ *    become connection specific. This increases memory usage but improves
+ *    concurrency.
+ *  - allocate a single connection manager and share a pointer to it with all
+ *    connections created by this endpoint. The message pool will be shared
+ *    among all connections, improving memory usage and performance at the cost
+ *    of reduced concurrency
+ */
+
+/// Custom deleter for use in shared_ptrs to message.
+/**
+ * This is used to catch messages about to be deleted and offer the manager the
+ * ability to recycle them instead. Message::recycle will return true if it was
+ * successfully recycled and false otherwise. In the case of exceptions or error
+ * this deleter frees the memory.
+ */
+template <typename T>
+void message_deleter(T* msg) {
+    try {
+        if (!msg->recycle()) {
+            delete msg;
+        }
+    } catch (...) {
+        // TODO: is there a better way to ensure this function doesn't throw?
+        delete msg;
+    }
+}
+
+/// Represents a buffer for a single WebSocket message.
+/**
+ *
+ *
+ */
+template <typename con_msg_manager>
+class message {
+public:
+    typedef lib::shared_ptr<message> ptr;
+
+    typedef typename con_msg_manager::weak_ptr con_msg_man_ptr;
+
+    message(con_msg_man_ptr manager, size_t size = 128)
+      : m_manager(manager)
+      , m_payload(size) {}
+
+    frame::opcode::value get_opcode() const {
+        return m_opcode;
+    }
+    const std::string& get_header() const {
+        return m_header;
+    }
+    const std::string& get_extension_data() const {
+        return m_extension_data;
+    }
+    const std::string& get_payload() const {
+        return m_payload;
+    }
+
+    /// Recycle the message
+    /**
+     * A request to recycle this message was received. Forward that request to
+     * the connection message manager for processing. Errors and exceptions
+     * from the manager's recycle member function should be passed back up the
+     * call chain. The caller to message::recycle will deal with them.
+     *
+     * Recycle must *only* be called by the message shared_ptr's destructor.
+     * Once recycled successfully, ownership of the memory has been passed to
+     * another system and must not be accessed again.
+     *
+     * @return true if the message was successfully recycled, false otherwise.
+     */
+    bool recycle() {
+        typename con_msg_manager::ptr shared = m_manager.lock();
+
+        if (shared) {
+            return shared->(recycle(this));
+        } else {
+            return false;
+        }
+    }
+private:
+    con_msg_man_ptr             m_manager;
+
+    frame::opcode::value        m_opcode;
+    std::string                 m_header;
+    std::string                 m_extension_data;
+    std::string                 m_payload;
+};
+
+namespace alloc {
+
+/// A connection message manager that allocates a new message for each
+/// request.
+template <typename message>
+class con_msg_manager {
+public:
+    typedef lib::shared_ptr<con_msg_manager> ptr;
+    typedef lib::weak_ptr<con_msg_manager> weak_ptr;
+
+    typedef typename message::ptr message_ptr;
+
+    /// Get a message buffer with specified size
+    /**
+     * @param size Minimum size in bytes to request for the message payload.
+     *
+     * @return A shared pointer to a new message with specified size.
+     */
+    message_ptr get_message(size_t size) const {
+        return lib::make_shared<message>(size);
+    }
+
+    /// Recycle a message
+    /**
+     * This method shouldn't be called. If it is, return false to indicate an
+     * error. The rest of the method recycle chain should notice this and free
+     * the memory.
+     *
+     * @param msg The message to be recycled.
+     *
+     * @return true if the message was successfully recycled, false otherwse.
+     */
+    bool recycle(message * msg) {
+        return false;
+    }
+};
+
+/// An endpoint message manager that allocates a new manager for each
+/// connection.
+template <typename con_msg_manager>
+class endpoint_msg_manager {
+public:
+    typedef typename con_msg_manager::ptr con_msg_man_ptr;
+
+    /// Get a pointer to a connection message manager
+    /**
+     * @return A pointer to the requested connection message manager.
+     */
+    con_msg_man_ptr get_manager() const {
+        return lib::make_shared<con_msg_manager>();
+    }
+};
+
+} // namespace alloc
+
+namespace pool {
+
+/// A connection messages manager that maintains a pool of messages that is
+/// used to fulfill get_message requests.
+class con_msg_manager {
+
+};
+
+/// An endpoint manager that maintains a shared pool of connection managers
+/// and returns an appropriate one for the requesting connection.
+class endpoint_msg_manager {
+
+};
+
+} // namespace pool
+
+} // namespace message_buffer
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_MESSAGE_BUFFER_ALLOC_HPP
diff --git a/extlibs/websocketpp/websocketpp/processors/base.hpp b/extlibs/websocketpp/websocketpp/processors/base.hpp
new file mode 100644
index 000000000..ddb8b81a4
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/processors/base.hpp
@@ -0,0 +1,299 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_PROCESSOR_BASE_HPP
+#define WEBSOCKETPP_PROCESSOR_BASE_HPP
+
+#include <websocketpp/close.hpp>
+#include <websocketpp/utilities.hpp>
+#include <websocketpp/uri.hpp>
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/system_error.hpp>
+
+#include <string>
+
+namespace websocketpp {
+namespace processor {
+
+/// Constants related to processing WebSocket connections
+namespace constants {
+
+static char const upgrade_token[] = "websocket";
+static char const connection_token[] = "upgrade";
+static char const handshake_guid[] = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
+
+} // namespace constants
+
+
+/// Processor class related error codes
+namespace error_cat {
+enum value {
+    BAD_REQUEST = 0, // Error was the result of improperly formatted user input
+    INTERNAL_ERROR = 1, // Error was a logic error internal to WebSocket++
+    PROTOCOL_VIOLATION = 2,
+    MESSAGE_TOO_BIG = 3,
+    PAYLOAD_VIOLATION = 4 // Error was due to receiving invalid payload data
+};
+} // namespace error_cat
+
+/// Error code category and codes used by all processor types
+namespace error {
+enum processor_errors {
+    /// Catch-all error for processor policy errors that don't fit in other
+    /// categories
+    general = 1,
+
+    /// Error was the result of improperly formatted user input
+    bad_request,
+
+    /// Processor encountered a protocol violation in an incoming message
+    protocol_violation,
+
+    /// Processor encountered a message that was too large
+    message_too_big,
+
+    /// Processor encountered invalid payload data.
+    invalid_payload,
+
+    /// The processor method was called with invalid arguments
+    invalid_arguments,
+
+    /// Opcode was invalid for requested operation
+    invalid_opcode,
+
+    /// Control frame too large
+    control_too_big,
+
+    /// Illegal use of reserved bit
+    invalid_rsv_bit,
+
+    /// Fragmented control message
+    fragmented_control,
+
+    /// Continuation without message
+    invalid_continuation,
+
+    /// Clients may not send unmasked frames
+    masking_required,
+
+    /// Servers may not send masked frames
+    masking_forbidden,
+
+    /// Payload length not minimally encoded
+    non_minimal_encoding,
+
+    /// Not supported on 32 bit systems
+    requires_64bit,
+
+    /// Invalid UTF-8 encoding
+    invalid_utf8,
+
+    /// Operation required not implemented functionality
+    not_implemented,
+
+    /// Invalid HTTP method
+    invalid_http_method,
+
+    /// Invalid HTTP version
+    invalid_http_version,
+
+    /// Invalid HTTP status
+    invalid_http_status,
+
+    /// Missing Required Header
+    missing_required_header,
+
+    /// Embedded SHA-1 library error
+    sha1_library,
+
+    /// No support for this feature in this protocol version.
+    no_protocol_support,
+
+    /// Reserved close code used
+    reserved_close_code,
+
+    /// Invalid close code used
+    invalid_close_code,
+
+    /// Using a reason requires a close code
+    reason_requires_code,
+
+    /// Error parsing subprotocols
+    subprotocol_parse_error,
+
+    /// Error parsing extensions
+    extension_parse_error,
+
+    /// Extension related operation was ignored because extensions are disabled
+    extensions_disabled,
+    
+    /// Short Ke3 read. Hybi00 requires a third key to be read from the 8 bytes
+    /// after the handshake. Less than 8 bytes were read.
+    short_key3
+};
+
+/// Category for processor errors
+class processor_category : public lib::error_category {
+public:
+    processor_category() {}
+
+    char const * name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp.processor";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case error::general:
+                return "Generic processor error";
+            case error::bad_request:
+                return "invalid user input";
+            case error::protocol_violation:
+                return "Generic protocol violation";
+            case error::message_too_big:
+                return "A message was too large";
+            case error::invalid_payload:
+                return "A payload contained invalid data";
+            case error::invalid_arguments:
+                return "invalid function arguments";
+            case error::invalid_opcode:
+                return "invalid opcode";
+            case error::control_too_big:
+                return "Control messages are limited to fewer than 125 characters";
+            case error::invalid_rsv_bit:
+                return "Invalid use of reserved bits";
+            case error::fragmented_control:
+                return "Control messages cannot be fragmented";
+            case error::invalid_continuation:
+                return "Invalid message continuation";
+            case error::masking_required:
+                return "Clients may not send unmasked frames";
+            case error::masking_forbidden:
+                return "Servers may not send masked frames";
+            case error::non_minimal_encoding:
+                return "Payload length was not minimally encoded";
+            case error::requires_64bit:
+                return "64 bit frames are not supported on 32 bit systems";
+            case error::invalid_utf8:
+                return "Invalid UTF8 encoding";
+            case error::not_implemented:
+                return "Operation required not implemented functionality";
+            case error::invalid_http_method:
+                return "Invalid HTTP method.";
+            case error::invalid_http_version:
+                return "Invalid HTTP version.";
+            case error::invalid_http_status:
+                return "Invalid HTTP status.";
+            case error::missing_required_header:
+                return "A required HTTP header is missing";
+            case error::sha1_library:
+                return "SHA-1 library error";
+            case error::no_protocol_support:
+                return "The WebSocket protocol version in use does not support this feature";
+            case error::reserved_close_code:
+                return "Reserved close code used";
+            case error::invalid_close_code:
+                return "Invalid close code used";
+            case error::reason_requires_code:
+                return "Using a close reason requires a valid close code";
+            case error::subprotocol_parse_error:
+                return "Error parsing subprotocol header";
+            case error::extension_parse_error:
+                return "Error parsing extension header";
+            case error::extensions_disabled:
+                return "Extensions are disabled";
+            case error::short_key3:
+                return "Short Hybi00 Key 3 read";
+            default:
+                return "Unknown";
+        }
+    }
+};
+
+/// Get a reference to a static copy of the processor error category
+inline lib::error_category const & get_processor_category() {
+    static processor_category instance;
+    return instance;
+}
+
+/// Create an error code with the given value and the processor category
+inline lib::error_code make_error_code(error::processor_errors e) {
+    return lib::error_code(static_cast<int>(e), get_processor_category());
+}
+
+/// Converts a processor error_code into a websocket close code
+/**
+ * Looks up the appropriate WebSocket close code that should be sent after an
+ * error of this sort occurred.
+ *
+ * If the error is not in the processor category close::status::blank is
+ * returned.
+ *
+ * If the error isn't normally associated with reasons to close a connection
+ * (such as errors intended to be used internally or delivered to client
+ * applications, ex: invalid arguments) then
+ * close::status::internal_endpoint_error is returned.
+ */
+inline close::status::value to_ws(lib::error_code ec) {
+    if (ec.category() != get_processor_category()) {
+        return close::status::blank;
+    }
+
+    switch (ec.value()) {
+        case error::protocol_violation:
+        case error::control_too_big:
+        case error::invalid_opcode:
+        case error::invalid_rsv_bit:
+        case error::fragmented_control:
+        case error::invalid_continuation:
+        case error::masking_required:
+        case error::masking_forbidden:
+        case error::reserved_close_code:
+        case error::invalid_close_code:
+            return close::status::protocol_error;
+        case error::invalid_payload:
+        case error::invalid_utf8:
+            return close::status::invalid_payload;
+        case error::message_too_big:
+            return close::status::message_too_big;
+        default:
+            return close::status::internal_endpoint_error;
+    }
+}
+
+} // namespace error
+} // namespace processor
+} // namespace websocketpp
+
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_
+template<> struct is_error_code_enum<websocketpp::processor::error::processor_errors>
+{
+    static bool const value = true;
+};
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_
+
+#endif //WEBSOCKETPP_PROCESSOR_BASE_HPP
diff --git a/extlibs/websocketpp/websocketpp/processors/hybi00.hpp b/extlibs/websocketpp/websocketpp/processors/hybi00.hpp
new file mode 100644
index 000000000..991813922
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/processors/hybi00.hpp
@@ -0,0 +1,446 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_PROCESSOR_HYBI00_HPP
+#define WEBSOCKETPP_PROCESSOR_HYBI00_HPP
+
+#include <websocketpp/frame.hpp>
+#include <websocketpp/utf8_validator.hpp>
+#include <websocketpp/common/network.hpp>
+#include <websocketpp/common/md5.hpp>
+#include <websocketpp/common/platforms.hpp>
+
+#include <websocketpp/processors/processor.hpp>
+
+#include <algorithm>
+#include <cstdlib>
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+namespace processor {
+
+/// Processor for Hybi Draft version 00
+/**
+ * There are many differences between Hybi 00 and Hybi 13
+ */
+template <typename config>
+class hybi00 : public processor<config> {
+public:
+    typedef processor<config> base;
+
+    typedef typename config::request_type request_type;
+    typedef typename config::response_type response_type;
+
+    typedef typename config::message_type message_type;
+    typedef typename message_type::ptr message_ptr;
+
+    typedef typename config::con_msg_manager_type::ptr msg_manager_ptr;
+
+    explicit hybi00(bool secure, bool p_is_server, msg_manager_ptr manager)
+      : processor<config>(secure, p_is_server)
+      , msg_hdr(0x00)
+      , msg_ftr(0xff)
+      , m_state(HEADER)
+      , m_msg_manager(manager) {}
+
+    int get_version() const {
+        return 0;
+    }
+
+    lib::error_code validate_handshake(request_type const & r) const {
+        if (r.get_method() != "GET") {
+            return make_error_code(error::invalid_http_method);
+        }
+
+        if (r.get_version() != "HTTP/1.1") {
+            return make_error_code(error::invalid_http_version);
+        }
+
+        // required headers
+        // Host is required by HTTP/1.1
+        // Connection is required by is_websocket_handshake
+        // Upgrade is required by is_websocket_handshake
+        if (r.get_header("Sec-WebSocket-Key1") == "" ||
+            r.get_header("Sec-WebSocket-Key2") == "" ||
+            r.get_header("Sec-WebSocket-Key3") == "")
+        {
+            return make_error_code(error::missing_required_header);
+        }
+
+        return lib::error_code();
+    }
+
+    lib::error_code process_handshake(request_type const & req,
+        std::string const & subprotocol, response_type & res) const
+    {
+        char key_final[16];
+
+        // copy key1 into final key
+        decode_client_key(req.get_header("Sec-WebSocket-Key1"), &key_final[0]);
+
+        // copy key2 into final key
+        decode_client_key(req.get_header("Sec-WebSocket-Key2"), &key_final[4]);
+
+        // copy key3 into final key
+        // key3 should be exactly 8 bytes. If it is more it will be truncated
+        // if it is less the final key will almost certainly be wrong.
+        // TODO: decide if it is best to silently fail here or produce some sort
+        //       of warning or exception.
+        std::string const & key3 = req.get_header("Sec-WebSocket-Key3");
+        std::copy(key3.c_str(),
+                  key3.c_str()+(std::min)(static_cast<size_t>(8), key3.size()),
+                  &key_final[8]);
+
+        res.append_header(
+            "Sec-WebSocket-Key3",
+            md5::md5_hash_string(std::string(key_final,16))
+        );
+
+        res.append_header("Upgrade","WebSocket");
+        res.append_header("Connection","Upgrade");
+
+        // Echo back client's origin unless our local application set a
+        // more restrictive one.
+        if (res.get_header("Sec-WebSocket-Origin") == "") {
+            res.append_header("Sec-WebSocket-Origin",req.get_header("Origin"));
+        }
+
+        // Echo back the client's request host unless our local application
+        // set a different one.
+        if (res.get_header("Sec-WebSocket-Location") == "") {
+            uri_ptr uri = get_uri(req);
+            res.append_header("Sec-WebSocket-Location",uri->str());
+        }
+
+        if (subprotocol != "") {
+            res.replace_header("Sec-WebSocket-Protocol",subprotocol);
+        }
+
+        return lib::error_code();
+    }
+
+    /// Fill in a set of request headers for a client connection request
+    /**
+     * The Hybi 00 processor only implements incoming connections so this will
+     * always return an error.
+     *
+     * @param [out] req  Set of headers to fill in
+     * @param [in] uri The uri being connected to
+     * @param [in] subprotocols The list of subprotocols to request
+     */
+    lib::error_code client_handshake_request(request_type &, uri_ptr,
+        std::vector<std::string> const &) const
+    {
+        return error::make_error_code(error::no_protocol_support);
+    }
+
+    /// Validate the server's response to an outgoing handshake request
+    /**
+     * The Hybi 00 processor only implements incoming connections so this will
+     * always return an error.
+     *
+     * @param req The original request sent
+     * @param res The reponse to generate
+     * @return An error code, 0 on success, non-zero for other errors
+     */
+    lib::error_code validate_server_handshake_response(request_type const &,
+        response_type &) const
+    {
+        return error::make_error_code(error::no_protocol_support);
+    }
+
+    std::string get_raw(response_type const & res) const {
+        response_type temp = res;
+        temp.remove_header("Sec-WebSocket-Key3");
+        return temp.raw() + res.get_header("Sec-WebSocket-Key3");
+    }
+
+    std::string const & get_origin(request_type const & r) const {
+        return r.get_header("Origin");
+    }
+
+    /// Extracts requested subprotocols from a handshake request
+    /**
+     * hybi00 doesn't support subprotocols so there never will be any requested
+     *
+     * @param [in] req The request to extract from
+     * @param [out] subprotocol_list A reference to a vector of strings to store
+     * the results in.
+     */
+    lib::error_code extract_subprotocols(request_type const &, 
+        std::vector<std::string> &)
+    {
+        return lib::error_code();
+    }
+
+    uri_ptr get_uri(request_type const & request) const {
+        std::string h = request.get_header("Host");
+
+        size_t last_colon = h.rfind(":");
+        size_t last_sbrace = h.rfind("]");
+
+        // no : = hostname with no port
+        // last : before ] = ipv6 literal with no port
+        // : with no ] = hostname with port
+        // : after ] = ipv6 literal with port
+
+        if (last_colon == std::string::npos ||
+            (last_sbrace != std::string::npos && last_sbrace > last_colon))
+        {
+            return lib::make_shared<uri>(base::m_secure, h, request.get_uri());
+        } else {
+            return lib::make_shared<uri>(base::m_secure,
+                                   h.substr(0,last_colon),
+                                   h.substr(last_colon+1),
+                                   request.get_uri());
+        }
+
+        // TODO: check if get_uri is a full uri
+    }
+
+    /// Get hybi00 handshake key3
+    /**
+     * @todo This doesn't appear to be used anymore. It might be able to be
+     * removed
+     */
+    std::string get_key3() const {
+        return "";
+    }
+
+    /// Process new websocket connection bytes
+    size_t consume(uint8_t * buf, size_t len, lib::error_code & ec) {
+        // if in state header we are expecting a 0x00 byte, if we don't get one
+        // it is a fatal error
+        size_t p = 0; // bytes processed
+        size_t l = 0;
+
+        ec = lib::error_code();
+
+        while (p < len) {
+            if (m_state == HEADER) {
+                if (buf[p] == msg_hdr) {
+                    p++;
+                    m_msg_ptr = m_msg_manager->get_message(frame::opcode::text,1);
+
+                    if (!m_msg_ptr) {
+                        ec = make_error_code(websocketpp::error::no_incoming_buffers);
+                        m_state = FATAL_ERROR;
+                    } else {
+                        m_state = PAYLOAD;
+                    }
+                } else {
+                    ec = make_error_code(error::protocol_violation);
+                    m_state = FATAL_ERROR;
+                }
+            } else if (m_state == PAYLOAD) {
+                uint8_t *it = std::find(buf+p,buf+len,msg_ftr);
+
+                // 0    1    2    3    4    5
+                // 0x00 0x23 0x23 0x23 0xff 0xXX
+
+                // Copy payload bytes into message
+                l = static_cast<size_t>(it-(buf+p));
+                m_msg_ptr->append_payload(buf+p,l);
+                p += l;
+
+                if (it != buf+len) {
+                    // message is done, copy it and the trailing
+                    p++;
+                    // TODO: validation
+                    m_state = READY;
+                }
+            } else {
+                // TODO
+                break;
+            }
+        }
+        // If we get one, we create a new message and move to application state
+
+        // if in state application we are copying bytes into the output message
+        // and validating them for UTF8 until we hit a 0xff byte. Once we hit
+        // 0x00, the message is complete and is dispatched. Then we go back to
+        // header state.
+
+        //ec = make_error_code(error::not_implemented);
+        return p;
+    }
+
+    bool ready() const {
+        return (m_state == READY);
+    }
+
+    bool get_error() const {
+        return false;
+    }
+
+    message_ptr get_message() {
+        message_ptr ret = m_msg_ptr;
+        m_msg_ptr = message_ptr();
+        m_state = HEADER;
+        return ret;
+    }
+
+    /// Prepare a message for writing
+    /**
+     * Performs validation, masking, compression, etc. will return an error if
+     * there was an error, otherwise msg will be ready to be written
+     */
+    virtual lib::error_code prepare_data_frame(message_ptr in, message_ptr out)
+    {
+        if (!in || !out) {
+            return make_error_code(error::invalid_arguments);
+        }
+
+        // TODO: check if the message is prepared already
+
+        // validate opcode
+        if (in->get_opcode() != frame::opcode::text) {
+            return make_error_code(error::invalid_opcode);
+        }
+
+        std::string& i = in->get_raw_payload();
+        //std::string& o = out->get_raw_payload();
+
+        // validate payload utf8
+        if (!utf8_validator::validate(i)) {
+            return make_error_code(error::invalid_payload);
+        }
+
+        // generate header
+        out->set_header(std::string(reinterpret_cast<char const *>(&msg_hdr),1));
+
+        // process payload
+        out->set_payload(i);
+        out->append_payload(std::string(reinterpret_cast<char const *>(&msg_ftr),1));
+
+        // hybi00 doesn't support compression
+        // hybi00 doesn't have masking
+
+        out->set_prepared(true);
+
+        return lib::error_code();
+    }
+
+    /// Prepare a ping frame
+    /**
+     * Hybi 00 doesn't support pings so this will always return an error
+     *
+     * @param in The string to use for the ping payload
+     * @param out The message buffer to prepare the ping in.
+     * @return Status code, zero on success, non-zero on failure
+     */
+    lib::error_code prepare_ping(std::string const &, message_ptr) const
+    {
+        return lib::error_code(error::no_protocol_support);
+    }
+
+    /// Prepare a pong frame
+    /**
+     * Hybi 00 doesn't support pongs so this will always return an error
+     *
+     * @param in The string to use for the pong payload
+     * @param out The message buffer to prepare the pong in.
+     * @return Status code, zero on success, non-zero on failure
+     */
+    lib::error_code prepare_pong(std::string const &, message_ptr) const
+    {
+        return lib::error_code(error::no_protocol_support);
+    }
+
+    /// Prepare a close frame
+    /**
+     * Hybi 00 doesn't support the close code or reason so these parameters are
+     * ignored.
+     *
+     * @param code The close code to send
+     * @param reason The reason string to send
+     * @param out The message buffer to prepare the fame in
+     * @return Status code, zero on success, non-zero on failure
+     */
+    lib::error_code prepare_close(close::status::value, std::string const &, 
+        message_ptr out) const
+    {
+        if (!out) {
+            return lib::error_code(error::invalid_arguments);
+        }
+
+        std::string val;
+        val.append(1,'\xff');
+        val.append(1,'\x00');
+        out->set_payload(val);
+        out->set_prepared(true);
+
+        return lib::error_code();
+    }
+private:
+    void decode_client_key(std::string const & key, char * result) const {
+        unsigned int spaces = 0;
+        std::string digits = "";
+        uint32_t num;
+
+        // key2
+        for (size_t i = 0; i < key.size(); i++) {
+            if (key[i] == ' ') {
+                spaces++;
+            } else if (key[i] >= '0' && key[i] <= '9') {
+                digits += key[i];
+            }
+        }
+
+        num = static_cast<uint32_t>(strtoul(digits.c_str(), NULL, 10));
+        if (spaces > 0 && num > 0) {
+            num = htonl(num/spaces);
+            std::copy(reinterpret_cast<char*>(&num),
+                      reinterpret_cast<char*>(&num)+4,
+                      result);
+        } else {
+            std::fill(result,result+4,0);
+        }
+    }
+
+    enum state {
+        HEADER = 0,
+        PAYLOAD = 1,
+        READY = 2,
+        FATAL_ERROR = 3
+    };
+
+    uint8_t const msg_hdr;
+    uint8_t const msg_ftr;
+
+    state m_state;
+
+    msg_manager_ptr m_msg_manager;
+    message_ptr m_msg_ptr;
+    utf8_validator::validator m_validator;
+};
+
+} // namespace processor
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_PROCESSOR_HYBI00_HPP
diff --git a/extlibs/websocketpp/websocketpp/processors/hybi07.hpp b/extlibs/websocketpp/websocketpp/processors/hybi07.hpp
new file mode 100644
index 000000000..14b67c21a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/processors/hybi07.hpp
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_PROCESSOR_HYBI07_HPP
+#define WEBSOCKETPP_PROCESSOR_HYBI07_HPP
+
+#include <websocketpp/processors/hybi08.hpp>
+
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+namespace processor {
+
+/// Processor for Hybi Draft version 07
+/**
+ * The primary difference between 07 and 08 is a version number.
+ */
+template <typename config>
+class hybi07 : public hybi08<config> {
+public:
+    typedef typename config::request_type request_type;
+
+    typedef typename config::con_msg_manager_type::ptr msg_manager_ptr;
+    typedef typename config::rng_type rng_type;
+
+    explicit hybi07(bool secure, bool p_is_server, msg_manager_ptr manager, rng_type& rng)
+      : hybi08<config>(secure, p_is_server, manager, rng) {}
+
+    /// Fill in a set of request headers for a client connection request
+    /**
+     * The Hybi 07 processor only implements incoming connections so this will
+     * always return an error.
+     *
+     * @param [out] req  Set of headers to fill in
+     * @param [in] uri The uri being connected to
+     * @param [in] subprotocols The list of subprotocols to request
+     */
+    lib::error_code client_handshake_request(request_type &, uri_ptr,
+        std::vector<std::string> const &) const
+    {
+        return error::make_error_code(error::no_protocol_support);
+    }
+
+    int get_version() const {
+        return 7;
+    }
+private:
+};
+
+} // namespace processor
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_PROCESSOR_HYBI07_HPP
diff --git a/extlibs/websocketpp/websocketpp/processors/hybi08.hpp b/extlibs/websocketpp/websocketpp/processors/hybi08.hpp
new file mode 100644
index 000000000..15f6e6586
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/processors/hybi08.hpp
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_PROCESSOR_HYBI08_HPP
+#define WEBSOCKETPP_PROCESSOR_HYBI08_HPP
+
+#include <websocketpp/processors/hybi13.hpp>
+
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+namespace processor {
+
+/// Processor for Hybi Draft version 08
+/**
+ * The primary difference between 08 and 13 is a different origin header name
+ */
+template <typename config>
+class hybi08 : public hybi13<config> {
+public:
+    typedef hybi08<config> type;
+    typedef typename config::request_type request_type;
+
+    typedef typename config::con_msg_manager_type::ptr msg_manager_ptr;
+    typedef typename config::rng_type rng_type;
+
+    explicit hybi08(bool secure, bool p_is_server, msg_manager_ptr manager, rng_type& rng)
+      : hybi13<config>(secure, p_is_server, manager, rng) {}
+
+    /// Fill in a set of request headers for a client connection request
+    /**
+     * The Hybi 08 processor only implements incoming connections so this will
+     * always return an error.
+     *
+     * @param [out] req  Set of headers to fill in
+     * @param [in] uri The uri being connected to
+     * @param [in] subprotocols The list of subprotocols to request
+     */
+    lib::error_code client_handshake_request(request_type &, uri_ptr,
+        std::vector<std::string> const &) const
+    {
+        return error::make_error_code(error::no_protocol_support);
+    }
+
+    int get_version() const {
+        return 8;
+    }
+
+    std::string const & get_origin(request_type const & r) const {
+        return r.get_header("Sec-WebSocket-Origin");
+    }
+private:
+};
+
+} // namespace processor
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_PROCESSOR_HYBI08_HPP
diff --git a/extlibs/websocketpp/websocketpp/processors/hybi13.hpp b/extlibs/websocketpp/websocketpp/processors/hybi13.hpp
new file mode 100644
index 000000000..51ce3403d
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/processors/hybi13.hpp
@@ -0,0 +1,1005 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_PROCESSOR_HYBI13_HPP
+#define WEBSOCKETPP_PROCESSOR_HYBI13_HPP
+
+#include <websocketpp/processors/processor.hpp>
+
+#include <websocketpp/frame.hpp>
+#include <websocketpp/http/constants.hpp>
+
+#include <websocketpp/utf8_validator.hpp>
+#include <websocketpp/sha1/sha1.hpp>
+#include <websocketpp/base64/base64.hpp>
+
+#include <websocketpp/common/network.hpp>
+#include <websocketpp/common/platforms.hpp>
+
+#include <algorithm>
+#include <cassert>
+#include <string>
+#include <vector>
+#include <utility>
+
+namespace websocketpp {
+namespace processor {
+
+/// Processor for Hybi version 13 (RFC6455)
+template <typename config>
+class hybi13 : public processor<config> {
+public:
+    typedef processor<config> base;
+
+    typedef typename config::request_type request_type;
+    typedef typename config::response_type response_type;
+
+    typedef typename config::message_type message_type;
+    typedef typename message_type::ptr message_ptr;
+
+    typedef typename config::con_msg_manager_type msg_manager_type;
+    typedef typename msg_manager_type::ptr msg_manager_ptr;
+    typedef typename config::rng_type rng_type;
+
+    typedef typename config::permessage_deflate_type permessage_deflate_type;
+
+    typedef std::pair<lib::error_code,std::string> err_str_pair;
+
+    explicit hybi13(bool secure, bool p_is_server, msg_manager_ptr manager, rng_type& rng)
+      : processor<config>(secure, p_is_server)
+      , m_msg_manager(manager)
+      , m_rng(rng)
+    {
+        reset_headers();
+    }
+
+    int get_version() const {
+        return 13;
+    }
+
+    bool has_permessage_deflate() const {
+        return m_permessage_deflate.is_implemented();
+    }
+
+    err_str_pair negotiate_extensions(request_type const & req) {
+        err_str_pair ret;
+
+        // Respect blanket disabling of all extensions and don't even parse
+        // the extension header
+        if (!config::enable_extensions) {
+            ret.first = make_error_code(error::extensions_disabled);
+            return ret;
+        }
+
+        http::parameter_list p;
+
+        bool error = req.get_header_as_plist("Sec-WebSocket-Extensions",p);
+
+        if (error) {
+            ret.first = make_error_code(error::extension_parse_error);
+            return ret;
+        }
+
+        // If there are no extensions parsed then we are done!
+        if (p.size() == 0) {
+            return ret;
+        }
+
+        http::parameter_list::const_iterator it;
+
+        if (m_permessage_deflate.is_implemented()) {
+            err_str_pair neg_ret;
+            for (it = p.begin(); it != p.end(); ++it) {
+                // look through each extension, if the key is permessage-deflate
+                if (it->first == "permessage-deflate") {
+                    neg_ret = m_permessage_deflate.negotiate(it->second);
+
+                    if (neg_ret.first) {
+                        // Figure out if this is an error that should halt all
+                        // extension negotiations or simply cause negotiation of
+                        // this specific extension to fail.
+                        //std::cout << "permessage-compress negotiation failed: "
+                        //          << neg_ret.first.message() << std::endl;
+                    } else {
+                        // Note: this list will need commas if WebSocket++ ever
+                        // supports more than one extension
+                        ret.second += neg_ret.second;
+                        continue;
+                    }
+                }
+            }
+        }
+
+        return ret;
+    }
+
+    lib::error_code validate_handshake(request_type const & r) const {
+        if (r.get_method() != "GET") {
+            return make_error_code(error::invalid_http_method);
+        }
+
+        if (r.get_version() != "HTTP/1.1") {
+            return make_error_code(error::invalid_http_version);
+        }
+
+        // required headers
+        // Host is required by HTTP/1.1
+        // Connection is required by is_websocket_handshake
+        // Upgrade is required by is_websocket_handshake
+        if (r.get_header("Sec-WebSocket-Key") == "") {
+            return make_error_code(error::missing_required_header);
+        }
+
+        return lib::error_code();
+    }
+
+    /* TODO: the 'subprotocol' parameter may need to be expanded into a more
+     * generic struct if other user input parameters to the processed handshake
+     * are found.
+     */
+    lib::error_code process_handshake(request_type const & request, 
+        std::string const & subprotocol, response_type & response) const
+    {
+        std::string server_key = request.get_header("Sec-WebSocket-Key");
+
+        lib::error_code ec = process_handshake_key(server_key);
+
+        if (ec) {
+            return ec;
+        }
+
+        response.replace_header("Sec-WebSocket-Accept",server_key);
+        response.append_header("Upgrade",constants::upgrade_token);
+        response.append_header("Connection",constants::connection_token);
+
+        if (!subprotocol.empty()) {
+            response.replace_header("Sec-WebSocket-Protocol",subprotocol);
+        }
+
+        return lib::error_code();
+    }
+
+    /// Fill in a set of request headers for a client connection request
+    /**
+     * @param [out] req  Set of headers to fill in
+     * @param [in] uri The uri being connected to
+     * @param [in] subprotocols The list of subprotocols to request
+     */
+    lib::error_code client_handshake_request(request_type & req, uri_ptr
+        uri, std::vector<std::string> const & subprotocols) const
+    {
+        req.set_method("GET");
+        req.set_uri(uri->get_resource());
+        req.set_version("HTTP/1.1");
+
+        req.append_header("Upgrade","websocket");
+        req.append_header("Connection","Upgrade");
+        req.replace_header("Sec-WebSocket-Version","13");
+        req.replace_header("Host",uri->get_host_port());
+
+        if (!subprotocols.empty()) {
+            std::ostringstream result;
+            std::vector<std::string>::const_iterator it = subprotocols.begin();
+            result << *it++;
+            while (it != subprotocols.end()) {
+                result << ", " << *it++;
+            }
+
+            req.replace_header("Sec-WebSocket-Protocol",result.str());
+        }
+
+        // Generate handshake key
+        frame::uint32_converter conv;
+        unsigned char raw_key[16];
+
+        for (int i = 0; i < 4; i++) {
+            conv.i = m_rng();
+            std::copy(conv.c,conv.c+4,&raw_key[i*4]);
+        }
+
+        req.replace_header("Sec-WebSocket-Key",base64_encode(raw_key, 16));
+
+        return lib::error_code();
+    }
+
+    /// Validate the server's response to an outgoing handshake request
+    /**
+     * @param req The original request sent
+     * @param res The reponse to generate
+     * @return An error code, 0 on success, non-zero for other errors
+     */
+    lib::error_code validate_server_handshake_response(request_type const & req,
+        response_type& res) const
+    {
+        // A valid response has an HTTP 101 switching protocols code
+        if (res.get_status_code() != http::status_code::switching_protocols) {
+            return error::make_error_code(error::invalid_http_status);
+        }
+
+        // And the upgrade token in an upgrade header
+        std::string const & upgrade_header = res.get_header("Upgrade");
+        if (utility::ci_find_substr(upgrade_header, constants::upgrade_token,
+            sizeof(constants::upgrade_token)-1) == upgrade_header.end())
+        {
+            return error::make_error_code(error::missing_required_header);
+        }
+
+        // And the websocket token in the connection header
+        std::string const & con_header = res.get_header("Connection");
+        if (utility::ci_find_substr(con_header, constants::connection_token,
+            sizeof(constants::connection_token)-1) == con_header.end())
+        {
+            return error::make_error_code(error::missing_required_header);
+        }
+
+        // And has a valid Sec-WebSocket-Accept value
+        std::string key = req.get_header("Sec-WebSocket-Key");
+        lib::error_code ec = process_handshake_key(key);
+
+        if (ec || key != res.get_header("Sec-WebSocket-Accept")) {
+            return error::make_error_code(error::missing_required_header);
+        }
+
+        return lib::error_code();
+    }
+
+    std::string get_raw(response_type const & res) const {
+        return res.raw();
+    }
+
+    std::string const & get_origin(request_type const & r) const {
+        return r.get_header("Origin");
+    }
+
+    lib::error_code extract_subprotocols(request_type const & req,
+        std::vector<std::string> & subprotocol_list)
+    {
+        if (!req.get_header("Sec-WebSocket-Protocol").empty()) {
+            http::parameter_list p;
+
+             if (!req.get_header_as_plist("Sec-WebSocket-Protocol",p)) {
+                 http::parameter_list::const_iterator it;
+
+                 for (it = p.begin(); it != p.end(); ++it) {
+                     subprotocol_list.push_back(it->first);
+                 }
+             } else {
+                 return error::make_error_code(error::subprotocol_parse_error);
+             }
+        }
+        return lib::error_code();
+    }
+
+    uri_ptr get_uri(request_type const & request) const {
+        return get_uri_from_host(request,(base::m_secure ? "wss" : "ws"));
+    }
+
+    /// Process new websocket connection bytes
+    /**
+     *
+     * Hybi 13 data streams represent a series of variable length frames. Each
+     * frame is made up of a series of fixed length fields. The lengths of later
+     * fields are contained in earlier fields. The first field length is fixed
+     * by the spec.
+     *
+     * This processor represents a state machine that keeps track of what field
+     * is presently being read and how many more bytes are needed to complete it
+     *
+     *
+     *
+     *
+     * Read two header bytes
+     *   Extract full frame length.
+     *   Read extra header bytes
+     * Validate frame header (including extension validate)
+     * Read extension data into extension message state object
+     * Read payload data into payload
+     *
+     * @param buf Input buffer
+     *
+     * @param len Length of input buffer
+     *
+     * @return Number of bytes processed or zero on error
+     */
+    size_t consume(uint8_t * buf, size_t len, lib::error_code & ec) {
+        size_t p = 0;
+
+        ec = lib::error_code();
+
+        //std::cout << "consume: " << utility::to_hex(buf,len) << std::endl;
+
+        // Loop while we don't have a message ready and we still have bytes
+        // left to process.
+        while (m_state != READY && m_state != FATAL_ERROR &&
+               (p < len || m_bytes_needed == 0))
+        {
+            if (m_state == HEADER_BASIC) {
+                p += this->copy_basic_header_bytes(buf+p,len-p);
+
+                if (m_bytes_needed > 0) {
+                    continue;
+                }
+
+                ec = this->validate_incoming_basic_header(
+                    m_basic_header, base::m_server, !m_data_msg.msg_ptr
+                );
+                if (ec) {break;}
+
+                // extract full header size and adjust consume state accordingly
+                m_state = HEADER_EXTENDED;
+                m_cursor = 0;
+                m_bytes_needed = frame::get_header_len(m_basic_header) -
+                    frame::BASIC_HEADER_LENGTH;
+            } else if (m_state == HEADER_EXTENDED) {
+                p += this->copy_extended_header_bytes(buf+p,len-p);
+
+                if (m_bytes_needed > 0) {
+                    continue;
+                }
+
+                ec = validate_incoming_extended_header(m_basic_header,m_extended_header);
+                if (ec){break;}
+
+                m_state = APPLICATION;
+                m_bytes_needed = static_cast<size_t>(get_payload_size(m_basic_header,m_extended_header));
+
+                // check if this frame is the start of a new message and set up
+                // the appropriate message metadata.
+                frame::opcode::value op = frame::get_opcode(m_basic_header);
+
+                // TODO: get_message failure conditions
+
+                if (frame::opcode::is_control(op)) {
+                    m_control_msg = msg_metadata(
+                        m_msg_manager->get_message(op,m_bytes_needed),
+                        frame::get_masking_key(m_basic_header,m_extended_header)
+                    );
+
+                    m_current_msg = &m_control_msg;
+                } else {
+                    if (!m_data_msg.msg_ptr) {
+                        if (m_bytes_needed > base::m_max_message_size) {
+                            ec = make_error_code(error::message_too_big);
+                            break;
+                        }
+                        
+                        m_data_msg = msg_metadata(
+                            m_msg_manager->get_message(op,m_bytes_needed),
+                            frame::get_masking_key(m_basic_header,m_extended_header)
+                        );
+                    } else {
+                        // Fetch the underlying payload buffer from the data message we
+                        // are writing into.
+                        std::string & out = m_data_msg.msg_ptr->get_raw_payload();
+                        
+                        if (out.size() + m_bytes_needed > base::m_max_message_size) {
+                            ec = make_error_code(error::message_too_big);
+                            break;
+                        }
+                        
+                        // Each frame starts a new masking key. All other state
+                        // remains between frames.
+                        m_data_msg.prepared_key = prepare_masking_key(
+                            frame::get_masking_key(
+                                m_basic_header,
+                                m_extended_header
+                            )
+                        );
+                        
+                        out.reserve(out.size() + m_bytes_needed);
+                    }
+                    m_current_msg = &m_data_msg;
+                }
+            } else if (m_state == EXTENSION) {
+                m_state = APPLICATION;
+            } else if (m_state == APPLICATION) {
+                size_t bytes_to_process = (std::min)(m_bytes_needed,len-p);
+
+                if (bytes_to_process > 0) {
+                    p += this->process_payload_bytes(buf+p,bytes_to_process,ec);
+
+                    if (ec) {break;}
+                }
+
+                if (m_bytes_needed > 0) {
+                    continue;
+                }
+
+                // If this was the last frame in the message set the ready flag.
+                // Otherwise, reset processor state to read additional frames.
+                if (frame::get_fin(m_basic_header)) {
+                    // ensure that text messages end on a valid UTF8 code point
+                    if (frame::get_opcode(m_basic_header) == frame::opcode::TEXT) {
+                        if (!m_current_msg->validator.complete()) {
+                            ec = make_error_code(error::invalid_utf8);
+                            break;
+                        }
+                    }
+
+                    m_state = READY;
+                } else {
+                    this->reset_headers();
+                }
+            } else {
+                // shouldn't be here
+                ec = make_error_code(error::general);
+                return 0;
+            }
+        }
+
+        return p;
+    }
+
+    void reset_headers() {
+        m_state = HEADER_BASIC;
+        m_bytes_needed = frame::BASIC_HEADER_LENGTH;
+
+        m_basic_header.b0 = 0x00;
+        m_basic_header.b1 = 0x00;
+
+        std::fill_n(
+            m_extended_header.bytes,
+            frame::MAX_EXTENDED_HEADER_LENGTH,
+            0x00
+        );
+    }
+
+    /// Test whether or not the processor has a message ready
+    bool ready() const {
+        return (m_state == READY);
+    }
+
+    message_ptr get_message() {
+        if (!ready()) {
+            return message_ptr();
+        }
+        message_ptr ret = m_current_msg->msg_ptr;
+        m_current_msg->msg_ptr.reset();
+
+        if (frame::opcode::is_control(ret->get_opcode())) {
+            m_control_msg.msg_ptr.reset();
+        } else {
+            m_data_msg.msg_ptr.reset();
+        }
+
+        this->reset_headers();
+
+        return ret;
+    }
+
+    /// Test whether or not the processor is in a fatal error state.
+    bool get_error() const {
+        return m_state == FATAL_ERROR;
+    }
+
+    size_t get_bytes_needed() const {
+        return m_bytes_needed;
+    }
+
+    /// Prepare a user data message for writing
+    /**
+     * Performs validation, masking, compression, etc. will return an error if
+     * there was an error, otherwise msg will be ready to be written
+     *
+     * By default WebSocket++ performs block masking/unmasking in a manner that
+     * makes assumptions about the nature of the machine and STL library used.
+     * In particular the assumption is either a 32 or 64 bit word size and an
+     * STL with std::string::data returning a contiguous char array.
+     *
+     * This method improves masking performance by 3-8x depending on the ratio
+     * of small to large messages and the availability of a 64 bit processor.
+     *
+     * To disable this optimization (for use with alternative STL
+     * implementations or processors) define WEBSOCKETPP_STRICT_MASKING when
+     * compiling the library. This will force the library to perform masking in
+     * single byte chunks.
+     *
+     * TODO: tests
+     *
+     * @param in An unprepared message to prepare
+     * @param out A message to be overwritten with the prepared message
+     * @return error code
+     */
+    virtual lib::error_code prepare_data_frame(message_ptr in, message_ptr out)
+    {
+        if (!in || !out) {
+            return make_error_code(error::invalid_arguments);
+        }
+
+        frame::opcode::value op = in->get_opcode();
+
+        // validate opcode: only regular data frames
+        if (frame::opcode::is_control(op)) {
+            return make_error_code(error::invalid_opcode);
+        }
+
+        std::string& i = in->get_raw_payload();
+        std::string& o = out->get_raw_payload();
+
+        // validate payload utf8
+        if (op == frame::opcode::TEXT && !utf8_validator::validate(i)) {
+            return make_error_code(error::invalid_payload);
+        }
+
+        frame::masking_key_type key;
+        bool masked = !base::m_server;
+        bool compressed = m_permessage_deflate.is_enabled()
+                          && in->get_compressed();
+        bool fin = in->get_fin();
+
+        // generate header
+        frame::basic_header h(op,i.size(),fin,masked,compressed);
+
+        if (masked) {
+            // Generate masking key.
+            key.i = m_rng();
+
+            frame::extended_header e(i.size(),key.i);
+            out->set_header(frame::prepare_header(h,e));
+        } else {
+            frame::extended_header e(i.size());
+            out->set_header(frame::prepare_header(h,e));
+        }
+
+        // prepare payload
+        if (compressed) {
+            // compress and store in o after header.
+            m_permessage_deflate.compress(i,o);
+
+            // mask in place if necessary
+            if (masked) {
+                this->masked_copy(o,o,key);
+            }
+        } else {
+            // no compression, just copy data into the output buffer
+            o.resize(i.size());
+
+            // if we are masked, have the masking function write to the output
+            // buffer directly to avoid another copy. If not masked, copy
+            // directly without masking.
+            if (masked) {
+                this->masked_copy(i,o,key);
+            } else {
+                std::copy(i.begin(),i.end(),o.begin());
+            }
+        }
+
+        out->set_prepared(true);
+        out->set_opcode(op);
+
+        return lib::error_code();
+    }
+
+    /// Get URI
+    lib::error_code prepare_ping(std::string const & in, message_ptr out) const {
+        return this->prepare_control(frame::opcode::PING,in,out);
+    }
+
+    lib::error_code prepare_pong(std::string const & in, message_ptr out) const {
+        return this->prepare_control(frame::opcode::PONG,in,out);
+    }
+
+    virtual lib::error_code prepare_close(close::status::value code,
+        std::string const & reason, message_ptr out) const
+    {
+        if (close::status::reserved(code)) {
+            return make_error_code(error::reserved_close_code);
+        }
+
+        if (close::status::invalid(code) && code != close::status::no_status) {
+            return make_error_code(error::invalid_close_code);
+        }
+
+        if (code == close::status::no_status && reason.size() > 0) {
+            return make_error_code(error::reason_requires_code);
+        }
+
+        if (reason.size() > frame:: limits::payload_size_basic-2) {
+            return make_error_code(error::control_too_big);
+        }
+
+        std::string payload;
+
+        if (code != close::status::no_status) {
+            close::code_converter val;
+            val.i = htons(code);
+
+            payload.resize(reason.size()+2);
+
+            payload[0] = val.c[0];
+            payload[1] = val.c[1];
+
+            std::copy(reason.begin(),reason.end(),payload.begin()+2);
+        }
+
+        return this->prepare_control(frame::opcode::CLOSE,payload,out);
+    }
+protected:
+    /// Convert a client handshake key into a server response key in place
+    lib::error_code process_handshake_key(std::string & key) const {
+        key.append(constants::handshake_guid);
+
+        unsigned char message_digest[20];
+        sha1::calc(key.c_str(),key.length(),message_digest);
+        key = base64_encode(message_digest,20);
+
+        return lib::error_code();
+    }
+
+    /// Reads bytes from buf into m_basic_header
+    size_t copy_basic_header_bytes(uint8_t const * buf, size_t len) {
+        if (len == 0 || m_bytes_needed == 0) {
+            return 0;
+        }
+
+        if (len > 1) {
+            // have at least two bytes
+            if (m_bytes_needed == 2) {
+                m_basic_header.b0 = buf[0];
+                m_basic_header.b1 = buf[1];
+                m_bytes_needed -= 2;
+                return 2;
+            } else {
+                m_basic_header.b1 = buf[0];
+                m_bytes_needed--;
+                return 1;
+            }
+        } else {
+            // have exactly one byte
+            if (m_bytes_needed == 2) {
+                m_basic_header.b0 = buf[0];
+                m_bytes_needed--;
+                return 1;
+            } else {
+                m_basic_header.b1 = buf[0];
+                m_bytes_needed--;
+                return 1;
+            }
+        }
+    }
+
+    /// Reads bytes from buf into m_extended_header
+    size_t copy_extended_header_bytes(uint8_t const * buf, size_t len) {
+        size_t bytes_to_read = (std::min)(m_bytes_needed,len);
+
+        std::copy(buf,buf+bytes_to_read,m_extended_header.bytes+m_cursor);
+        m_cursor += bytes_to_read;
+        m_bytes_needed -= bytes_to_read;
+
+        return bytes_to_read;
+    }
+
+    /// Reads bytes from buf into message payload
+    /**
+     * This function performs unmasking and uncompression, validates the
+     * decoded bytes, and writes them to the appropriate message buffer.
+     *
+     * This member function will use the input buffer as stratch space for its
+     * work. The raw input bytes will not be preserved. This applies only to the
+     * bytes actually needed. At most min(m_bytes_needed,len) will be processed.
+     *
+     * @param buf Input/working buffer
+     * @param len Length of buf
+     * @return Number of bytes processed or zero in case of an error
+     */
+    size_t process_payload_bytes(uint8_t * buf, size_t len, lib::error_code& ec)
+    {
+        // unmask if masked
+        if (frame::get_masked(m_basic_header)) {
+            #ifdef WEBSOCKETPP_STRICT_MASKING
+                m_current_msg->prepared_key = frame::byte_mask_circ(
+                    buf,
+                    len,
+                    m_current_msg->prepared_key
+                );
+            #else
+                m_current_msg->prepared_key = frame::word_mask_circ(
+                    buf,
+                    len,
+                    m_current_msg->prepared_key
+                );
+            #endif
+        }
+
+        std::string & out = m_current_msg->msg_ptr->get_raw_payload();
+        size_t offset = out.size();
+
+        // decompress message if needed.
+        if (m_permessage_deflate.is_enabled()
+            && frame::get_rsv1(m_basic_header))
+        {
+            // Decompress current buffer into the message buffer
+            m_permessage_deflate.decompress(buf,len,out);
+
+            // get the length of the newly uncompressed output
+            offset = out.size() - offset;
+        } else {
+            // No compression, straight copy
+            out.append(reinterpret_cast<char *>(buf),len);
+        }
+
+        // validate unmasked, decompressed values
+        if (m_current_msg->msg_ptr->get_opcode() == frame::opcode::TEXT) {
+            if (!m_current_msg->validator.decode(out.begin()+offset,out.end())) {
+                ec = make_error_code(error::invalid_utf8);
+                return 0;
+            }
+        }
+
+        m_bytes_needed -= len;
+
+        return len;
+    }
+
+    /// Validate an incoming basic header
+    /**
+     * Validates an incoming hybi13 basic header.
+     *
+     * @param h The basic header to validate
+     * @param is_server Whether or not the endpoint that received this frame
+     * is a server.
+     * @param new_msg Whether or not this is the first frame of the message
+     * @return 0 on success or a non-zero error code on failure
+     */
+    lib::error_code validate_incoming_basic_header(frame::basic_header const & h,
+        bool is_server, bool new_msg) const
+    {
+        frame::opcode::value op = frame::get_opcode(h);
+
+        // Check control frame size limit
+        if (frame::opcode::is_control(op) &&
+            frame::get_basic_size(h) > frame::limits::payload_size_basic)
+        {
+            return make_error_code(error::control_too_big);
+        }
+
+        // Check that RSV bits are clear
+        // The only RSV bits allowed are rsv1 if the permessage_compress
+        // extension is enabled for this connection and the message is not
+        // a control message.
+        //
+        // TODO: unit tests for this
+        if (frame::get_rsv1(h) && (!m_permessage_deflate.is_enabled()
+                || frame::opcode::is_control(op)))
+        {
+            return make_error_code(error::invalid_rsv_bit);
+        }
+
+        if (frame::get_rsv2(h) || frame::get_rsv3(h)) {
+            return make_error_code(error::invalid_rsv_bit);
+        }
+
+        // Check for reserved opcodes
+        if (frame::opcode::reserved(op)) {
+            return make_error_code(error::invalid_opcode);
+        }
+
+        // Check for invalid opcodes
+        // TODO: unit tests for this?
+        if (frame::opcode::invalid(op)) {
+            return make_error_code(error::invalid_opcode);
+        }
+
+        // Check for fragmented control message
+        if (frame::opcode::is_control(op) && !frame::get_fin(h)) {
+            return make_error_code(error::fragmented_control);
+        }
+
+        // Check for continuation without an active message
+        if (new_msg && op == frame::opcode::CONTINUATION) {
+            return make_error_code(error::invalid_continuation);
+        }
+
+        // Check for new data frame when expecting continuation
+        if (!new_msg && !frame::opcode::is_control(op) &&
+            op != frame::opcode::CONTINUATION)
+        {
+            return make_error_code(error::invalid_continuation);
+        }
+
+        // Servers should reject any unmasked frames from clients.
+        // Clients should reject any masked frames from servers.
+        if (is_server && !frame::get_masked(h)) {
+            return make_error_code(error::masking_required);
+        } else if (!is_server && frame::get_masked(h)) {
+            return make_error_code(error::masking_forbidden);
+        }
+
+        return lib::error_code();
+    }
+
+    /// Validate an incoming extended header
+    /**
+     * Validates an incoming hybi13 full header.
+     *
+     * @todo unit test for the >32 bit frames on 32 bit systems case
+     *
+     * @param h The basic header to validate
+     * @param e The extended header to validate
+     * @return An error_code, non-zero values indicate why the validation
+     * failed
+     */
+    lib::error_code validate_incoming_extended_header(frame::basic_header h,
+        frame::extended_header e) const
+    {
+        uint8_t basic_size = frame::get_basic_size(h);
+        uint64_t payload_size = frame::get_payload_size(h,e);
+
+        // Check for non-minimally encoded payloads
+        if (basic_size == frame::payload_size_code_16bit &&
+            payload_size <= frame::limits::payload_size_basic)
+        {
+            return make_error_code(error::non_minimal_encoding);
+        }
+
+        if (basic_size == frame::payload_size_code_64bit &&
+            payload_size <= frame::limits::payload_size_extended)
+        {
+            return make_error_code(error::non_minimal_encoding);
+        }
+
+        // Check for >32bit frames on 32 bit systems
+        if (sizeof(size_t) == 4 && (payload_size >> 32)) {
+            return make_error_code(error::requires_64bit);
+        }
+
+        return lib::error_code();
+    }
+
+    /// Copy and mask/unmask in one operation
+    /**
+     * Reads input from one string and writes unmasked output to another.
+     *
+     * @param [in] i The input string.
+     * @param [out] o The output string.
+     * @param [in] key The masking key to use for masking/unmasking
+     */
+    void masked_copy (std::string const & i, std::string & o,
+        frame::masking_key_type key) const
+    {
+        #ifdef WEBSOCKETPP_STRICT_MASKING
+            frame::byte_mask(i.begin(),i.end(),o.begin(),key);
+        #else
+            websocketpp::frame::word_mask_exact(
+                reinterpret_cast<uint8_t *>(const_cast<char *>(i.data())),
+                reinterpret_cast<uint8_t *>(const_cast<char *>(o.data())),
+                i.size(),
+                key
+            );
+        #endif
+    }
+
+    /// Generic prepare control frame with opcode and payload.
+    /**
+     * Internal control frame building method. Handles validation, masking, etc
+     *
+     * @param op The control opcode to use
+     * @param payload The payload to use
+     * @param out The message buffer to store the prepared frame in
+     * @return Status code, zero on success, non-zero on error
+     */
+    lib::error_code prepare_control(frame::opcode::value op,
+        std::string const & payload, message_ptr out) const
+    {
+        if (!out) {
+            return make_error_code(error::invalid_arguments);
+        }
+
+        if (!frame::opcode::is_control(op)) {
+            return make_error_code(error::invalid_opcode);
+        }
+
+        if (payload.size() > frame::limits::payload_size_basic) {
+            return make_error_code(error::control_too_big);
+        }
+
+        frame::masking_key_type key;
+        bool masked = !base::m_server;
+
+        frame::basic_header h(op,payload.size(),true,masked);
+
+        std::string & o = out->get_raw_payload();
+        o.resize(payload.size());
+
+        if (masked) {
+            // Generate masking key.
+            key.i = m_rng();
+
+            frame::extended_header e(payload.size(),key.i);
+            out->set_header(frame::prepare_header(h,e));
+            this->masked_copy(payload,o,key);
+        } else {
+            frame::extended_header e(payload.size());
+            out->set_header(frame::prepare_header(h,e));
+            std::copy(payload.begin(),payload.end(),o.begin());
+        }
+
+        out->set_prepared(true);
+
+        return lib::error_code();
+    }
+
+    enum state {
+        HEADER_BASIC = 0,
+        HEADER_EXTENDED = 1,
+        EXTENSION = 2,
+        APPLICATION = 3,
+        READY = 4,
+        FATAL_ERROR = 5
+    };
+
+    /// This data structure holds data related to processing a message, such as
+    /// the buffer it is being written to, its masking key, its UTF8 validation
+    /// state, and sometimes its compression state.
+    struct msg_metadata {
+        msg_metadata() {}
+        msg_metadata(message_ptr m, size_t p) : msg_ptr(m),prepared_key(p) {}
+        msg_metadata(message_ptr m, frame::masking_key_type p)
+          : msg_ptr(m)
+          , prepared_key(prepare_masking_key(p)) {}
+
+        message_ptr msg_ptr;        // pointer to the message data buffer
+        size_t      prepared_key;   // prepared masking key
+        utf8_validator::validator validator; // utf8 validation state
+    };
+
+    // Basic header of the frame being read
+    frame::basic_header m_basic_header;
+
+    // Pointer to a manager that can create message buffers for us.
+    msg_manager_ptr m_msg_manager;
+
+    // Number of bytes needed to complete the current operation
+    size_t m_bytes_needed;
+
+    // Number of extended header bytes read
+    size_t m_cursor;
+
+    // Metadata for the current data msg
+    msg_metadata m_data_msg;
+    // Metadata for the current control msg
+    msg_metadata m_control_msg;
+
+    // Pointer to the metadata associated with the frame being read
+    msg_metadata * m_current_msg;
+
+    // Extended header of current frame
+    frame::extended_header m_extended_header;
+
+    rng_type & m_rng;
+
+    // Overall state of the processor
+    state m_state;
+
+    // Extensions
+    permessage_deflate_type m_permessage_deflate;
+};
+
+} // namespace processor
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_PROCESSOR_HYBI13_HPP
diff --git a/extlibs/websocketpp/websocketpp/processors/processor.hpp b/extlibs/websocketpp/websocketpp/processors/processor.hpp
new file mode 100644
index 000000000..99b64cae8
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/processors/processor.hpp
@@ -0,0 +1,392 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_PROCESSOR_HPP
+#define WEBSOCKETPP_PROCESSOR_HPP
+
+#include <websocketpp/processors/base.hpp>
+#include <websocketpp/common/system_error.hpp>
+
+#include <websocketpp/close.hpp>
+#include <websocketpp/utilities.hpp>
+#include <websocketpp/uri.hpp>
+
+#include <sstream>
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace websocketpp {
+/// Processors encapsulate the protocol rules specific to each WebSocket version
+/**
+ * The processors namespace includes a number of free functions that operate on
+ * various WebSocket related data structures and perform processing that is not
+ * related to specific versions of the protocol.
+ *
+ * It also includes the abstract interface for the protocol specific processing
+ * engines. These engines wrap all of the logic necessary for parsing and
+ * validating WebSocket handshakes and messages of specific protocol version
+ * and set of allowed extensions.
+ *
+ * An instance of a processor represents the state of a single WebSocket
+ * connection of the associated version. One processor instance is needed per
+ * logical WebSocket connection.
+ */
+namespace processor {
+
+/// Determine whether or not a generic HTTP request is a WebSocket handshake
+/**
+ * @param r The HTTP request to read.
+ *
+ * @return True if the request is a WebSocket handshake, false otherwise
+ */
+template <typename request_type>
+bool is_websocket_handshake(request_type& r) {
+    using utility::ci_find_substr;
+
+    std::string const & upgrade_header = r.get_header("Upgrade");
+
+    if (ci_find_substr(upgrade_header, constants::upgrade_token,
+        sizeof(constants::upgrade_token)-1) == upgrade_header.end())
+    {
+        return false;
+    }
+
+    std::string const & con_header = r.get_header("Connection");
+
+    if (ci_find_substr(con_header, constants::connection_token,
+        sizeof(constants::connection_token)-1) == con_header.end())
+    {
+        return false;
+    }
+
+    return true;
+}
+
+/// Extract the version from a WebSocket handshake request
+/**
+ * A blank version header indicates a spec before versions were introduced.
+ * The only such versions in shipping products are Hixie Draft 75 and Hixie
+ * Draft 76. Draft 75 is present in Chrome 4-5 and Safari 5.0.0, Draft 76 (also
+ * known as hybi 00 is present in Chrome 6-13 and Safari 5.0.1+. As
+ * differentiating between these two sets of browsers is very difficult and
+ * Safari 5.0.1+ accounts for the vast majority of cases in the wild this
+ * function assumes that all handshakes without a valid version header are
+ * Hybi 00.
+ *
+ * @param r The WebSocket handshake request to read.
+ *
+ * @return The WebSocket handshake version or -1 if there was an extraction
+ * error.
+ */
+template <typename request_type>
+int get_websocket_version(request_type& r) {
+    if (!r.ready()) {
+        return -2;
+    }
+    
+    if (r.get_header("Sec-WebSocket-Version") == "") {
+        return 0;
+    }
+
+    int version;
+    std::istringstream ss(r.get_header("Sec-WebSocket-Version"));
+
+    if ((ss >> version).fail()) {
+        return -1;
+    }
+
+    return version;
+}
+
+/// Extract a URI ptr from the host header of the request
+/**
+ * @param request The request to extract the Host header from.
+ *
+ * @param scheme The scheme under which this request was received (ws, wss,
+ * http, https, etc)
+ *
+ * @return A uri_pointer that encodes the value of the host header.
+ */
+template <typename request_type>
+uri_ptr get_uri_from_host(request_type & request, std::string scheme) {
+    std::string h = request.get_header("Host");
+
+    size_t last_colon = h.rfind(":");
+    size_t last_sbrace = h.rfind("]");
+
+    // no : = hostname with no port
+    // last : before ] = ipv6 literal with no port
+    // : with no ] = hostname with port
+    // : after ] = ipv6 literal with port
+    if (last_colon == std::string::npos ||
+        (last_sbrace != std::string::npos && last_sbrace > last_colon))
+    {
+        return lib::make_shared<uri>(scheme, h, request.get_uri());
+    } else {
+        return lib::make_shared<uri>(scheme,
+                               h.substr(0,last_colon),
+                               h.substr(last_colon+1),
+                               request.get_uri());
+    }
+}
+
+/// WebSocket protocol processor abstract base class
+template <typename config>
+class processor {
+public:
+    typedef processor<config> type;
+    typedef typename config::request_type request_type;
+    typedef typename config::response_type response_type;
+    typedef typename config::message_type::ptr message_ptr;
+    typedef std::pair<lib::error_code,std::string> err_str_pair;
+
+    explicit processor(bool secure, bool p_is_server)
+      : m_secure(secure)
+      , m_server(p_is_server)
+      , m_max_message_size(config::max_message_size)
+    {}
+
+    virtual ~processor() {}
+
+    /// Get the protocol version of this processor
+    virtual int get_version() const = 0;
+
+    /// Get maximum message size
+    /**
+     * Get maximum message size. Maximum message size determines the point at which the
+     * processor will fail a connection with the message_too_big protocol error.
+     *
+     * The default is retrieved from the max_message_size value from the template config
+     *
+     * @since 0.3.0
+     */
+    size_t get_max_message_size() const {
+        return m_max_message_size;
+    }
+    
+    /// Set maximum message size
+    /**
+     * Set maximum message size. Maximum message size determines the point at which the
+     * processor will fail a connection with the message_too_big protocol error.
+     *
+     * The default is retrieved from the max_message_size value from the template config
+     *
+     * @since 0.3.0
+     *
+     * @param new_value The value to set as the maximum message size.
+     */
+    void set_max_message_size(size_t new_value) {
+        m_max_message_size = new_value;
+    }
+
+    /// Returns whether or not the permessage_compress extension is implemented
+    /**
+     * Compile time flag that indicates whether this processor has implemented
+     * the permessage_compress extension. By default this is false.
+     */
+    virtual bool has_permessage_compress() const {
+        return false;
+    }
+
+    /// Initializes extensions based on the Sec-WebSocket-Extensions header
+    /**
+     * Reads the Sec-WebSocket-Extensions header and determines if any of the
+     * requested extensions are supported by this processor. If they are their
+     * settings data is initialized.
+     *
+     * @param request The request headers to look at.
+     */
+    virtual err_str_pair negotiate_extensions(request_type const &) {
+        return err_str_pair();
+    }
+
+    /// validate a WebSocket handshake request for this version
+    /**
+     * @param request The WebSocket handshake request to validate.
+     * is_websocket_handshake(request) must be true and
+     * get_websocket_version(request) must equal this->get_version().
+     *
+     * @return A status code, 0 on success, non-zero for specific sorts of
+     * failure
+     */
+    virtual lib::error_code validate_handshake(request_type const & request) const = 0;
+
+    /// Calculate the appropriate response for this websocket request
+    /**
+     * @param req The request to process
+     *
+     * @param subprotocol The subprotocol in use
+     *
+     * @param res The response to store the processed response in
+     *
+     * @return An error code, 0 on success, non-zero for other errors
+     */
+    virtual lib::error_code process_handshake(request_type const & req,
+        std::string const & subprotocol, response_type& res) const = 0;
+
+    /// Fill in an HTTP request for an outgoing connection handshake
+    /**
+     * @param req The request to process.
+     *
+     * @return An error code, 0 on success, non-zero for other errors
+     */
+    virtual lib::error_code client_handshake_request(request_type & req,
+        uri_ptr uri, std::vector<std::string> const & subprotocols) const = 0;
+
+    /// Validate the server's response to an outgoing handshake request
+    /**
+     * @param req The original request sent
+     * @param res The reponse to generate
+     * @return An error code, 0 on success, non-zero for other errors
+     */
+    virtual lib::error_code validate_server_handshake_response(request_type
+        const & req, response_type & res) const = 0;
+
+    /// Given a completed response, get the raw bytes to put on the wire
+    virtual std::string get_raw(response_type const & request) const = 0;
+
+    /// Return the value of the header containing the CORS origin.
+    virtual std::string const & get_origin(request_type const & request) const = 0;
+
+    /// Extracts requested subprotocols from a handshake request
+    /**
+     * Extracts a list of all subprotocols that the client has requested in the
+     * given opening handshake request.
+     *
+     * @param [in] req The request to extract from
+     * @param [out] subprotocol_list A reference to a vector of strings to store
+     * the results in.
+     */
+    virtual lib::error_code extract_subprotocols(const request_type & req,
+        std::vector<std::string> & subprotocol_list) = 0;
+
+    /// Extracts client uri from a handshake request
+    virtual uri_ptr get_uri(request_type const & request) const = 0;
+
+    /// process new websocket connection bytes
+    /**
+     * WebSocket connections are a continous stream of bytes that must be
+     * interpreted by a protocol processor into discrete frames.
+     *
+     * @param buf Buffer from which bytes should be read.
+     * @param len Length of buffer
+     * @param ec Reference to an error code to return any errors in
+     * @return Number of bytes processed
+     */
+    virtual size_t consume(uint8_t *buf, size_t len, lib::error_code & ec) = 0;
+
+    /// Checks if there is a message ready
+    /**
+     * Checks if the most recent consume operation processed enough bytes to
+     * complete a new WebSocket message. The message can be retrieved by calling
+     * get_message() which will reset the internal state to not-ready and allow
+     * consume to read more bytes.
+     *
+     * @return Whether or not a message is ready.
+     */
+    virtual bool ready() const = 0;
+
+    /// Retrieves the most recently processed message
+    /**
+     * Retrieves a shared pointer to the recently completed message if there is
+     * one. If ready() returns true then there is a message available.
+     * Retrieving the message with get_message will reset the state of ready.
+     * As such, each new message may be retrieved only once. Calling get_message
+     * when there is no message available will result in a null pointer being
+     * returned.
+     *
+     * @return A pointer to the most recently processed message or a null shared
+     *         pointer.
+     */
+    virtual message_ptr get_message() = 0;
+
+    /// Tests whether the processor is in a fatal error state
+    virtual bool get_error() const = 0;
+
+    /// Retrieves the number of bytes presently needed by the processor
+    /// This value may be used as a hint to the transport layer as to how many
+    /// bytes to wait for before running consume again.
+    virtual size_t get_bytes_needed() const {
+        return 1;
+    }
+
+    /// Prepare a data message for writing
+    /**
+     * Performs validation, masking, compression, etc. will return an error if
+     * there was an error, otherwise msg will be ready to be written
+     */
+    virtual lib::error_code prepare_data_frame(message_ptr in, message_ptr out) = 0;
+
+    /// Prepare a ping frame
+    /**
+     * Ping preparation is entirely state free. There is no payload validation
+     * other than length. Payload need not be UTF-8.
+     *
+     * @param in The string to use for the ping payload
+     * @param out The message buffer to prepare the ping in.
+     * @return Status code, zero on success, non-zero on failure
+     */
+    virtual lib::error_code prepare_ping(std::string const & in, message_ptr out) const 
+        = 0;
+
+    /// Prepare a pong frame
+    /**
+     * Pong preparation is entirely state free. There is no payload validation
+     * other than length. Payload need not be UTF-8.
+     *
+     * @param in The string to use for the pong payload
+     * @param out The message buffer to prepare the pong in.
+     * @return Status code, zero on success, non-zero on failure
+     */
+    virtual lib::error_code prepare_pong(std::string const & in, message_ptr out) const 
+        = 0;
+
+    /// Prepare a close frame
+    /**
+     * Close preparation is entirely state free. The code and reason are both
+     * subject to validation. Reason must be valid UTF-8. Code must be a valid
+     * un-reserved WebSocket close code. Use close::status::no_status to
+     * indicate no code. If no code is supplied a reason may not be specified.
+     *
+     * @param code The close code to send
+     * @param reason The reason string to send
+     * @param out The message buffer to prepare the fame in
+     * @return Status code, zero on success, non-zero on failure
+     */
+    virtual lib::error_code prepare_close(close::status::value code,
+        std::string const & reason, message_ptr out) const = 0;
+protected:
+    bool const m_secure;
+    bool const m_server;
+    size_t m_max_message_size;
+};
+
+} // namespace processor
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_PROCESSOR_HPP
diff --git a/extlibs/websocketpp/websocketpp/random/none.hpp b/extlibs/websocketpp/websocketpp/random/none.hpp
new file mode 100644
index 000000000..2163e6f4a
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/random/none.hpp
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_RANDOM_NONE_HPP
+#define WEBSOCKETPP_RANDOM_NONE_HPP
+
+namespace websocketpp {
+/// Random number generation policies
+namespace random {
+/// Stub RNG policy that always returns 0
+namespace none {
+
+/// Thread safe stub "random" integer generator.
+/**
+ * This template class provides a random integer stub. The interface mimics the
+ * WebSocket++ RNG generator classes but the generater function always returns
+ * zero. This can be used to stub out the RNG for unit and performance testing.
+ *
+ * Call operator() to generate the next number
+ */
+template <typename int_type>
+class int_generator {
+    public:
+        int_generator() {}
+
+        /// advances the engine's state and returns the generated value
+        int_type operator()() {
+            return 0;
+        }
+};
+
+} // namespace none
+} // namespace random
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_RANDOM_NONE_HPP
diff --git a/extlibs/websocketpp/websocketpp/random/random_device.hpp b/extlibs/websocketpp/websocketpp/random/random_device.hpp
new file mode 100644
index 000000000..91e7dd162
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/random/random_device.hpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_RANDOM_RANDOM_DEVICE_HPP
+#define WEBSOCKETPP_RANDOM_RANDOM_DEVICE_HPP
+
+#include <websocketpp/common/random.hpp>
+
+namespace websocketpp {
+namespace random {
+/// RNG policy based on std::random_device or boost::random_device
+namespace random_device {
+
+/// Thread safe non-deterministic random integer generator.
+/**
+ * This template class provides thread safe non-deterministic random integer
+ * generation. Numbers are produced in a uniformly distributed range from the
+ * smallest to largest value that int_type can store.
+ *
+ * Thread-safety is provided via locking based on the concurrency template
+ * parameter.
+ *
+ * Non-deterministic RNG is provided via websocketpp::lib which uses either
+ * C++11 or Boost 1.47+'s random_device class.
+ *
+ * Call operator() to generate the next number
+ */
+template <typename int_type, typename concurrency>
+class int_generator {
+    public:
+        typedef typename concurrency::scoped_lock_type scoped_lock_type;
+        typedef typename concurrency::mutex_type mutex_type;
+
+        /// constructor
+        //mac TODO: figure out if signed types present a range problem
+        int_generator() {}
+
+        /// advances the engine's state and returns the generated value
+        int_type operator()() {
+            scoped_lock_type guard(m_lock);
+            return m_dis(m_rng);
+        }
+    private:
+
+
+        lib::random_device m_rng;
+        lib::uniform_int_distribution<int_type> m_dis;
+
+        mutex_type m_lock;
+};
+
+} // namespace random_device
+} // namespace random
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_RANDOM_RANDOM_DEVICE_HPP
diff --git a/extlibs/websocketpp/websocketpp/roles/client_endpoint.hpp b/extlibs/websocketpp/websocketpp/roles/client_endpoint.hpp
new file mode 100644
index 000000000..d5a9f0038
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/roles/client_endpoint.hpp
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_CLIENT_ENDPOINT_HPP
+#define WEBSOCKETPP_CLIENT_ENDPOINT_HPP
+
+#include <websocketpp/endpoint.hpp>
+
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/common/system_error.hpp>
+
+#include <string>
+
+namespace websocketpp {
+
+/// Client endpoint role based on the given config
+/**
+ *
+ */
+template <typename config>
+class client : public endpoint<connection<config>,config> {
+public:
+    /// Type of this endpoint
+    typedef client<config> type;
+
+    /// Type of the endpoint concurrency component
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of the endpoint transport component
+    typedef typename config::transport_type transport_type;
+
+    /// Type of the connections this server will create
+    typedef connection<config> connection_type;
+    /// Type of a shared pointer to the connections this server will create
+    typedef typename connection_type::ptr connection_ptr;
+
+    /// Type of the connection transport component
+    typedef typename transport_type::transport_con_type transport_con_type;
+    /// Type of a shared pointer to the connection transport component
+    typedef typename transport_con_type::ptr transport_con_ptr;
+
+    /// Type of the endpoint component of this server
+    typedef endpoint<connection_type,config> endpoint_type;
+
+    explicit client() : endpoint_type(false)
+    {
+        endpoint_type::m_alog.write(log::alevel::devel, "client constructor");
+    }
+
+    /// Get a new connection
+    /**
+     * Creates and returns a pointer to a new connection to the given URI
+     * suitable for passing to connect(connection_ptr). This method allows
+     * applying connection specific settings before performing the opening
+     * handshake.
+     *
+     * @param [in] location URI to open the connection to as a uri_ptr
+     * @param [out] ec An status code indicating failure reasons, if any
+     *
+     * @return A connection_ptr to the new connection
+     */
+    connection_ptr get_connection(uri_ptr location, lib::error_code & ec) {
+        if (location->get_secure() && !transport_type::is_secure()) {
+            ec = error::make_error_code(error::endpoint_not_secure);
+            return connection_ptr();
+        }
+
+        connection_ptr con = endpoint_type::create_connection();
+
+        if (!con) {
+            ec = error::make_error_code(error::con_creation_failed);
+            return con;
+        }
+
+        con->set_uri(location);
+
+        ec = lib::error_code();
+        return con;
+    }
+
+    /// Get a new connection (string version)
+    /**
+     * Creates and returns a pointer to a new connection to the given URI
+     * suitable for passing to connect(connection_ptr). This overload allows
+     * default construction of the uri_ptr from a standard string.
+     *
+     * @param [in] u URI to open the connection to as a string
+     * @param [out] ec An status code indicating failure reasons, if any
+     *
+     * @return A connection_ptr to the new connection
+     */
+    connection_ptr get_connection(std::string const & u, lib::error_code & ec) {
+        uri_ptr location = lib::make_shared<uri>(u);
+
+        if (!location->get_valid()) {
+            ec = error::make_error_code(error::invalid_uri);
+            return connection_ptr();
+        }
+
+        return get_connection(location, ec);
+    }
+
+    /// Begin the connection process for the given connection
+    /**
+     * Initiates the opening connection handshake for connection con. Exact
+     * behavior depends on the underlying transport policy.
+     *
+     * @param con The connection to connect
+     *
+     * @return The pointer to the connection originally passed in.
+     */
+    connection_ptr connect(connection_ptr con) {
+        // Ask transport to perform a connection
+        transport_type::async_connect(
+            lib::static_pointer_cast<transport_con_type>(con),
+            con->get_uri(),
+            lib::bind(
+                &type::handle_connect,
+                this,
+                con,
+                lib::placeholders::_1
+            )
+        );
+
+        return con;
+    }
+private:
+    // handle_connect
+    void handle_connect(connection_ptr con, lib::error_code const & ec) {
+        if (ec) {
+            con->terminate(ec);
+
+            endpoint_type::m_elog.write(log::elevel::rerror,
+                    "handle_connect error: "+ec.message());
+        } else {
+            endpoint_type::m_alog.write(log::alevel::connect,
+                "Successful connection");
+
+            con->start();
+        }
+    }
+};
+
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_CLIENT_ENDPOINT_HPP
diff --git a/extlibs/websocketpp/websocketpp/roles/server_endpoint.hpp b/extlibs/websocketpp/websocketpp/roles/server_endpoint.hpp
new file mode 100644
index 000000000..45a4bef9e
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/roles/server_endpoint.hpp
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_SERVER_ENDPOINT_HPP
+#define WEBSOCKETPP_SERVER_ENDPOINT_HPP
+
+#include <websocketpp/endpoint.hpp>
+
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/common/system_error.hpp>
+
+namespace websocketpp {
+
+/// Server endpoint role based on the given config
+/**
+ *
+ */
+template <typename config>
+class server : public endpoint<connection<config>,config> {
+public:
+    /// Type of this endpoint
+    typedef server<config> type;
+
+    /// Type of the endpoint concurrency component
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of the endpoint transport component
+    typedef typename config::transport_type transport_type;
+
+    /// Type of the connections this server will create
+    typedef connection<config> connection_type;
+    /// Type of a shared pointer to the connections this server will create
+    typedef typename connection_type::ptr connection_ptr;
+
+    /// Type of the connection transport component
+    typedef typename transport_type::transport_con_type transport_con_type;
+    /// Type of a shared pointer to the connection transport component
+    typedef typename transport_con_type::ptr transport_con_ptr;
+
+    /// Type of the endpoint component of this server
+    typedef endpoint<connection_type,config> endpoint_type;
+
+    explicit server() : endpoint_type(true)
+    {
+        endpoint_type::m_alog.write(log::alevel::devel, "server constructor");
+    }
+
+    /// Create and initialize a new connection
+    /**
+     * The connection will be initialized and ready to begin. Call its start()
+     * method to begin the processing loop.
+     *
+     * Note: The connection must either be started or terminated using
+     * connection::terminate in order to avoid memory leaks.
+     *
+     * @return A pointer to the new connection.
+     */
+    connection_ptr get_connection() {
+        return endpoint_type::create_connection();
+    }
+
+    /// Starts the server's async connection acceptance loop (exception free)
+    /**
+     * Initiates the server connection acceptance loop. Must be called after
+     * listen. This method will have no effect until the underlying io_service
+     * starts running. It may be called after the io_service is already running.
+     *
+     * Refer to documentation for the transport policy you are using for
+     * instructions on how to stop this acceptance loop.
+     * 
+     * @param [out] ec A status code indicating an error, if any.
+     */
+    void start_accept(lib::error_code & ec) {
+        if (!transport_type::is_listening()) {
+            ec = error::make_error_code(error::async_accept_not_listening);
+            return;
+        }
+        
+        ec = lib::error_code();
+        connection_ptr con = get_connection();
+        
+        transport_type::async_accept(
+            lib::static_pointer_cast<transport_con_type>(con),
+            lib::bind(&type::handle_accept,this,con,lib::placeholders::_1),
+            ec
+        );
+        
+        if (ec && con) {
+            // If the connection was constructed but the accept failed,
+            // terminate the connection to prevent memory leaks
+            con->terminate(lib::error_code());
+        }
+    }
+
+    /// Starts the server's async connection acceptance loop
+    /**
+     * Initiates the server connection acceptance loop. Must be called after
+     * listen. This method will have no effect until the underlying io_service
+     * starts running. It may be called after the io_service is already running.
+     *
+     * Refer to documentation for the transport policy you are using for
+     * instructions on how to stop this acceptance loop.
+     */
+    void start_accept() {
+        lib::error_code ec;
+        start_accept(ec);
+        if (ec) {
+            throw exception(ec);
+        }
+    }
+
+    /// Handler callback for start_accept
+    void handle_accept(connection_ptr con, lib::error_code const & ec) {
+        if (ec) {
+            con->terminate(ec);
+
+            if (ec == error::operation_canceled) {
+                endpoint_type::m_elog.write(log::elevel::info,
+                    "handle_accept error: "+ec.message());
+            } else {
+                endpoint_type::m_elog.write(log::elevel::rerror,
+                    "handle_accept error: "+ec.message());
+            }
+        } else {
+            con->start();
+        }
+
+        lib::error_code start_ec;
+        start_accept(start_ec);
+        if (start_ec == error::async_accept_not_listening) {
+            endpoint_type::m_elog.write(log::elevel::info,
+                "Stopping acceptance of new connections because the underlying transport is no longer listening.");
+        } else if (start_ec) {
+            endpoint_type::m_elog.write(log::elevel::rerror,
+                "Restarting async_accept loop failed: "+ec.message());
+        }
+    }
+};
+
+} // namespace websocketpp
+
+#endif //WEBSOCKETPP_SERVER_ENDPOINT_HPP
diff --git a/extlibs/websocketpp/websocketpp/server.hpp b/extlibs/websocketpp/websocketpp/server.hpp
new file mode 100644
index 000000000..342fa8c54
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/server.hpp
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_SERVER_HPP
+#define WEBSOCKETPP_SERVER_HPP
+
+#include <websocketpp/roles/server_endpoint.hpp>
+
+#endif //WEBSOCKETPP_SERVER_HPP
diff --git a/extlibs/websocketpp/websocketpp/sha1/sha1.hpp b/extlibs/websocketpp/websocketpp/sha1/sha1.hpp
new file mode 100644
index 000000000..43a843382
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/sha1/sha1.hpp
@@ -0,0 +1,189 @@
+/*
+*****
+sha1.hpp is a repackaging of the sha1.cpp and sha1.h files from the smallsha1
+library (http://code.google.com/p/smallsha1/) into a single header suitable for
+use as a header only library. This conversion was done by Peter Thorson
+(webmaster@zaphoyd.com) in 2013. All modifications to the code are redistributed
+under the same license as the original, which is listed below.
+*****
+
+ Copyright (c) 2011, Micael Hildenborg
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Micael Hildenborg nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY Micael Hildenborg ''AS IS'' AND ANY
+ EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ DISCLAIMED. IN NO EVENT SHALL Micael Hildenborg BE LIABLE FOR ANY
+ DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SHA1_DEFINED
+#define SHA1_DEFINED
+
+namespace websocketpp {
+namespace sha1 {
+
+namespace { // local
+
+// Rotate an integer value to left.
+inline unsigned int rol(unsigned int value, unsigned int steps) {
+    return ((value << steps) | (value >> (32 - steps)));
+}
+
+// Sets the first 16 integers in the buffert to zero.
+// Used for clearing the W buffert.
+inline void clearWBuffert(unsigned int * buffert)
+{
+    for (int pos = 16; --pos >= 0;)
+    {
+        buffert[pos] = 0;
+    }
+}
+
+inline void innerHash(unsigned int * result, unsigned int * w)
+{
+    unsigned int a = result[0];
+    unsigned int b = result[1];
+    unsigned int c = result[2];
+    unsigned int d = result[3];
+    unsigned int e = result[4];
+
+    int round = 0;
+
+    #define sha1macro(func,val) \
+    { \
+        const unsigned int t = rol(a, 5) + (func) + e + val + w[round]; \
+        e = d; \
+        d = c; \
+        c = rol(b, 30); \
+        b = a; \
+        a = t; \
+    }
+
+    while (round < 16)
+    {
+        sha1macro((b & c) | (~b & d), 0x5a827999)
+        ++round;
+    }
+    while (round < 20)
+    {
+        w[round] = rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]), 1);
+        sha1macro((b & c) | (~b & d), 0x5a827999)
+        ++round;
+    }
+    while (round < 40)
+    {
+        w[round] = rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]), 1);
+        sha1macro(b ^ c ^ d, 0x6ed9eba1)
+        ++round;
+    }
+    while (round < 60)
+    {
+        w[round] = rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]), 1);
+        sha1macro((b & c) | (b & d) | (c & d), 0x8f1bbcdc)
+        ++round;
+    }
+    while (round < 80)
+    {
+        w[round] = rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]), 1);
+        sha1macro(b ^ c ^ d, 0xca62c1d6)
+        ++round;
+    }
+
+    #undef sha1macro
+
+    result[0] += a;
+    result[1] += b;
+    result[2] += c;
+    result[3] += d;
+    result[4] += e;
+}
+
+} // namespace
+
+/// Calculate a SHA1 hash
+/**
+ * @param src points to any kind of data to be hashed.
+ * @param bytelength the number of bytes to hash from the src pointer.
+ * @param hash should point to a buffer of at least 20 bytes of size for storing
+ * the sha1 result in.
+ */
+inline void calc(void const * src, size_t bytelength, unsigned char * hash) {
+    // Init the result array.
+    unsigned int result[5] = { 0x67452301, 0xefcdab89, 0x98badcfe,
+                               0x10325476, 0xc3d2e1f0 };
+
+    // Cast the void src pointer to be the byte array we can work with.
+    unsigned char const * sarray = (unsigned char const *) src;
+
+    // The reusable round buffer
+    unsigned int w[80];
+
+    // Loop through all complete 64byte blocks.
+
+    size_t endCurrentBlock;
+    size_t currentBlock = 0;
+
+    if (bytelength >= 64) {
+        size_t const endOfFullBlocks = bytelength - 64;
+
+        while (currentBlock <= endOfFullBlocks) {
+            endCurrentBlock = currentBlock + 64;
+
+            // Init the round buffer with the 64 byte block data.
+            for (int roundPos = 0; currentBlock < endCurrentBlock; currentBlock += 4)
+            {
+                // This line will swap endian on big endian and keep endian on
+                // little endian.
+                w[roundPos++] = (unsigned int) sarray[currentBlock + 3]
+                        | (((unsigned int) sarray[currentBlock + 2]) << 8)
+                        | (((unsigned int) sarray[currentBlock + 1]) << 16)
+                        | (((unsigned int) sarray[currentBlock]) << 24);
+            }
+            innerHash(result, w);
+        }
+    }
+
+    // Handle the last and not full 64 byte block if existing.
+    endCurrentBlock = bytelength - currentBlock;
+    clearWBuffert(w);
+    size_t lastBlockBytes = 0;
+    for (;lastBlockBytes < endCurrentBlock; ++lastBlockBytes) {
+        w[lastBlockBytes >> 2] |= (unsigned int) sarray[lastBlockBytes + currentBlock] << ((3 - (lastBlockBytes & 3)) << 3);
+    }
+
+    w[lastBlockBytes >> 2] |= 0x80 << ((3 - (lastBlockBytes & 3)) << 3);
+    if (endCurrentBlock >= 56) {
+        innerHash(result, w);
+        clearWBuffert(w);
+    }
+    w[15] = bytelength << 3;
+    innerHash(result, w);
+
+    // Store hash in result pointer, and make sure we get in in the correct
+    // order on both endian models.
+    for (int hashByte = 20; --hashByte >= 0;) {
+        hash[hashByte] = (result[hashByte >> 2] >> (((3 - hashByte) & 0x3) << 3)) & 0xff;
+    }
+}
+
+} // namespace sha1
+} // namespace websocketpp
+
+#endif // SHA1_DEFINED
diff --git a/extlibs/websocketpp/websocketpp/transport/asio/base.hpp b/extlibs/websocketpp/websocketpp/transport/asio/base.hpp
new file mode 100644
index 000000000..8ede3aaab
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/asio/base.hpp
@@ -0,0 +1,251 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_ASIO_BASE_HPP
+#define WEBSOCKETPP_TRANSPORT_ASIO_BASE_HPP
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/functional.hpp>
+#include <websocketpp/common/system_error.hpp>
+
+#include <boost/system/error_code.hpp>
+
+#include <boost/aligned_storage.hpp>
+#include <boost/noncopyable.hpp>
+#include <boost/array.hpp>
+
+#include <string>
+
+namespace websocketpp {
+namespace transport {
+/// Transport policy that uses boost::asio
+/**
+ * This policy uses a single boost::asio io_service to provide transport
+ * services to a WebSocket++ endpoint.
+ */
+namespace asio {
+
+//
+
+// Class to manage the memory to be used for handler-based custom allocation.
+// It contains a single block of memory which may be returned for allocation
+// requests. If the memory is in use when an allocation request is made, the
+// allocator delegates allocation to the global heap.
+class handler_allocator
+  : private boost::noncopyable
+{
+public:
+  handler_allocator()
+    : in_use_(false)
+  {
+  }
+
+  void* allocate(std::size_t size)
+  {
+    if (!in_use_ && size < storage_.size)
+    {
+      in_use_ = true;
+      return storage_.address();
+    }
+    else
+    {
+      return ::operator new(size);
+    }
+  }
+
+  void deallocate(void* pointer)
+  {
+    if (pointer == storage_.address())
+    {
+      in_use_ = false;
+    }
+    else
+    {
+      ::operator delete(pointer);
+    }
+  }
+
+private:
+  // Storage space used for handler-based custom memory allocation.
+  boost::aligned_storage<1024> storage_;
+
+  // Whether the handler-based custom allocation storage has been used.
+  bool in_use_;
+};
+
+// Wrapper class template for handler objects to allow handler memory
+// allocation to be customised. Calls to operator() are forwarded to the
+// encapsulated handler.
+template <typename Handler>
+class custom_alloc_handler
+{
+public:
+  custom_alloc_handler(handler_allocator& a, Handler h)
+    : allocator_(a),
+      handler_(h)
+  {
+  }
+
+  template <typename Arg1>
+  void operator()(Arg1 arg1)
+  {
+    handler_(arg1);
+  }
+
+  template <typename Arg1, typename Arg2>
+  void operator()(Arg1 arg1, Arg2 arg2)
+  {
+    handler_(arg1, arg2);
+  }
+
+  friend void* asio_handler_allocate(std::size_t size,
+      custom_alloc_handler<Handler>* this_handler)
+  {
+    return this_handler->allocator_.allocate(size);
+  }
+
+  friend void asio_handler_deallocate(void* pointer, std::size_t /*size*/,
+      custom_alloc_handler<Handler>* this_handler)
+  {
+    this_handler->allocator_.deallocate(pointer);
+  }
+
+private:
+  handler_allocator& allocator_;
+  Handler handler_;
+};
+
+// Helper function to wrap a handler object to add custom allocation.
+template <typename Handler>
+inline custom_alloc_handler<Handler> make_custom_alloc_handler(
+    handler_allocator& a, Handler h)
+{
+  return custom_alloc_handler<Handler>(a, h);
+}
+
+
+
+
+
+
+
+// Forward declaration of class endpoint so that it can be friended/referenced
+// before being included.
+template <typename config>
+class endpoint;
+
+typedef lib::function<void(boost::system::error_code const &)>
+    socket_shutdown_handler;
+
+typedef lib::function<void (boost::system::error_code const & ec,
+    size_t bytes_transferred)> async_read_handler;
+
+typedef lib::function<void (boost::system::error_code const & ec,
+    size_t bytes_transferred)> async_write_handler;
+
+typedef lib::function<void (lib::error_code const & ec)> pre_init_handler;
+
+// handle_timer: dynamic parameters, multiple copies
+// handle_proxy_write
+// handle_proxy_read
+// handle_async_write
+// handle_pre_init
+
+
+/// Asio transport errors
+namespace error {
+enum value {
+    /// Catch-all error for transport policy errors that don't fit in other
+    /// categories
+    general = 1,
+
+    /// async_read_at_least call requested more bytes than buffer can store
+    invalid_num_bytes,
+
+    /// there was an error in the underlying transport library
+    pass_through,
+
+    /// The connection to the requested proxy server failed
+    proxy_failed,
+
+    /// Invalid Proxy URI
+    proxy_invalid,
+
+    /// Invalid host or service
+    invalid_host_service
+};
+
+/// Asio transport error category
+class category : public lib::error_category {
+public:
+    char const * name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp.transport.asio";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case error::general:
+                return "Generic asio transport policy error";
+            case error::invalid_num_bytes:
+                return "async_read_at_least call requested more bytes than buffer can store";
+            case error::pass_through:
+                return "Underlying Transport Error";
+            case error::proxy_failed:
+                return "Proxy connection failed";
+            case error::proxy_invalid:
+                return "Invalid proxy URI";
+            case error::invalid_host_service:
+                return "Invalid host or service";
+            default:
+                return "Unknown";
+        }
+    }
+};
+
+/// Get a reference to a static copy of the asio transport error category
+inline lib::error_category const & get_category() {
+    static category instance;
+    return instance;
+}
+
+/// Create an error code with the given value and the asio transport category
+inline lib::error_code make_error_code(error::value e) {
+    return lib::error_code(static_cast<int>(e), get_category());
+}
+
+} // namespace error
+} // namespace asio
+} // namespace transport
+} // namespace websocketpp
+
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_
+template<> struct is_error_code_enum<websocketpp::transport::asio::error::value>
+{
+    static bool const value = true;
+};
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_
+#endif // WEBSOCKETPP_TRANSPORT_ASIO_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/asio/connection.hpp b/extlibs/websocketpp/websocketpp/transport/asio/connection.hpp
new file mode 100644
index 000000000..0be40f6b4
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/asio/connection.hpp
@@ -0,0 +1,1162 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_ASIO_CON_HPP
+#define WEBSOCKETPP_TRANSPORT_ASIO_CON_HPP
+
+#include <websocketpp/transport/asio/base.hpp>
+
+#include <websocketpp/transport/base/connection.hpp>
+
+#include <websocketpp/logger/levels.hpp>
+#include <websocketpp/http/constants.hpp>
+
+#include <websocketpp/base64/base64.hpp>
+#include <websocketpp/error.hpp>
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/common/functional.hpp>
+#include <websocketpp/common/connection_hdl.hpp>
+
+#include <boost/asio.hpp>
+#include <boost/system/error_code.hpp>
+
+#include <istream>
+#include <sstream>
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+namespace transport {
+namespace asio {
+
+typedef lib::function<void(connection_hdl)> tcp_init_handler;
+
+/// Boost Asio based connection transport component
+/**
+ * transport::asio::connection implements a connection transport component using
+ * Boost ASIO that works with the transport::asio::endpoint endpoint transport
+ * component.
+ */
+template <typename config>
+class connection : public config::socket_type::socket_con_type {
+public:
+    /// Type of this connection transport component
+    typedef connection<config> type;
+    /// Type of a shared pointer to this connection transport component
+    typedef lib::shared_ptr<type> ptr;
+
+    /// Type of the socket connection component
+    typedef typename config::socket_type::socket_con_type socket_con_type;
+    /// Type of a shared pointer to the socket connection component
+    typedef typename socket_con_type::ptr socket_con_ptr;
+    /// Type of this transport's access logging policy
+    typedef typename config::alog_type alog_type;
+    /// Type of this transport's error logging policy
+    typedef typename config::elog_type elog_type;
+
+    typedef typename config::request_type request_type;
+    typedef typename request_type::ptr request_ptr;
+    typedef typename config::response_type response_type;
+    typedef typename response_type::ptr response_ptr;
+
+    /// Type of a pointer to the ASIO io_service being used
+    typedef boost::asio::io_service* io_service_ptr;
+    /// Type of a pointer to the ASIO io_service::strand being used
+    typedef lib::shared_ptr<boost::asio::io_service::strand> strand_ptr;
+    /// Type of a pointer to the ASIO timer class
+    typedef lib::shared_ptr<boost::asio::deadline_timer> timer_ptr;
+
+    // connection is friends with its associated endpoint to allow the endpoint
+    // to call private/protected utility methods that we don't want to expose
+    // to the public api.
+    friend class endpoint<config>;
+
+    // generate and manage our own io_service
+    explicit connection(bool is_server, alog_type& alog, elog_type& elog)
+      : m_is_server(is_server)
+      , m_alog(alog)
+      , m_elog(elog)
+    {
+        m_alog.write(log::alevel::devel,"asio con transport constructor");
+    }
+
+    /// Get a shared pointer to this component
+    ptr get_shared() {
+        return lib::static_pointer_cast<type>(socket_con_type::get_shared());
+    }
+
+    bool is_secure() const {
+        return socket_con_type::is_secure();
+    }
+
+    /// Sets the tcp pre init handler
+    /**
+     * The tcp pre init handler is called after the raw tcp connection has been
+     * established but before any additional wrappers (proxy connects, TLS
+     * handshakes, etc) have been performed.
+     *
+     * @since 0.3.0
+     *
+     * @param h The handler to call on tcp pre init.
+     */
+    void set_tcp_pre_init_handler(tcp_init_handler h) {
+        m_tcp_pre_init_handler = h;
+    }
+
+    /// Sets the tcp pre init handler (deprecated)
+    /**
+     * The tcp pre init handler is called after the raw tcp connection has been
+     * established but before any additional wrappers (proxy connects, TLS
+     * handshakes, etc) have been performed.
+     *
+     * @deprecated Use set_tcp_pre_init_handler instead
+     *
+     * @param h The handler to call on tcp pre init.
+     */
+    void set_tcp_init_handler(tcp_init_handler h) {
+        set_tcp_pre_init_handler(h);
+    }
+
+    /// Sets the tcp post init handler
+    /**
+     * The tcp post init handler is called after the tcp connection has been
+     * established and all additional wrappers (proxy connects, TLS handshakes,
+     * etc have been performed. This is fired before any bytes are read or any
+     * WebSocket specific handshake logic has been performed.
+     *
+     * @since 0.3.0
+     *
+     * @param h The handler to call on tcp post init.
+     */
+    void set_tcp_post_init_handler(tcp_init_handler h) {
+        m_tcp_post_init_handler = h;
+    }
+
+    /// Set the proxy to connect through (exception free)
+    /**
+     * The URI passed should be a complete URI including scheme. For example:
+     * http://proxy.example.com:8080/
+     *
+     * The proxy must be set up as an explicit (CONNECT) proxy allowed to
+     * connect to the port you specify. Traffic to the proxy is not encrypted.
+     *
+     * @param uri The full URI of the proxy to connect to.
+     *
+     * @param ec A status value
+     */
+    void set_proxy(std::string const & uri, lib::error_code & ec) {
+        // TODO: return errors for illegal URIs here?
+        // TODO: should https urls be illegal for the moment?
+        m_proxy = uri;
+        m_proxy_data = lib::make_shared<proxy_data>();
+        ec = lib::error_code();
+    }
+
+    /// Set the proxy to connect through (exception)
+    void set_proxy(std::string const & uri) {
+        lib::error_code ec;
+        set_proxy(uri,ec);
+        if (ec) { throw exception(ec); }
+    }
+
+    /// Set the basic auth credentials to use (exception free)
+    /**
+     * The URI passed should be a complete URI including scheme. For example:
+     * http://proxy.example.com:8080/
+     *
+     * The proxy must be set up as an explicit proxy
+     *
+     * @param username The username to send
+     *
+     * @param password The password to send
+     *
+     * @param ec A status value
+     */
+    void set_proxy_basic_auth(std::string const & username, std::string const &
+        password, lib::error_code & ec)
+    {
+        if (!m_proxy_data) {
+            ec = make_error_code(websocketpp::error::invalid_state);
+            return;
+        }
+
+        // TODO: username can't contain ':'
+        std::string val = "Basic "+base64_encode(username + ":" + password);
+        m_proxy_data->req.replace_header("Proxy-Authorization",val);
+        ec = lib::error_code();
+    }
+
+    /// Set the basic auth credentials to use (exception)
+    void set_proxy_basic_auth(std::string const & username, std::string const &
+        password)
+    {
+        lib::error_code ec;
+        set_proxy_basic_auth(username,password,ec);
+        if (ec) { throw exception(ec); }
+    }
+
+    /// Set the proxy timeout duration (exception free)
+    /**
+     * Duration is in milliseconds. Default value is based on the transport
+     * config
+     *
+     * @param duration The number of milliseconds to wait before aborting the
+     * proxy connection.
+     *
+     * @param ec A status value
+     */
+    void set_proxy_timeout(long duration, lib::error_code & ec) {
+        if (!m_proxy_data) {
+            ec = make_error_code(websocketpp::error::invalid_state);
+            return;
+        }
+
+        m_proxy_data->timeout_proxy = duration;
+        ec = lib::error_code();
+    }
+
+    /// Set the proxy timeout duration (exception)
+    void set_proxy_timeout(long duration) {
+        lib::error_code ec;
+        set_proxy_timeout(duration,ec);
+        if (ec) { throw exception(ec); }
+    }
+
+    std::string const & get_proxy() const {
+        return m_proxy;
+    }
+
+    /// Get the remote endpoint address
+    /**
+     * The iostream transport has no information about the ultimate remote
+     * endpoint. It will return the string "iostream transport". To indicate
+     * this.
+     *
+     * TODO: allow user settable remote endpoint addresses if this seems useful
+     *
+     * @return A string identifying the address of the remote endpoint
+     */
+    std::string get_remote_endpoint() const {
+        lib::error_code ec;
+
+        std::string ret = socket_con_type::get_remote_endpoint(ec);
+
+        if (ec) {
+            m_elog.write(log::elevel::info,ret);
+            return "Unknown";
+        } else {
+            return ret;
+        }
+    }
+
+    /// Get the connection handle
+    connection_hdl get_handle() const {
+        return m_connection_hdl;
+    }
+
+    /// Call back a function after a period of time.
+    /**
+     * Sets a timer that calls back a function after the specified period of
+     * milliseconds. Returns a handle that can be used to cancel the timer.
+     * A cancelled timer will return the error code error::operation_aborted
+     * A timer that expired will return no error.
+     *
+     * @param duration Length of time to wait in milliseconds
+     *
+     * @param callback The function to call back when the timer has expired
+     *
+     * @return A handle that can be used to cancel the timer if it is no longer
+     * needed.
+     */
+    timer_ptr set_timer(long duration, timer_handler callback) {
+        timer_ptr new_timer = lib::make_shared<boost::asio::deadline_timer>(
+            lib::ref(*m_io_service),
+            boost::posix_time::milliseconds(duration)
+        );
+
+        if (config::enable_multithreading) {
+            new_timer->async_wait(m_strand->wrap(lib::bind(
+                &type::handle_timer, get_shared(),
+                new_timer,
+                callback,
+                lib::placeholders::_1
+            )));
+        } else {
+            new_timer->async_wait(lib::bind(
+                &type::handle_timer, get_shared(),
+                new_timer,
+                callback,
+                lib::placeholders::_1
+            ));
+        }
+
+        return new_timer;
+    }
+
+    /// Timer callback
+    /**
+     * The timer pointer is included to ensure the timer isn't destroyed until
+     * after it has expired.
+     *
+     * TODO: candidate for protected status
+     *
+     * @param post_timer Pointer to the timer in question
+     * @param callback The function to call back
+     * @param ec The status code
+     */
+    void handle_timer(timer_ptr, timer_handler callback,
+        boost::system::error_code const & ec)
+    {
+        if (ec) {
+            if (ec == boost::asio::error::operation_aborted) {
+                callback(make_error_code(transport::error::operation_aborted));
+            } else {
+                log_err(log::elevel::info,"asio handle_timer",ec);
+                callback(make_error_code(error::pass_through));
+            }
+        } else {
+            callback(lib::error_code());
+        }
+    }
+protected:
+    /// Get a pointer to this connection's strand
+    strand_ptr get_strand() {
+        return m_strand;
+    }
+
+    /// Initialize transport for reading
+    /**
+     * init_asio is called once immediately after construction to initialize
+     * boost::asio components to the io_service
+     *
+     * The transport initialization sequence consists of the following steps:
+     * - Pre-init: the underlying socket is initialized to the point where
+     * bytes may be written. No bytes are actually written in this stage
+     * - Proxy negotiation: if a proxy is set, a request is made to it to start
+     * a tunnel to the final destination. This stage ends when the proxy is
+     * ready to forward the
+     * next byte to the remote endpoint.
+     * - Post-init: Perform any i/o with the remote endpoint, such as setting up
+     * tunnels for encryption. This stage ends when the connection is ready to
+     * read or write the WebSocket handshakes. At this point the original
+     * callback function is called.
+     */
+    void init(init_handler callback) {
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,"asio connection init");
+        }
+
+        // TODO: pre-init timeout. Right now no implemented socket policies
+        // actually have an asyncronous pre-init
+
+        m_init_handler = callback;
+
+        socket_con_type::pre_init(
+            lib::bind(
+                &type::handle_pre_init,
+                get_shared(),
+                lib::placeholders::_1
+            )
+        );
+    }
+
+    /// initialize the proxy buffers and http parsers
+    /**
+     *
+     * @param authority The address of the server we want the proxy to tunnel to
+     * in the format of a URI authority (host:port)
+     *
+     * @return Status code indicating what errors occurred, if any
+     */
+    lib::error_code proxy_init(std::string const & authority) {
+        if (!m_proxy_data) {
+            return websocketpp::error::make_error_code(
+                websocketpp::error::invalid_state);
+        }
+        m_proxy_data->req.set_version("HTTP/1.1");
+        m_proxy_data->req.set_method("CONNECT");
+
+        m_proxy_data->req.set_uri(authority);
+        m_proxy_data->req.replace_header("Host",authority);
+
+        return lib::error_code();
+    }
+
+    /// Finish constructing the transport
+    /**
+     * init_asio is called once immediately after construction to initialize
+     * boost::asio components to the io_service.
+     *
+     * @param io_service A pointer to the io_service to register with this
+     * connection
+     *
+     * @return Status code for the success or failure of the initialization
+     */
+    lib::error_code init_asio (io_service_ptr io_service) {
+        m_io_service = io_service;
+
+        if (config::enable_multithreading) {
+            m_strand = lib::make_shared<boost::asio::strand>(
+                lib::ref(*io_service));
+
+            m_async_read_handler = m_strand->wrap(lib::bind(
+                &type::handle_async_read, get_shared(),lib::placeholders::_1,
+                lib::placeholders::_2));
+
+            m_async_write_handler = m_strand->wrap(lib::bind(
+                &type::handle_async_write, get_shared(),lib::placeholders::_1,
+                lib::placeholders::_2));
+        } else {
+            m_async_read_handler = lib::bind(&type::handle_async_read,
+                get_shared(), lib::placeholders::_1, lib::placeholders::_2);
+
+            m_async_write_handler = lib::bind(&type::handle_async_write,
+                get_shared(), lib::placeholders::_1, lib::placeholders::_2);
+        }
+
+        lib::error_code ec = socket_con_type::init_asio(io_service, m_strand,
+            m_is_server);
+
+        if (ec) {
+            // reset the handlers to break the circular reference:
+            // this->handler->this
+            lib::clear_function(m_async_read_handler);
+            lib::clear_function(m_async_write_handler);
+        }
+
+        return ec;
+    }
+
+    void handle_pre_init(lib::error_code const & ec) {
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,"asio connection handle pre_init");
+        }
+
+        if (m_tcp_pre_init_handler) {
+            m_tcp_pre_init_handler(m_connection_hdl);
+        }
+
+        if (ec) {
+            m_init_handler(ec);
+        }
+
+        // If we have a proxy set issue a proxy connect, otherwise skip to
+        // post_init
+        if (!m_proxy.empty()) {
+            proxy_write();
+        } else {
+            post_init();
+        }
+    }
+
+    void post_init() {
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,"asio connection post_init");
+        }
+
+        timer_ptr post_timer;
+        
+        if (config::timeout_socket_post_init > 0) {
+            post_timer = set_timer(
+                config::timeout_socket_post_init,
+                lib::bind(
+                    &type::handle_post_init_timeout,
+                    get_shared(),
+                    post_timer,
+                    m_init_handler,
+                    lib::placeholders::_1
+                )
+            );
+        }
+
+        socket_con_type::post_init(
+            lib::bind(
+                &type::handle_post_init,
+                get_shared(),
+                post_timer,
+                m_init_handler,
+                lib::placeholders::_1
+            )
+        );
+    }
+
+    /// Post init timeout callback
+    /**
+     * The timer pointer is included to ensure the timer isn't destroyed until
+     * after it has expired.
+     *
+     * @param post_timer Pointer to the timer in question
+     * @param callback The function to call back
+     * @param ec The status code
+     */
+    void handle_post_init_timeout(timer_ptr, init_handler callback,
+        lib::error_code const & ec)
+    {
+        lib::error_code ret_ec;
+
+        if (ec) {
+            if (ec == transport::error::operation_aborted) {
+                m_alog.write(log::alevel::devel,
+                    "asio post init timer cancelled");
+                return;
+            }
+
+            log_err(log::elevel::devel,"asio handle_post_init_timeout",ec);
+            ret_ec = ec;
+        } else {
+            if (socket_con_type::get_ec()) {
+                ret_ec = socket_con_type::get_ec();
+            } else {
+                ret_ec = make_error_code(transport::error::timeout);
+            }
+        }
+
+        m_alog.write(log::alevel::devel,"Asio transport post-init timed out");
+        socket_con_type::cancel_socket();
+        callback(ret_ec);
+    }
+
+    /// Post init timeout callback
+    /**
+     * The timer pointer is included to ensure the timer isn't destroyed until
+     * after it has expired.
+     *
+     * @param post_timer Pointer to the timer in question
+     * @param callback The function to call back
+     * @param ec The status code
+     */
+    void handle_post_init(timer_ptr post_timer, init_handler callback,
+        lib::error_code const & ec)
+    {
+        if (ec == transport::error::operation_aborted ||
+            (post_timer && post_timer->expires_from_now().is_negative()))
+        {
+            m_alog.write(log::alevel::devel,"post_init cancelled");
+            return;
+        }
+
+        if (post_timer) {
+            post_timer->cancel();
+        }
+
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,"asio connection handle_post_init");
+        }
+
+        if (m_tcp_post_init_handler) {
+            m_tcp_post_init_handler(m_connection_hdl);
+        }
+
+        callback(ec);
+    }
+
+    void proxy_write() {
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,"asio connection proxy_write");
+        }
+
+        if (!m_proxy_data) {
+            m_elog.write(log::elevel::library,
+                "assertion failed: !m_proxy_data in asio::connection::proxy_write");
+            m_init_handler(make_error_code(error::general));
+            return;
+        }
+
+        m_proxy_data->write_buf = m_proxy_data->req.raw();
+
+        m_bufs.push_back(boost::asio::buffer(m_proxy_data->write_buf.data(),
+                                             m_proxy_data->write_buf.size()));
+
+        m_alog.write(log::alevel::devel,m_proxy_data->write_buf);
+
+        // Set a timer so we don't wait forever for the proxy to respond
+        m_proxy_data->timer = this->set_timer(
+            m_proxy_data->timeout_proxy,
+            lib::bind(
+                &type::handle_proxy_timeout,
+                get_shared(),
+                m_init_handler,
+                lib::placeholders::_1
+            )
+        );
+
+        // Send proxy request
+        if (config::enable_multithreading) {
+            boost::asio::async_write(
+                socket_con_type::get_next_layer(),
+                m_bufs,
+                m_strand->wrap(lib::bind(
+                    &type::handle_proxy_write, get_shared(),
+                    m_init_handler,
+                    lib::placeholders::_1
+                ))
+            );
+        } else {
+            boost::asio::async_write(
+                socket_con_type::get_next_layer(),
+                m_bufs,
+                lib::bind(
+                    &type::handle_proxy_write, get_shared(),
+                    m_init_handler,
+                    lib::placeholders::_1
+                )
+            );
+        }
+    }
+
+    void handle_proxy_timeout(init_handler callback, lib::error_code const & ec)
+    {
+        if (ec == transport::error::operation_aborted) {
+            m_alog.write(log::alevel::devel,
+                "asio handle_proxy_write timer cancelled");
+            return;
+        } else if (ec) {
+            log_err(log::elevel::devel,"asio handle_proxy_write",ec);
+            callback(ec);
+        } else {
+            m_alog.write(log::alevel::devel,
+                "asio handle_proxy_write timer expired");
+            socket_con_type::cancel_socket();
+            callback(make_error_code(transport::error::timeout));
+        }
+    }
+
+    void handle_proxy_write(init_handler callback,
+        boost::system::error_code const & ec)
+    {
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,
+                "asio connection handle_proxy_write");
+        }
+
+        m_bufs.clear();
+
+        // Timer expired or the operation was aborted for some reason.
+        // Whatever aborted it will be issuing the callback so we are safe to
+        // return
+        if (ec == boost::asio::error::operation_aborted ||
+            m_proxy_data->timer->expires_from_now().is_negative())
+        {
+            m_elog.write(log::elevel::devel,"write operation aborted");
+            return;
+        }
+
+        if (ec) {
+            log_err(log::elevel::info,"asio handle_proxy_write",ec);
+            m_proxy_data->timer->cancel();
+            callback(make_error_code(error::pass_through));
+            return;
+        }
+
+        proxy_read(callback);
+    }
+
+    void proxy_read(init_handler callback) {
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,"asio connection proxy_read");
+        }
+
+        if (!m_proxy_data) {
+            m_elog.write(log::elevel::library,
+                "assertion failed: !m_proxy_data in asio::connection::proxy_read");
+            m_proxy_data->timer->cancel();
+            callback(make_error_code(error::general));
+            return;
+        }
+
+        if (config::enable_multithreading) {
+            boost::asio::async_read_until(
+                socket_con_type::get_next_layer(),
+                m_proxy_data->read_buf,
+                "\r\n\r\n",
+                m_strand->wrap(lib::bind(
+                    &type::handle_proxy_read, get_shared(),
+                    callback,
+                    lib::placeholders::_1, lib::placeholders::_2
+                ))
+            );
+        } else {
+            boost::asio::async_read_until(
+                socket_con_type::get_next_layer(),
+                m_proxy_data->read_buf,
+                "\r\n\r\n",
+                lib::bind(
+                    &type::handle_proxy_read, get_shared(),
+                    callback,
+                    lib::placeholders::_1, lib::placeholders::_2
+                )
+            );
+        }
+    }
+
+    /// Proxy read callback
+    /**
+     * @param init_handler The function to call back
+     * @param ec The status code
+     * @param bytes_transferred The number of bytes read
+     */
+    void handle_proxy_read(init_handler callback,
+        boost::system::error_code const & ec, size_t)
+    {
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,
+                "asio connection handle_proxy_read");
+        }
+
+        // Timer expired or the operation was aborted for some reason.
+        // Whatever aborted it will be issuing the callback so we are safe to
+        // return
+        if (ec == boost::asio::error::operation_aborted ||
+            m_proxy_data->timer->expires_from_now().is_negative())
+        {
+            m_elog.write(log::elevel::devel,"read operation aborted");
+            return;
+        }
+
+        // At this point there is no need to wait for the timer anymore
+        m_proxy_data->timer->cancel();
+
+        if (ec) {
+            m_elog.write(log::elevel::info,
+                "asio handle_proxy_read error: "+ec.message());
+            callback(make_error_code(error::pass_through));
+        } else {
+            if (!m_proxy_data) {
+                m_elog.write(log::elevel::library,
+                    "assertion failed: !m_proxy_data in asio::connection::handle_proxy_read");
+                callback(make_error_code(error::general));
+                return;
+            }
+
+            std::istream input(&m_proxy_data->read_buf);
+
+            m_proxy_data->res.consume(input);
+
+            if (!m_proxy_data->res.headers_ready()) {
+                // we read until the headers were done in theory but apparently
+                // they aren't. Internal endpoint error.
+                callback(make_error_code(error::general));
+                return;
+            }
+
+            m_alog.write(log::alevel::devel,m_proxy_data->res.raw());
+
+            if (m_proxy_data->res.get_status_code() != http::status_code::ok) {
+                // got an error response back
+                // TODO: expose this error in a programmatically accessible way?
+                // if so, see below for an option on how to do this.
+                std::stringstream s;
+                s << "Proxy connection error: "
+                  << m_proxy_data->res.get_status_code()
+                  << " ("
+                  << m_proxy_data->res.get_status_msg()
+                  << ")";
+                m_elog.write(log::elevel::info,s.str());
+                callback(make_error_code(error::proxy_failed));
+                return;
+            }
+
+            // we have successfully established a connection to the proxy, now
+            // we can continue and the proxy will transparently forward the
+            // WebSocket connection.
+
+            // TODO: decide if we want an on_proxy callback that would allow
+            // access to the proxy response.
+
+            // free the proxy buffers and req/res objects as they aren't needed
+            // anymore
+            m_proxy_data.reset();
+
+            // Continue with post proxy initialization
+            post_init();
+        }
+    }
+
+    /// read at least num_bytes bytes into buf and then call handler.
+    /**
+     *
+     *
+     */
+    void async_read_at_least(size_t num_bytes, char *buf, size_t len,
+        read_handler handler)
+    {
+        if (m_alog.static_test(log::alevel::devel)) {
+            std::stringstream s;
+            s << "asio async_read_at_least: " << num_bytes;
+            m_alog.write(log::alevel::devel,s.str());
+        }
+
+        if (!m_async_read_handler) {
+            m_alog.write(log::alevel::devel,
+                "async_read_at_least called after async_shutdown");
+            handler(make_error_code(transport::error::action_after_shutdown),0);
+            return;
+        }
+
+        // TODO: safety vs speed ?
+        // maybe move into an if devel block
+        /*if (num_bytes > len) {
+            m_elog.write(log::elevel::devel,
+                "asio async_read_at_least error::invalid_num_bytes");
+            handler(make_error_code(transport::error::invalid_num_bytes),
+                size_t(0));
+            return;
+        }*/
+
+        m_read_handler = handler;
+
+        if (!m_read_handler) {
+            m_alog.write(log::alevel::devel,
+                "asio con async_read_at_least called with bad handler");
+        }
+
+        boost::asio::async_read(
+            socket_con_type::get_socket(),
+            boost::asio::buffer(buf,len),
+            boost::asio::transfer_at_least(num_bytes),
+            make_custom_alloc_handler(
+                m_read_handler_allocator,
+                m_async_read_handler
+            )
+        );
+    }
+
+    void handle_async_read(boost::system::error_code const & ec,
+        size_t bytes_transferred)
+    {
+        m_alog.write(log::alevel::devel, "asio con handle_async_read");
+
+        // translate boost error codes into more lib::error_codes
+        lib::error_code tec;
+        if (ec == boost::asio::error::eof) {
+            tec = make_error_code(transport::error::eof);
+        } else if (ec) {
+            // We don't know much more about the error at this point. As our
+            // socket/security policy if it knows more:
+            tec = socket_con_type::translate_ec(ec);
+
+            if (tec == transport::error::tls_error ||
+                tec == transport::error::pass_through)
+            {
+                // These are aggregate/catch all errors. Log some human readable
+                // information to the info channel to give library users some
+                // more details about why the upstream method may have failed.
+                log_err(log::elevel::info,"asio async_read_at_least",ec);
+            }
+        }
+        if (m_read_handler) {
+            m_read_handler(tec,bytes_transferred);
+            // TODO: why does this line break things?
+            //m_read_handler = _WEBSOCKETPP_NULL_FUNCTION_;
+        } else {
+            // This can happen in cases where the connection is terminated while
+            // the transport is waiting on a read.
+            m_alog.write(log::alevel::devel,
+                "handle_async_read called with null read handler");
+        }
+    }
+
+    void async_write(const char* buf, size_t len, write_handler handler) {
+        if (!m_async_write_handler) {
+            m_alog.write(log::alevel::devel,
+                "async_write (single) called after async_shutdown");
+            handler(make_error_code(transport::error::action_after_shutdown));
+            return;
+        }
+
+        m_bufs.push_back(boost::asio::buffer(buf,len));
+
+        m_write_handler = handler;
+
+        boost::asio::async_write(
+            socket_con_type::get_socket(),
+            m_bufs,
+            make_custom_alloc_handler(
+                m_write_handler_allocator,
+                m_async_write_handler
+            )
+        );
+    }
+
+    void async_write(std::vector<buffer> const & bufs, write_handler handler) {
+        if (!m_async_write_handler) {
+            m_alog.write(log::alevel::devel,
+                "async_write (vector) called after async_shutdown");
+            handler(make_error_code(transport::error::action_after_shutdown));
+            return;
+        }
+        std::vector<buffer>::const_iterator it;
+
+        for (it = bufs.begin(); it != bufs.end(); ++it) {
+            m_bufs.push_back(boost::asio::buffer((*it).buf,(*it).len));
+        }
+
+        m_write_handler = handler;
+
+        boost::asio::async_write(
+            socket_con_type::get_socket(),
+            m_bufs,
+            make_custom_alloc_handler(
+                m_write_handler_allocator,
+                m_async_write_handler
+            )
+        );
+    }
+
+    /// Async write callback
+    /**
+     * @param ec The status code
+     * @param bytes_transferred The number of bytes read
+     */
+    void handle_async_write(boost::system::error_code const & ec, size_t) {
+        m_bufs.clear();
+        lib::error_code tec;
+        if (ec) {
+            log_err(log::elevel::info,"asio async_write",ec);
+            tec = make_error_code(transport::error::pass_through);
+        }
+        if (m_write_handler) {
+            m_write_handler(tec);
+            // TODO: why does this line break things?
+            //m_write_handler = _WEBSOCKETPP_NULL_FUNCTION_;
+        } else {
+            // This can happen in cases where the connection is terminated while
+            // the transport is waiting on a read.
+            m_alog.write(log::alevel::devel,
+                "handle_async_write called with null write handler");
+        }
+    }
+
+    /// Set Connection Handle
+    /**
+     * See common/connection_hdl.hpp for information
+     *
+     * @param hdl A connection_hdl that the transport will use to refer
+     * to itself
+     */
+    void set_handle(connection_hdl hdl) {
+        m_connection_hdl = hdl;
+        socket_con_type::set_handle(hdl);
+    }
+
+    /// Trigger the on_interrupt handler
+    /**
+     * This needs to be thread safe
+     */
+    lib::error_code interrupt(interrupt_handler handler) {
+        if (config::enable_multithreading) {
+            m_io_service->post(m_strand->wrap(handler));
+        } else {
+            m_io_service->post(handler);
+        }
+        return lib::error_code();
+    }
+
+    lib::error_code dispatch(dispatch_handler handler) {
+        if (config::enable_multithreading) {
+            m_io_service->post(m_strand->wrap(handler));
+        } else {
+            m_io_service->post(handler);
+        }
+        return lib::error_code();
+    }
+
+    /*void handle_interrupt(interrupt_handler handler) {
+        handler();
+    }*/
+
+    /// close and clean up the underlying socket
+    void async_shutdown(shutdown_handler callback) {
+        if (m_alog.static_test(log::alevel::devel)) {
+            m_alog.write(log::alevel::devel,"asio connection async_shutdown");
+        }
+
+        // Reset cached handlers now that we won't be reading or writing anymore
+        // These cached handlers store shared pointers to this connection and
+        // will leak the connection if not destroyed.
+        lib::clear_function(m_async_read_handler);
+        lib::clear_function(m_async_write_handler);
+        lib::clear_function(m_init_handler);
+
+        lib::clear_function(m_read_handler);
+        lib::clear_function(m_write_handler);
+
+        timer_ptr shutdown_timer;
+        shutdown_timer = set_timer(
+            config::timeout_socket_shutdown,
+            lib::bind(
+                &type::handle_async_shutdown_timeout,
+                get_shared(),
+                shutdown_timer,
+                callback,
+                lib::placeholders::_1
+            )
+        );
+
+        socket_con_type::async_shutdown(
+            lib::bind(
+                &type::handle_async_shutdown,
+                get_shared(),
+                shutdown_timer,
+                callback,
+                lib::placeholders::_1
+            )
+        );
+    }
+
+    /// Async shutdown timeout handler
+    /**
+     * @param shutdown_timer A pointer to the timer to keep it in scope
+     * @param callback The function to call back
+     * @param ec The status code
+     */
+    void handle_async_shutdown_timeout(timer_ptr, init_handler callback, 
+        lib::error_code const & ec)
+    {
+        lib::error_code ret_ec;
+
+        if (ec) {
+            if (ec == transport::error::operation_aborted) {
+                m_alog.write(log::alevel::devel,
+                    "asio socket shutdown timer cancelled");
+                return;
+            }
+
+            log_err(log::elevel::devel,"asio handle_async_shutdown_timeout",ec);
+            ret_ec = ec;
+        } else {
+            ret_ec = make_error_code(transport::error::timeout);
+        }
+
+        m_alog.write(log::alevel::devel,
+            "Asio transport socket shutdown timed out");
+        socket_con_type::cancel_socket();
+        callback(ret_ec);
+    }
+
+    void handle_async_shutdown(timer_ptr shutdown_timer, shutdown_handler
+        callback, boost::system::error_code const & ec)
+    {
+        if (ec == boost::asio::error::operation_aborted ||
+            shutdown_timer->expires_from_now().is_negative())
+        {
+            m_alog.write(log::alevel::devel,"async_shutdown cancelled");
+            return;
+        }
+
+        shutdown_timer->cancel();
+
+        lib::error_code tec;
+        if (ec) {
+            if (ec == boost::asio::error::not_connected) {
+                // The socket was already closed when we tried to close it. This
+                // happens periodically (usually if a read or write fails
+                // earlier and if it is a real error will be caught at another
+                // level of the stack.
+            } else {
+                // We don't know anything more about this error, give our
+                // socket/security policy a crack at it.
+                tec = socket_con_type::translate_ec(ec);
+
+                if (tec == transport::error::tls_short_read) {
+                    // TLS short read at this point is somewhat expected if both
+                    // sides try and end the connection at the same time or if
+                    // SSLv2 is being used. In general there is nothing that can
+                    // be done here other than a low level development log.
+                } else {
+                    // all other errors are effectively pass through errors of
+                    // some sort so print some detail on the info channel for
+                    // library users to look up if needed.
+                    log_err(log::elevel::info,"asio async_shutdown",ec);
+                }
+            }
+        } else {
+            if (m_alog.static_test(log::alevel::devel)) {
+                m_alog.write(log::alevel::devel,
+                    "asio con handle_async_shutdown");
+            }
+        }
+        callback(tec);
+    }
+private:
+    /// Convenience method for logging the code and message for an error_code
+    template <typename error_type>
+    void log_err(log::level l, const char * msg, const error_type & ec) {
+        std::stringstream s;
+        s << msg << " error: " << ec << " (" << ec.message() << ")";
+        m_elog.write(l,s.str());
+    }
+
+    // static settings
+    const bool m_is_server;
+    alog_type& m_alog;
+    elog_type& m_elog;
+
+    struct proxy_data {
+        proxy_data() : timeout_proxy(config::timeout_proxy) {}
+
+        request_type req;
+        response_type res;
+        std::string write_buf;
+        boost::asio::streambuf read_buf;
+        long timeout_proxy;
+        timer_ptr timer;
+    };
+
+    std::string m_proxy;
+    lib::shared_ptr<proxy_data> m_proxy_data;
+
+    // transport resources
+    io_service_ptr  m_io_service;
+    strand_ptr      m_strand;
+    connection_hdl  m_connection_hdl;
+
+    std::vector<boost::asio::const_buffer> m_bufs;
+
+    // Handlers
+    tcp_init_handler    m_tcp_pre_init_handler;
+    tcp_init_handler    m_tcp_post_init_handler;
+
+    handler_allocator   m_read_handler_allocator;
+    handler_allocator   m_write_handler_allocator;
+
+    read_handler        m_read_handler;
+    write_handler       m_write_handler;
+    init_handler        m_init_handler;
+
+    async_read_handler  m_async_read_handler;
+    async_write_handler m_async_write_handler;
+};
+
+
+} // namespace asio
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_ASIO_CON_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/asio/endpoint.hpp b/extlibs/websocketpp/websocketpp/transport/asio/endpoint.hpp
new file mode 100644
index 000000000..ef3b07db4
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/asio/endpoint.hpp
@@ -0,0 +1,1094 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_ASIO_HPP
+#define WEBSOCKETPP_TRANSPORT_ASIO_HPP
+
+#include <websocketpp/transport/base/endpoint.hpp>
+#include <websocketpp/transport/asio/connection.hpp>
+#include <websocketpp/transport/asio/security/none.hpp>
+
+#include <websocketpp/uri.hpp>
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/common/functional.hpp>
+
+#include <boost/asio.hpp>
+#include <boost/bind.hpp>
+#include <boost/system/error_code.hpp>
+
+#include <sstream>
+#include <string>
+
+namespace websocketpp {
+namespace transport {
+namespace asio {
+
+/// Boost Asio based endpoint transport component
+/**
+ * transport::asio::endpoint implements an endpoint transport component using
+ * Boost ASIO.
+ */
+template <typename config>
+class endpoint : public config::socket_type {
+public:
+    /// Type of this endpoint transport component
+    typedef endpoint<config> type;
+
+    /// Type of the concurrency policy
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of the socket policy
+    typedef typename config::socket_type socket_type;
+    /// Type of the error logging policy
+    typedef typename config::elog_type elog_type;
+    /// Type of the access logging policy
+    typedef typename config::alog_type alog_type;
+
+    /// Type of the socket connection component
+    typedef typename socket_type::socket_con_type socket_con_type;
+    /// Type of a shared pointer to the socket connection component
+    typedef typename socket_con_type::ptr socket_con_ptr;
+
+    /// Type of the connection transport component associated with this
+    /// endpoint transport component
+    typedef asio::connection<config> transport_con_type;
+    /// Type of a shared pointer to the connection transport component
+    /// associated with this endpoint transport component
+    typedef typename transport_con_type::ptr transport_con_ptr;
+
+    /// Type of a pointer to the ASIO io_service being used
+    typedef boost::asio::io_service* io_service_ptr;
+    /// Type of a shared pointer to the acceptor being used
+    typedef lib::shared_ptr<boost::asio::ip::tcp::acceptor> acceptor_ptr;
+    /// Type of a shared pointer to the resolver being used
+    typedef lib::shared_ptr<boost::asio::ip::tcp::resolver> resolver_ptr;
+    /// Type of timer handle
+    typedef lib::shared_ptr<boost::asio::deadline_timer> timer_ptr;
+    /// Type of a shared pointer to an io_service work object
+    typedef lib::shared_ptr<boost::asio::io_service::work> work_ptr;
+
+    // generate and manage our own io_service
+    explicit endpoint()
+      : m_io_service(NULL)
+      , m_external_io_service(false)
+      , m_listen_backlog(0)
+      , m_reuse_addr(false)
+      , m_state(UNINITIALIZED)
+    {
+        //std::cout << "transport::asio::endpoint constructor" << std::endl;
+    }
+
+    ~endpoint() {
+        // clean up our io_service if we were initialized with an internal one.
+        m_acceptor.reset();
+        if (m_state != UNINITIALIZED && !m_external_io_service) {
+            delete m_io_service;
+        }
+    }
+
+    /// transport::asio objects are moveable but not copyable or assignable.
+    /// The following code sets this situation up based on whether or not we
+    /// have C++11 support or not
+#ifdef _WEBSOCKETPP_DELETED_FUNCTIONS_
+    endpoint(const endpoint& src) = delete;
+    endpoint& operator= (const endpoint & rhs) = delete;
+#else
+private:
+    endpoint(const endpoint& src);
+    endpoint& operator= (const endpoint & rhs);
+public:
+#endif
+
+#ifdef _WEBSOCKETPP_RVALUE_REFERENCES_
+    endpoint (endpoint&& src)
+      : m_io_service(src.m_io_service)
+      , m_external_io_service(src.m_external_io_service)
+      , m_acceptor(src.m_acceptor)
+      , m_listen_backlog(boost::asio::socket_base::max_connections)
+      , m_reuse_addr(src.m_reuse_addr)
+      , m_state(src.m_state)
+    {
+        src.m_io_service = NULL;
+        src.m_external_io_service = false;
+        src.m_acceptor = NULL;
+        src.m_state = UNINITIALIZED;
+    }
+
+    endpoint& operator= (const endpoint && rhs) {
+        if (this != &rhs) {
+            m_io_service = rhs.m_io_service;
+            m_external_io_service = rhs.m_external_io_service;
+            m_acceptor = rhs.m_acceptor;
+            m_listen_backlog = rhs.m_listen_backlog;
+            m_reuse_addr = rhs.m_reuse_addr;
+            m_state = rhs.m_state;
+
+            rhs.m_io_service = NULL;
+            rhs.m_external_io_service = false;
+            rhs.m_acceptor = NULL;
+            rhs.m_listen_backlog = boost::asio::socket_base::max_connections;
+            rhs.m_state = UNINITIALIZED;
+        }
+        return *this;
+    }
+#endif
+    /// Return whether or not the endpoint produces secure connections.
+    bool is_secure() const {
+        return socket_type::is_secure();
+    }
+
+    /// initialize asio transport with external io_service (exception free)
+    /**
+     * Initialize the ASIO transport policy for this endpoint using the provided
+     * io_service object. asio_init must be called exactly once on any endpoint
+     * that uses transport::asio before it can be used.
+     *
+     * @param ptr A pointer to the io_service to use for asio events
+     * @param ec Set to indicate what error occurred, if any.
+     */
+    void init_asio(io_service_ptr ptr, lib::error_code & ec) {
+        if (m_state != UNINITIALIZED) {
+            m_elog->write(log::elevel::library,
+                "asio::init_asio called from the wrong state");
+            using websocketpp::error::make_error_code;
+            ec = make_error_code(websocketpp::error::invalid_state);
+            return;
+        }
+
+        m_alog->write(log::alevel::devel,"asio::init_asio");
+
+        m_io_service = ptr;
+        m_external_io_service = true;
+        m_acceptor = lib::make_shared<boost::asio::ip::tcp::acceptor>(
+            lib::ref(*m_io_service));
+
+        m_state = READY;
+        ec = lib::error_code();
+    }
+
+    /// initialize asio transport with external io_service
+    /**
+     * Initialize the ASIO transport policy for this endpoint using the provided
+     * io_service object. asio_init must be called exactly once on any endpoint
+     * that uses transport::asio before it can be used.
+     *
+     * @param ptr A pointer to the io_service to use for asio events
+     */
+    void init_asio(io_service_ptr ptr) {
+        lib::error_code ec;
+        init_asio(ptr,ec);
+        if (ec) { throw exception(ec); }
+    }
+
+    /// Initialize asio transport with internal io_service (exception free)
+    /**
+     * This method of initialization will allocate and use an internally managed
+     * io_service.
+     *
+     * @see init_asio(io_service_ptr ptr)
+     *
+     * @param ec Set to indicate what error occurred, if any.
+     */
+    void init_asio(lib::error_code & ec) {
+        init_asio(new boost::asio::io_service(), ec);
+        m_external_io_service = false;
+    }
+
+    /// Initialize asio transport with internal io_service
+    /**
+     * This method of initialization will allocate and use an internally managed
+     * io_service.
+     *
+     * @see init_asio(io_service_ptr ptr)
+     */
+    void init_asio() {
+        init_asio(new boost::asio::io_service());
+        m_external_io_service = false;
+    }
+
+    /// Sets the tcp pre init handler
+    /**
+     * The tcp pre init handler is called after the raw tcp connection has been
+     * established but before any additional wrappers (proxy connects, TLS
+     * handshakes, etc) have been performed.
+     *
+     * @since 0.3.0
+     *
+     * @param h The handler to call on tcp pre init.
+     */
+    void set_tcp_pre_init_handler(tcp_init_handler h) {
+        m_tcp_pre_init_handler = h;
+    }
+
+    /// Sets the tcp pre init handler (deprecated)
+    /**
+     * The tcp pre init handler is called after the raw tcp connection has been
+     * established but before any additional wrappers (proxy connects, TLS
+     * handshakes, etc) have been performed.
+     *
+     * @deprecated Use set_tcp_pre_init_handler instead
+     *
+     * @param h The handler to call on tcp pre init.
+     */
+    void set_tcp_init_handler(tcp_init_handler h) {
+        set_tcp_pre_init_handler(h);
+    }
+
+    /// Sets the tcp post init handler
+    /**
+     * The tcp post init handler is called after the tcp connection has been
+     * established and all additional wrappers (proxy connects, TLS handshakes,
+     * etc have been performed. This is fired before any bytes are read or any
+     * WebSocket specific handshake logic has been performed.
+     *
+     * @since 0.3.0
+     *
+     * @param h The handler to call on tcp post init.
+     */
+    void set_tcp_post_init_handler(tcp_init_handler h) {
+        m_tcp_post_init_handler = h;
+    }
+
+    /// Sets the maximum length of the queue of pending connections.
+    /**
+     * Sets the maximum length of the queue of pending connections. Increasing
+     * this will allow WebSocket++ to queue additional incoming connections.
+     * Setting it higher may prevent failed connections at high connection rates
+     * but may cause additional latency.
+     *
+     * For this value to take effect you may need to adjust operating system
+     * settings.
+     *
+     * New values affect future calls to listen only.
+     *
+     * A value of zero will use the operating system default. This is the
+     * default value.
+     *
+     * @since 0.3.0
+     *
+     * @param backlog The maximum length of the queue of pending connections
+     */
+    void set_listen_backlog(int backlog) {
+        m_listen_backlog = backlog;
+    }
+
+    /// Sets whether to use the SO_REUSEADDR flag when opening listening sockets
+    /**
+     * Specifies whether or not to use the SO_REUSEADDR TCP socket option. What
+     * this flag does depends on your operating system. Please consult operating
+     * system documentation for more details.
+     *
+     * New values affect future calls to listen only.
+     *
+     * The default is false.
+     *
+     * @since 0.3.0
+     *
+     * @param value Whether or not to use the SO_REUSEADDR option
+     */
+    void set_reuse_addr(bool value) {
+        m_reuse_addr = value;
+    }
+
+    /// Retrieve a reference to the endpoint's io_service
+    /**
+     * The io_service may be an internal or external one. This may be used to
+     * call methods of the io_service that are not explicitly wrapped by the
+     * endpoint.
+     *
+     * This method is only valid after the endpoint has been initialized with
+     * `init_asio`. No error will be returned if it isn't.
+     *
+     * @return A reference to the endpoint's io_service
+     */
+    boost::asio::io_service & get_io_service() {
+        return *m_io_service;
+    }
+
+    /// Set up endpoint for listening manually (exception free)
+    /**
+     * Bind the internal acceptor using the specified settings. The endpoint
+     * must have been initialized by calling init_asio before listening.
+     *
+     * @param ep An endpoint to read settings from
+     * @param ec Set to indicate what error occurred, if any.
+     */
+    void listen(boost::asio::ip::tcp::endpoint const & ep, lib::error_code & ec)
+    {
+        if (m_state != READY) {
+            m_elog->write(log::elevel::library,
+                "asio::listen called from the wrong state");
+            using websocketpp::error::make_error_code;
+            ec = make_error_code(websocketpp::error::invalid_state);
+            return;
+        }
+
+        m_alog->write(log::alevel::devel,"asio::listen");
+
+        boost::system::error_code bec;
+
+        m_acceptor->open(ep.protocol(),bec);
+        if (!bec) {
+            m_acceptor->set_option(boost::asio::socket_base::reuse_address(m_reuse_addr),bec);
+        }
+        if (!bec) {
+            m_acceptor->bind(ep,bec);
+        }
+        if (!bec) {
+            m_acceptor->listen(m_listen_backlog,bec);
+        }
+        if (bec) {
+            if (m_acceptor->is_open()) {
+                m_acceptor->close();
+            }
+            log_err(log::elevel::info,"asio listen",bec);
+            ec = make_error_code(error::pass_through);
+        } else {
+            m_state = LISTENING;
+            ec = lib::error_code();
+        }
+    }
+
+    /// Set up endpoint for listening manually
+    /**
+     * Bind the internal acceptor using the settings specified by the endpoint e
+     *
+     * @param ep An endpoint to read settings from
+     */
+    void listen(boost::asio::ip::tcp::endpoint const & ep) {
+        lib::error_code ec;
+        listen(ep,ec);
+        if (ec) { throw exception(ec); }
+    }
+
+    /// Set up endpoint for listening with protocol and port (exception free)
+    /**
+     * Bind the internal acceptor using the given internet protocol and port.
+     * The endpoint must have been initialized by calling init_asio before
+     * listening.
+     *
+     * Common options include:
+     * - IPv6 with mapped IPv4 for dual stack hosts boost::asio::ip::tcp::v6()
+     * - IPv4 only: boost::asio::ip::tcp::v4()
+     *
+     * @param internet_protocol The internet protocol to use.
+     * @param port The port to listen on.
+     * @param ec Set to indicate what error occurred, if any.
+     */
+    template <typename InternetProtocol>
+    void listen(InternetProtocol const & internet_protocol, uint16_t port,
+        lib::error_code & ec)
+    {
+        boost::asio::ip::tcp::endpoint ep(internet_protocol, port);
+        listen(ep,ec);
+    }
+
+    /// Set up endpoint for listening with protocol and port
+    /**
+     * Bind the internal acceptor using the given internet protocol and port.
+     * The endpoint must have been initialized by calling init_asio before
+     * listening.
+     *
+     * Common options include:
+     * - IPv6 with mapped IPv4 for dual stack hosts boost::asio::ip::tcp::v6()
+     * - IPv4 only: boost::asio::ip::tcp::v4()
+     *
+     * @param internet_protocol The internet protocol to use.
+     * @param port The port to listen on.
+     */
+    template <typename InternetProtocol>
+    void listen(InternetProtocol const & internet_protocol, uint16_t port)
+    {
+        boost::asio::ip::tcp::endpoint ep(internet_protocol, port);
+        listen(ep);
+    }
+
+    /// Set up endpoint for listening on a port (exception free)
+    /**
+     * Bind the internal acceptor using the given port. The IPv6 protocol with
+     * mapped IPv4 for dual stack hosts will be used. If you need IPv4 only use
+     * the overload that allows specifying the protocol explicitly.
+     *
+     * The endpoint must have been initialized by calling init_asio before
+     * listening.
+     *
+     * @param port The port to listen on.
+     * @param ec Set to indicate what error occurred, if any.
+     */
+    void listen(uint16_t port, lib::error_code & ec) {
+        listen(boost::asio::ip::tcp::v6(), port, ec);
+    }
+
+    /// Set up endpoint for listening on a port
+    /**
+     * Bind the internal acceptor using the given port. The IPv6 protocol with
+     * mapped IPv4 for dual stack hosts will be used. If you need IPv4 only use
+     * the overload that allows specifying the protocol explicitly.
+     *
+     * The endpoint must have been initialized by calling init_asio before
+     * listening.
+     *
+     * @param port The port to listen on.
+     * @param ec Set to indicate what error occurred, if any.
+     */
+    void listen(uint16_t port) {
+        listen(boost::asio::ip::tcp::v6(), port);
+    }
+
+    /// Set up endpoint for listening on a host and service (exception free)
+    /**
+     * Bind the internal acceptor using the given host and service. More details
+     * about what host and service can be are available in the boost asio
+     * documentation for ip::basic_resolver_query::basic_resolver_query's
+     * constructors.
+     *
+     * The endpoint must have been initialized by calling init_asio before
+     * listening.
+     *
+     * @param host A string identifying a location. May be a descriptive name or
+     * a numeric address string.
+     * @param service A string identifying the requested service. This may be a
+     * descriptive name or a numeric string corresponding to a port number.
+     * @param ec Set to indicate what error occurred, if any.
+     */
+    void listen(std::string const & host, std::string const & service,
+        lib::error_code & ec)
+    {
+        using boost::asio::ip::tcp;
+        tcp::resolver r(*m_io_service);
+        tcp::resolver::query query(host, service);
+        tcp::resolver::iterator endpoint_iterator = r.resolve(query);
+        tcp::resolver::iterator end;
+        if (endpoint_iterator == end) {
+            m_elog->write(log::elevel::library,
+                "asio::listen could not resolve the supplied host or service");
+            ec = make_error_code(error::invalid_host_service);
+            return;
+        }
+        listen(*endpoint_iterator,ec);
+    }
+
+    /// Set up endpoint for listening on a host and service
+    /**
+     * Bind the internal acceptor using the given host and service. More details
+     * about what host and service can be are available in the boost asio
+     * documentation for ip::basic_resolver_query::basic_resolver_query's
+     * constructors.
+     *
+     * The endpoint must have been initialized by calling init_asio before
+     * listening.
+     *
+     * @param host A string identifying a location. May be a descriptive name or
+     * a numeric address string.
+     * @param service A string identifying the requested service. This may be a
+     * descriptive name or a numeric string corresponding to a port number.
+     * @param ec Set to indicate what error occurred, if any.
+     */
+    void listen(std::string const & host, std::string const & service)
+    {
+        lib::error_code ec;
+        listen(host,service,ec);
+        if (ec) { throw exception(ec); }
+    }
+
+    /// Stop listening (exception free)
+    /**
+     * Stop listening and accepting new connections. This will not end any
+     * existing connections.
+     *
+     * @since 0.3.0-alpha4
+     * @param ec A status code indicating an error, if any.
+     */
+    void stop_listening(lib::error_code & ec) {
+        if (m_state != LISTENING) {
+            m_elog->write(log::elevel::library,
+                "asio::listen called from the wrong state");
+            using websocketpp::error::make_error_code;
+            ec = make_error_code(websocketpp::error::invalid_state);
+            return;
+        }
+
+        m_acceptor->close();
+        m_state = READY;
+        ec = lib::error_code();
+    }
+
+    /// Stop listening
+    /**
+     * Stop listening and accepting new connections. This will not end any
+     * existing connections.
+     *
+     * @since 0.3.0-alpha4
+     */
+    void stop_listening() {
+        lib::error_code ec;
+        stop_listening(ec);
+        if (ec) { throw exception(ec); }
+    }
+
+    /// Check if the endpoint is listening
+    /**
+     * @return Whether or not the endpoint is listening.
+     */
+    bool is_listening() const {
+        return (m_state == LISTENING);
+    }
+
+    /// wraps the run method of the internal io_service object
+    std::size_t run() {
+        return m_io_service->run();
+    }
+
+    /// wraps the run_one method of the internal io_service object
+    /**
+     * @since 0.3.0-alpha4
+     */
+    std::size_t run_one() {
+        return m_io_service->run_one();
+    }
+
+    /// wraps the stop method of the internal io_service object
+    void stop() {
+        m_io_service->stop();
+    }
+
+    /// wraps the poll method of the internal io_service object
+    std::size_t poll() {
+        return m_io_service->poll();
+    }
+
+    /// wraps the poll_one method of the internal io_service object
+    std::size_t poll_one() {
+        return m_io_service->poll_one();
+    }
+
+    /// wraps the reset method of the internal io_service object
+    void reset() {
+        m_io_service->reset();
+    }
+
+    /// wraps the stopped method of the internal io_service object
+    bool stopped() const {
+        return m_io_service->stopped();
+    }
+
+    /// Marks the endpoint as perpetual, stopping it from exiting when empty
+    /**
+     * Marks the endpoint as perpetual. Perpetual endpoints will not
+     * automatically exit when they run out of connections to process. To stop
+     * a perpetual endpoint call `end_perpetual`.
+     *
+     * An endpoint may be marked perpetual at any time by any thread. It must be
+     * called either before the endpoint has run out of work or before it was
+     * started
+     *
+     * @since 0.3.0
+     */
+    void start_perpetual() {
+        m_work = lib::make_shared<boost::asio::io_service::work>(
+            lib::ref(*m_io_service)
+        );
+    }
+
+    /// Clears the endpoint's perpetual flag, allowing it to exit when empty
+    /**
+     * Clears the endpoint's perpetual flag. This will cause the endpoint's run
+     * method to exit normally when it runs out of connections. If there are
+     * currently active connections it will not end until they are complete.
+     *
+     * @since 0.3.0
+     */
+    void stop_perpetual() {
+        m_work.reset();
+    }
+
+    /// Call back a function after a period of time.
+    /**
+     * Sets a timer that calls back a function after the specified period of
+     * milliseconds. Returns a handle that can be used to cancel the timer.
+     * A cancelled timer will return the error code error::operation_aborted
+     * A timer that expired will return no error.
+     *
+     * @param duration Length of time to wait in milliseconds
+     * @param callback The function to call back when the timer has expired
+     * @return A handle that can be used to cancel the timer if it is no longer
+     * needed.
+     */
+    timer_ptr set_timer(long duration, timer_handler callback) {
+        timer_ptr new_timer = lib::make_shared<boost::asio::deadline_timer>(
+            *m_io_service,
+            boost::posix_time::milliseconds(duration)
+        );
+
+        new_timer->async_wait(
+            lib::bind(
+                &type::handle_timer,
+                this,
+                new_timer,
+                callback,
+                lib::placeholders::_1
+            )
+        );
+
+        return new_timer;
+    }
+
+    /// Timer handler
+    /**
+     * The timer pointer is included to ensure the timer isn't destroyed until
+     * after it has expired.
+     *
+     * @param t Pointer to the timer in question
+     * @param callback The function to call back
+     * @param ec A status code indicating an error, if any.
+     */
+    void handle_timer(timer_ptr, timer_handler callback,
+        boost::system::error_code const & ec)
+    {
+        if (ec) {
+            if (ec == boost::asio::error::operation_aborted) {
+                callback(make_error_code(transport::error::operation_aborted));
+            } else {
+                m_elog->write(log::elevel::info,
+                    "asio handle_timer error: "+ec.message());
+                log_err(log::elevel::info,"asio handle_timer",ec);
+                callback(make_error_code(error::pass_through));
+            }
+        } else {
+            callback(lib::error_code());
+        }
+    }
+
+    /// Accept the next connection attempt and assign it to con (exception free)
+    /**
+     * @param tcon The connection to accept into.
+     * @param callback The function to call when the operation is complete.
+     * @param ec A status code indicating an error, if any.
+     */
+    void async_accept(transport_con_ptr tcon, accept_handler callback,
+        lib::error_code & ec)
+    {
+        if (m_state != LISTENING) {
+            using websocketpp::error::make_error_code;
+            ec = make_error_code(websocketpp::error::async_accept_not_listening);
+            return;
+        }
+
+        m_alog->write(log::alevel::devel, "asio::async_accept");
+
+        if (config::enable_multithreading) {
+            m_acceptor->async_accept(
+                tcon->get_raw_socket(),
+                tcon->get_strand()->wrap(lib::bind(
+                    &type::handle_accept,
+                    this,
+                    callback,
+                    lib::placeholders::_1
+                ))
+            );
+        } else {
+            m_acceptor->async_accept(
+                tcon->get_raw_socket(),
+                lib::bind(
+                    &type::handle_accept,
+                    this,
+                    callback,
+                    lib::placeholders::_1
+                )
+            );
+        }
+    }
+
+    /// Accept the next connection attempt and assign it to con.
+    /**
+     * @param tcon The connection to accept into.
+     * @param callback The function to call when the operation is complete.
+     */
+    void async_accept(transport_con_ptr tcon, accept_handler callback) {
+        lib::error_code ec;
+        async_accept(tcon,callback,ec);
+        if (ec) { throw exception(ec); }
+    }
+protected:
+    /// Initialize logging
+    /**
+     * The loggers are located in the main endpoint class. As such, the
+     * transport doesn't have direct access to them. This method is called
+     * by the endpoint constructor to allow shared logging from the transport
+     * component. These are raw pointers to member variables of the endpoint.
+     * In particular, they cannot be used in the transport constructor as they
+     * haven't been constructed yet, and cannot be used in the transport
+     * destructor as they will have been destroyed by then.
+     */
+    void init_logging(alog_type* a, elog_type* e) {
+        m_alog = a;
+        m_elog = e;
+    }
+
+    void handle_accept(accept_handler callback, boost::system::error_code const
+        & boost_ec)
+    {
+        lib::error_code ret_ec;
+
+        m_alog->write(log::alevel::devel, "asio::handle_accept");
+
+        if (boost_ec) {
+            if (boost_ec == boost::system::errc::operation_canceled) {
+                ret_ec = make_error_code(websocketpp::error::operation_canceled);
+            } else {
+                log_err(log::elevel::info,"asio handle_accept",boost_ec);
+                ret_ec = make_error_code(error::pass_through);
+            }
+        }
+
+        callback(ret_ec);
+    }
+
+    /// Initiate a new connection
+    // TODO: there have to be some more failure conditions here
+    void async_connect(transport_con_ptr tcon, uri_ptr u, connect_handler cb) {
+        using namespace boost::asio::ip;
+
+        // Create a resolver
+        if (!m_resolver) {
+            m_resolver = lib::make_shared<boost::asio::ip::tcp::resolver>(
+                lib::ref(*m_io_service));
+        }
+
+        std::string proxy = tcon->get_proxy();
+        std::string host;
+        std::string port;
+
+        if (proxy.empty()) {
+            host = u->get_host();
+            port = u->get_port_str();
+        } else {
+            lib::error_code ec;
+
+            uri_ptr pu = lib::make_shared<uri>(proxy);
+
+            if (!pu->get_valid()) {
+                cb(make_error_code(error::proxy_invalid));
+                return;
+            }
+
+            ec = tcon->proxy_init(u->get_authority());
+            if (ec) {
+                cb(ec);
+                return;
+            }
+
+            host = pu->get_host();
+            port = pu->get_port_str();
+        }
+
+        tcp::resolver::query query(host,port);
+
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,
+                "starting async DNS resolve for "+host+":"+port);
+        }
+
+        timer_ptr dns_timer;
+
+        dns_timer = tcon->set_timer(
+            config::timeout_dns_resolve,
+            lib::bind(
+                &type::handle_resolve_timeout,
+                this,
+                dns_timer,
+                cb,
+                lib::placeholders::_1
+            )
+        );
+
+        if (config::enable_multithreading) {
+            m_resolver->async_resolve(
+                query,
+                tcon->get_strand()->wrap(lib::bind(
+                    &type::handle_resolve,
+                    this,
+                    tcon,
+                    dns_timer,
+                    cb,
+                    lib::placeholders::_1,
+                    lib::placeholders::_2
+                ))
+            );
+        } else {
+            m_resolver->async_resolve(
+                query,
+                lib::bind(
+                    &type::handle_resolve,
+                    this,
+                    tcon,
+                    dns_timer,
+                    cb,
+                    lib::placeholders::_1,
+                    lib::placeholders::_2
+                )
+            );
+        }
+    }
+
+    /// DNS resolution timeout handler
+    /**
+     * The timer pointer is included to ensure the timer isn't destroyed until
+     * after it has expired.
+     *
+     * @param dns_timer Pointer to the timer in question
+     * @param callback The function to call back
+     * @param ec A status code indicating an error, if any.
+     */
+    void handle_resolve_timeout(timer_ptr, connect_handler callback,
+        lib::error_code const & ec)
+    {
+        lib::error_code ret_ec;
+
+        if (ec) {
+            if (ec == transport::error::operation_aborted) {
+                m_alog->write(log::alevel::devel,
+                    "asio handle_resolve_timeout timer cancelled");
+                return;
+            }
+
+            log_err(log::elevel::devel,"asio handle_resolve_timeout",ec);
+            ret_ec = ec;
+        } else {
+            ret_ec = make_error_code(transport::error::timeout);
+        }
+
+        m_alog->write(log::alevel::devel,"DNS resolution timed out");
+        m_resolver->cancel();
+        callback(ret_ec);
+    }
+
+    void handle_resolve(transport_con_ptr tcon, timer_ptr dns_timer,
+        connect_handler callback, boost::system::error_code const & ec,
+        boost::asio::ip::tcp::resolver::iterator iterator)
+    {
+        if (ec == boost::asio::error::operation_aborted ||
+            dns_timer->expires_from_now().is_negative())
+        {
+            m_alog->write(log::alevel::devel,"async_resolve cancelled");
+            return;
+        }
+
+        dns_timer->cancel();
+
+        if (ec) {
+            log_err(log::elevel::info,"asio async_resolve",ec);
+            callback(make_error_code(error::pass_through));
+            return;
+        }
+
+        if (m_alog->static_test(log::alevel::devel)) {
+            std::stringstream s;
+            s << "Async DNS resolve successful. Results: ";
+
+            boost::asio::ip::tcp::resolver::iterator it, end;
+            for (it = iterator; it != end; ++it) {
+                s << (*it).endpoint() << " ";
+            }
+
+            m_alog->write(log::alevel::devel,s.str());
+        }
+
+        m_alog->write(log::alevel::devel,"Starting async connect");
+
+        timer_ptr con_timer;
+
+        con_timer = tcon->set_timer(
+            config::timeout_connect,
+            lib::bind(
+                &type::handle_connect_timeout,
+                this,
+                tcon,
+                con_timer,
+                callback,
+                lib::placeholders::_1
+            )
+        );
+
+        if (config::enable_multithreading) {
+            boost::asio::async_connect(
+                tcon->get_raw_socket(),
+                iterator,
+                tcon->get_strand()->wrap(lib::bind(
+                    &type::handle_connect,
+                    this,
+                    tcon,
+                    con_timer,
+                    callback,
+                    lib::placeholders::_1
+                ))
+            );
+        } else {
+            boost::asio::async_connect(
+                tcon->get_raw_socket(),
+                iterator,
+                lib::bind(
+                    &type::handle_connect,
+                    this,
+                    tcon,
+                    con_timer,
+                    callback,
+                    lib::placeholders::_1
+                )
+            );
+        }
+    }
+
+    /// Asio connect timeout handler
+    /**
+     * The timer pointer is included to ensure the timer isn't destroyed until
+     * after it has expired.
+     *
+     * @param tcon Pointer to the transport connection that is being connected
+     * @param con_timer Pointer to the timer in question
+     * @param callback The function to call back
+     * @param ec A status code indicating an error, if any.
+     */
+    void handle_connect_timeout(transport_con_ptr tcon, timer_ptr,
+        connect_handler callback, lib::error_code const & ec)
+    {
+        lib::error_code ret_ec;
+
+        if (ec) {
+            if (ec == transport::error::operation_aborted) {
+                m_alog->write(log::alevel::devel,
+                    "asio handle_connect_timeout timer cancelled");
+                return;
+            }
+
+            log_err(log::elevel::devel,"asio handle_connect_timeout",ec);
+            ret_ec = ec;
+        } else {
+            ret_ec = make_error_code(transport::error::timeout);
+        }
+
+        m_alog->write(log::alevel::devel,"TCP connect timed out");
+        tcon->cancel_socket();
+        callback(ret_ec);
+    }
+
+    void handle_connect(transport_con_ptr tcon, timer_ptr con_timer,
+        connect_handler callback, boost::system::error_code const & ec)
+    {
+        if (ec == boost::asio::error::operation_aborted ||
+            con_timer->expires_from_now().is_negative())
+        {
+            m_alog->write(log::alevel::devel,"async_connect cancelled");
+            return;
+        }
+
+        con_timer->cancel();
+
+        if (ec) {
+            log_err(log::elevel::info,"asio async_connect",ec);
+            callback(make_error_code(error::pass_through));
+            return;
+        }
+
+        if (m_alog->static_test(log::alevel::devel)) {
+            m_alog->write(log::alevel::devel,
+                "Async connect to "+tcon->get_remote_endpoint()+" successful.");
+        }
+
+        callback(lib::error_code());
+    }
+
+    /// Initialize a connection
+    /**
+     * init is called by an endpoint once for each newly created connection.
+     * It's purpose is to give the transport policy the chance to perform any
+     * transport specific initialization that couldn't be done via the default
+     * constructor.
+     *
+     * @param tcon A pointer to the transport portion of the connection.
+     *
+     * @return A status code indicating the success or failure of the operation
+     */
+    lib::error_code init(transport_con_ptr tcon) {
+        m_alog->write(log::alevel::devel, "transport::asio::init");
+
+        // Initialize the connection socket component
+        socket_type::init(lib::static_pointer_cast<socket_con_type,
+            transport_con_type>(tcon));
+
+        lib::error_code ec;
+
+        ec = tcon->init_asio(m_io_service);
+        if (ec) {return ec;}
+
+        tcon->set_tcp_pre_init_handler(m_tcp_pre_init_handler);
+        tcon->set_tcp_post_init_handler(m_tcp_post_init_handler);
+
+        return lib::error_code();
+    }
+private:
+    /// Convenience method for logging the code and message for an error_code
+    template <typename error_type>
+    void log_err(log::level l, char const * msg, error_type const & ec) {
+        std::stringstream s;
+        s << msg << " error: " << ec << " (" << ec.message() << ")";
+        m_elog->write(l,s.str());
+    }
+
+    enum state {
+        UNINITIALIZED = 0,
+        READY = 1,
+        LISTENING = 2
+    };
+
+    // Handlers
+    tcp_init_handler    m_tcp_pre_init_handler;
+    tcp_init_handler    m_tcp_post_init_handler;
+
+    // Network Resources
+    io_service_ptr      m_io_service;
+    bool                m_external_io_service;
+    acceptor_ptr        m_acceptor;
+    resolver_ptr        m_resolver;
+    work_ptr            m_work;
+
+    // Network constants
+    int                 m_listen_backlog;
+    bool                m_reuse_addr;
+
+    elog_type* m_elog;
+    alog_type* m_alog;
+
+    // Transport state
+    state               m_state;
+};
+
+} // namespace asio
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_ASIO_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/asio/security/base.hpp b/extlibs/websocketpp/websocketpp/transport/asio/security/base.hpp
new file mode 100644
index 000000000..543a3533c
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/asio/security/base.hpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_ASIO_SOCKET_BASE_HPP
+#define WEBSOCKETPP_TRANSPORT_ASIO_SOCKET_BASE_HPP
+
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/common/functional.hpp>
+#include <websocketpp/common/system_error.hpp>
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/connection_hdl.hpp>
+
+#include <boost/asio.hpp>
+
+#include <string>
+
+// Interface that sockets/security policies must implement
+
+/*
+ * Endpoint Interface
+ *
+ * bool is_secure() const;
+ * @return Whether or not the endpoint creates secure connections
+ *
+ * lib::error_code init(socket_con_ptr scon);
+ * Called by the transport after a new connection is created to initialize
+ * the socket component of the connection.
+ * @param scon Pointer to the socket component of the connection
+ * @return Error code (empty on success)
+ */
+
+
+// Connection
+// TODO
+// pre_init(init_handler);
+// post_init(init_handler);
+
+namespace websocketpp {
+namespace transport {
+namespace asio {
+namespace socket {
+
+/**
+ * The transport::asio::socket::* classes are a set of security/socket related
+ * policies and support code for the ASIO transport types.
+ */
+
+/// Errors related to asio transport sockets
+namespace error {
+    enum value {
+        /// Catch-all error for security policy errors that don't fit in other
+        /// categories
+        security = 1,
+
+        /// Catch-all error for socket component errors that don't fit in other
+        /// categories
+        socket,
+
+        /// A function was called in a state that it was illegal to do so.
+        invalid_state,
+
+        /// The application was prompted to provide a TLS context and it was
+        /// empty or otherwise invalid
+        invalid_tls_context,
+
+        /// TLS Handshake Timeout
+        tls_handshake_timeout,
+
+        /// pass_through from underlying library
+        pass_through,
+
+        /// Required tls_init handler not present
+        missing_tls_init_handler,
+
+        /// TLS Handshake Failed
+        tls_handshake_failed
+    };
+} // namespace error
+
+/// Error category related to asio transport socket policies
+class socket_category : public lib::error_category {
+public:
+    char const * name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp.transport.asio.socket";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case error::security:
+                return "Security policy error";
+            case error::socket:
+                return "Socket component error";
+            case error::invalid_state:
+                return "Invalid state";
+            case error::invalid_tls_context:
+                return "Invalid or empty TLS context supplied";
+            case error::tls_handshake_timeout:
+                return "TLS handshake timed out";
+            case error::pass_through:
+                return "Pass through from socket policy";
+            case error::missing_tls_init_handler:
+                return "Required tls_init handler not present.";
+            case error::tls_handshake_failed:
+                return "TLS handshake failed";
+            default:
+                return "Unknown";
+        }
+    }
+};
+
+inline lib::error_category const & get_socket_category() {
+    static socket_category instance;
+    return instance;
+}
+
+inline lib::error_code make_error_code(error::value e) {
+    return lib::error_code(static_cast<int>(e), get_socket_category());
+}
+
+/// Type of asio transport socket policy initialization handlers
+typedef lib::function<void(const lib::error_code&)> init_handler;
+
+} // namespace socket
+} // namespace asio
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_ASIO_SOCKET_BASE_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/asio/security/none.hpp b/extlibs/websocketpp/websocketpp/transport/asio/security/none.hpp
new file mode 100644
index 000000000..14b6f8b5f
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/asio/security/none.hpp
@@ -0,0 +1,329 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_SECURITY_NONE_HPP
+#define WEBSOCKETPP_TRANSPORT_SECURITY_NONE_HPP
+
+#include <websocketpp/transport/asio/security/base.hpp>
+
+#include <websocketpp/common/memory.hpp>
+
+#include <boost/asio.hpp>
+
+#include <sstream>
+#include <string>
+
+namespace websocketpp {
+namespace transport {
+namespace asio {
+/// A socket policy for the asio transport that implements a plain, unencrypted
+/// socket
+namespace basic_socket {
+
+/// The signature of the socket init handler for this socket policy
+typedef lib::function<void(connection_hdl,boost::asio::ip::tcp::socket&)>
+    socket_init_handler;
+
+/// Basic Boost ASIO connection socket component
+/**
+ * transport::asio::basic_socket::connection implements a connection socket
+ * component using Boost ASIO ip::tcp::socket.
+ */
+class connection : public lib::enable_shared_from_this<connection> {
+public:
+    /// Type of this connection socket component
+    typedef connection type;
+    /// Type of a shared pointer to this connection socket component
+    typedef lib::shared_ptr<type> ptr;
+
+    /// Type of a pointer to the ASIO io_service being used
+    typedef boost::asio::io_service* io_service_ptr;
+    /// Type of a pointer to the ASIO io_service strand being used
+    typedef lib::shared_ptr<boost::asio::io_service::strand> strand_ptr;
+    /// Type of the ASIO socket being used
+    typedef boost::asio::ip::tcp::socket socket_type;
+    /// Type of a shared pointer to the socket being used.
+    typedef lib::shared_ptr<socket_type> socket_ptr;
+
+    explicit connection() : m_state(UNINITIALIZED) {
+        //std::cout << "transport::asio::basic_socket::connection constructor"
+        //          << std::endl;
+    }
+
+    /// Get a shared pointer to this component
+    ptr get_shared() {
+        return shared_from_this();
+    }
+
+    /// Check whether or not this connection is secure
+    /**
+     * @return Whether or not this connection is secure
+     */
+    bool is_secure() const {
+        return false;
+    }
+
+    /// Set the socket initialization handler
+    /**
+     * The socket initialization handler is called after the socket object is
+     * created but before it is used. This gives the application a chance to
+     * set any ASIO socket options it needs.
+     *
+     * @param h The new socket_init_handler
+     */
+    void set_socket_init_handler(socket_init_handler h) {
+        m_socket_init_handler = h;
+    }
+
+    /// Retrieve a pointer to the underlying socket
+    /**
+     * This is used internally. It can also be used to set socket options, etc
+     */
+    boost::asio::ip::tcp::socket& get_socket() {
+        return *m_socket;
+    }
+
+    /// Retrieve a pointer to the underlying socket
+    /**
+     * This is used internally.
+     */
+    boost::asio::ip::tcp::socket& get_next_layer() {
+        return *m_socket;
+    }
+
+    /// Retrieve a pointer to the underlying socket
+    /**
+     * This is used internally. It can also be used to set socket options, etc
+     */
+    boost::asio::ip::tcp::socket& get_raw_socket() {
+        return *m_socket;
+    }
+
+    /// Get the remote endpoint address
+    /**
+     * The iostream transport has no information about the ultimate remote
+     * endpoint. It will return the string "iostream transport". To indicate
+     * this.
+     *
+     * TODO: allow user settable remote endpoint addresses if this seems useful
+     *
+     * @return A string identifying the address of the remote endpoint
+     */
+    std::string get_remote_endpoint(lib::error_code &ec) const {
+        std::stringstream s;
+
+        boost::system::error_code bec;
+        boost::asio::ip::tcp::endpoint ep = m_socket->remote_endpoint(bec);
+
+        if (bec) {
+            ec = error::make_error_code(error::pass_through);
+            s << "Error getting remote endpoint: " << bec
+               << " (" << bec.message() << ")";
+            return s.str();
+        } else {
+            ec = lib::error_code();
+            s << ep;
+            return s.str();
+        }
+    }
+protected:
+    /// Perform one time initializations
+    /**
+     * init_asio is called once immediately after construction to initialize
+     * boost::asio components to the io_service
+     *
+     * @param service A pointer to the endpoint's io_service
+     * @param strand A shared pointer to the connection's asio strand
+     * @param is_server Whether or not the endpoint is a server or not.
+     */
+    lib::error_code init_asio (io_service_ptr service, strand_ptr, bool)
+    {
+        if (m_state != UNINITIALIZED) {
+            return socket::make_error_code(socket::error::invalid_state);
+        }
+
+        m_socket = lib::make_shared<boost::asio::ip::tcp::socket>(
+            lib::ref(*service));
+
+        m_state = READY;
+
+        return lib::error_code();
+    }
+
+    /// Pre-initialize security policy
+    /**
+     * Called by the transport after a new connection is created to initialize
+     * the socket component of the connection. This method is not allowed to
+     * write any bytes to the wire. This initialization happens before any
+     * proxies or other intermediate wrappers are negotiated.
+     *
+     * @param callback Handler to call back with completion information
+     */
+    void pre_init(init_handler callback) {
+        if (m_state != READY) {
+            callback(socket::make_error_code(socket::error::invalid_state));
+            return;
+        }
+
+        if (m_socket_init_handler) {
+            m_socket_init_handler(m_hdl,*m_socket);
+        }
+
+        m_state = READING;
+
+        callback(lib::error_code());
+    }
+
+    /// Post-initialize security policy
+    /**
+     * Called by the transport after all intermediate proxies have been
+     * negotiated. This gives the security policy the chance to talk with the
+     * real remote endpoint for a bit before the websocket handshake.
+     *
+     * @param callback Handler to call back with completion information
+     */
+    void post_init(init_handler callback) {
+        callback(lib::error_code());
+    }
+
+    /// Sets the connection handle
+    /**
+     * The connection handle is passed to any handlers to identify the
+     * connection
+     *
+     * @param hdl The new handle
+     */
+    void set_handle(connection_hdl hdl) {
+        m_hdl = hdl;
+    }
+
+    /// Cancel all async operations on this socket
+    void cancel_socket() {
+        m_socket->cancel();
+    }
+
+    void async_shutdown(socket_shutdown_handler h) {
+        boost::system::error_code ec;
+        m_socket->shutdown(boost::asio::ip::tcp::socket::shutdown_both,ec);
+        h(ec);
+    }
+
+    lib::error_code get_ec() const {
+        return lib::error_code();
+    }
+
+    /// Translate any security policy specific information about an error code
+    /**
+     * Translate_ec takes a boost error code and attempts to convert its value
+     * to an appropriate websocketpp error code. The plain socket policy does
+     * not presently provide any additional information so all errors will be
+     * reported as the generic transport pass_through error.
+     *
+     * @since 0.3.0
+     *
+     * @param ec The error code to translate_ec
+     * @return The translated error code
+     */
+    lib::error_code translate_ec(boost::system::error_code) {
+        // We don't know any more information about this error so pass through
+        return make_error_code(transport::error::pass_through);
+    }
+private:
+    enum state {
+        UNINITIALIZED = 0,
+        READY = 1,
+        READING = 2
+    };
+
+    socket_ptr          m_socket;
+    state               m_state;
+
+    connection_hdl      m_hdl;
+    socket_init_handler m_socket_init_handler;
+};
+
+/// Basic ASIO endpoint socket component
+/**
+ * transport::asio::basic_socket::endpoint implements an endpoint socket
+ * component that uses Boost ASIO's ip::tcp::socket.
+ */
+class endpoint {
+public:
+    /// The type of this endpoint socket component
+    typedef endpoint type;
+
+    /// The type of the corresponding connection socket component
+    typedef connection socket_con_type;
+    /// The type of a shared pointer to the corresponding connection socket
+    /// component.
+    typedef socket_con_type::ptr socket_con_ptr;
+
+    explicit endpoint() {}
+
+    /// Checks whether the endpoint creates secure connections
+    /**
+     * @return Whether or not the endpoint creates secure connections
+     */
+    bool is_secure() const {
+        return false;
+    }
+
+    /// Set socket init handler
+    /**
+     * The socket init handler is called after a connection's socket is created
+     * but before it is used. This gives the end application an opportunity to
+     * set asio socket specific parameters.
+     *
+     * @param h The new socket_init_handler
+     */
+    void set_socket_init_handler(socket_init_handler h) {
+        m_socket_init_handler = h;
+    }
+protected:
+    /// Initialize a connection
+    /**
+     * Called by the transport after a new connection is created to initialize
+     * the socket component of the connection.
+     *
+     * @param scon Pointer to the socket component of the connection
+     *
+     * @return Error code (empty on success)
+     */
+    lib::error_code init(socket_con_ptr scon) {
+        scon->set_socket_init_handler(m_socket_init_handler);
+        return lib::error_code();
+    }
+private:
+    socket_init_handler m_socket_init_handler;
+};
+
+} // namespace basic_socket
+} // namespace asio
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_SECURITY_NONE_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/asio/security/tls.hpp b/extlibs/websocketpp/websocketpp/transport/asio/security/tls.hpp
new file mode 100644
index 000000000..8434a5c3d
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/asio/security/tls.hpp
@@ -0,0 +1,421 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_SECURITY_TLS_HPP
+#define WEBSOCKETPP_TRANSPORT_SECURITY_TLS_HPP
+
+#include <websocketpp/transport/asio/security/base.hpp>
+
+#include <websocketpp/common/connection_hdl.hpp>
+#include <websocketpp/common/functional.hpp>
+#include <websocketpp/common/memory.hpp>
+
+#include <boost/asio.hpp>
+#include <boost/asio/ssl.hpp>
+#include <boost/system/error_code.hpp>
+
+#include <sstream>
+#include <string>
+
+namespace websocketpp {
+namespace transport {
+namespace asio {
+/// A socket policy for the asio transport that implements a TLS encrypted
+/// socket by wrapping with an asio::ssl::stream
+namespace tls_socket {
+
+/// The signature of the socket_init_handler for this socket policy
+typedef lib::function<void(connection_hdl,boost::asio::ssl::stream<
+    boost::asio::ip::tcp::socket>&)> socket_init_handler;
+/// The signature of the tls_init_handler for this socket policy
+typedef lib::function<lib::shared_ptr<boost::asio::ssl::context>(connection_hdl)>
+    tls_init_handler;
+
+/// TLS enabled Boost ASIO connection socket component
+/**
+ * transport::asio::tls_socket::connection implements a secure connection socket
+ * component that uses Boost ASIO's ssl::stream to wrap an ip::tcp::socket.
+ */
+class connection : public lib::enable_shared_from_this<connection> {
+public:
+    /// Type of this connection socket component
+    typedef connection type;
+    /// Type of a shared pointer to this connection socket component
+    typedef lib::shared_ptr<type> ptr;
+
+    /// Type of the ASIO socket being used
+    typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> socket_type;
+    /// Type of a shared pointer to the ASIO socket being used
+    typedef lib::shared_ptr<socket_type> socket_ptr;
+    /// Type of a pointer to the ASIO io_service being used
+    typedef boost::asio::io_service* io_service_ptr;
+    /// Type of a pointer to the ASIO io_service strand being used
+    typedef lib::shared_ptr<boost::asio::io_service::strand> strand_ptr;
+    /// Type of a shared pointer to the ASIO TLS context being used
+    typedef lib::shared_ptr<boost::asio::ssl::context> context_ptr;
+
+    typedef boost::system::error_code boost_error;
+
+    explicit connection() {
+        //std::cout << "transport::asio::tls_socket::connection constructor"
+        //          << std::endl;
+    }
+
+    /// Get a shared pointer to this component
+    ptr get_shared() {
+        return shared_from_this();
+    }
+
+    /// Check whether or not this connection is secure
+    /**
+     * @return Whether or not this connection is secure
+     */
+    bool is_secure() const {
+        return true;
+    }
+
+    /// Retrieve a pointer to the underlying socket
+    /**
+     * This is used internally. It can also be used to set socket options, etc
+     */
+    socket_type::lowest_layer_type& get_raw_socket() {
+        return m_socket->lowest_layer();
+    }
+
+    /// Retrieve a pointer to the layer below the ssl stream
+    /**
+     * This is used internally.
+     */
+    socket_type::next_layer_type& get_next_layer() {
+        return m_socket->next_layer();
+    }
+
+    /// Retrieve a pointer to the wrapped socket
+    /**
+     * This is used internally.
+     */
+    socket_type& get_socket() {
+        return *m_socket;
+    }
+
+    /// Set the socket initialization handler
+    /**
+     * The socket initialization handler is called after the socket object is
+     * created but before it is used. This gives the application a chance to
+     * set any ASIO socket options it needs.
+     *
+     * @param h The new socket_init_handler
+     */
+    void set_socket_init_handler(socket_init_handler h) {
+        m_socket_init_handler = h;
+    }
+
+    /// Set TLS init handler
+    /**
+     * The tls init handler is called when needed to request a TLS context for
+     * the library to use. A TLS init handler must be set and it must return a
+     * valid TLS context in order for this endpoint to be able to initialize
+     * TLS connections
+     *
+     * @param h The new tls_init_handler
+     */
+    void set_tls_init_handler(tls_init_handler h) {
+        m_tls_init_handler = h;
+    }
+
+    /// Get the remote endpoint address
+    /**
+     * The iostream transport has no information about the ultimate remote
+     * endpoint. It will return the string "iostream transport". To indicate
+     * this.
+     *
+     * TODO: allow user settable remote endpoint addresses if this seems useful
+     *
+     * @return A string identifying the address of the remote endpoint
+     */
+    std::string get_remote_endpoint(lib::error_code &ec) const {
+        std::stringstream s;
+
+        boost::system::error_code bec;
+        boost::asio::ip::tcp::endpoint ep = m_socket->lowest_layer().remote_endpoint(bec);
+
+        if (bec) {
+            ec = error::make_error_code(error::pass_through);
+            s << "Error getting remote endpoint: " << bec
+               << " (" << bec.message() << ")";
+            return s.str();
+        } else {
+            ec = lib::error_code();
+            s << ep;
+            return s.str();
+        }
+    }
+protected:
+    /// Perform one time initializations
+    /**
+     * init_asio is called once immediately after construction to initialize
+     * boost::asio components to the io_service
+     *
+     * @param service A pointer to the endpoint's io_service
+     * @param strand A pointer to the connection's strand
+     * @param is_server Whether or not the endpoint is a server or not.
+     */
+    lib::error_code init_asio (io_service_ptr service, strand_ptr strand,
+        bool is_server)
+    {
+        if (!m_tls_init_handler) {
+            return socket::make_error_code(socket::error::missing_tls_init_handler);
+        }
+        m_context = m_tls_init_handler(m_hdl);
+
+        if (!m_context) {
+            return socket::make_error_code(socket::error::invalid_tls_context);
+        }
+        m_socket = lib::make_shared<socket_type>(
+            _WEBSOCKETPP_REF(*service),lib::ref(*m_context));
+
+        m_io_service = service;
+        m_strand = strand;
+        m_is_server = is_server;
+
+        return lib::error_code();
+    }
+
+    /// Pre-initialize security policy
+    /**
+     * Called by the transport after a new connection is created to initialize
+     * the socket component of the connection. This method is not allowed to
+     * write any bytes to the wire. This initialization happens before any
+     * proxies or other intermediate wrappers are negotiated.
+     *
+     * @param callback Handler to call back with completion information
+     */
+    void pre_init(init_handler callback) {
+        if (m_socket_init_handler) {
+            m_socket_init_handler(m_hdl,get_socket());
+        }
+
+        callback(lib::error_code());
+    }
+
+    /// Post-initialize security policy
+    /**
+     * Called by the transport after all intermediate proxies have been
+     * negotiated. This gives the security policy the chance to talk with the
+     * real remote endpoint for a bit before the websocket handshake.
+     *
+     * @param callback Handler to call back with completion information
+     */
+    void post_init(init_handler callback) {
+        m_ec = socket::make_error_code(socket::error::tls_handshake_timeout);
+
+        // TLS handshake
+        if (m_strand) {
+            m_socket->async_handshake(
+                get_handshake_type(),
+                m_strand->wrap(lib::bind(
+                    &type::handle_init, get_shared(),
+                    callback,
+                    lib::placeholders::_1
+                ))
+            );
+        } else {
+            m_socket->async_handshake(
+                get_handshake_type(),
+                lib::bind(
+                    &type::handle_init, get_shared(),
+                    callback,
+                    lib::placeholders::_1
+                )
+            );
+        }
+    }
+
+    /// Sets the connection handle
+    /**
+     * The connection handle is passed to any handlers to identify the
+     * connection
+     *
+     * @param hdl The new handle
+     */
+    void set_handle(connection_hdl hdl) {
+        m_hdl = hdl;
+    }
+
+    void handle_init(init_handler callback,boost::system::error_code const & ec)
+    {
+        if (ec) {
+            m_ec = socket::make_error_code(socket::error::tls_handshake_failed);
+        } else {
+            m_ec = lib::error_code();
+        }
+
+        callback(m_ec);
+    }
+
+    lib::error_code get_ec() const {
+        return m_ec;
+    }
+
+    /// Cancel all async operations on this socket
+    void cancel_socket() {
+        get_raw_socket().cancel();
+    }
+
+    void async_shutdown(socket_shutdown_handler callback) {
+        m_socket->async_shutdown(callback);
+    }
+
+    /// Translate any security policy specific information about an error code
+    /**
+     * Translate_ec takes a boost error code and attempts to convert its value
+     * to an appropriate websocketpp error code. Any error that is determined to
+     * be related to TLS but does not have a more specific websocketpp error
+     * code is returned under the catch all error "tls_error".
+     *
+     * Non-TLS related errors are returned as the transport generic pass_through
+     * error.
+     *
+     * @since 0.3.0
+     *
+     * @param ec The error code to translate_ec
+     * @return The translated error code
+     */
+    lib::error_code translate_ec(boost::system::error_code ec) {
+        if (ec.category() == boost::asio::error::get_ssl_category()) {
+            if (ERR_GET_REASON(ec.value()) == SSL_R_SHORT_READ) {
+                return make_error_code(transport::error::tls_short_read);
+            } else {
+                // We know it is a TLS related error, but otherwise don't know
+                // more. Pass through as TLS generic.
+                return make_error_code(transport::error::tls_error);
+            }
+        } else {
+            // We don't know any more information about this error so pass
+            // through
+            return make_error_code(transport::error::pass_through);
+        }
+    }
+private:
+    socket_type::handshake_type get_handshake_type() {
+        if (m_is_server) {
+            return boost::asio::ssl::stream_base::server;
+        } else {
+            return boost::asio::ssl::stream_base::client;
+        }
+    }
+
+    io_service_ptr      m_io_service;
+    strand_ptr          m_strand;
+    context_ptr         m_context;
+    socket_ptr          m_socket;
+    bool                m_is_server;
+
+    lib::error_code     m_ec;
+
+    connection_hdl      m_hdl;
+    socket_init_handler m_socket_init_handler;
+    tls_init_handler    m_tls_init_handler;
+};
+
+/// TLS enabled Boost ASIO endpoint socket component
+/**
+ * transport::asio::tls_socket::endpoint implements a secure endpoint socket
+ * component that uses Boost ASIO's ssl::stream to wrap an ip::tcp::socket.
+ */
+class endpoint {
+public:
+    /// The type of this endpoint socket component
+    typedef endpoint type;
+
+    /// The type of the corresponding connection socket component
+    typedef connection socket_con_type;
+    /// The type of a shared pointer to the corresponding connection socket
+    /// component.
+    typedef socket_con_type::ptr socket_con_ptr;
+
+    explicit endpoint() {}
+
+    /// Checks whether the endpoint creates secure connections
+    /**
+     * @return Whether or not the endpoint creates secure connections
+     */
+    bool is_secure() const {
+        return true;
+    }
+
+    /// Set socket init handler
+    /**
+     * The socket init handler is called after a connection's socket is created
+     * but before it is used. This gives the end application an opportunity to
+     * set asio socket specific parameters.
+     *
+     * @param h The new socket_init_handler
+     */
+    void set_socket_init_handler(socket_init_handler h) {
+        m_socket_init_handler = h;
+    }
+
+    /// Set TLS init handler
+    /**
+     * The tls init handler is called when needed to request a TLS context for
+     * the library to use. A TLS init handler must be set and it must return a
+     * valid TLS context in order for this endpoint to be able to initialize
+     * TLS connections
+     *
+     * @param h The new tls_init_handler
+     */
+    void set_tls_init_handler(tls_init_handler h) {
+        m_tls_init_handler = h;
+    }
+protected:
+    /// Initialize a connection
+    /**
+     * Called by the transport after a new connection is created to initialize
+     * the socket component of the connection.
+     *
+     * @param scon Pointer to the socket component of the connection
+     *
+     * @return Error code (empty on success)
+     */
+    lib::error_code init(socket_con_ptr scon) {
+        scon->set_socket_init_handler(m_socket_init_handler);
+        scon->set_tls_init_handler(m_tls_init_handler);
+        return lib::error_code();
+    }
+
+private:
+    socket_init_handler m_socket_init_handler;
+    tls_init_handler m_tls_init_handler;
+};
+
+} // namespace tls_socket
+} // namespace asio
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_SECURITY_TLS_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/base/connection.hpp b/extlibs/websocketpp/websocketpp/transport/base/connection.hpp
new file mode 100644
index 000000000..f76d40913
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/base/connection.hpp
@@ -0,0 +1,238 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_BASE_CON_HPP
+#define WEBSOCKETPP_TRANSPORT_BASE_CON_HPP
+
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/connection_hdl.hpp>
+#include <websocketpp/common/functional.hpp>
+#include <websocketpp/common/system_error.hpp>
+
+#include <string>
+
+namespace websocketpp {
+/// Transport policies provide network connectivity and timers
+/**
+ * ### Connection Interface
+ *
+ * Transport connection components needs to provide:
+ *
+ * **init**\n
+ * `void init(init_handler handler)`\n
+ * Called once shortly after construction to give the policy the chance to
+ * perform one time initialization. When complete, the policy must call the
+ * supplied `init_handler` to continue setup. The handler takes one argument
+ * with the error code if any. If an error is returned here setup will fail and
+ * the connection will be aborted or terminated.
+ *
+ * WebSocket++ will call init only once. The transport must call `handler`
+ * exactly once.
+ *
+ * **async_read_at_least**\n
+ * `void async_read_at_least(size_t num_bytes, char *buf, size_t len,
+ * read_handler handler)`\n
+ * start an async read for at least num_bytes and at most len
+ * bytes into buf. Call handler when done with number of bytes read.
+ *
+ * WebSocket++ promises to have only one async_read_at_least in flight at a
+ * time. The transport must promise to only call read_handler once per async
+ * read.
+ *
+ * **async_write**\n
+ * `void async_write(const char* buf, size_t len, write_handler handler)`\n
+ * `void async_write(std::vector<buffer> & bufs, write_handler handler)`\n
+ * Start a write of all of the data in buf or bufs. In second case data is
+ * written sequentially and in place without copying anything to a temporary
+ * location.
+ *
+ * Websocket++ promises to have only one async_write in flight at a time.
+ * The transport must promise to only call the write_handler once per async
+ * write
+ *
+ * **set_handle**\n
+ * `void set_handle(connection_hdl hdl)`\n
+ * Called by WebSocket++ to let this policy know the hdl to the connection. It
+ * may be stored for later use or ignored/discarded. This handle should be used
+ * if the policy adds any connection handlers. Connection handlers must be
+ * called with the handle as the first argument so that the handler code knows
+ * which connection generated the callback.
+ *
+ * **set_timer**\n
+ * `timer_ptr set_timer(long duration, timer_handler handler)`\n
+ * WebSocket++ uses the timers provided by the transport policy as the
+ * implementation of timers is often highly coupled with the implementation of
+ * the networking event loops.
+ *
+ * Transport timer support is an optional feature. A transport method may elect
+ * to implement a dummy timer object and have this method return an empty
+ * pointer. If so, all timer related features of WebSocket++ core will be
+ * disabled. This includes many security features designed to prevent denial of
+ * service attacks. Use timer-free transport policies with caution.
+ *
+ * **get_remote_endpoint**\n
+ * `std::string get_remote_endpoint()`\n
+ * retrieve address of remote endpoint
+ *
+ * **is_secure**\n
+ * `void is_secure()`\n
+ * whether or not the connection to the remote endpoint is secure
+ *
+ * **dispatch**\n
+ * `lib::error_code dispatch(dispatch_handler handler)`: invoke handler within
+ * the transport's event system if it uses one. Otherwise, this method should
+ * simply call `handler` immediately.
+ *
+ * **async_shutdown**\n
+ * `void async_shutdown(shutdown_handler handler)`\n
+ * Perform any cleanup necessary (if any). Call `handler` when complete.
+ */
+namespace transport {
+
+/// The type and signature of the callback passed to the init hook
+typedef lib::function<void(lib::error_code const &)> init_handler;
+
+/// The type and signature of the callback passed to the read method
+typedef lib::function<void(lib::error_code const &,size_t)> read_handler;
+
+/// The type and signature of the callback passed to the write method
+typedef lib::function<void(lib::error_code const &)> write_handler;
+
+/// The type and signature of the callback passed to the read method
+typedef lib::function<void(lib::error_code const &)> timer_handler;
+
+/// The type and signature of the callback passed to the shutdown method
+typedef lib::function<void(lib::error_code const &)> shutdown_handler;
+
+/// The type and signature of the callback passed to the interrupt method
+typedef lib::function<void()> interrupt_handler;
+
+/// The type and signature of the callback passed to the dispatch method
+typedef lib::function<void()> dispatch_handler;
+
+/// A simple utility buffer class
+struct buffer {
+    buffer(char const * b, size_t l) : buf(b),len(l) {}
+
+    char const * buf;
+    size_t len;
+};
+
+/// Generic transport related errors
+namespace error {
+enum value {
+    /// Catch-all error for transport policy errors that don't fit in other
+    /// categories
+    general = 1,
+
+    /// underlying transport pass through
+    pass_through,
+
+    /// async_read_at_least call requested more bytes than buffer can store
+    invalid_num_bytes,
+
+    /// async_read called while another async_read was in progress
+    double_read,
+
+    /// Operation aborted
+    operation_aborted,
+
+    /// Operation not supported
+    operation_not_supported,
+
+    /// End of file
+    eof,
+
+    /// TLS short read
+    tls_short_read,
+
+    /// Timer expired
+    timeout,
+
+    /// read or write after shutdown
+    action_after_shutdown,
+
+    /// Other TLS error
+    tls_error
+};
+
+class category : public lib::error_category {
+    public:
+    category() {}
+
+    char const * name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp.transport";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case general:
+                return "Generic transport policy error";
+            case pass_through:
+                return "Underlying Transport Error";
+            case invalid_num_bytes:
+                return "async_read_at_least call requested more bytes than buffer can store";
+            case operation_aborted:
+                return "The operation was aborted";
+            case operation_not_supported:
+                return "The operation is not supported by this transport";
+            case eof:
+                return "End of File";
+            case tls_short_read:
+                return "TLS Short Read";
+            case timeout:
+                return "Timer Expired";
+            case action_after_shutdown:
+                return "A transport action was requested after shutdown";
+            case tls_error:
+                return "Generic TLS related error";
+            default:
+                return "Unknown";
+        }
+    }
+};
+
+inline lib::error_category const & get_category() {
+    static category instance;
+    return instance;
+}
+
+inline lib::error_code make_error_code(error::value e) {
+    return lib::error_code(static_cast<int>(e), get_category());
+}
+
+} // namespace error
+} // namespace transport
+} // namespace websocketpp
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_
+template<> struct is_error_code_enum<websocketpp::transport::error::value>
+{
+    static bool const value = true;
+};
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_
+
+#endif // WEBSOCKETPP_TRANSPORT_BASE_CON_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/base/endpoint.hpp b/extlibs/websocketpp/websocketpp/transport/base/endpoint.hpp
new file mode 100644
index 000000000..3b4b0d6db
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/base/endpoint.hpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_BASE_HPP
+#define WEBSOCKETPP_TRANSPORT_BASE_HPP
+
+#include <websocketpp/common/functional.hpp>
+#include <websocketpp/common/system_error.hpp>
+
+namespace websocketpp {
+/// Transport policies provide network connectivity and timers
+/**
+ * ### Endpoint Interface
+ *
+ * Transport endpoint components needs to provide:
+ *
+ * **init**\n
+ * `lib::error_code init(transport_con_ptr tcon)`\n
+ * init is called by an endpoint once for each newly created connection.
+ * It's purpose is to give the transport policy the chance to perform any
+ * transport specific initialization that couldn't be done via the default
+ * constructor.
+ *
+ * **is_secure**\n
+ * `bool is_secure() const`\n
+ * Test whether the transport component of this endpoint is capable of secure
+ * connections.
+ *
+ * **async_connect**\n
+ * `void async_connect(transport_con_ptr tcon, uri_ptr location,
+ *  connect_handler handler)`\n
+ * Initiate a connection to `location` using the given connection `tcon`. `tcon`
+ * is a pointer to the transport connection component of the connection. When
+ * complete, `handler` should be called with the the connection's
+ * `connection_hdl` and any error that occurred.
+ *
+ * **init_logging**
+ * `void init_logging(alog_type * a, elog_type * e)`\n
+ * Called once after construction to provide pointers to the endpoint's access
+ * and error loggers. These may be stored and used to log messages or ignored.
+ */
+namespace transport {
+
+/// The type and signature of the callback passed to the accept method
+typedef lib::function<void(lib::error_code const &)> accept_handler;
+
+/// The type and signature of the callback passed to the connect method
+typedef lib::function<void(lib::error_code const &)> connect_handler;
+
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_BASE_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/debug/base.hpp b/extlibs/websocketpp/websocketpp/transport/debug/base.hpp
new file mode 100644
index 000000000..2e477b501
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/debug/base.hpp
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_DEBUG_BASE_HPP
+#define WEBSOCKETPP_TRANSPORT_DEBUG_BASE_HPP
+
+#include <websocketpp/common/system_error.hpp>
+#include <websocketpp/common/cpp11.hpp>
+
+#include <string>
+
+namespace websocketpp {
+namespace transport {
+/// Debug transport policy that is used for various mocking and stubbing duties
+/// in unit tests.
+namespace debug {
+
+/// debug transport errors
+namespace error {
+enum value {
+    /// Catch-all error for transport policy errors that don't fit in other
+    /// categories
+    general = 1,
+
+    /// not implemented
+    not_implemented,
+    
+    invalid_num_bytes,
+    
+    double_read
+};
+
+/// debug transport error category
+class category : public lib::error_category {
+    public:
+    category() {}
+
+    char const * name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp.transport.debug";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case general:
+                return "Generic stub transport policy error";
+            case not_implemented:
+                return "feature not implemented";
+            case invalid_num_bytes:
+                return "Invalid number of bytes";
+            case double_read:
+                return "Read while another read was outstanding";
+            default:
+                return "Unknown";
+        }
+    }
+};
+
+/// Get a reference to a static copy of the debug transport error category
+inline lib::error_category const & get_category() {
+    static category instance;
+    return instance;
+}
+
+/// Get an error code with the given value and the debug transport category
+inline lib::error_code make_error_code(error::value e) {
+    return lib::error_code(static_cast<int>(e), get_category());
+}
+
+} // namespace error
+} // namespace debug
+} // namespace transport
+} // namespace websocketpp
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_
+template<> struct is_error_code_enum<websocketpp::transport::debug::error::value>
+{
+    static bool const value = true;
+};
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_
+
+#endif // WEBSOCKETPP_TRANSPORT_DEBUG_BASE_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/debug/connection.hpp b/extlibs/websocketpp/websocketpp/transport/debug/connection.hpp
new file mode 100644
index 000000000..7b8c29cbd
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/debug/connection.hpp
@@ -0,0 +1,397 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_DEBUG_CON_HPP
+#define WEBSOCKETPP_TRANSPORT_DEBUG_CON_HPP
+
+#include <websocketpp/transport/debug/base.hpp>
+
+#include <websocketpp/transport/base/connection.hpp>
+
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/common/connection_hdl.hpp>
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/common/platforms.hpp>
+
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+namespace transport {
+namespace debug {
+
+/// Empty timer class to stub out for timer functionality that stub
+/// transport doesn't support
+struct timer {
+    void cancel() {}
+};
+
+template <typename config>
+class connection : public lib::enable_shared_from_this< connection<config> > {
+public:
+    /// Type of this connection transport component
+    typedef connection<config> type;
+    /// Type of a shared pointer to this connection transport component
+    typedef lib::shared_ptr<type> ptr;
+
+    /// transport concurrency policy
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of this transport's access logging policy
+    typedef typename config::alog_type alog_type;
+    /// Type of this transport's error logging policy
+    typedef typename config::elog_type elog_type;
+
+    // Concurrency policy types
+    typedef typename concurrency_type::scoped_lock_type scoped_lock_type;
+    typedef typename concurrency_type::mutex_type mutex_type;
+
+    typedef lib::shared_ptr<timer> timer_ptr;
+
+    explicit connection(bool is_server, alog_type & alog, elog_type & elog)
+      : m_reading(false), m_is_server(is_server), m_alog(alog), m_elog(elog)
+    {
+        m_alog.write(log::alevel::devel,"debug con transport constructor");
+    }
+
+    /// Get a shared pointer to this component
+    ptr get_shared() {
+        return type::shared_from_this();
+    }
+
+    /// Set whether or not this connection is secure
+    /**
+     * Todo: docs
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param value Whether or not this connection is secure.
+     */
+    void set_secure(bool) {}
+
+    /// Tests whether or not the underlying transport is secure
+    /**
+     * TODO: docs
+     *
+     * @return Whether or not the underlying transport is secure
+     */
+    bool is_secure() const {
+        return false;
+    }
+
+    /// Set human readable remote endpoint address
+    /**
+     * Sets the remote endpoint address returned by `get_remote_endpoint`. This
+     * value should be a human readable string that describes the remote
+     * endpoint. Typically an IP address or hostname, perhaps with a port. But
+     * may be something else depending on the nature of the underlying
+     * transport.
+     *
+     * If none is set a default is returned.
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param value The remote endpoint address to set.
+     */
+    void set_remote_endpoint(std::string) {}
+
+    /// Get human readable remote endpoint address
+    /**
+     * TODO: docs
+     *
+     * This value is used in access and error logs and is available to the end
+     * application for including in user facing interfaces and messages.
+     *
+     * @return A string identifying the address of the remote endpoint
+     */
+    std::string get_remote_endpoint() const {
+        return "unknown (debug transport)";
+    }
+
+    /// Get the connection handle
+    /**
+     * @return The handle for this connection.
+     */
+    connection_hdl get_handle() const {
+        return connection_hdl();
+    }
+
+    /// Call back a function after a period of time.
+    /**
+     * Timers are not implemented in this transport. The timer pointer will
+     * always be empty. The handler will never be called.
+     *
+     * @param duration Length of time to wait in milliseconds
+     * @param callback The function to call back when the timer has expired
+     * @return A handle that can be used to cancel the timer if it is no longer
+     * needed.
+     */
+    timer_ptr set_timer(long, timer_handler handler) {
+        m_alog.write(log::alevel::devel,"debug connection set timer");
+        m_timer_handler = handler;
+        return timer_ptr();
+    }
+    
+    /// Manual input supply (read all)
+    /**
+     * Similar to read_some, but continues to read until all bytes in the
+     * supplied buffer have been read or the connection runs out of read
+     * requests.
+     *
+     * This method still may not read all of the bytes in the input buffer. if
+     * it doesn't it indicates that the connection was most likely closed or
+     * is in an error state where it is no longer accepting new input.
+     *
+     * @since 0.3.0
+     *
+     * @param buf Char buffer to read into the websocket
+     * @param len Length of buf
+     * @return The number of characters from buf actually read.
+     */
+    size_t read_all(char const * buf, size_t len) {        
+        size_t total_read = 0;
+        size_t temp_read = 0;
+
+        do {
+            temp_read = this->read_some_impl(buf+total_read,len-total_read);
+            total_read += temp_read;
+        } while (temp_read != 0 && total_read < len);
+
+        return total_read;
+    }
+    
+    // debug stuff to invoke the async handlers
+    void expire_timer(lib::error_code const & ec) {
+        m_timer_handler(ec);
+    }
+    
+    void fullfil_write() {
+        m_write_handler(lib::error_code());
+    }
+protected:
+    /// Initialize the connection transport
+    /**
+     * Initialize the connection's transport component.
+     *
+     * @param handler The `init_handler` to call when initialization is done
+     */
+    void init(init_handler handler) {
+        m_alog.write(log::alevel::devel,"debug connection init");
+        handler(lib::error_code());
+    }
+
+    /// Initiate an async_read for at least num_bytes bytes into buf
+    /**
+     * Initiates an async_read request for at least num_bytes bytes. The input
+     * will be read into buf. A maximum of len bytes will be input. When the
+     * operation is complete, handler will be called with the status and number
+     * of bytes read.
+     *
+     * This method may or may not call handler from within the initial call. The
+     * application should be prepared to accept either.
+     *
+     * The application should never call this method a second time before it has
+     * been called back for the first read. If this is done, the second read
+     * will be called back immediately with a double_read error.
+     *
+     * If num_bytes or len are zero handler will be called back immediately
+     * indicating success.
+     *
+     * @param num_bytes Don't call handler until at least this many bytes have
+     * been read.
+     * @param buf The buffer to read bytes into
+     * @param len The size of buf. At maximum, this many bytes will be read.
+     * @param handler The callback to invoke when the operation is complete or
+     * ends in an error
+     */
+    void async_read_at_least(size_t num_bytes, char * buf, size_t len,
+        read_handler handler)
+    {
+        std::stringstream s;
+        s << "debug_con async_read_at_least: " << num_bytes;
+        m_alog.write(log::alevel::devel,s.str());
+
+        if (num_bytes > len) {
+            handler(make_error_code(error::invalid_num_bytes),size_t(0));
+            return;
+        }
+
+        if (m_reading == true) {
+            handler(make_error_code(error::double_read),size_t(0));
+            return;
+        }
+
+        if (num_bytes == 0 || len == 0) {
+            handler(lib::error_code(),size_t(0));
+            return;
+        }
+
+        m_buf = buf;
+        m_len = len;
+        m_bytes_needed = num_bytes;
+        m_read_handler = handler;
+        m_cursor = 0;
+        m_reading = true;
+    }
+
+    /// Asyncronous Transport Write
+    /**
+     * Write len bytes in buf to the output stream. Call handler to report
+     * success or failure. handler may or may not be called during async_write,
+     * but it must be safe for this to happen.
+     *
+     * Will return 0 on success.
+     *
+     * @param buf buffer to read bytes from
+     * @param len number of bytes to write
+     * @param handler Callback to invoke with operation status.
+     */
+    void async_write(char const *, size_t, write_handler handler) {
+        m_alog.write(log::alevel::devel,"debug_con async_write");
+        m_write_handler = handler;
+    }
+
+    /// Asyncronous Transport Write (scatter-gather)
+    /**
+     * Write a sequence of buffers to the output stream. Call handler to report
+     * success or failure. handler may or may not be called during async_write,
+     * but it must be safe for this to happen.
+     *
+     * Will return 0 on success.
+     *
+     * @param bufs vector of buffers to write
+     * @param handler Callback to invoke with operation status.
+     */
+    void async_write(std::vector<buffer> const &, write_handler handler) {
+        m_alog.write(log::alevel::devel,"debug_con async_write buffer list");
+        m_write_handler = handler;
+    }
+
+    /// Set Connection Handle
+    /**
+     * @param hdl The new handle
+     */
+    void set_handle(connection_hdl) {}
+
+    /// Call given handler back within the transport's event system (if present)
+    /**
+     * Invoke a callback within the transport's event system if it has one. If
+     * it doesn't, the handler will be invoked immediately before this function
+     * returns.
+     *
+     * @param handler The callback to invoke
+     *
+     * @return Whether or not the transport was able to register the handler for
+     * callback.
+     */
+    lib::error_code dispatch(dispatch_handler handler) {
+        handler();
+        return lib::error_code();
+    }
+
+    /// Perform cleanup on socket shutdown_handler
+    /**
+     * @param h The `shutdown_handler` to call back when complete
+     */
+    void async_shutdown(shutdown_handler handler) {
+        handler(lib::error_code());
+    }
+    
+    size_t read_some_impl(char const * buf, size_t len) {
+        m_alog.write(log::alevel::devel,"debug_con read_some");
+
+        if (!m_reading) {
+            m_elog.write(log::elevel::devel,"write while not reading");
+            return 0;
+        }
+
+        size_t bytes_to_copy = (std::min)(len,m_len-m_cursor);
+
+        std::copy(buf,buf+bytes_to_copy,m_buf+m_cursor);
+
+        m_cursor += bytes_to_copy;
+
+        if (m_cursor >= m_bytes_needed) {
+            complete_read(lib::error_code());
+        }
+
+        return bytes_to_copy;
+    }
+
+    /// Signal that a requested read is complete
+    /**
+     * Sets the reading flag to false and returns the handler that should be
+     * called back with the result of the read. The cursor position that is sent
+     * is whatever the value of m_cursor is.
+     *
+     * It MUST NOT be called when m_reading is false.
+     * it MUST be called while holding the read lock
+     *
+     * It is important to use this method rather than directly setting/calling
+     * m_read_handler back because this function makes sure to delete the
+     * locally stored handler which contains shared pointers that will otherwise
+     * cause circular reference based memory leaks.
+     *
+     * @param ec The error code to forward to the read handler
+     */
+    void complete_read(lib::error_code const & ec) {
+        m_reading = false;
+
+        read_handler handler = m_read_handler;
+        m_read_handler = read_handler();
+
+        handler(ec,m_cursor);
+    }
+private:
+    timer_handler m_timer_handler;
+    
+    // Read space (Protected by m_read_mutex)
+    char *          m_buf;
+    size_t          m_len;
+    size_t          m_bytes_needed;
+    read_handler    m_read_handler;
+    size_t          m_cursor;
+
+    // transport resources
+    connection_hdl  m_connection_hdl;
+    write_handler   m_write_handler;
+    shutdown_handler    m_shutdown_handler;
+
+    bool            m_reading;
+    bool const      m_is_server;
+    bool            m_is_secure;
+    alog_type &     m_alog;
+    elog_type &     m_elog;
+    std::string     m_remote_endpoint;
+};
+
+
+} // namespace debug
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_DEBUG_CON_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/debug/endpoint.hpp b/extlibs/websocketpp/websocketpp/transport/debug/endpoint.hpp
new file mode 100644
index 000000000..1cca70c59
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/debug/endpoint.hpp
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_DEBUG_HPP
+#define WEBSOCKETPP_TRANSPORT_DEBUG_HPP
+
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/transport/base/endpoint.hpp>
+#include <websocketpp/transport/debug/connection.hpp>
+
+namespace websocketpp {
+namespace transport {
+namespace debug {
+
+template <typename config>
+class endpoint {
+public:
+    /// Type of this endpoint transport component
+    typedef endpoint type;
+    /// Type of a pointer to this endpoint transport component
+    typedef lib::shared_ptr<type> ptr;
+
+    /// Type of this endpoint's concurrency policy
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of this endpoint's error logging policy
+    typedef typename config::elog_type elog_type;
+    /// Type of this endpoint's access logging policy
+    typedef typename config::alog_type alog_type;
+
+    /// Type of this endpoint transport component's associated connection
+    /// transport component.
+    typedef debug::connection<config> transport_con_type;
+    /// Type of a shared pointer to this endpoint transport component's
+    /// associated connection transport component
+    typedef typename transport_con_type::ptr transport_con_ptr;
+
+    // generate and manage our own io_service
+    explicit endpoint()
+    {
+        //std::cout << "transport::iostream::endpoint constructor" << std::endl;
+    }
+
+    /// Set whether or not endpoint can create secure connections
+    /**
+     * TODO: docs
+     *
+     * Setting this value only indicates whether or not the endpoint is capable
+     * of producing and managing secure connections. Connections produced by
+     * this endpoint must also be individually flagged as secure if they are.
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param value Whether or not the endpoint can create secure connections.
+     */
+    void set_secure(bool) {}
+
+    /// Tests whether or not the underlying transport is secure
+    /**
+     * TODO: docs
+     *
+     * @return Whether or not the underlying transport is secure
+     */
+    bool is_secure() const {
+        return false;
+    }
+protected:
+    /// Initialize logging
+    /**
+     * The loggers are located in the main endpoint class. As such, the
+     * transport doesn't have direct access to them. This method is called
+     * by the endpoint constructor to allow shared logging from the transport
+     * component. These are raw pointers to member variables of the endpoint.
+     * In particular, they cannot be used in the transport constructor as they
+     * haven't been constructed yet, and cannot be used in the transport
+     * destructor as they will have been destroyed by then.
+     *
+     * @param a A pointer to the access logger to use.
+     * @param e A pointer to the error logger to use.
+     */
+    void init_logging(alog_type *, elog_type *) {}
+
+    /// Initiate a new connection
+    /**
+     * @param tcon A pointer to the transport connection component of the
+     * connection to connect.
+     * @param u A URI pointer to the URI to connect to.
+     * @param cb The function to call back with the results when complete.
+     */
+    void async_connect(transport_con_ptr, uri_ptr, connect_handler cb) {
+        cb(lib::error_code());
+    }
+
+    /// Initialize a connection
+    /**
+     * Init is called by an endpoint once for each newly created connection.
+     * It's purpose is to give the transport policy the chance to perform any
+     * transport specific initialization that couldn't be done via the default
+     * constructor.
+     *
+     * @param tcon A pointer to the transport portion of the connection.
+     * @return A status code indicating the success or failure of the operation
+     */
+    lib::error_code init(transport_con_ptr) {
+        return lib::error_code();
+    }
+private:
+
+};
+
+} // namespace debug
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_DEBUG_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/iostream/base.hpp b/extlibs/websocketpp/websocketpp/transport/iostream/base.hpp
new file mode 100644
index 000000000..0103856a9
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/iostream/base.hpp
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_IOSTREAM_BASE_HPP
+#define WEBSOCKETPP_TRANSPORT_IOSTREAM_BASE_HPP
+
+#include <websocketpp/common/system_error.hpp>
+#include <websocketpp/common/cpp11.hpp>
+#include <websocketpp/common/functional.hpp>
+#include <websocketpp/common/connection_hdl.hpp>
+
+#include <string>
+
+namespace websocketpp {
+namespace transport {
+/// Transport policy that uses STL iostream for I/O and does not support timers
+namespace iostream {
+
+/// The type and signature of the callback used by iostream transport to write
+typedef lib::function<lib::error_code(connection_hdl, char const *, size_t)> 
+    write_handler;
+
+/// The type and signature of the callback used by iostream transport to signal 
+/// a transport shutdown.
+typedef lib::function<lib::error_code(connection_hdl)> shutdown_handler;
+
+/// iostream transport errors
+namespace error {
+enum value {
+    /// Catch-all error for transport policy errors that don't fit in other
+    /// categories
+    general = 1,
+
+    /// async_read_at_least call requested more bytes than buffer can store
+    invalid_num_bytes,
+
+    /// async_read called while another async_read was in progress
+    double_read,
+
+    /// An operation that requires an output stream was attempted before
+    /// setting one.
+    output_stream_required,
+
+    /// stream error
+    bad_stream
+};
+
+/// iostream transport error category
+class category : public lib::error_category {
+    public:
+    category() {}
+
+    char const * name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp.transport.iostream";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case general:
+                return "Generic iostream transport policy error";
+            case invalid_num_bytes:
+                return "async_read_at_least call requested more bytes than buffer can store";
+            case double_read:
+                return "Async read already in progress";
+            case output_stream_required:
+                return "An output stream to be set before async_write can be used";
+            case bad_stream:
+                return "A stream operation returned ios::bad";
+            default:
+                return "Unknown";
+        }
+    }
+};
+
+/// Get a reference to a static copy of the iostream transport error category
+inline lib::error_category const & get_category() {
+    static category instance;
+    return instance;
+}
+
+/// Get an error code with the given value and the iostream transport category
+inline lib::error_code make_error_code(error::value e) {
+    return lib::error_code(static_cast<int>(e), get_category());
+}
+
+} // namespace error
+} // namespace iostream
+} // namespace transport
+} // namespace websocketpp
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_
+template<> struct is_error_code_enum<websocketpp::transport::iostream::error::value>
+{
+    static bool const value = true;
+};
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_
+
+#endif // WEBSOCKETPP_TRANSPORT_IOSTREAM_BASE_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/iostream/connection.hpp b/extlibs/websocketpp/websocketpp/transport/iostream/connection.hpp
new file mode 100644
index 000000000..c0d090118
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/iostream/connection.hpp
@@ -0,0 +1,661 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_IOSTREAM_CON_HPP
+#define WEBSOCKETPP_TRANSPORT_IOSTREAM_CON_HPP
+
+#include <websocketpp/transport/iostream/base.hpp>
+
+#include <websocketpp/transport/base/connection.hpp>
+
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/common/connection_hdl.hpp>
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/common/platforms.hpp>
+
+#include <algorithm>
+#include <iostream>
+#include <sstream>
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+namespace transport {
+namespace iostream {
+
+/// Empty timer class to stub out for timer functionality that iostream
+/// transport doesn't support
+struct timer {
+    void cancel() {}
+};
+
+template <typename config>
+class connection : public lib::enable_shared_from_this< connection<config> > {
+public:
+    /// Type of this connection transport component
+    typedef connection<config> type;
+    /// Type of a shared pointer to this connection transport component
+    typedef lib::shared_ptr<type> ptr;
+
+    /// transport concurrency policy
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of this transport's access logging policy
+    typedef typename config::alog_type alog_type;
+    /// Type of this transport's error logging policy
+    typedef typename config::elog_type elog_type;
+
+    // Concurrency policy types
+    typedef typename concurrency_type::scoped_lock_type scoped_lock_type;
+    typedef typename concurrency_type::mutex_type mutex_type;
+
+    typedef lib::shared_ptr<timer> timer_ptr;
+
+    explicit connection(bool is_server, alog_type & alog, elog_type & elog)
+      : m_output_stream(NULL)
+      , m_reading(false)
+      , m_is_server(is_server)
+      , m_is_secure(false)
+      , m_alog(alog)
+      , m_elog(elog)
+      , m_remote_endpoint("iostream transport")
+    {
+        m_alog.write(log::alevel::devel,"iostream con transport constructor");
+    }
+
+    /// Get a shared pointer to this component
+    ptr get_shared() {
+        return type::shared_from_this();
+    }
+
+    /// Register a std::ostream with the transport for writing output
+    /**
+     * Register a std::ostream with the transport. All future writes will be
+     * done to this output stream.
+     *
+     * @param o A pointer to the ostream to use for output.
+     */
+    void register_ostream(std::ostream * o) {
+        // TODO: lock transport state?
+        scoped_lock_type lock(m_read_mutex);
+        m_output_stream = o;
+    }
+
+    /// Overloaded stream input operator
+    /**
+     * Attempts to read input from the given stream into the transport. Bytes
+     * will be extracted from the input stream to fulfill any pending reads.
+     * Input in this manner will only read until the current read buffer has
+     * been filled. Then it will signal the library to process the input. If the
+     * library's input handler adds a new async_read, additional bytes will be
+     * read, otherwise the input operation will end.
+     *
+     * When this function returns one of the following conditions is true:
+     * - There is no outstanding read operation
+     * - There are no more bytes available in the input stream
+     *
+     * You can use tellg() on the input stream to determine if all of the input
+     * bytes were read or not.
+     *
+     * If there is no pending read operation when the input method is called, it
+     * will return immediately and tellg() will not have changed.
+     */
+    friend std::istream & operator>> (std::istream & in, type & t) {
+        // this serializes calls to external read.
+        scoped_lock_type lock(t.m_read_mutex);
+
+        t.read(in);
+
+        return in;
+    }
+
+    /// Manual input supply (read some)
+    /**
+     * Copies bytes from buf into WebSocket++'s input buffers. Bytes will be
+     * copied from the supplied buffer to fulfill any pending library reads. It
+     * will return the number of bytes successfully processed. If there are no
+     * pending reads read_some will return immediately. Not all of the bytes may
+     * be able to be read in one call.
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param buf Char buffer to read into the websocket
+     * @param len Length of buf
+     * @return The number of characters from buf actually read.
+     */
+    size_t read_some(char const * buf, size_t len) {
+        // this serializes calls to external read.
+        scoped_lock_type lock(m_read_mutex);
+
+        return this->read_some_impl(buf,len);
+    }
+    
+    /// Manual input supply (read all)
+    /**
+     * Similar to read_some, but continues to read until all bytes in the
+     * supplied buffer have been read or the connection runs out of read
+     * requests.
+     *
+     * This method still may not read all of the bytes in the input buffer. if
+     * it doesn't it indicates that the connection was most likely closed or
+     * is in an error state where it is no longer accepting new input.
+     *
+     * @since 0.3.0
+     *
+     * @param buf Char buffer to read into the websocket
+     * @param len Length of buf
+     * @return The number of characters from buf actually read.
+     */
+    size_t read_all(char const * buf, size_t len) {
+        // this serializes calls to external read.
+        scoped_lock_type lock(m_read_mutex);
+        
+        size_t total_read = 0;
+        size_t temp_read = 0;
+
+        do {
+            temp_read = this->read_some_impl(buf+total_read,len-total_read);
+            total_read += temp_read;
+        } while (temp_read != 0 && total_read < len);
+
+        return total_read;
+    }
+
+    /// Manual input supply (DEPRECATED)
+    /**
+     * @deprecated DEPRECATED in favor of read_some()
+     * @see read_some()
+     */
+    size_t readsome(char const * buf, size_t len) {
+        return this->read_some(buf,len);
+    }
+
+    /// Signal EOF
+    /**
+     * Signals to the transport that data stream being read has reached EOF and
+     * that no more bytes may be read or written to/from the transport.
+     *
+     * @since 0.3.0-alpha4
+     */
+    void eof() {
+        // this serializes calls to external read.
+        scoped_lock_type lock(m_read_mutex);
+
+        if (m_reading) {
+            complete_read(make_error_code(transport::error::eof));
+        }
+    }
+
+    /// Signal transport error
+    /**
+     * Signals to the transport that a fatal data stream error has occurred and
+     * that no more bytes may be read or written to/from the transport.
+     *
+     * @since 0.3.0-alpha4
+     */
+    void fatal_error() {
+        // this serializes calls to external read.
+        scoped_lock_type lock(m_read_mutex);
+
+        if (m_reading) {
+            complete_read(make_error_code(transport::error::pass_through));
+        }
+    }
+
+    /// Set whether or not this connection is secure
+    /**
+     * The iostream transport does not provide any security features. As such
+     * it defaults to returning false when `is_secure` is called. However, the
+     * iostream transport may be used to wrap an external socket API that may
+     * provide secure transport. This method allows that external API to flag
+     * whether or not this connection is secure so that users of the WebSocket++
+     * API will get more accurate information.
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param value Whether or not this connection is secure.
+     */
+    void set_secure(bool value) {
+        m_is_secure = value;
+    }
+
+    /// Tests whether or not the underlying transport is secure
+    /**
+     * iostream transport will return false always because it has no information
+     * about the ultimate remote endpoint. This may or may not be accurate
+     * depending on the real source of bytes being input. The `set_secure`
+     * method may be used to flag connections that are secured by an external
+     * API
+     *
+     * @return Whether or not the underlying transport is secure
+     */
+    bool is_secure() const {
+        return m_is_secure;
+    }
+
+    /// Set human readable remote endpoint address
+    /**
+     * Sets the remote endpoint address returned by `get_remote_endpoint`. This
+     * value should be a human readable string that describes the remote
+     * endpoint. Typically an IP address or hostname, perhaps with a port. But
+     * may be something else depending on the nature of the underlying
+     * transport.
+     *
+     * If none is set the default is "iostream transport".
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param value The remote endpoint address to set.
+     */
+    void set_remote_endpoint(std::string value) {
+        m_remote_endpoint = value;
+    }
+
+    /// Get human readable remote endpoint address
+    /**
+     * The iostream transport has no information about the ultimate remote
+     * endpoint. It will return the string "iostream transport". The
+     * `set_remote_endpoint` method may be used by external network code to set
+     * a more accurate value.
+     *
+     * This value is used in access and error logs and is available to the end
+     * application for including in user facing interfaces and messages.
+     *
+     * @return A string identifying the address of the remote endpoint
+     */
+    std::string get_remote_endpoint() const {
+        return m_remote_endpoint;
+    }
+
+    /// Get the connection handle
+    /**
+     * @return The handle for this connection.
+     */
+    connection_hdl get_handle() const {
+        return m_connection_hdl;
+    }
+
+    /// Call back a function after a period of time.
+    /**
+     * Timers are not implemented in this transport. The timer pointer will
+     * always be empty. The handler will never be called.
+     *
+     * @param duration Length of time to wait in milliseconds
+     * @param callback The function to call back when the timer has expired
+     * @return A handle that can be used to cancel the timer if it is no longer
+     * needed.
+     */
+    timer_ptr set_timer(long, timer_handler) {
+        return timer_ptr();
+    }
+    
+    /// Sets the write handler
+    /**
+     * The write handler is called when the iostream transport receives data
+     * that needs to be written to the appropriate output location. This handler
+     * can be used in place of registering an ostream for output.
+     *
+     * The signature of the handler is 
+     * `lib::error_code (connection_hdl, char const *, size_t)` The
+     * code returned will be reported and logged by the core library.
+     *
+     * @since 0.5.0
+     *
+     * @param h The handler to call on connection shutdown.
+     */
+    void set_write_handler(write_handler h) {
+        m_write_handler = h;
+    }
+    
+    /// Sets the shutdown handler
+    /**
+     * The shutdown handler is called when the iostream transport receives a
+     * notification from the core library that it is finished with all read and
+     * write operations and that the underlying transport can be cleaned up.
+     *
+     * If you are using iostream transport with another socket library, this is
+     * a good time to close/shutdown the socket for this connection.
+     *
+     * The signature of the handler is `lib::error_code (connection_hdl)`. The
+     * code returned will be reported and logged by the core library.
+     *
+     * @since 0.5.0
+     *
+     * @param h The handler to call on connection shutdown.
+     */
+    void set_shutdown_handler(shutdown_handler h) {
+        m_shutdown_handler = h;
+    }
+protected:
+    /// Initialize the connection transport
+    /**
+     * Initialize the connection's transport component.
+     *
+     * @param handler The `init_handler` to call when initialization is done
+     */
+    void init(init_handler handler) {
+        m_alog.write(log::alevel::devel,"iostream connection init");
+        handler(lib::error_code());
+    }
+
+    /// Initiate an async_read for at least num_bytes bytes into buf
+    /**
+     * Initiates an async_read request for at least num_bytes bytes. The input
+     * will be read into buf. A maximum of len bytes will be input. When the
+     * operation is complete, handler will be called with the status and number
+     * of bytes read.
+     *
+     * This method may or may not call handler from within the initial call. The
+     * application should be prepared to accept either.
+     *
+     * The application should never call this method a second time before it has
+     * been called back for the first read. If this is done, the second read
+     * will be called back immediately with a double_read error.
+     *
+     * If num_bytes or len are zero handler will be called back immediately
+     * indicating success.
+     *
+     * @param num_bytes Don't call handler until at least this many bytes have
+     * been read.
+     * @param buf The buffer to read bytes into
+     * @param len The size of buf. At maximum, this many bytes will be read.
+     * @param handler The callback to invoke when the operation is complete or
+     * ends in an error
+     */
+    void async_read_at_least(size_t num_bytes, char *buf, size_t len,
+        read_handler handler)
+    {
+        std::stringstream s;
+        s << "iostream_con async_read_at_least: " << num_bytes;
+        m_alog.write(log::alevel::devel,s.str());
+
+        if (num_bytes > len) {
+            handler(make_error_code(error::invalid_num_bytes),size_t(0));
+            return;
+        }
+
+        if (m_reading == true) {
+            handler(make_error_code(error::double_read),size_t(0));
+            return;
+        }
+
+        if (num_bytes == 0 || len == 0) {
+            handler(lib::error_code(),size_t(0));
+            return;
+        }
+
+        m_buf = buf;
+        m_len = len;
+        m_bytes_needed = num_bytes;
+        m_read_handler = handler;
+        m_cursor = 0;
+        m_reading = true;
+    }
+
+    /// Asyncronous Transport Write
+    /**
+     * Write len bytes in buf to the output method. Call handler to report
+     * success or failure. handler may or may not be called during async_write,
+     * but it must be safe for this to happen.
+     *
+     * Will return 0 on success. Other possible errors (not exhaustive)
+     * output_stream_required: No output stream was registered to write to
+     * bad_stream: a ostream pass through error
+     *
+     * This method will attempt to write to the registered ostream first. If an
+     * ostream is not registered it will use the write handler. If neither are
+     * registered then an error is passed up to the connection.
+     *
+     * @param buf buffer to read bytes from
+     * @param len number of bytes to write
+     * @param handler Callback to invoke with operation status.
+     */
+    void async_write(char const * buf, size_t len, transport::write_handler 
+        handler)
+    {
+        m_alog.write(log::alevel::devel,"iostream_con async_write");
+        // TODO: lock transport state?
+
+        lib::error_code ec;
+
+        if (m_output_stream) {
+            m_output_stream->write(buf,len);
+            
+            if (m_output_stream->bad()) {
+                ec = make_error_code(error::bad_stream);
+            }
+        } else if (m_write_handler) {
+            ec = m_write_handler(m_connection_hdl, buf, len);
+        } else {
+            ec = make_error_code(error::output_stream_required);
+        }
+
+        handler(ec);
+    }
+
+    /// Asyncronous Transport Write (scatter-gather)
+    /**
+     * Write a sequence of buffers to the output method. Call handler to report
+     * success or failure. handler may or may not be called during async_write,
+     * but it must be safe for this to happen.
+     *
+     * Will return 0 on success. Other possible errors (not exhaustive)
+     * output_stream_required: No output stream was registered to write to
+     * bad_stream: a ostream pass through error
+     *
+     * This method will attempt to write to the registered ostream first. If an
+     * ostream is not registered it will use the write handler. If neither are
+     * registered then an error is passed up to the connection.
+     *
+     * @param bufs vector of buffers to write
+     * @param handler Callback to invoke with operation status.
+     */
+    void async_write(std::vector<buffer> const & bufs, transport::write_handler
+        handler)
+    {
+        m_alog.write(log::alevel::devel,"iostream_con async_write buffer list");
+        // TODO: lock transport state?
+
+        lib::error_code ec;
+
+        if (m_output_stream) {
+            std::vector<buffer>::const_iterator it;
+            for (it = bufs.begin(); it != bufs.end(); it++) {
+                m_output_stream->write((*it).buf,(*it).len);
+
+                if (m_output_stream->bad()) {
+                    ec = make_error_code(error::bad_stream);
+                    break;
+                }
+            }
+        } else if (m_write_handler) {
+            std::vector<buffer>::const_iterator it;
+            for (it = bufs.begin(); it != bufs.end(); it++) {
+                ec = m_write_handler(m_connection_hdl, (*it).buf, (*it).len);
+                if (ec) {break;}
+            }
+            
+        } else {
+            ec = make_error_code(error::output_stream_required);
+        }
+        
+        handler(ec);
+    }
+
+    /// Set Connection Handle
+    /**
+     * @param hdl The new handle
+     */
+    void set_handle(connection_hdl hdl) {
+        m_connection_hdl = hdl;
+    }
+
+    /// Call given handler back within the transport's event system (if present)
+    /**
+     * Invoke a callback within the transport's event system if it has one. If
+     * it doesn't, the handler will be invoked immediately before this function
+     * returns.
+     *
+     * @param handler The callback to invoke
+     *
+     * @return Whether or not the transport was able to register the handler for
+     * callback.
+     */
+    lib::error_code dispatch(dispatch_handler handler) {
+        handler();
+        return lib::error_code();
+    }
+
+    /// Perform cleanup on socket shutdown_handler
+    /**
+     * If a shutdown handler is set, call it and pass through its return error
+     * code. Otherwise assume there is nothing to do and pass through a success
+     * code.
+     *
+     * @param handler The `shutdown_handler` to call back when complete
+     */
+    void async_shutdown(transport::shutdown_handler handler) {
+        lib::error_code ec;
+        
+        if (m_shutdown_handler) {
+            ec = m_shutdown_handler(m_connection_hdl);
+        }
+        
+        handler(ec);
+    }
+private:
+    void read(std::istream &in) {
+        m_alog.write(log::alevel::devel,"iostream_con read");
+
+        while (in.good()) {
+            if (!m_reading) {
+                m_elog.write(log::elevel::devel,"write while not reading");
+                break;
+            }
+
+            in.read(m_buf+m_cursor,static_cast<std::streamsize>(m_len-m_cursor));
+
+            if (in.gcount() == 0) {
+                m_elog.write(log::elevel::devel,"read zero bytes");
+                break;
+            }
+
+            m_cursor += static_cast<size_t>(in.gcount());
+
+            // TODO: error handling
+            if (in.bad()) {
+                m_reading = false;
+                complete_read(make_error_code(error::bad_stream));
+            }
+
+            if (m_cursor >= m_bytes_needed) {
+                m_reading = false;
+                complete_read(lib::error_code());
+            }
+        }
+    }
+
+    size_t read_some_impl(char const * buf, size_t len) {
+        m_alog.write(log::alevel::devel,"iostream_con read_some");
+
+        if (!m_reading) {
+            m_elog.write(log::elevel::devel,"write while not reading");
+            return 0;
+        }
+
+        size_t bytes_to_copy = (std::min)(len,m_len-m_cursor);
+
+        std::copy(buf,buf+bytes_to_copy,m_buf+m_cursor);
+
+        m_cursor += bytes_to_copy;
+
+        if (m_cursor >= m_bytes_needed) {
+            complete_read(lib::error_code());
+        }
+
+        return bytes_to_copy;
+    }
+
+    /// Signal that a requested read is complete
+    /**
+     * Sets the reading flag to false and returns the handler that should be
+     * called back with the result of the read. The cursor position that is sent
+     * is whatever the value of m_cursor is.
+     *
+     * It MUST NOT be called when m_reading is false.
+     * it MUST be called while holding the read lock
+     *
+     * It is important to use this method rather than directly setting/calling
+     * m_read_handler back because this function makes sure to delete the
+     * locally stored handler which contains shared pointers that will otherwise
+     * cause circular reference based memory leaks.
+     *
+     * @param ec The error code to forward to the read handler
+     */
+    void complete_read(lib::error_code const & ec) {
+        m_reading = false;
+
+        read_handler handler = m_read_handler;
+        m_read_handler = read_handler();
+
+        handler(ec,m_cursor);
+    }
+
+    // Read space (Protected by m_read_mutex)
+    char *          m_buf;
+    size_t          m_len;
+    size_t          m_bytes_needed;
+    read_handler    m_read_handler;
+    size_t          m_cursor;
+
+    // transport resources
+    std::ostream *  m_output_stream;
+    connection_hdl  m_connection_hdl;
+    write_handler   m_write_handler;
+    shutdown_handler    m_shutdown_handler;
+
+    bool            m_reading;
+    bool const      m_is_server;
+    bool            m_is_secure;
+    alog_type &     m_alog;
+    elog_type &     m_elog;
+    std::string     m_remote_endpoint;
+
+    // This lock ensures that only one thread can edit read data for this
+    // connection. This is a very coarse lock that is basically locked all the
+    // time. The nature of the connection is such that it cannot be
+    // parallelized, the locking is here to prevent intra-connection concurrency
+    // in order to allow inter-connection concurrency.
+    mutex_type      m_read_mutex;
+};
+
+
+} // namespace iostream
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_IOSTREAM_CON_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/iostream/endpoint.hpp b/extlibs/websocketpp/websocketpp/transport/iostream/endpoint.hpp
new file mode 100644
index 000000000..14ec65370
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/iostream/endpoint.hpp
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_IOSTREAM_HPP
+#define WEBSOCKETPP_TRANSPORT_IOSTREAM_HPP
+
+#include <websocketpp/transport/base/endpoint.hpp>
+#include <websocketpp/transport/iostream/connection.hpp>
+
+#include <websocketpp/uri.hpp>
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/common/memory.hpp>
+
+#include <ostream>
+
+namespace websocketpp {
+namespace transport {
+namespace iostream {
+
+template <typename config>
+class endpoint {
+public:
+    /// Type of this endpoint transport component
+    typedef endpoint type;
+    /// Type of a pointer to this endpoint transport component
+    typedef lib::shared_ptr<type> ptr;
+
+    /// Type of this endpoint's concurrency policy
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of this endpoint's error logging policy
+    typedef typename config::elog_type elog_type;
+    /// Type of this endpoint's access logging policy
+    typedef typename config::alog_type alog_type;
+
+    /// Type of this endpoint transport component's associated connection
+    /// transport component.
+    typedef iostream::connection<config> transport_con_type;
+    /// Type of a shared pointer to this endpoint transport component's
+    /// associated connection transport component
+    typedef typename transport_con_type::ptr transport_con_ptr;
+
+    // generate and manage our own io_service
+    explicit endpoint() : m_output_stream(NULL), m_is_secure(false)
+    {
+        //std::cout << "transport::iostream::endpoint constructor" << std::endl;
+    }
+
+    /// Register a default output stream
+    /**
+     * The specified output stream will be assigned to future connections as the
+     * default output stream.
+     *
+     * @param o The ostream to use as the default output stream.
+     */
+    void register_ostream(std::ostream * o) {
+        m_alog->write(log::alevel::devel,"register_ostream");
+        m_output_stream = o;
+    }
+
+    /// Set whether or not endpoint can create secure connections
+    /**
+     * The iostream transport does not provide any security features. As such
+     * it defaults to returning false when `is_secure` is called. However, the
+     * iostream transport may be used to wrap an external socket API that may
+     * provide secure transport. This method allows that external API to flag
+     * whether or not it can create secure connections so that users of the
+     * WebSocket++ API will get more accurate information.
+     *
+     * Setting this value only indicates whether or not the endpoint is capable
+     * of producing and managing secure connections. Connections produced by
+     * this endpoint must also be individually flagged as secure if they are.
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param value Whether or not the endpoint can create secure connections.
+     */
+    void set_secure(bool value) {
+        m_is_secure = value;
+    }
+
+    /// Tests whether or not the underlying transport is secure
+    /**
+     * iostream transport will return false by default because it has no
+     * information about the ultimate remote endpoint. This may or may not be
+     * accurate depending on the real source of bytes being input. `set_secure`
+     * may be used by a wrapper API to correct the return value in the case that
+     * secure connections are in fact possible.
+     *
+     * @return Whether or not the underlying transport is secure
+     */
+    bool is_secure() const {
+        return m_is_secure;
+    }
+    
+    /// Sets the write handler
+    /**
+     * The write handler is called when the iostream transport receives data
+     * that needs to be written to the appropriate output location. This handler
+     * can be used in place of registering an ostream for output.
+     *
+     * The signature of the handler is 
+     * `lib::error_code (connection_hdl, char const *, size_t)` The
+     * code returned will be reported and logged by the core library.
+     *
+     * @since 0.5.0
+     *
+     * @param h The handler to call on connection shutdown.
+     */
+    void set_write_handler(write_handler h) {
+        m_write_handler = h;
+    }
+    
+    /// Sets the shutdown handler
+    /**
+     * The shutdown handler is called when the iostream transport receives a
+     * notification from the core library that it is finished with all read and
+     * write operations and that the underlying transport can be cleaned up.
+     *
+     * If you are using iostream transport with another socket library, this is
+     * a good time to close/shutdown the socket for this connection.
+     *
+     * The signature of the handler is lib::error_code (connection_hdl). The
+     * code returned will be reported and logged by the core library.
+     *
+     * @since 0.5.0
+     *
+     * @param h The handler to call on connection shutdown.
+     */
+    void set_shutdown_handler(shutdown_handler h) {
+        m_shutdown_handler = h;
+    }
+protected:
+    /// Initialize logging
+    /**
+     * The loggers are located in the main endpoint class. As such, the
+     * transport doesn't have direct access to them. This method is called
+     * by the endpoint constructor to allow shared logging from the transport
+     * component. These are raw pointers to member variables of the endpoint.
+     * In particular, they cannot be used in the transport constructor as they
+     * haven't been constructed yet, and cannot be used in the transport
+     * destructor as they will have been destroyed by then.
+     *
+     * @param a A pointer to the access logger to use.
+     * @param e A pointer to the error logger to use.
+     */
+    void init_logging(alog_type * a, elog_type * e) {
+        m_elog = e;
+        m_alog = a;
+    }
+
+    /// Initiate a new connection
+    /**
+     * @param tcon A pointer to the transport connection component of the
+     * connection to connect.
+     * @param u A URI pointer to the URI to connect to.
+     * @param cb The function to call back with the results when complete.
+     */
+    void async_connect(transport_con_ptr, uri_ptr, connect_handler cb) {
+        cb(lib::error_code());
+    }
+
+    /// Initialize a connection
+    /**
+     * Init is called by an endpoint once for each newly created connection.
+     * It's purpose is to give the transport policy the chance to perform any
+     * transport specific initialization that couldn't be done via the default
+     * constructor.
+     *
+     * @param tcon A pointer to the transport portion of the connection.
+     * @return A status code indicating the success or failure of the operation
+     */
+    lib::error_code init(transport_con_ptr tcon) {
+        tcon->register_ostream(m_output_stream);
+        if (m_shutdown_handler) {
+            tcon->set_shutdown_handler(m_shutdown_handler);
+        }
+        if (m_write_handler) {
+            tcon->set_write_handler(m_write_handler);
+        }
+        return lib::error_code();
+    }
+private:
+    std::ostream *  m_output_stream;
+    shutdown_handler m_shutdown_handler;
+    write_handler   m_write_handler;
+    
+    elog_type *     m_elog;
+    alog_type *     m_alog;
+    bool            m_is_secure;
+};
+
+
+} // namespace iostream
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_IOSTREAM_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/stub/base.hpp b/extlibs/websocketpp/websocketpp/transport/stub/base.hpp
new file mode 100644
index 000000000..754981e29
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/stub/base.hpp
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_STUB_BASE_HPP
+#define WEBSOCKETPP_TRANSPORT_STUB_BASE_HPP
+
+#include <websocketpp/common/system_error.hpp>
+#include <websocketpp/common/cpp11.hpp>
+
+#include <string>
+
+namespace websocketpp {
+namespace transport {
+/// Stub transport policy that has no input or output.
+namespace stub {
+
+/// stub transport errors
+namespace error {
+enum value {
+    /// Catch-all error for transport policy errors that don't fit in other
+    /// categories
+    general = 1,
+
+    /// not implemented
+    not_implemented
+};
+
+/// stub transport error category
+class category : public lib::error_category {
+    public:
+    category() {}
+
+    char const * name() const _WEBSOCKETPP_NOEXCEPT_TOKEN_ {
+        return "websocketpp.transport.stub";
+    }
+
+    std::string message(int value) const {
+        switch(value) {
+            case general:
+                return "Generic stub transport policy error";
+            case not_implemented:
+                return "feature not implemented";
+            default:
+                return "Unknown";
+        }
+    }
+};
+
+/// Get a reference to a static copy of the stub transport error category
+inline lib::error_category const & get_category() {
+    static category instance;
+    return instance;
+}
+
+/// Get an error code with the given value and the stub transport category
+inline lib::error_code make_error_code(error::value e) {
+    return lib::error_code(static_cast<int>(e), get_category());
+}
+
+} // namespace error
+} // namespace stub
+} // namespace transport
+} // namespace websocketpp
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_START_
+template<> struct is_error_code_enum<websocketpp::transport::stub::error::value>
+{
+    static bool const value = true;
+};
+_WEBSOCKETPP_ERROR_CODE_ENUM_NS_END_
+
+#endif // WEBSOCKETPP_TRANSPORT_STUB_BASE_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/stub/connection.hpp b/extlibs/websocketpp/websocketpp/transport/stub/connection.hpp
new file mode 100644
index 000000000..3e501a963
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/stub/connection.hpp
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_STUB_CON_HPP
+#define WEBSOCKETPP_TRANSPORT_STUB_CON_HPP
+
+#include <websocketpp/transport/stub/base.hpp>
+
+#include <websocketpp/transport/base/connection.hpp>
+
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/common/connection_hdl.hpp>
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/common/platforms.hpp>
+
+#include <string>
+#include <vector>
+
+namespace websocketpp {
+namespace transport {
+namespace stub {
+
+/// Empty timer class to stub out for timer functionality that stub
+/// transport doesn't support
+struct timer {
+    void cancel() {}
+};
+
+template <typename config>
+class connection : public lib::enable_shared_from_this< connection<config> > {
+public:
+    /// Type of this connection transport component
+    typedef connection<config> type;
+    /// Type of a shared pointer to this connection transport component
+    typedef lib::shared_ptr<type> ptr;
+
+    /// transport concurrency policy
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of this transport's access logging policy
+    typedef typename config::alog_type alog_type;
+    /// Type of this transport's error logging policy
+    typedef typename config::elog_type elog_type;
+
+    // Concurrency policy types
+    typedef typename concurrency_type::scoped_lock_type scoped_lock_type;
+    typedef typename concurrency_type::mutex_type mutex_type;
+
+    typedef lib::shared_ptr<timer> timer_ptr;
+
+    explicit connection(bool is_server, alog_type & alog, elog_type & elog)
+      : m_alog(alog), m_elog(elog)
+    {
+        m_alog.write(log::alevel::devel,"stub con transport constructor");
+    }
+
+    /// Get a shared pointer to this component
+    ptr get_shared() {
+        return type::shared_from_this();
+    }
+
+    /// Set whether or not this connection is secure
+    /**
+     * Todo: docs
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param value Whether or not this connection is secure.
+     */
+    void set_secure(bool value) {}
+
+    /// Tests whether or not the underlying transport is secure
+    /**
+     * TODO: docs
+     *
+     * @return Whether or not the underlying transport is secure
+     */
+    bool is_secure() const {
+        return false;
+    }
+
+    /// Set human readable remote endpoint address
+    /**
+     * Sets the remote endpoint address returned by `get_remote_endpoint`. This
+     * value should be a human readable string that describes the remote
+     * endpoint. Typically an IP address or hostname, perhaps with a port. But
+     * may be something else depending on the nature of the underlying
+     * transport.
+     *
+     * If none is set a default is returned.
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param value The remote endpoint address to set.
+     */
+    void set_remote_endpoint(std::string value) {}
+
+    /// Get human readable remote endpoint address
+    /**
+     * TODO: docs
+     *
+     * This value is used in access and error logs and is available to the end
+     * application for including in user facing interfaces and messages.
+     *
+     * @return A string identifying the address of the remote endpoint
+     */
+    std::string get_remote_endpoint() const {
+        return "unknown (stub transport)";
+    }
+
+    /// Get the connection handle
+    /**
+     * @return The handle for this connection.
+     */
+    connection_hdl get_handle() const {
+        return connection_hdl();
+    }
+
+    /// Call back a function after a period of time.
+    /**
+     * Timers are not implemented in this transport. The timer pointer will
+     * always be empty. The handler will never be called.
+     *
+     * @param duration Length of time to wait in milliseconds
+     * @param callback The function to call back when the timer has expired
+     * @return A handle that can be used to cancel the timer if it is no longer
+     * needed.
+     */
+    timer_ptr set_timer(long duration, timer_handler handler) {
+        return timer_ptr();
+    }
+protected:
+    /// Initialize the connection transport
+    /**
+     * Initialize the connection's transport component.
+     *
+     * @param handler The `init_handler` to call when initialization is done
+     */
+    void init(init_handler handler) {
+        m_alog.write(log::alevel::devel,"stub connection init");
+        handler(make_error_code(error::not_implemented));
+    }
+
+    /// Initiate an async_read for at least num_bytes bytes into buf
+    /**
+     * Initiates an async_read request for at least num_bytes bytes. The input
+     * will be read into buf. A maximum of len bytes will be input. When the
+     * operation is complete, handler will be called with the status and number
+     * of bytes read.
+     *
+     * This method may or may not call handler from within the initial call. The
+     * application should be prepared to accept either.
+     *
+     * The application should never call this method a second time before it has
+     * been called back for the first read. If this is done, the second read
+     * will be called back immediately with a double_read error.
+     *
+     * If num_bytes or len are zero handler will be called back immediately
+     * indicating success.
+     *
+     * @param num_bytes Don't call handler until at least this many bytes have
+     * been read.
+     * @param buf The buffer to read bytes into
+     * @param len The size of buf. At maximum, this many bytes will be read.
+     * @param handler The callback to invoke when the operation is complete or
+     * ends in an error
+     */
+    void async_read_at_least(size_t num_bytes, char * buf, size_t len,
+        read_handler handler)
+    {
+        m_alog.write(log::alevel::devel, "stub_con async_read_at_least");
+        handler(make_error_code(error::not_implemented), 0);
+    }
+
+    /// Asyncronous Transport Write
+    /**
+     * Write len bytes in buf to the output stream. Call handler to report
+     * success or failure. handler may or may not be called during async_write,
+     * but it must be safe for this to happen.
+     *
+     * Will return 0 on success.
+     *
+     * @param buf buffer to read bytes from
+     * @param len number of bytes to write
+     * @param handler Callback to invoke with operation status.
+     */
+    void async_write(char const * buf, size_t len, write_handler handler) {
+        m_alog.write(log::alevel::devel,"stub_con async_write");
+        handler(make_error_code(error::not_implemented));
+    }
+
+    /// Asyncronous Transport Write (scatter-gather)
+    /**
+     * Write a sequence of buffers to the output stream. Call handler to report
+     * success or failure. handler may or may not be called during async_write,
+     * but it must be safe for this to happen.
+     *
+     * Will return 0 on success.
+     *
+     * @param bufs vector of buffers to write
+     * @param handler Callback to invoke with operation status.
+     */
+    void async_write(std::vector<buffer> const & bufs, write_handler handler) {
+        m_alog.write(log::alevel::devel,"stub_con async_write buffer list");
+        handler(make_error_code(error::not_implemented));
+    }
+
+    /// Set Connection Handle
+    /**
+     * @param hdl The new handle
+     */
+    void set_handle(connection_hdl hdl) {}
+
+    /// Call given handler back within the transport's event system (if present)
+    /**
+     * Invoke a callback within the transport's event system if it has one. If
+     * it doesn't, the handler will be invoked immediately before this function
+     * returns.
+     *
+     * @param handler The callback to invoke
+     *
+     * @return Whether or not the transport was able to register the handler for
+     * callback.
+     */
+    lib::error_code dispatch(dispatch_handler handler) {
+        handler();
+        return lib::error_code();
+    }
+
+    /// Perform cleanup on socket shutdown_handler
+    /**
+     * @param h The `shutdown_handler` to call back when complete
+     */
+    void async_shutdown(shutdown_handler handler) {
+        handler(lib::error_code());
+    }
+private:
+    // member variables!
+    alog_type & m_alog;
+    elog_type & m_elog;
+};
+
+
+} // namespace stub
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_STUB_CON_HPP
diff --git a/extlibs/websocketpp/websocketpp/transport/stub/endpoint.hpp b/extlibs/websocketpp/websocketpp/transport/stub/endpoint.hpp
new file mode 100644
index 000000000..3bbb78f35
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/transport/stub/endpoint.hpp
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_TRANSPORT_STUB_HPP
+#define WEBSOCKETPP_TRANSPORT_STUB_HPP
+
+#include <websocketpp/common/memory.hpp>
+#include <websocketpp/logger/levels.hpp>
+
+#include <websocketpp/transport/base/endpoint.hpp>
+#include <websocketpp/transport/stub/connection.hpp>
+
+namespace websocketpp {
+namespace transport {
+namespace stub {
+
+template <typename config>
+class endpoint {
+public:
+    /// Type of this endpoint transport component
+    typedef endpoint type;
+    /// Type of a pointer to this endpoint transport component
+    typedef lib::shared_ptr<type> ptr;
+
+    /// Type of this endpoint's concurrency policy
+    typedef typename config::concurrency_type concurrency_type;
+    /// Type of this endpoint's error logging policy
+    typedef typename config::elog_type elog_type;
+    /// Type of this endpoint's access logging policy
+    typedef typename config::alog_type alog_type;
+
+    /// Type of this endpoint transport component's associated connection
+    /// transport component.
+    typedef stub::connection<config> transport_con_type;
+    /// Type of a shared pointer to this endpoint transport component's
+    /// associated connection transport component
+    typedef typename transport_con_type::ptr transport_con_ptr;
+
+    // generate and manage our own io_service
+    explicit endpoint()
+    {
+        //std::cout << "transport::iostream::endpoint constructor" << std::endl;
+    }
+
+    /// Set whether or not endpoint can create secure connections
+    /**
+     * TODO: docs
+     *
+     * Setting this value only indicates whether or not the endpoint is capable
+     * of producing and managing secure connections. Connections produced by
+     * this endpoint must also be individually flagged as secure if they are.
+     *
+     * @since 0.3.0-alpha4
+     *
+     * @param value Whether or not the endpoint can create secure connections.
+     */
+    void set_secure(bool value) {}
+
+    /// Tests whether or not the underlying transport is secure
+    /**
+     * TODO: docs
+     *
+     * @return Whether or not the underlying transport is secure
+     */
+    bool is_secure() const {
+        return false;
+    }
+protected:
+    /// Initialize logging
+    /**
+     * The loggers are located in the main endpoint class. As such, the
+     * transport doesn't have direct access to them. This method is called
+     * by the endpoint constructor to allow shared logging from the transport
+     * component. These are raw pointers to member variables of the endpoint.
+     * In particular, they cannot be used in the transport constructor as they
+     * haven't been constructed yet, and cannot be used in the transport
+     * destructor as they will have been destroyed by then.
+     *
+     * @param a A pointer to the access logger to use.
+     * @param e A pointer to the error logger to use.
+     */
+    void init_logging(alog_type * a, elog_type * e) {}
+
+    /// Initiate a new connection
+    /**
+     * @param tcon A pointer to the transport connection component of the
+     * connection to connect.
+     * @param u A URI pointer to the URI to connect to.
+     * @param cb The function to call back with the results when complete.
+     */
+    void async_connect(transport_con_ptr tcon, uri_ptr u, connect_handler cb) {
+        cb(make_error_code(error::not_implemented));
+    }
+
+    /// Initialize a connection
+    /**
+     * Init is called by an endpoint once for each newly created connection.
+     * It's purpose is to give the transport policy the chance to perform any
+     * transport specific initialization that couldn't be done via the default
+     * constructor.
+     *
+     * @param tcon A pointer to the transport portion of the connection.
+     * @return A status code indicating the success or failure of the operation
+     */
+    lib::error_code init(transport_con_ptr tcon) {
+        return make_error_code(error::not_implemented);
+    }
+private:
+
+};
+
+} // namespace stub
+} // namespace transport
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_TRANSPORT_STUB_HPP
diff --git a/extlibs/websocketpp/websocketpp/uri.hpp b/extlibs/websocketpp/websocketpp/uri.hpp
new file mode 100644
index 000000000..e2cd8c837
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/uri.hpp
@@ -0,0 +1,354 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_URI_HPP
+#define WEBSOCKETPP_URI_HPP
+
+#include <websocketpp/error.hpp>
+
+#include <websocketpp/common/memory.hpp>
+
+#include <algorithm>
+#include <sstream>
+#include <string>
+
+namespace websocketpp {
+
+// TODO: figure out why this fixes horrible linking errors.
+
+/// Default port for ws://
+static uint16_t const uri_default_port = 80;
+/// Default port for wss://
+static uint16_t const uri_default_secure_port = 443;
+
+class uri {
+public:
+    explicit uri(std::string const & uri_string) : m_valid(false) {
+        std::string::const_iterator it;
+        std::string::const_iterator temp;
+
+        int state = 0;
+
+        it = uri_string.begin();
+
+        if (std::equal(it,it+6,"wss://")) {
+            m_secure = true;
+            m_scheme = "wss";
+            it += 6;
+        } else if (std::equal(it,it+5,"ws://")) {
+            m_secure = false;
+            m_scheme = "ws";
+            it += 5;
+        } else if (std::equal(it,it+7,"http://")) {
+            m_secure = false;
+            m_scheme = "http";
+            it += 7;
+        } else if (std::equal(it,it+8,"https://")) {
+            m_secure = true;
+            m_scheme = "https";
+            it += 8;
+        } else {
+            return;
+        }
+
+        // extract host.
+        // either a host string
+        // an IPv4 address
+        // or an IPv6 address
+        if (*it == '[') {
+            ++it;
+            // IPv6 literal
+            // extract IPv6 digits until ]
+
+            // TODO: this doesn't work on g++... not sure why
+            //temp = std::find(it,it2,']');
+
+            temp = it;
+            while (temp != uri_string.end()) {
+                if (*temp == ']') {
+                    break;
+                }
+                ++temp;
+            }
+
+            if (temp == uri_string.end()) {
+                return;
+            } else {
+                // validate IPv6 literal parts
+                // can contain numbers, a-f and A-F
+                m_host.append(it,temp);
+            }
+            it = temp+1;
+            if (it == uri_string.end()) {
+                state = 2;
+            } else if (*it == '/') {
+                state = 2;
+                ++it;
+            } else if (*it == ':') {
+                state = 1;
+                ++it;
+            } else {
+                // problem
+                return;
+            }
+        } else {
+            // IPv4 or hostname
+            // extract until : or /
+            while (state == 0) {
+                if (it == uri_string.end()) {
+                    state = 2;
+                    break;
+                } else if (*it == '/') {
+                    state = 2;
+                } else if (*it == ':') {
+                    // end hostname start port
+                    state = 1;
+                } else {
+                    m_host += *it;
+                }
+                ++it;
+            }
+        }
+
+        // parse port
+        std::string port = "";
+        while (state == 1) {
+            if (it == uri_string.end()) {
+                // state is not used after this point presently.
+                // this should be re-enabled if it ever is needed in a future
+                // refactoring
+                //state = 3;
+                break;
+            } else if (*it == '/') {
+                state = 3;
+            } else {
+                port += *it;
+            }
+            ++it;
+        }
+
+        lib::error_code ec;
+        m_port = get_port_from_string(port, ec);
+
+        if (ec) {
+            return;
+        }
+
+        m_resource = "/";
+        m_resource.append(it,uri_string.end());
+
+
+        m_valid = true;
+    }
+
+    uri(bool secure, std::string const & host, uint16_t port,
+        std::string const & resource)
+      : m_scheme(secure ? "wss" : "ws")
+      , m_host(host)
+      , m_resource(resource == "" ? "/" : resource)
+      , m_port(port)
+      , m_secure(secure)
+      , m_valid(true) {}
+
+    uri(bool secure, std::string const & host, std::string const & resource)
+      : m_scheme(secure ? "wss" : "ws")
+      , m_host(host)
+      , m_resource(resource == "" ? "/" : resource)
+      , m_port(secure ? uri_default_secure_port : uri_default_port)
+      , m_secure(secure)
+      , m_valid(true) {}
+
+    uri(bool secure, std::string const & host, std::string const & port,
+        std::string const & resource)
+      : m_scheme(secure ? "wss" : "ws")
+      , m_host(host)
+      , m_resource(resource == "" ? "/" : resource)
+      , m_secure(secure)
+    {
+        lib::error_code ec;
+        m_port = get_port_from_string(port,ec);
+        m_valid = !ec;
+    }
+
+    uri(std::string const & scheme, std::string const & host, uint16_t port,
+        std::string const & resource)
+      : m_scheme(scheme)
+      , m_host(host)
+      , m_resource(resource == "" ? "/" : resource)
+      , m_port(port)
+      , m_secure(scheme == "wss" || scheme == "https")
+      , m_valid(true) {}
+
+    uri(std::string scheme, std::string const & host, std::string const & resource)
+      : m_scheme(scheme)
+      , m_host(host)
+      , m_resource(resource == "" ? "/" : resource)
+      , m_port((scheme == "wss" || scheme == "https") ? uri_default_secure_port : uri_default_port)
+      , m_secure(scheme == "wss" || scheme == "https")
+      , m_valid(true) {}
+
+    uri(std::string const & scheme, std::string const & host,
+        std::string const & port, std::string const & resource)
+      : m_scheme(scheme)
+      , m_host(host)
+      , m_resource(resource == "" ? "/" : resource)
+      , m_secure(scheme == "wss" || scheme == "https")
+    {
+        lib::error_code ec;
+        m_port = get_port_from_string(port,ec);
+        m_valid = !ec;
+    }
+
+    bool get_valid() const {
+        return m_valid;
+    }
+
+    bool get_secure() const {
+        return m_secure;
+    }
+
+    std::string const & get_scheme() const {
+        return m_scheme;
+    }
+
+    std::string const & get_host() const {
+        return m_host;
+    }
+
+    std::string get_host_port() const {
+        if (m_port == (m_secure ? uri_default_secure_port : uri_default_port)) {
+            return m_host;
+        } else {
+            std::stringstream p;
+            p << m_host << ":" << m_port;
+            return p.str();
+        }
+    }
+
+    std::string get_authority() const {
+        std::stringstream p;
+        p << m_host << ":" << m_port;
+        return p.str();
+    }
+
+    uint16_t get_port() const {
+        return m_port;
+    }
+
+    std::string get_port_str() const {
+        std::stringstream p;
+        p << m_port;
+        return p.str();
+    }
+
+    std::string const & get_resource() const {
+        return m_resource;
+    }
+
+    std::string str() const {
+        std::stringstream s;
+
+        s << m_scheme << "://" << m_host;
+
+        if (m_port != (m_secure ? uri_default_secure_port : uri_default_port)) {
+            s << ":" << m_port;
+        }
+
+        s << m_resource;
+        return s.str();
+    }
+
+    /// Return the query portion
+    /**
+     * Returns the query portion (after the ?) of the URI or an empty string if
+     * there is none.
+     *
+     * @return query portion of the URI.
+     */
+    std::string get_query() const {
+        std::size_t found = m_resource.find('?');
+        if (found != std::string::npos) {
+            return m_resource.substr(found + 1);
+        } else {
+            return "";
+        }
+    }
+
+    // get fragment
+
+    // hi <3
+
+    // get the string representation of this URI
+
+    //std::string base() const; // is this still needed?
+
+    // setter methods set some or all (in the case of parse) based on the input.
+    // These functions throw a uri_exception on failure.
+    /*void set_uri(const std::string& uri);
+
+    void set_secure(bool secure);
+    void set_host(const std::string& host);
+    void set_port(uint16_t port);
+    void set_port(const std::string& port);
+    void set_resource(const std::string& resource);*/
+private:
+    uint16_t get_port_from_string(std::string const & port, lib::error_code &
+        ec) const
+    {
+        ec = lib::error_code();
+
+        if (port == "") {
+            return (m_secure ? uri_default_secure_port : uri_default_port);
+        }
+
+        unsigned int t_port = static_cast<unsigned int>(atoi(port.c_str()));
+
+        if (t_port > 65535) {
+            ec = error::make_error_code(error::invalid_port);
+        }
+
+        if (t_port == 0) {
+            ec = error::make_error_code(error::invalid_port);
+        }
+
+        return static_cast<uint16_t>(t_port);
+    }
+
+    std::string m_scheme;
+    std::string m_host;
+    std::string m_resource;
+    uint16_t    m_port;
+    bool        m_secure;
+    bool        m_valid;
+};
+
+/// Pointer to a URI
+typedef lib::shared_ptr<uri> uri_ptr;
+
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_URI_HPP
diff --git a/extlibs/websocketpp/websocketpp/utf8_validator.hpp b/extlibs/websocketpp/websocketpp/utf8_validator.hpp
new file mode 100644
index 000000000..c057da629
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/utf8_validator.hpp
@@ -0,0 +1,154 @@
+/*
+ * The following code is adapted from code originally written by Bjoern
+ * Hoehrmann <bjoern@hoehrmann.de>. See
+ * http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.
+ *
+ * The original license:
+ *
+ * Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+*/
+
+#ifndef UTF8_VALIDATOR_HPP
+#define UTF8_VALIDATOR_HPP
+
+#include <websocketpp/common/stdint.hpp>
+
+#include <string>
+
+namespace websocketpp {
+namespace utf8_validator {
+
+/// State that represents a valid utf8 input sequence
+static unsigned int const utf8_accept = 0;
+/// State that represents an invalid utf8 input sequence
+static unsigned int const utf8_reject = 1;
+
+/// Lookup table for the UTF8 decode state machine
+static uint8_t const utf8d[] = {
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f
+  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f
+  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf
+  8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df
+  0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef
+  0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff
+  0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0
+  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2
+  1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4
+  1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6
+  1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8
+};
+
+/// Decode the next byte of a UTF8 sequence
+/**
+ * @param [out] state The decoder state to advance
+ * @param [out] codep The codepoint to fill in
+ * @param [in] byte The byte to input
+ * @return The ending state of the decode operation
+ */
+inline uint32_t decode(uint32_t * state, uint32_t * codep, uint8_t byte) {
+  uint32_t type = utf8d[byte];
+
+  *codep = (*state != utf8_accept) ?
+    (byte & 0x3fu) | (*codep << 6) :
+    (0xff >> type) & (byte);
+
+  *state = utf8d[256 + *state*16 + type];
+  return *state;
+}
+
+/// Provides streaming UTF8 validation functionality
+class validator {
+public:
+    /// Construct and initialize the validator
+    validator() : m_state(utf8_accept),m_codepoint(0) {}
+
+    /// Advance the state of the validator with the next input byte
+    /**
+     * @param byte The byte to advance the validation state with
+     * @return Whether or not the byte resulted in a validation error.
+     */
+    bool consume (uint8_t byte) {
+        if (utf8_validator::decode(&m_state,&m_codepoint,byte) == utf8_reject) {
+            return false;
+        }
+        return true;
+    }
+
+    /// Advance validator state with input from an iterator pair
+    /**
+     * @param begin Input iterator to the start of the input range
+     * @param end Input iterator to the end of the input range
+     * @return Whether or not decoding the bytes resulted in a validation error.
+     */
+    template <typename iterator_type>
+    bool decode (iterator_type begin, iterator_type end) {
+        for (iterator_type it = begin; it != end; ++it) {
+            unsigned int result = utf8_validator::decode(
+                &m_state,
+                &m_codepoint,
+                static_cast<uint8_t>(*it)
+            );
+
+            if (result == utf8_reject) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /// Return whether the input sequence ended on a valid utf8 codepoint
+    /**
+     * @return Whether or not the input sequence ended on a valid codepoint.
+     */
+    bool complete() {
+        return m_state == utf8_accept;
+    }
+
+    /// Reset the validator to decode another message
+    void reset() {
+        m_state = utf8_accept;
+        m_codepoint = 0;
+    }
+private:
+    uint32_t    m_state;
+    uint32_t    m_codepoint;
+};
+
+/// Validate a UTF8 string
+/**
+ * convenience function that creates a validator, validates a complete string
+ * and returns the result.
+ */
+inline bool validate(std::string const & s) {
+    validator v;
+    if (!v.decode(s.begin(),s.end())) {
+        return false;
+    }
+    return v.complete();
+}
+
+} // namespace utf8_validator
+} // namespace websocketpp
+
+#endif // UTF8_VALIDATOR_HPP
diff --git a/extlibs/websocketpp/websocketpp/utilities.hpp b/extlibs/websocketpp/websocketpp/utilities.hpp
new file mode 100644
index 000000000..747f1199b
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/utilities.hpp
@@ -0,0 +1,182 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_UTILITIES_HPP
+#define WEBSOCKETPP_UTILITIES_HPP
+
+#include <websocketpp/common/stdint.hpp>
+
+#include <algorithm>
+#include <string>
+#include <locale>
+
+namespace websocketpp {
+/// Generic non-websocket specific utility functions and data structures
+namespace utility {
+
+/// Helper functor for case insensitive find
+/**
+ * Based on code from
+ * http://stackoverflow.com/questions/3152241/case-insensitive-stdstring-find
+ *
+ * templated version of my_equal so it could work with both char and wchar_t
+ */
+template<typename charT>
+struct my_equal {
+    /// Construct the functor with the given locale
+    /**
+     * @param [in] loc The locale to use for determining the case of values
+     */
+    my_equal(std::locale const & loc ) : m_loc(loc) {}
+
+    /// Perform a case insensitive comparison
+    /**
+     * @param ch1 The first value to compare
+     * @param ch2 The second value to compare
+     * @return Whether or not the two values are equal when both are converted
+     *         to uppercase using the given locale.
+     */
+    bool operator()(charT ch1, charT ch2) {
+        return std::toupper(ch1, m_loc) == std::toupper(ch2, m_loc);
+    }
+private:
+    std::locale const & m_loc;
+};
+
+/// Helper less than functor for case insensitive find
+/**
+ * Based on code from
+ * http://stackoverflow.com/questions/3152241/case-insensitive-stdstring-find
+ */
+struct ci_less : std::binary_function<std::string, std::string, bool> {
+    // case-independent (ci) compare_less binary function
+    struct nocase_compare
+      : public std::binary_function<unsigned char,unsigned char,bool>
+    {
+        bool operator() (unsigned char const & c1, unsigned char const & c2) const {
+            return tolower (c1) < tolower (c2);
+        }
+    };
+    bool operator() (std::string const & s1, std::string const & s2) const {
+        return std::lexicographical_compare
+            (s1.begin (), s1.end (),   // source range
+            s2.begin (), s2.end (),   // dest range
+            nocase_compare ());  // comparison
+    }
+};
+
+/// Find substring (case insensitive)
+/**
+ * @param [in] haystack The string to search in
+ * @param [in] needle The string to search for
+ * @param [in] loc The locale to use for determining the case of values.
+ *             Defaults to the current locale.
+ * @return An iterator to the first element of the first occurrance of needle in
+ *         haystack. If the sequence is not found, the function returns
+ *         haystack.end()
+ */
+template<typename T>
+typename T::const_iterator ci_find_substr(T const & haystack, T const & needle,
+    std::locale const & loc = std::locale())
+{
+    return std::search( haystack.begin(), haystack.end(),
+        needle.begin(), needle.end(), my_equal<typename T::value_type>(loc) );
+}
+
+/// Find substring (case insensitive)
+/**
+ * @todo Is this still used? This method may not make sense.. should use
+ * iterators or be less generic. As is it is too tightly coupled to std::string
+ *
+ * @param [in] haystack The string to search in
+ * @param [in] needle The string to search for as a char array of values
+ * @param [in] size Length of needle
+ * @param [in] loc The locale to use for determining the case of values.
+ *             Defaults to the current locale.
+ * @return An iterator to the first element of the first occurrance of needle in
+ *         haystack. If the sequence is not found, the function returns
+ *         haystack.end()
+ */
+template<typename T>
+typename T::const_iterator ci_find_substr(T const & haystack,
+    typename T::value_type const * needle, typename T::size_type size,
+    std::locale const & loc = std::locale())
+{
+    return std::search( haystack.begin(), haystack.end(),
+        needle, needle+size, my_equal<typename T::value_type>(loc) );
+}
+
+/// Convert a string to lowercase
+/**
+ * @param [in] in The string to convert
+ * @return The converted string
+ */
+std::string to_lower(std::string const & in);
+
+/// Replace all occurrances of a substring with another
+/**
+ * @param [in] subject The string to search in
+ * @param [in] search The string to search for
+ * @param [in] replace The string to replace with
+ * @return A copy of `subject` with all occurances of `search` replaced with
+ *         `replace`
+ */
+std::string string_replace_all(std::string subject, std::string const & search,
+                               std::string const & replace);
+
+/// Convert std::string to ascii printed string of hex digits
+/**
+ * @param [in] input The string to print
+ * @return A copy of `input` converted to the printable representation of the
+ *         hex values of its data.
+ */
+std::string to_hex(std::string const & input);
+
+/// Convert byte array (uint8_t) to ascii printed string of hex digits
+/**
+ * @param [in] input The byte array to print
+ * @param [in] length The length of input
+ * @return A copy of `input` converted to the printable representation of the
+ *         hex values of its data.
+ */
+std::string to_hex(uint8_t const * input, size_t length);
+
+/// Convert char array to ascii printed string of hex digits
+/**
+ * @param [in] input The char array to print
+ * @param [in] length The length of input
+ * @return A copy of `input` converted to the printable representation of the
+ *         hex values of its data.
+ */
+std::string to_hex(char const * input, size_t length);
+
+} // namespace utility
+} // namespace websocketpp
+
+#include <websocketpp/impl/utilities_impl.hpp>
+
+#endif // WEBSOCKETPP_UTILITIES_HPP
diff --git a/extlibs/websocketpp/websocketpp/version.hpp b/extlibs/websocketpp/websocketpp/version.hpp
new file mode 100644
index 000000000..24d6be4a2
--- /dev/null
+++ b/extlibs/websocketpp/websocketpp/version.hpp
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2014, Peter Thorson. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the WebSocket++ Project nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef WEBSOCKETPP_VERSION_HPP
+#define WEBSOCKETPP_VERSION_HPP
+
+/// Namespace for the WebSocket++ project
+namespace websocketpp {
+
+/*
+ other places where version information is kept
+ - readme.md
+ - changelog.md
+ - Doxyfile
+ - CMakeLists.txt
+*/
+
+/// Library major version number
+static int const major_version = 0;
+/// Library minor version number
+static int const minor_version = 5;
+/// Library patch version number
+static int const patch_version = 1;
+/// Library pre-release flag
+/**
+ * This is a textual flag indicating the type and number for pre-release
+ * versions (dev, alpha, beta, rc). This will be blank for release versions.
+ */
+static char const prerelease_flag[] = "";
+
+/// Default user agent string
+static char const user_agent[] = "WebSocket++/0.5.1";
+
+} // namespace websocketpp
+
+#endif // WEBSOCKETPP_VERSION_HPP
diff --git a/extlibs/wksxmppxep/prep.sh b/extlibs/wksxmppxep/prep.sh
old mode 100755
new mode 100644
diff --git a/extlibs/yaml/prep.sh b/extlibs/yaml/prep.sh
old mode 100755
new mode 100644
diff --git a/java/examples-android/gradlew b/java/examples-android/gradlew
old mode 100755
new mode 100644
diff --git a/java/examples-android/gradlew.bat b/java/examples-android/gradlew.bat
old mode 100755
new mode 100644
diff --git a/java/examples-java/ocflightserver/run.sh b/java/examples-java/ocflightserver/run.sh
old mode 100755
new mode 100644
diff --git a/java/gradlew b/java/gradlew
old mode 100755
new mode 100644
diff --git a/java/gradlew.bat b/java/gradlew.bat
old mode 100755
new mode 100644
diff --git a/java/iotivity-android/gradlew b/java/iotivity-android/gradlew
old mode 100755
new mode 100644
diff --git a/java/iotivity-android/run_android_smoketests.py b/java/iotivity-android/run_android_smoketests.py
old mode 100755
new mode 100644
diff --git a/resource/csdk/connectivity/build/tizen/gbsbuild.sh b/resource/csdk/connectivity/build/tizen/gbsbuild.sh
old mode 100755
new mode 100644
diff --git a/resource/csdk/connectivity/inc/cacertprofile.h b/resource/csdk/connectivity/inc/cacertprofile.h
index 0dd8a0722..0e57be53b 100644
--- a/resource/csdk/connectivity/inc/cacertprofile.h
+++ b/resource/csdk/connectivity/inc/cacertprofile.h
@@ -58,6 +58,8 @@ typedef enum
     CP_INVALID_CERT_INPUT,   /* Certificate input is invalid (or null) */
     CP_DATE_ERROR,           /* Problem setting or reading certificate validity dates */
     CP_BUF_TOO_SMALL,        /* Supplied buffer is not long enough for desired operation */
+    CP_MUL_CA_CERTS,         /* Multiple root CA certs in cert chain */
+    CP_NO_CA_CERT,           /* No root CA cert in cert chain */
     CP_STATUS_FAILED = 255   /* Failure */
 } CertProfileResult;
 
diff --git a/resource/csdk/connectivity/src/adapter_util/cacertprofile.c b/resource/csdk/connectivity/src/adapter_util/cacertprofile.c
index f644c15ea..bff461289 100644
--- a/resource/csdk/connectivity/src/adapter_util/cacertprofile.c
+++ b/resource/csdk/connectivity/src/adapter_util/cacertprofile.c
@@ -99,6 +99,42 @@ static CertProfileResult FindEndEntityCert(const mbedtls_x509_crt *certChain, mb
     return CP_STATUS_OK;
 }
 
+static CertProfileResult FindRootCACert(const mbedtls_x509_crt *certChain, mbedtls_x509_crt const **caCert)
+{
+    *caCert = NULL;
+
+    const mbedtls_x509_crt* curCert = certChain;
+    while (NULL != curCert)
+    {
+        if ((1 == curCert->ca_istrue) &&
+            (curCert->issuer_raw.len == curCert->subject_raw.len) &&
+            (0 == memcmp(curCert->issuer_raw.p, curCert->subject_raw.p, curCert->issuer_raw.len)))
+        {
+            // first CA
+            if (NULL == *caCert)
+            {
+                *caCert = curCert;
+            }
+            // more than 1 CA
+            else
+            {
+                *caCert = NULL;
+                OIC_LOG(ERROR, TAG, "More than 1 root CA cert in chain");
+                return CP_MUL_CA_CERTS;
+            }
+        }
+        curCert = curCert->next;
+    }
+
+    if (NULL == *caCert)
+    {
+        OIC_LOG(INFO, TAG, "No root CA cert in chain");
+        return CP_NO_CA_CERT;
+    }
+
+    return CP_STATUS_OK;
+}
+
 static CertProfileResult CheckMdAlgorithm(const mbedtls_x509_crt_profile *profile, mbedtls_md_type_t mdAlgorithm)
 {
     if ((MBEDTLS_X509_ID_FLAG(mdAlgorithm) & profile->allowed_mds) != 0)
@@ -412,6 +448,9 @@ int ValidateAuthCertChainProfiles(const mbedtls_x509_crt *certChain)
         return CP_INVALID_CERT_CHAIN;
     }
 
+    const mbedtls_x509_crt* caCert = NULL;
+    cpResult = FindRootCACert(certChain, &caCert);
+
     const mbedtls_x509_crt* curCert = certChain;
     while (NULL != curCert)
     {
@@ -419,6 +458,10 @@ int ValidateAuthCertChainProfiles(const mbedtls_x509_crt *certChain)
         {
             profileViolations = ValidateEndEntityCertProfile(curCert);
         }
+        else if (curCert == caCert)
+        {
+            profileViolations = ValidateRootCACertProfile(curCert);
+        }
         else
         {
             profileViolations = ValidateIntermediateCACertProfile(curCert);
diff --git a/resource/csdk/include/octypes.h b/resource/csdk/include/octypes.h
index f632d0f1f..1736f958b 100644
--- a/resource/csdk/include/octypes.h
+++ b/resource/csdk/include/octypes.h
@@ -342,13 +342,13 @@ extern "C" {
 #define OC_RSRVD_PROTOCOL_INDEPENDENT_ID "piid"
 
 /** Device specification version.*/
-#define OC_SPEC_VERSION                  "ocf.1.1.0"
+#define OC_SPEC_VERSION                  "ocf.2.0.0"
 
 /** Integer value of spec version (OCF1.0 0b0000:1000:0000:0000).*/
 #define OC_SPEC_VERSION_VALUE            2048
 
 /** Device Data Model version.*/
-#define OC_DATA_MODEL_VERSION            "ocf.res.1.1.0,ocf.sh.1.1.0"
+#define OC_DATA_MODEL_VERSION            "ocf.res.1.3.0,ocf.sh.1.3.0"
 
 /**
  *  Introspection.
diff --git a/resource/csdk/security/provisioning/sample/makecerts b/resource/csdk/security/provisioning/sample/makecerts
old mode 100755
new mode 100644
diff --git a/resource/csdk/security/provisioning/sample/system_test.py b/resource/csdk/security/provisioning/sample/system_test.py
old mode 100755
new mode 100644
diff --git a/resource/csdk/security/provisioning/src/ocprovisioningmanager.c b/resource/csdk/security/provisioning/src/ocprovisioningmanager.c
old mode 100755
new mode 100644
diff --git a/resource/csdk/stack/samples/tizen/build/gbsbuild.sh b/resource/csdk/stack/samples/tizen/build/gbsbuild.sh
old mode 100755
new mode 100644
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/App.less b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/App.less
old mode 100755
new mode 100644
diff --git a/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/package.json b/resource/csdk/stack/samples/webos/com.example.app.iotivity/src/App/package.json
old mode 100755
new mode 100644
diff --git a/resource/docs/javadocGen.sh b/resource/docs/javadocGen.sh
old mode 100755
new mode 100644
diff --git a/resource/src/OCAccountManager.cpp b/resource/src/OCAccountManager.cpp
index 948c1be20..94766a46e 100644
--- a/resource/src/OCAccountManager.cpp
+++ b/resource/src/OCAccountManager.cpp
@@ -54,6 +54,7 @@ OCAccountManager::OCAccountManager(std::weak_ptr<IClientWrapper> clientWrapper,
     }
 
     m_deviceID.append(di);
+
     checked_guard(m_clientWrapper.lock(), &IClientWrapper::GetDefaultQos, m_defaultQos);
 }
 
@@ -86,8 +87,11 @@ OCStackResult OCAccountManager::signUp(const std::string& authProvider,
     VERIFY_VALID_STRING(authProvider, "authProvider cannot be empty.", OC_STACK_INVALID_PARAM);
     VERIFY_VALID_STRING(authCode, "authCode cannot be empty.", OC_STACK_INVALID_PARAM);
 
-    std::string uri = m_host + OC_RSRVD_ACCOUNT_URI;
+    printf("device Id : %s\nauthProvider : %s\nauthCode : %s\n", m_deviceID.c_str(), authProvider.c_str(), authCode.c_str());
 
+    //std::string uri = m_host + OC_RSRVD_ACCOUNT_URI;
+    std::string uri = m_host + "/oic/account";
+    
     OCRepresentation rep;
     rep.setValue<std::string>(OC_RSRVD_DEVICE_ID, m_deviceID);
     rep.setValue<std::string>(OC_RSRVD_AUTHPROVIDER, authProvider);
@@ -144,7 +148,8 @@ OCStackResult OCAccountManager::signInOut(const std::string& userUuid,
                                           bool isSignIn,
                                           PostCallback cloudConnectHandler)
 {
-    std::string uri = m_host + OC_RSRVD_ACCOUNT_SESSION_URI;
+    //std::string uri = m_host + OC_RSRVD_ACCOUNT_SESSION_URI;
+    std::string uri = m_host + "/oic/account/session";
 
     OCRepresentation rep;
 
@@ -168,7 +173,8 @@ OCStackResult OCAccountManager::refreshAccessToken(const std::string& userUuid,
     VERIFY_VALID_STRING(userUuid, "userUuid cannot be empty.", OC_STACK_INVALID_PARAM);
     VERIFY_VALID_STRING(refreshToken, "refreshToken cannot be empty.", OC_STACK_INVALID_PARAM);
 
-    std::string uri = m_host + OC_RSRVD_ACCOUNT_TOKEN_REFRESH_URI;
+    //std::string uri = m_host + OC_RSRVD_ACCOUNT_TOKEN_REFRESH_URI;
+    std::string uri = m_host + "/oic/account/tokenrefresh";
 
     OCRepresentation rep;
     rep.setValue<std::string>(OC_RSRVD_USER_UUID, userUuid);
@@ -203,10 +209,14 @@ OCStackResult OCAccountManager::deleteDevice(const std::string& accessToken,
 {
     VERIFY_VALID_STRING(accessToken, "accessToken cannot be empty.", OC_STACK_INVALID_PARAM);
     VERIFY_VALID_STRING(deviceId, "deviceId cannot be empty.", OC_STACK_INVALID_PARAM);
-
+/*
     std::string uri = m_host + OC_RSRVD_ACCOUNT_URI
                       + "?" + OC_RSRVD_ACCESS_TOKEN + "=" + accessToken
                       + ";" + OC_RSRVD_DEVICE_ID + "=" + deviceId;
+*/
+    std::string uri = m_host + "/oic/account"
+                          + "?" + OC_RSRVD_ACCESS_TOKEN + "=" + accessToken
+                          + ";" + OC_RSRVD_DEVICE_ID + "=" + deviceId;
 
     return checked_guard(m_clientWrapper.lock(), &IClientWrapper::DeleteResource,
                          OCDevAddr(), uri, HeaderOptions(),
diff --git a/service/easy-setup/sampleapp/enrollee/tizen-sdb/EnrolleeSample/build/tizen/gbsbuild.sh b/service/easy-setup/sampleapp/enrollee/tizen-sdb/EnrolleeSample/build/tizen/gbsbuild.sh
old mode 100755
new mode 100644
diff --git a/service/notification/examples/android/NotiConsumerExample/gradlew.bat b/service/notification/examples/android/NotiConsumerExample/gradlew.bat
old mode 100755
new mode 100644
diff --git a/service/resource-container/examples/android/AndroidBundle/gradlew b/service/resource-container/examples/android/AndroidBundle/gradlew
old mode 100755
new mode 100644
diff --git a/service/resource-container/examples/android/AndroidBundle/gradlew.bat b/service/resource-container/examples/android/AndroidBundle/gradlew.bat
old mode 100755
new mode 100644
diff --git a/service/resource-container/examples/android/RCSampleServerApp/gradlew b/service/resource-container/examples/android/RCSampleServerApp/gradlew
old mode 100755
new mode 100644
diff --git a/service/resource-container/examples/android/RCSampleServerApp/gradlew.bat b/service/resource-container/examples/android/RCSampleServerApp/gradlew.bat
old mode 100755
new mode 100644
diff --git a/tools/darwin/build-ios.sh b/tools/darwin/build-ios.sh
old mode 100755
new mode 100644
diff --git a/tools/darwin/mkfwk_ios.sh b/tools/darwin/mkfwk_ios.sh
old mode 100755
new mode 100644
diff --git a/tools/darwin/mkfwk_osx.sh b/tools/darwin/mkfwk_osx.sh
old mode 100755
new mode 100644
diff --git a/tools/generate_report.sh b/tools/generate_report.sh
old mode 100755
new mode 100644
diff --git a/tools/style/astyle-clean-cpp-format.sh b/tools/style/astyle-clean-cpp-format.sh
old mode 100755
new mode 100644
diff --git a/tools/style/astyle-cpp-format.sh b/tools/style/astyle-cpp-format.sh
old mode 100755
new mode 100644
diff --git a/tools/vagrant/iotivity-setup.sh b/tools/vagrant/iotivity-setup.sh
old mode 100755
new mode 100644
-- 
2.16.1.windows.1

