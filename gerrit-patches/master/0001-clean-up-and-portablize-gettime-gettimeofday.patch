From e30cf5d2cfa5c26b8cae91df417359582c04f444 Mon Sep 17 00:00:00 2001
From: Gregg Reynolds <reynolds-gregg@norc.org>
Date: Sat, 11 Jun 2016 08:37:15 -0500
Subject: [PATCH] clean up and portablize gettime/gettimeofday

Change-Id: I6479c120697445b006babb3f6efbd94e7ba63ba1
Signed-off-by: Gregg Reynolds <reynolds-gregg@norc.org>
---
 .../telegesis_wrapper/src/telegesis_socket.c       | 38 +++++++++++++---
 .../csdk/security/provisioning/src/pmutility.c     | 31 ++++++++++---
 .../richsdk/src/RemoteEnrolleeResource.cpp         | 52 +++++++++++++---------
 3 files changed, 87 insertions(+), 34 deletions(-)

diff --git a/plugins/zigbee_wrapper/telegesis_wrapper/src/telegesis_socket.c b/plugins/zigbee_wrapper/telegesis_wrapper/src/telegesis_socket.c
index 877cf065e..2ccebfe12 100644
--- a/plugins/zigbee_wrapper/telegesis_wrapper/src/telegesis_socket.c
+++ b/plugins/zigbee_wrapper/telegesis_wrapper/src/telegesis_socket.c
@@ -25,7 +25,11 @@
 #include <errno.h>
 #include <signal.h>
 #include <sys/select.h>
+#if (_POSIX_TIMERS > 0)
 #include <time.h>
+#else
+#include <sys/time.h>
+#endif
 
 #include "twsocketlist.h"
 #include "oic_string.h"
@@ -126,8 +130,14 @@ TWResultCode TWWait(pthread_cond_t * cond, pthread_mutex_t * mutex, uint8_t time
     int ret = 0;
     // This is a blocking call which hold the calling thread until an entry
     // has been enqueued or until the specified timeout has surpassed.
-    struct timespec abs_time;
+    struct timespec abs_time = { .tv_sec = 0, .tv_nsec = 0 };
+#if (_POSIX_TIMERS > 0)
     clock_gettime(CLOCK_REALTIME , &abs_time);
+#else
+    struct timeval curr_time = { .tv_sec = 0, .tv_usec = 0 };
+    gettimeofday(&curr_time, NULL);
+    abs_time.tv_sec = curr_time.tv_sec;
+#endif
     abs_time.tv_sec += timeout;
     ret = pthread_cond_timedwait(cond, mutex, &abs_time);
 
@@ -811,9 +821,19 @@ TWResultCode TWDequeueEntry(PIPlugin_Zigbee * plugin, TWEntry ** entry, TWEntryT
     *entry = NULL;
     if(type != TW_NONE)
     {
-        struct timespec abs_time;
-        clock_gettime(CLOCK_REALTIME , &abs_time);
-        abs_time.tv_sec += TIME_OUT_10_SECONDS;
+	struct timespec abs_time = { .tv_sec = 0, .tv_nsec = 0 };
+#if (_POSIX_TIMERS > 0)
+	static const struct timespec zero_time = { .tv_sec = 0, .tv_nsec = 0 };
+	struct timespec curr_time = { .tv_sec = 0, .tv_nsec = 0 };
+	clock_gettime(CLOCK_REALTIME , &abs_time);
+#else
+	static const struct timeval zero_time = { .tv_sec = 0, .tv_usec = 0 };
+	struct timeval curr_time = { .tv_sec = 0, .tv_usec = 0 };
+	gettimeofday(&curr_time, NULL);
+	abs_time.tv_sec = curr_time.tv_sec;
+#endif
+	abs_time.tv_sec += TIME_OUT_10_SECONDS;
+
         while(!*entry)
          {
             // Wait for up to 10 seconds for the entry to put into the queue.
@@ -836,9 +856,13 @@ TWResultCode TWDequeueEntry(PIPlugin_Zigbee * plugin, TWEntry ** entry, TWEntryT
                     break;
                 }
             }
-            struct timespec cur_time;
-            clock_gettime(CLOCK_REALTIME, &cur_time);
-            if(cur_time.tv_sec >= abs_time.tv_sec)
+	    curr_time = zero_time;
+#if (_POSIX_TIMERS > 0)
+            clock_gettime(CLOCK_REALTIME, &curr_time);
+#else
+	    gettimeofday(&curr_time, NULL);
+#endif
+            if(curr_time.tv_sec >= abs_time.tv_sec)
             {
                 break;
             }
diff --git a/resource/csdk/security/provisioning/src/pmutility.c b/resource/csdk/security/provisioning/src/pmutility.c
index 38d137728..5fcde2971 100644
--- a/resource/csdk/security/provisioning/src/pmutility.c
+++ b/resource/csdk/security/provisioning/src/pmutility.c
@@ -23,8 +23,11 @@
 
 #include <unistd.h>
 #include <string.h>
+#if (_POSIX_TIMERS > 0)
 #include <time.h>
+#else
 #include <sys/time.h>
+#endif
 
 #include "ocstack.h"
 #include "oic_malloc.h"
@@ -341,25 +344,39 @@ exit:
  */
 OCStackResult PMTimeout(unsigned short waittime, bool waitForStackResponse)
 {
+    int clock_res;
+#if (_POSIX_TIMERS > 0)
     struct timespec startTime = {.tv_sec=0, .tv_nsec=0};
+    static const struct timespec zeroTime = {.tv_sec=0, .tv_nsec=0};
     struct timespec currTime  = {.tv_sec=0, .tv_nsec=0};
-
-    OCStackResult res = OC_STACK_OK;
-#ifdef _POSIX_MONOTONIC_CLOCK
-    int clock_res = clock_gettime(CLOCK_MONOTONIC, &startTime);
+# if defined(_POSIX_MONOTONIC_CLOCK)
+    clock_res = clock_gettime(CLOCK_MONOTONIC, &startTime);
+# else
+    clock_res = clock_gettime(CLOCK_REALTIME, &startTime);
+# endif
 #else
-    int clock_res = clock_gettime(CLOCK_REALTIME, &startTime);
+    struct timeval startTime = { .tv_sec = 0, .tv_usec = 0 };
+    static const struct timeval zeroTime = { .tv_sec = 0, .tv_usec = 0 };
+    struct timeval currTime = { .tv_sec = 0, .tv_usec = 0 };
+    clock_res = gettimeofday(&startTime, NULL);
 #endif
     if (0 != clock_res)
     {
         return OC_STACK_ERROR;
     }
+
+    OCStackResult res = OC_STACK_OK;
     while (OC_STACK_OK == res)
     {
-#ifdef _POSIX_MONOTONIC_CLOCK
+        currTime = zeroTime;
+#if (_POSIX_TIMERS > 0)
+# if defined(_POSIX_MONOTONIC_CLOCK)
         clock_res = clock_gettime(CLOCK_MONOTONIC, &currTime);
-#else
+# else
         clock_res = clock_gettime(CLOCK_REALTIME, &currTime);
+# endif
+#else
+        clock_res = gettimeofday(&currTime, NULL);
 #endif
         if (0 != clock_res)
         {
diff --git a/service/easy-setup/mediator/richsdk/src/RemoteEnrolleeResource.cpp b/service/easy-setup/mediator/richsdk/src/RemoteEnrolleeResource.cpp
index 368c5e0ec..a84ce27cc 100755
--- a/service/easy-setup/mediator/richsdk/src/RemoteEnrolleeResource.cpp
+++ b/service/easy-setup/mediator/richsdk/src/RemoteEnrolleeResource.cpp
@@ -18,8 +18,13 @@
 //
 //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
+#include <unistd.h>
 #include <functional>
+#if (_POSIX_TIMERS > 0)
 #include <time.h>
+#else
+#include <sys/time.h>
+#endif
 
 #include "RemoteEnrolleeResource.h"
 
@@ -208,33 +213,40 @@ namespace OIC
 
         ESResult RemoteEnrolleeResource::ESDiscoveryTimeout(unsigned short waittime)
         {
-            struct timespec startTime;
-            startTime.tv_sec=0;
-            startTime.tv_sec=0;
-            struct timespec currTime;
-            currTime.tv_sec=0;
-            currTime.tv_nsec=0;
-
-            ESResult res = ES_OK;
-            #ifdef _POSIX_MONOTONIC_CLOCK
-                int clock_res = clock_gettime(CLOCK_MONOTONIC, &startTime);
-            #else
-                int clock_res = clock_gettime(CLOCK_REALTIME, &startTime);
-            #endif
-
+	    int clock_res = 0;
+#if (_POSIX_TIMERS > 0)
+            struct timespec startTime = { 0, /* tv_sec */ 0 /* tv_nsec */};
+            static const struct timespec zeroTime = { 0, /* tv_sec */ 0 /* tv_nsec */};
+            struct timespec currTime  = { 0, /* tv_sec */ 0 /* tv_nsec */};
+# if defined(_POSIX_MONOTONIC_CLOCK)
+            clock_res = clock_gettime(CLOCK_MONOTONIC, &startTime);
+# else
+            clock_res = clock_gettime(CLOCK_REALTIME, &startTime);
+# endif
+#else
+            struct timeval startTime = { 0, /* tv_sec */ 0 /* tv_usec */};
+            static const struct timeval zeroTime = { 0, /* tv_sec */ 0 /* tv_usec */};
+            struct timeval currTime = { 0, /* tv_sec */ 0 /* tv_usec */};
+            clock_res = gettimeofday(&startTime, NULL);
+#endif
             if (0 != clock_res)
             {
                 return ES_ERROR;
             }
 
+            ESResult res = ES_OK;
             while (ES_OK == res || m_discoveryResponse == false)
             {
-                #ifdef _POSIX_MONOTONIC_CLOCK
-                        clock_res = clock_gettime(CLOCK_MONOTONIC, &currTime);
-                #else
-                        clock_res = clock_gettime(CLOCK_REALTIME, &currTime);
-                #endif
-
+	      currTime = zeroTime;
+#if (_POSIX_TIMERS > 0)
+# if defined(_POSIX_MONOTONIC_CLOCK)
+                clock_res = clock_gettime(CLOCK_MONOTONIC, &currTime);
+# else
+                clock_res = clock_gettime(CLOCK_REALTIME, &currTime);
+# endif
+#else
+                clock_res = gettimeofday(&currTime, NULL);
+#endif
                 if (0 != clock_res)
                 {
                     return ES_ERROR;
-- 
2.16.1.windows.1

