From decb37090c5aca56d633ce5a45def404eea598f3 Mon Sep 17 00:00:00 2001
From: Michal Wieckowski <michal.wieckowski@comarch.com>
Date: Wed, 27 Feb 2019 10:38:05 +0100
Subject: [PATCH 3/3] Update IUT http server as new way to get input

* Rework command line arguments:
* use "--help" to display possible arguments
* "--apiEndpoint arg1" provide ip:port to enable http server on given
endpoint
* "--mode arg2" SERVER or CLIENT, provide to run IUT as server or
client
* "--security arg3" JW, RDP, MFG or REUSE, provide to select svr
database
* "--ocfVer arg4" provide "icv" of device
* "--devType arg5" select one from list displayed after using "--help"
* "--options arg..." select multiple from list displayed after using "
--help"

* Http server:
* IUT http server exposes several resources:
    * POST "/command" give input in same way as from command line and
get response
    * GET "/info" display information about IUT device and discovery
endpoints
    * GET "/state" display current IUT menu
    * GET "/pin" display last generated PIN

* Other:
* Add "std::" prefixes
* Reworked menu options to be grouped by functionalities
* Allow resource discovery to select resource type and endpoint
* Allow resource request to select resource interface
* QOS for requests is now selected from menu
* Security option for resources is now selected from menu

Change-Id: Id59b53cea8b44f982dc25077a0b1bbf95940de48
Signed-off-by: Michal Wieckowski <michal.wieckowski@comarch.com>
---
 test/build/linux/SConscriptIUT                     |   20 +-
 test/include/ResourceHelper.h                      |   18 +-
 test/include/ResourceServer.h                      |  925 ++---
 test/include/SampleCollection.h                    |    4 +-
 test/include/SampleResource.h                      |  250 +-
 .../src/common/commonutil/c_cpp/ResourceHelper.cpp |  163 +
 .../src/common/commonutil/c_cpp/ResourceServer.cpp |  966 +++--
 .../common/commonutil/c_cpp/SampleCollection.cpp   |   81 +-
 .../src/common/commonutil/c_cpp/SampleResource.cpp |   44 +-
 .../IUTSimulatorApp/c_cpp/include/HttpResources.h  |   48 +
 .../c_cpp/include/IUTSimulatorUtils.h              |   95 +-
 .../IUTSimulatorApp/c_cpp/include/InputHandler.h   |  164 +
 .../c_cpp/include/http/Connection.hpp              |   48 +
 .../c_cpp/include/http/ConnectionManager.hpp       |   33 +
 .../c_cpp/include/http/RequestParser.hpp           |   34 +
 .../c_cpp/include/http/Response.hpp                |   41 +
 .../IUTSimulatorApp/c_cpp/include/http/Server.hpp  |   43 +
 .../IUTSimulatorApp/c_cpp/src/HttpResources.cpp    |   84 +
 .../IUTSimulatorApp/c_cpp/src/IUTSimulator.cpp     | 3782 +++++++++-----------
 .../c_cpp/src/IUTSimulatorUtils.cpp                |  312 +-
 .../IUTSimulatorApp/c_cpp/src/InputHandler.cpp     |  250 ++
 .../c_cpp/src/SampleResourceFactory.cpp            |   10 +-
 .../IUTSimulatorApp/c_cpp/src/http/Connection.cpp  |   81 +
 .../c_cpp/src/http/ConnectionManager.cpp           |   31 +
 .../c_cpp/src/http/RequestParser.cpp               |  152 +
 .../IUTSimulatorApp/c_cpp/src/http/Response.cpp    |   92 +
 .../IUTSimulatorApp/c_cpp/src/http/Server.cpp      |   54 +
 27 files changed, 4293 insertions(+), 3532 deletions(-)
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/include/HttpResources.h
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/include/InputHandler.h
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Connection.hpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/include/http/ConnectionManager.hpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/include/http/RequestParser.hpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Response.hpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Server.hpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/src/HttpResources.cpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/src/InputHandler.cpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Connection.cpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/src/http/ConnectionManager.cpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/src/http/RequestParser.cpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Response.cpp
 create mode 100644 test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Server.cpp

diff --git a/test/build/linux/SConscriptIUT b/test/build/linux/SConscriptIUT
index df69870b3..51a76ba11 100644
--- a/test/build/linux/SConscriptIUT
+++ b/test/build/linux/SConscriptIUT
@@ -56,6 +56,7 @@ if WITH_RD == True:
 
 include_paths = [
     iotivity_test_root + '/src/testapp/IUTSimulatorApp/c_cpp/include',
+    iotivity_test_root + '/src/testapp/IUTSimulatorApp/c_cpp/include/http',
     iotivity_test_root + '/include',
     iotivity_test_root + '/include/AM',
     iotivity_test_root + '/include/AM/dependencies',
@@ -64,6 +65,7 @@ include_paths = [
     iotivity_root + '/resource/csdk/connectivity/api',
     iotivity_root + '/resource/csdk/stack/include',
     iotivity_root + '/resource/csdk/security/include',
+    iotivity_root + '/resource/csdk/security/include/experimental',
     iotivity_root + '/resource/csdk/security/provisioning/include/cloud',
     iotivity_root + '/resource/csdk/ocsocket/include',
     iotivity_root + '/resource/csdk/ocrandom/include',
@@ -83,10 +85,11 @@ include_paths = [
     iotivity_lib_path + '/resource/c_common'
 ]
 
-libs = Split('libdl libexpat liboc liboctbstack liboc_logger libconnectivity_abstraction libcoap pthread libglib-2.0 gcov libocpmapi')
+libs = Split('libdl libexpat liboc liboctbstack liboc_logger libconnectivity_abstraction libcoap pthread libglib-2.0 gcov libocpmapi boost_program_options')
 enrolee_libs =  [ 'ESEnrolleeSDK' ]
 rd_libs = [ 'resource_directory' ]
-libs = libs + enrolee_libs + rd_libs
+http_libs = Split('boost_system boost_thread')
+libs = libs + enrolee_libs + rd_libs + http_libs
 
 src = [
     test_src_root + '/common/commonutil/c_cpp/ResourceServer.cpp',
@@ -99,12 +102,23 @@ src = [
     test_src_root + '/common/commonutil/c_cpp/AM/bloodpressure2.cpp',
     test_src_root + '/common/commonutil/c_cpp/AM/dependencies/MySignals/bloodpressure.cpp',
     test_src_root + '/common/commonutil/c_cpp/ResourceHelper.cpp',
+    test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/InputHandler.cpp',
+    test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/HttpResources.cpp',
     test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulatorUtils.cpp',
     test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/SampleResourceFactory.cpp',
     test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulator.cpp',
 ]
 
-iut_app = env_linux.Program(source = src, target = 'IUTSimulator', CPPPATH = include_paths,
+http_src = [
+    test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/http/Server.cpp',
+    test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/http/ConnectionManager.cpp',
+    test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/http/Connection.cpp',
+    test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/http/RequestParser.cpp',
+    test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/http/Request.cpp',
+    test_src_root + '/testapp/IUTSimulatorApp/c_cpp/src/http/Response.cpp',
+]
+
+iut_app = env_linux.Program(source = src + http_src, target = 'IUTSimulator', CPPPATH = include_paths,
                 LIBS = libs, LIBPATH = iotivity_lib_path, RPATH = iotivity_lib_path, CPPFLAGS = cppflags + common_linux_cppflags)
 install_targets += [iut_app]
 
diff --git a/test/include/ResourceHelper.h b/test/include/ResourceHelper.h
index d7ac053d6..7036e77df 100644
--- a/test/include/ResourceHelper.h
+++ b/test/include/ResourceHelper.h
@@ -117,6 +117,7 @@ namespace PH = std::placeholders;
 #define CON_RESOURCE_TYPE "oic.wk.con"
 #define CHROMA_RESOURCE_TYPE "oic.r.colour.chroma"
 #define DIMMING_RESOURCE_TYPE "oic.r.light.dimming"
+#define BLOOD_PRESSURE_MONITOR_TYPE "oic.r.bloodpressuremonitor-am"
 
 #define TV_Device_INTERFACE "oic.if.a"
 #define AC_Device_INTERFACE "oic.if.a"
@@ -200,8 +201,6 @@ const int SUCCESS_RESPONSE = 0;
 #define BANGLA_VALUE "bn"
 #define ENGLISH_VALUE "en"
 #define BANGLA_NAME_VALUE "বুদ্ধিমান এয়ার কন্ডিশনার"
-#define ENGLISH_NAME_VALUE "Vendor Smart Home AirCon Device"
-#define AP_ENGLISH_NAME_VALUE "Vendor Smart Home Air Purifier Device"
 #define LANGUAGE_VALUE "language"
 #define CIS_VALUE "coaps+tcp://192.168.56.1:49160"
 #define SID_VALUE "bd052d57-aa22-425f-9dc0-e18202f4b7a2"
@@ -329,8 +328,13 @@ const int SUCCESS_RESPONSE = 0;
 #define FIRMWARE_VERSION "1.1.1"
 #define SUPPORT_URL "support.default-vendor.com"
 #define SYSTEM_TIME "2016-06-20T10:10:10Z"
-#define DEVICE_NAME "IotivitySmartRoom"
-#define DEFAULT_DEVIE_TYPE "oic.wk.d"
+#define DEFAULT_SERVER_DEVICE_NAME "IotivitySmartRoom"
+#define DEFAULT_CLIENT_DEVICE_NAME "Smart Home Client Device"
+#define VENDOR_AIR_CON_DEVICE_NAME "Vendor Smart Home AirCon Device"
+#define VENDOR_AIR_PUR_DEVICE_NAME "Vendor Smart Home Air Purifier Device"
+#define VENDOR_ECO_POW_DEVICE_NAME "Vendor Defined System Server"
+#define VENDOR_BPM_DEVICE_NAME "Vendor Blood Pressure Monitor Device"
+#define DEFAULT_DEVICE_TYPE "oic.wk.d"
 
 #define TCP_ENDPOINT_KEY "tcp"
 #define SECURED_ENDPOINT_KEY "coaps"
@@ -338,7 +342,7 @@ const int SUCCESS_RESPONSE = 0;
 //  for OCF1.3 device
 #define CORE_SPEC_VERSION "ocf.1.0.0"
 #define RESOURCE_TYPE_SPEC_VERSION "ocf.res.1.3.0"
-#define SMART_HOME_SPEC_VERSION "ocf.sh.1.3.0"
+#define SMART_HOME_SPEC_VERSION "ocf.res.1.3.0,ocf.sh.1.3.0"
 
 #define COAP_RESPONSE_CODE_SUCCESS 205
 #define COAP_RESPONSE_CODE_CREATED 201
@@ -448,6 +452,8 @@ public:
 
     void printPayload(OCRepPayload* incomingPayload, OCRepresentation rep, int level = 0);
 
+    static void payloadToString(OCRepPayload* incomingPayload, std::string& stringPayload, int level = 0);
+
     /**
      * API for copying String to character array
      *
@@ -492,7 +498,7 @@ public:
      * @param [in] cmd - instruction to execute
      *
      */
-    string executeCommand(string cmd);
+    static string executeCommand(string cmd);
 };
 
 #endif // __RESOURCE_HELPER_H__
\ No newline at end of file
diff --git a/test/include/ResourceServer.h b/test/include/ResourceServer.h
index 99c046610..6d210c7af 100644
--- a/test/include/ResourceServer.h
+++ b/test/include/ResourceServer.h
@@ -1,456 +1,469 @@
-/******************************************************************
-*
-* Copyright 2017 Samsung Electronics All Rights Reserved.
-*
-*
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*
-******************************************************************/
-
-/// @file ResourceServer.h
-/// @brief  This file contains the declaration of the resource server
-///         class and its members.
-#ifndef _RESOURCE_SERVER_H_
-#define _RESOURCE_SERVER_H_
-
-#include <chrono>
-#include <iostream>
-#include <sstream>
-#include <pthread.h>
-#include <ResourceHelper.h>
-#include <stdexcept>
-#include <memory>
-#include <string>
-#include <memory>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include "OCPlatform.h"
-#include "OCApi.h"
-#include "ocstack.h"
-
-using namespace OC;
-
-    /**
-     * Types of handlers for Sample Resource
-     *
-     */
-    enum class HandlerType
-    {
-        DEFAULT,
-        SAMPLE
-    };
-
-    /**
-     * Types of Sample Resource handler response time
-     *
-     * NOTE: This will matter only when using SAMPLE resource handler
-     */
-    enum class ResponseTimeType
-    {
-        SLOW,
-        NORMAL
-    };
-
-/**
- *   @brief  To use a sample server, ResourceServer class must
- *           be instantiated. then it should be constructed and run
- */
-class ResourceServer
-{
-protected:
-    OCRepresentation m_representation;
-    std::string m_resourceURI;
-    std::string m_resourceTypeName;
-    std::vector<std::string> m_resourceTypeNames;
-    std::string m_resourceInterface;
-    std::vector<std::string> m_resourceInterfaces;
-    std::vector<ResourceServer*> m_childResourceList;
-    OCResourceHandle m_resourceHandle;
-    PlatformConfig m_platformConfig;
-    ResponseTimeType m_responseTimeType;
-    bool m_isRegisteredForPresence;
-    bool m_isServerRunning;
-    uint8_t m_resourceProperty;
-    static bool s_isServerConstructed;
-    static OCPlatformInfo s_platformInfo;
-    static OCDeviceInfo s_deviceInfo;
-    static ResourceHelper* p_resourceHelper;
-
-public:
-
-    /**
-     * Constructor for ResourceServer. Initializes server variables
-     *
-     */
-    ResourceServer(void);
-
-    /**
-     * virtual destructor for Resource Server.
-     */
-    virtual ~ResourceServer(void);
-
-    /**
-     * API for constructing the server with a PlatformConfig object
-     * @param cfg - PlatformConfig object containing platform settings
-     *
-     * @return OCStackResult - returns OC_STACK_OK if successful to construct server,
-     *                          else OC_STACK_ERROR
-     *
-     * NOTE: This API is for already available PlatformConfig
-     * NOTE: PlatformConfig is defined in OCApi.h.
-     */
-    static OCStackResult constructServer(PlatformConfig &cfg);
-
-    /**
-     * API for constructing the server with a client IP & port
-     *
-     * @param ip - IP address of the server
-     * @param port - port of the server
-     *
-     * @return OCStackResult - returns OC_STACK_OK if successful to construct server,
-     *                          else OC_STACK_ERROR
-     *
-     * NOTE: This API is for construction the server in Confirmable QoC mode
-     */
-    static OCStackResult constructServer(std::string ip, int port);
-
-    /**
-     * API for getting device info
-     *
-     * @return OCStackResult - returns s_deviceInfo
-     *
-     */
-    static OCDeviceInfo getDeviceInfo();
-
-    /**
-     * API to set the basic properties of the resource
-     *
-     * @param resourceURI - uri of the resource
-     * @param resourceTypeName - resource type name of the resource
-     * @param resourceInterface - interface of the resource
-     *
-     * @return OCStackResult - returns OC_STACK_OK if successful to set properties,
-     *                          else OC_STACK_ERROR
-     *
-     * NOTE: This function must be called before starting the resource
-     */
-    OCStackResult setResourceProperties(std::string resourceUri, std::string resourceTypeName,
-            std::string resourceInterface);
-
-    /**
-     * API to get the resource handle of the resource
-     *
-     * @return OCResourceHandle - returns the resource handle to the resource
-     *
-     * NOTE: available interfaces are defined in OCApi.h
-     */
-    OCResourceHandle getResourceHandle(void);
-
-    /**
-     * API to handle and response to the incoming request
-     *
-     * @param request - pointer to the OCResourceRequest type incoming request
-     * @param response - pointer to the OCResourceResponse type outgoing response
-     *
-     * NOTE: available interfaces are defined in OCApi.h
-     */
-
-    virtual OCEntityHandlerResult entityHandler(std::shared_ptr< OCResourceRequest > request);
-
-    /**
-     * API to get the representation model of the resource
-     *
-     * @return OCRepresentation, the representation class of the resource server
-     *
-     * NOTE: OCRepresentation is defined in OCApi.h
-     */
-    OCRepresentation getRepresentation(void);
-
-    /**
-     * API to get the representation model of the resource
-     *
-     * @return vector<string>, list of resource interfaces
-     */
-    std::vector<std::string> getResourceInterfaces(void);
-
-    /**
-     * API to get the representation model of the resource
-     *
-     * @return vector<string>, list of resource types
-     */
-    std::vector<std::string> getResourceTypes(void);
-
-    /**
-     * API to get the representation model of the resource
-     *
-     * @param OCRepresentation - the representation to set
-     *
-     * NOTE: OCRepresentation is defined in OCApi.h
-     */
-    void setResourceRepresentation(OCRepresentation oCRepresentation);
-
-    /**
-     * API to stop the server
-     *
-     * @return OCStackResult - returns OC_STACK_OK if successful to stop server,
-     *                          else OC_STACK_ERROR
-     */
-    OCStackResult stopResource(void);
-
-    /**
-     * API for starting the server.
-     *
-     * @param handlerType - type of handler to use by created resource
-     *
-     * @return OCStackResult - returns OC_STACK_OK if successful to start server,
-     *                          else OC_STACK_ERROR
-     *
-     * NOTE: The server will stop when the main program exits
-     */
-    OCStackResult startResource(uint8_t resourceProperty = OC_ACTIVE, HandlerType handlerType = HandlerType::SAMPLE);
-
-    /**
-     * API for getting the uri of the resource
-     *
-     * @return string - returns the uri of the resource
-     *
-     */
-    std::string getUri(void);
-
-    /**
-     * API for setting the resource response as secured
-     *
-     */
-    void setAsSecuredResource(void);
-
-    /**
-     * API for setting the resource response as discoverable
-     *
-     */
-    void setAsDiscoverableResource(void);
-
-    /**
-     * API for setting the resource response as observable
-     *
-     */
-    void setAsObservableResource(void);
-
-    /**
-     * API for setting the resource response
-     *
-     * @param responseTimeType - resource response time type to set
-     *
-     */
-    void setResponseTimeType(ResponseTimeType responseTimeType);
-
-    /**
-     * API for setting the resource response as slow
-     *
-     */
-    void setAsSlowResource(void);
-
-    /**
-     * API for setting the resource response as normal
-     *
-     */
-    void setAsNormalResource(void);
-
-    /**
-     * API for handling normal response
-     *
-     * @param[in] request - OCResourceRequest variable, the request from client
-     *
-     */
-    void handleResponse(std::shared_ptr< OCResourceRequest > request);
-
-    /**
-     * API for handling slow response
-     *
-     * @param[in] request - OCResourceRequest variable, the request from client
-     *
-     */
-    void handleSlowResponse(std::shared_ptr< OCResourceRequest > request);
-
-    /**
-     * API to know whether the resource is observable or not
-     *
-     * @return bool - if resource is observable. true is returned, else  false
-     *
-     */
-    bool isObservableResource(void);
-
-    /**
-     * API to know whether the resource is secured or not
-     *
-     * @return bool - if resource is observable. true is returned, else  false
-     *
-     */
-    bool isSecuredResource(void);
-
-    /**
-     * API to know whether the resource is discoverable or not
-     *
-     * @return bool - if resource is discoverable. true is returned, else  false
-     *
-     */
-    bool isDiscoverableResource(void);
-
-   /**
-     * API to add a new resource type to the existing resource
-     *
-     * @param[in] - resourceType - resource type to add
-     *
-     */
-    void addResourceType(string resourceType);
-
-    /**
-      * API to add a new resource interface to the existing resource
-      *
-      * @param[in] - resourceinterface - resource interface to add
-      *
-      */
-    void addResourceInterface(string resourceInterface);
-
-    /**
-      * API to set Platform info of the current device platform
-      *
-      * @param[in] - platformID - Unique ID of the platform in form of UUID
-      * @param[in] - manufacturerName - Human radable name of the device manufacturer
-      * @param[in] - manufacturerUrl - URI to the device manufacturer webpage
-      * @param[in] - platformID - Unique ID of the platform in form of UUID
-      * @param[in] - platformID - Unique ID of the platform in form of UUID
-      * @param[in] - platformID - Unique ID of the platform in form of UUID
-      *
-      */
-    static OCStackResult setPlatformInfo(string platformID, string manufacturerName,
-            string manufacturerUrl, string modelNumber, string dateOfManufacture,
-            string platformVersion, string operatingSystemVersion, string hardwareVersion,
-            string firmwareVersion, string supportUrl, string systemTime);
-
-    /**
-      * API to set Device info of the current device
-      *
-      * @param[in] - deviceName - Human readable name of the device
-      * @param[in] - deviceTypes - List of device types of the device(Optional)
-      * @param[in] - specVersion - OCF version for device, with default ocf.1.0.0
-      *
-      */
-    static OCStackResult setDeviceInfo(string deviceName, vector<string> deviceTypes = vector<string>(), string specVersion = CORE_SPEC_VERSION);
-
-    /**
-      * API to set Device info of the current device
-      *
-      * @param[in] - deviceName - Human readable name of the device
-      * @param[in] - deviceTypes - Device type of the device(Optional)
-      * @param[in] - specVersion - OCF version for device, with default ocf.1.0.0
-      *
-      */
-    static OCStackResult setDeviceInfo(string deviceName, string deviceTypes, string specVersion = CORE_SPEC_VERSION);
-
-    /***
-     * API to perform additional task for child
-     *
-     * @param[out] isRegisteredForPresence - Boolean variable to register for presence,
-     *             default value is false, to register for presence, set it to true
-     * @param[out] presenceInterval - interval between presences in millisecond
-     *             default value is 0 millisecond
-     *
-     * NOTE: This is a pure virtual function, thus it must be implemented by the child
-     */
-    virtual void onResourceServerStarted(bool &isRegisteredForPresence, int &presenceInterval) = 0;
-
-    /***
-     * API to handle OBSERVE request
-     *
-     * @param[in] queryParamsMap - A map containing all query parameters
-     * @param[out] response - response to the incoming request
-     *
-     * NOTE: This is a pure virtual function, thus it must be implemented by the child
-     */
-    virtual void handleObserveRequest(QueryParamsMap &queryParamsMap,
-            std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response) = 0;
-
-    /***
-     * API to handle DELETE request
-     *
-     * @param[in] queryParamsMap - A map containing all query parameters
-     * @param[out] response - response to the incoming request
-     *
-     * NOTE: This is a pure virtual function, thus it must be implemented by the child
-     */
-    virtual void handleDeleteRequest(QueryParamsMap &queryParamsMap,
-            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response) = 0;
-
-    /***
-     * API to handle POST request
-     *
-     * @param[in] queryParamsMap - A map containing all query parameters
-     * @param[out] response - response to the incoming request
-     *
-     * NOTE: This is a pure virtual function, thus it must be implemented by the child
-     */
-    virtual void handlePostRequest(QueryParamsMap &queryParamsMap,
-            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response) = 0;
-
-    /***
-     * API to handle GET request
-     *
-     * @param[in] queryParamsMap - A map containing all query parameters
-     * @param[out] response - response to the incoming request
-     *
-     * NOTE: This is a pure virtual function, thus it must be implemented by the child
-     */
-    virtual void handleGetRequest(QueryParamsMap &queryParamsMap,
-            std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response) = 0;
-
-    /***
-     * API to handle PUT request
-     *
-     * @param[in] queryParamsMap - A map containing all query parameters
-     * @param[out] response - response to the incoming request
-     *
-     * NOTE: This is a pure virtual function, thus it must be implemented by the child
-     */
-    virtual void handlePutRequest(QueryParamsMap &queryParamsMap,
-            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response) = 0;
-
-    /***
-     * API to handle INIT request
-     *
-     * @param[in] queryParamsMap - A map containing all query parameters
-     * @param[out] response - response to the incoming request
-     *
-     * NOTE: This is a pure virtual function, thus it must be implemented by the child
-     */
-    virtual void handleInitRequest(QueryParamsMap &queryParamsMap,
-            std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response) = 0;
-
-    /***
-     * API to get the attribute list of the resource server
-     *
-     * @param[in] temp - epresentation of the resource server
-     *
-     * @return OCRepresentation - representation of the resource server
-     */
-    virtual OCRepresentation getResourceRepresentation(OCRepresentation &temp) = 0;
-};
-
-#endif // _RESOURCE_SERVER_H_ end
+/******************************************************************
+*
+* Copyright 2017 Samsung Electronics All Rights Reserved.
+*
+*
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+******************************************************************/
+
+/// @file ResourceServer.h
+/// @brief  This file contains the declaration of the resource server
+///         class and its members.
+#ifndef _RESOURCE_SERVER_H_
+#define _RESOURCE_SERVER_H_
+
+#include <chrono>
+#include <iostream>
+#include <sstream>
+#include <pthread.h>
+#include <ResourceHelper.h>
+#include <stdexcept>
+#include <memory>
+#include <string>
+#include <memory>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include "OCPlatform.h"
+#include "OCApi.h"
+#include "ocstack.h"
+
+using namespace OC;
+
+    /**
+     * Types of handlers for Sample Resource
+     *
+     */
+    enum class HandlerType
+    {
+        DEFAULT,
+        SAMPLE
+    };
+
+    /**
+     * Types of Sample Resource handler response time
+     *
+     * NOTE: This will matter only when using SAMPLE resource handler
+     */
+    enum class ResponseTimeType
+    {
+        SLOW,
+        NORMAL
+    };
+
+/**
+ *   @brief  To use a sample server, ResourceServer class must
+ *           be instantiated. then it should be constructed and run
+ */
+class ResourceServer
+{
+protected:
+    OCRepresentation m_representation;
+    std::string m_resourceURI;
+    std::string m_resourceTypeName;
+    std::vector<std::string> m_resourceTypeNames;
+    std::string m_resourceInterface;
+    std::vector<std::string> m_resourceInterfaces;
+    OCResourceHandle m_resourceHandle;
+    ResponseTimeType m_responseTimeType;
+    bool m_isRegisteredForPresence;
+    bool m_isResourceRunning;
+    uint8_t m_resourceProperty;
+    static bool s_isServerConstructed;
+    static ResourceHelper* p_resourceHelper;
+
+public:
+
+    /**
+     * Constructor for ResourceServer. Initializes server variables
+     *
+     */
+    ResourceServer(void);
+
+    /**
+     * virtual destructor for Resource Server.
+     */
+    virtual ~ResourceServer(void);
+
+    /**
+     * API for constructing the server with a PlatformConfig object
+     * @param cfg - PlatformConfig object containing platform settings
+     * @param deviceName - Name of device resource
+     * @param deviceTypes - Resource types of device resource
+     * @param specVersion - Specification version
+     *
+     * @return OCStackResult - returns OC_STACK_OK if successful to construct server,
+     *                          else OC_STACK_ERROR
+     *
+     * NOTE: This API is for already available PlatformConfig
+     * NOTE: PlatformConfig is defined in OCApi.h.
+     */
+    static OCStackResult constructServer(PlatformConfig &cfg, std::string deviceName = DEFAULT_SERVER_DEVICE_NAME, std::vector<string> deviceTypes = {}, std::string specVersion = CORE_SPEC_VERSION);
+
+    /**
+     * API for stopping the server
+     *
+     * @return OCStackResult - returns OC_STACK_OK if successful to stop server,
+     *                          else OC_STACK_ERROR
+     *
+     * NOTE: Shall be only used after constructing server
+     * NOTE: Should be always used once after constructing server
+     */
+    static OCStackResult stopServer();
+
+    /**
+     * API to retrive whenever server is constructed
+     *
+     * @return OCStackResult - returns true if server is constructed and false if not
+     */
+    static bool isServerConstructed();
+
+    /**
+     * API for getting device name
+     *
+     * @return std::string - returns /oic/d "n" property value
+     *
+     */
+    static std::string getDeviceName();
+
+    /**
+     * API for getting device id
+     *
+     * @return std::string - returns /oic/d "di" property value
+     *
+     */
+    static std::string getDeviceID();
+
+    /**
+     * API to set the basic properties of the resource
+     *
+     * @param resourceURI - uri of the resource
+     * @param resourceTypeName - resource type name of the resource
+     * @param resourceInterface - interface of the resource
+     *
+     * @return OCStackResult - returns OC_STACK_OK if successful to set properties,
+     *                          else OC_STACK_ERROR
+     *
+     * NOTE: This function must be called before starting the resource
+     */
+    OCStackResult setResourceProperties(std::string resourceUri, std::string resourceTypeName,
+            std::string resourceInterface);
+
+    /**
+     * API to get the resource handle of the resource
+     *
+     * @return OCResourceHandle - returns the resource handle to the resource
+     *
+     * NOTE: available interfaces are defined in OCApi.h
+     */
+    OCResourceHandle getResourceHandle(void);
+
+    /**
+     * API to handle and response to the incoming request
+     *
+     * @param request - pointer to the OCResourceRequest type incoming request
+     * @param response - pointer to the OCResourceResponse type outgoing response
+     *
+     * NOTE: available interfaces are defined in OCApi.h
+     */
+
+    virtual OCEntityHandlerResult entityHandler(std::shared_ptr< OCResourceRequest > request);
+
+    /**
+     * API to get the representation model of the resource
+     *
+     * @return OCRepresentation, the representation class of the resource server
+     *
+     * NOTE: OCRepresentation is defined in OCApi.h
+     */
+    OCRepresentation getRepresentation(void);
+
+    /**
+     * API to get the representation model of the resource
+     *
+     * @return vector<string>, list of resource interfaces
+     */
+    std::vector<std::string> getResourceInterfaces(void);
+
+    /**
+     * API to get the representation model of the resource
+     *
+     * @return vector<string>, list of resource types
+     */
+    std::vector<std::string> getResourceTypes(void);
+
+    /**
+     * API to get the representation model of the resource
+     *
+     * @param OCRepresentation - the representation to set
+     *
+     * NOTE: OCRepresentation is defined in OCApi.h
+     */
+    void setResourceRepresentation(OCRepresentation oCRepresentation);
+
+    /**
+     * API to stop the resource
+     *
+     * @return OCStackResult - returns OC_STACK_OK if successful to stop server,
+     *                          else OC_STACK_ERROR
+     */
+    virtual OCStackResult stopResource(void) = 0;
+
+    /**
+     * API for starting the server.
+     *
+     * @param handlerType - type of handler to use by created resource
+     *
+     * @return OCStackResult - returns OC_STACK_OK if successful to start server,
+     *                          else OC_STACK_ERROR
+     *
+     * NOTE: The server will stop when the main program exits
+     */
+    OCStackResult startResource(uint8_t resourceProperty = OC_ACTIVE, HandlerType handlerType = HandlerType::SAMPLE);
+
+    /**
+     * API for getting the uri of the resource
+     *
+     * @return string - returns the uri of the resource
+     *
+     */
+    std::string getUri(void);
+
+    /**
+     * API for setting the resource response as secured
+     *
+     */
+    void setAsSecuredResource(void);
+
+    /**
+     * API for setting the resource response as discoverable
+     *
+     */
+    void setAsDiscoverableResource(void);
+
+    /**
+     * API for setting the resource response as observable
+     *
+     */
+    void setAsObservableResource(void);
+
+    /**
+     * API for setting the resource response
+     *
+     * @param responseTimeType - resource response time type to set
+     *
+     */
+    void setResponseTimeType(ResponseTimeType responseTimeType);
+
+    /**
+     * API for setting the resource response as slow
+     *
+     */
+    void setAsSlowResource(void);
+
+    /**
+     * API for setting the resource response as normal
+     *
+     */
+    void setAsNormalResource(void);
+
+    /**
+     * API for handling normal response
+     *
+     * @param[in] request - OCResourceRequest variable, the request from client
+     *
+     */
+    void handleResponse(std::shared_ptr< OCResourceRequest > request);
+
+    /**
+     * API for handling slow response
+     *
+     * @param[in] request - OCResourceRequest variable, the request from client
+     *
+     */
+    void handleSlowResponse(std::shared_ptr< OCResourceRequest > request);
+
+    /**
+     * API to know whether the resource is observable or not
+     *
+     * @return bool - if resource is observable. true is returned, else  false
+     *
+     */
+    bool isObservableResource(void);
+
+    /**
+     * API to know whether the resource is secured or not
+     *
+     * @return bool - if resource is observable. true is returned, else  false
+     *
+     */
+    bool isSecuredResource(void);
+
+    /**
+     * API to know whether the resource is discoverable or not
+     *
+     * @return bool - if resource is discoverable. true is returned, else  false
+     *
+     */
+    bool isDiscoverableResource(void);
+
+   /**
+     * API to add a new resource type to the existing resource
+     *
+     * @param[in] - resourceType - resource type to add
+     *
+     */
+    void addResourceType(string resourceType);
+
+    /**
+      * API to add a new resource interface to the existing resource
+      *
+      * @param[in] - resourceinterface - resource interface to add
+      *
+      */
+    void addResourceInterface(string resourceInterface);
+
+    /***
+     * API to perform additional task for child
+     *
+     * @param[out] isRegisteredForPresence - Boolean variable to register for presence,
+     *             default value is false, to register for presence, set it to true
+     * @param[out] presenceInterval - interval between presences in millisecond
+     *             default value is 0 millisecond
+     *
+     * NOTE: This is a pure virtual function, thus it must be implemented by the child
+     */
+    virtual void onResourceServerStarted(bool &isRegisteredForPresence, int &presenceInterval) = 0;
+
+    /***
+     * API to handle OBSERVE request
+     *
+     * @param[in] queryParamsMap - A map containing all query parameters
+     * @param[out] response - response to the incoming request
+     *
+     * NOTE: This is a pure virtual function, thus it must be implemented by the child
+     */
+    virtual void handleObserveRequest(QueryParamsMap &queryParamsMap,
+            std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response) = 0;
+
+    /***
+     * API to handle DELETE request
+     *
+     * @param[in] queryParamsMap - A map containing all query parameters
+     * @param[out] response - response to the incoming request
+     *
+     * NOTE: This is a pure virtual function, thus it must be implemented by the child
+     */
+    virtual void handleDeleteRequest(QueryParamsMap &queryParamsMap,
+            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response) = 0;
+
+    /***
+     * API to handle POST request
+     *
+     * @param[in] queryParamsMap - A map containing all query parameters
+     * @param[out] response - response to the incoming request
+     *
+     * NOTE: This is a pure virtual function, thus it must be implemented by the child
+     */
+    virtual void handlePostRequest(QueryParamsMap &queryParamsMap,
+            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response) = 0;
+
+    /***
+     * API to handle GET request
+     *
+     * @param[in] queryParamsMap - A map containing all query parameters
+     * @param[out] response - response to the incoming request
+     *
+     * NOTE: This is a pure virtual function, thus it must be implemented by the child
+     */
+    virtual void handleGetRequest(QueryParamsMap &queryParamsMap,
+            std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response) = 0;
+
+    /***
+     * API to handle PUT request
+     *
+     * @param[in] queryParamsMap - A map containing all query parameters
+     * @param[out] response - response to the incoming request
+     *
+     * NOTE: This is a pure virtual function, thus it must be implemented by the child
+     */
+    virtual void handlePutRequest(QueryParamsMap &queryParamsMap,
+            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response) = 0;
+
+    /***
+     * API to handle INIT request
+     *
+     * @param[in] queryParamsMap - A map containing all query parameters
+     * @param[out] response - response to the incoming request
+     *
+     * NOTE: This is a pure virtual function, thus it must be implemented by the child
+     */
+    virtual void handleInitRequest(QueryParamsMap &queryParamsMap,
+            std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response) = 0;
+
+    /***
+     * API to get the attribute list of the resource server
+     *
+     * @param[in] temp - epresentation of the resource server
+     *
+     * @return OCRepresentation - representation of the resource server
+     */
+    virtual OCRepresentation getResourceRepresentation(OCRepresentation &temp) = 0;
+
+    /**
+      * Set Platform info of the current device platform
+      *
+      * @param[in] - platformID - Unique ID of the platform in form of UUID
+      * @param[in] - manufacturerName - Human radable name of the device manufacturer
+      * @param[in] - manufacturerUrl - URI to the device manufacturer webpage
+      * @param[in] - platformID - Unique ID of the platform in form of UUID
+      * @param[in] - platformID - Unique ID of the platform in form of UUID
+      * @param[in] - platformID - Unique ID of the platform in form of UUID
+      *
+      */
+    static OCStackResult setPlatformInfo(string platformID, string manufacturerName,
+            string manufacturerUrl, string modelNumber, string dateOfManufacture,
+            string platformVersion, string operatingSystemVersion, string hardwareVersion,
+            string firmwareVersion, string supportUrl, string systemTime);
+
+    /**
+      * Set Device info of the current device
+      *
+      * @param[in] - deviceName - Human readable name of the device
+      * @param[in] - deviceTypes - List of device types of the device(Optional)
+      * @param[in] - specVersion - OCF version for device, with default ocf.1.0.0
+      *
+      */
+    static OCStackResult setDeviceInfo(string deviceName, vector<string> deviceTypes = vector<string>(), string specVersion = CORE_SPEC_VERSION);
+
+    /**
+      * Set Device info of the current device
+      *
+      * @param[in] - deviceName - Human readable name of the device
+      * @param[in] - deviceTypes - Device type of the device(Optional)
+      * @param[in] - specVersion - OCF version for device, with default ocf.1.0.0
+      *
+      */
+    static OCStackResult setDeviceInfo(string deviceName, string deviceTypes, string specVersion = CORE_SPEC_VERSION);
+
+};
+
+#endif // _RESOURCE_SERVER_H_ end
diff --git a/test/include/SampleCollection.h b/test/include/SampleCollection.h
index 294ca3bf0..99bc9d704 100644
--- a/test/include/SampleCollection.h
+++ b/test/include/SampleCollection.h
@@ -44,7 +44,7 @@ private:
 
     ObservationIds m_listOfObservers;
     shared_ptr< OCResourceResponse > m_pResponse;
-    vector< shared_ptr< SampleResource >  > m_childResourceList;
+    vector< shared_ptr< SampleResource >  > m_childResources;
     map< string, string > m_accessmodifier;
 
 public:
@@ -56,6 +56,8 @@ public:
 
     bool isReadonly(string key);
 
+    virtual OCStackResult stopResource(void);
+
     virtual void onResourceServerStarted(bool &isRegisteredForPresence, int &presenceInterval);
 
     virtual void handleObserveRequest(QueryParamsMap &queryParamsMap,
diff --git a/test/include/SampleResource.h b/test/include/SampleResource.h
index 39593619d..3aa05bdd4 100644
--- a/test/include/SampleResource.h
+++ b/test/include/SampleResource.h
@@ -1,124 +1,126 @@
-/******************************************************************
- *
- * Copyright 2017 Samsung Electronics All Rights Reserved.
- *
- *
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ******************************************************************/
-
-#ifndef COMMON_TESTCASE_SAMPLERESOURCE_H_
-#define COMMON_TESTCASE_SAMPLERESOURCE_H_
-
-#include "ResourceHelper.h"
-#include "ResourceServer.h"
-
-using namespace std;
-namespace PH = std::placeholders;
-
-class SampleResource: public ResourceServer
-{
-protected:
-    int m_recursiveDelay;
-    int m_scheduledDelay;
-    bool m_isCancelCalled;
-    bool m_isObserveRegistered;
-    ObservationIds m_listOfObservers;
-    shared_ptr< OCResourceResponse > m_pResponse;
-    vector< string > m_resourceList;
-    map< string, string > m_accessmodifier;
-    std::shared_ptr< SampleResource > m_pSensorTwin;
-
-
-
-public:
-    SampleResource(void);
-
-    SampleResource(std::string resourceUri,
-            std::string resourceTypeName,
-            std::string resourceInterface,
-            uint8_t resourceProperty = OC_ACTIVE);
-
-    SampleResource(std::string resourceUri,
-            std::string resourceTypeName,
-            std::string resourceInterface,
-            uint8_t resourceProperty,
-            OCRepresentation resourceRepresentation);
-
-    virtual ~SampleResource(void);
-
-    void setAsReadOnly(string key);
-
-    bool isReadonly(string key);
-
-    void setSensorTwin(std::shared_ptr< SampleResource > p_sensorResource);
-
-    virtual void onResourceServerStarted(bool &isRegisteredForPresence, int &presenceInterval);
-
-    virtual void handleObserveRequest(QueryParamsMap &queryParamsMap,
-            std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response);
-
-    virtual void handleDeleteRequest(QueryParamsMap &queryParamsMap,
-            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response);
-
-    virtual void handlePostRequest(QueryParamsMap &queryParamsMap,
-            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response);
-
-    virtual void handleGetRequest(QueryParamsMap &queryParamsMap,
-            std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response);
-
-    virtual void handleGetRequest(QueryParamsMap &queryParamsMap,
-            std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response,
-            OCRepresentation rep);
-
-    virtual void handlePutRequest(QueryParamsMap &queryParamsMap,
-            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response);
-
-    virtual void handleInitRequest(QueryParamsMap &queryParamsMap,
-            std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response);
-
-    virtual OCRepresentation getResourceRepresentation(OCRepresentation &resourceRep);
-
-    OCStackResult addArrayAttribute(string key, OCRepresentation arrayRep);
-
-    void notifyObservers();
-    void notifyObservers(void *param);
-    bool updateRepresentation(string key, AttributeValue value);
-    bool updateRepresentation(string key, OCRepresentation incomingRep);
-    bool updateBatchRepresentation(string key, OCRepresentation incomingRep, bool &isError);
-
-protected:
-    void handleRecursiveActionSet();
-
-    void handleScheduledActionSet();
-
-    bool updateRepresentation(string key, OCRepresentation incomingRep,
-            shared_ptr< OCResourceResponse > response);
-
-    void createResource(string initialUri, OCRepresentation incomingRepresentation,
-            shared_ptr< OCResourceResponse > response);
-
-    void supportCreateAndOthersForPUT(QueryParamsMap &queryParamsMap,
-            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
-            std::shared_ptr< OCResourceResponse > response);
-};
-
-#endif /* COMMON_TESTCASE_SAMPLERESOURCE_H_ */
+/******************************************************************
+ *
+ * Copyright 2017 Samsung Electronics All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#ifndef COMMON_TESTCASE_SAMPLERESOURCE_H_
+#define COMMON_TESTCASE_SAMPLERESOURCE_H_
+
+#include "ResourceHelper.h"
+#include "ResourceServer.h"
+
+using namespace std;
+namespace PH = std::placeholders;
+
+class SampleResource: public ResourceServer
+{
+protected:
+    int m_recursiveDelay;
+    int m_scheduledDelay;
+    bool m_isCancelCalled;
+    bool m_isObserveRegistered;
+    ObservationIds m_listOfObservers;
+    shared_ptr< OCResourceResponse > m_pResponse;
+    vector< string > m_resourceList;
+    map< string, string > m_accessmodifier;
+    std::shared_ptr< SampleResource > m_pSensorTwin;
+
+
+
+public:
+    SampleResource(void);
+
+    SampleResource(std::string resourceUri,
+            std::string resourceTypeName,
+            std::string resourceInterface,
+            uint8_t resourceProperty = OC_ACTIVE);
+
+    SampleResource(std::string resourceUri,
+            std::string resourceTypeName,
+            std::string resourceInterface,
+            uint8_t resourceProperty,
+            OCRepresentation resourceRepresentation);
+
+    virtual ~SampleResource(void);
+
+    virtual OCStackResult stopResource(void);
+
+    void setAsReadOnly(string key);
+
+    bool isReadonly(string key);
+
+    void setSensorTwin(std::shared_ptr< SampleResource > p_sensorResource);
+
+    virtual void onResourceServerStarted(bool &isRegisteredForPresence, int &presenceInterval);
+
+    virtual void handleObserveRequest(QueryParamsMap &queryParamsMap,
+            std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response);
+
+    virtual void handleDeleteRequest(QueryParamsMap &queryParamsMap,
+            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response);
+
+    virtual void handlePostRequest(QueryParamsMap &queryParamsMap,
+            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response);
+
+    virtual void handleGetRequest(QueryParamsMap &queryParamsMap,
+            std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response);
+
+    virtual void handleGetRequest(QueryParamsMap &queryParamsMap,
+            std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response,
+            OCRepresentation rep);
+
+    virtual void handlePutRequest(QueryParamsMap &queryParamsMap,
+            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response);
+
+    virtual void handleInitRequest(QueryParamsMap &queryParamsMap,
+            std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response);
+
+    virtual OCRepresentation getResourceRepresentation(OCRepresentation &resourceRep);
+
+    OCStackResult addArrayAttribute(string key, OCRepresentation arrayRep);
+
+    void notifyObservers();
+    void notifyObservers(void *param);
+    bool updateRepresentation(string key, AttributeValue value);
+    bool updateRepresentation(string key, OCRepresentation incomingRep);
+    bool updateBatchRepresentation(string key, OCRepresentation incomingRep, bool &isError);
+
+protected:
+    void handleRecursiveActionSet();
+
+    void handleScheduledActionSet();
+
+    bool updateRepresentation(string key, OCRepresentation incomingRep,
+            shared_ptr< OCResourceResponse > response);
+
+    void createResource(string initialUri, OCRepresentation incomingRepresentation,
+            shared_ptr< OCResourceResponse > response);
+
+    void supportCreateAndOthersForPUT(QueryParamsMap &queryParamsMap,
+            OCRepresentation incomingRepresentation, std::shared_ptr< OCResourceRequest > request,
+            std::shared_ptr< OCResourceResponse > response);
+};
+
+#endif /* COMMON_TESTCASE_SAMPLERESOURCE_H_ */
diff --git a/test/src/common/commonutil/c_cpp/ResourceHelper.cpp b/test/src/common/commonutil/c_cpp/ResourceHelper.cpp
index 695ff786c..6e46b41b0 100644
--- a/test/src/common/commonutil/c_cpp/ResourceHelper.cpp
+++ b/test/src/common/commonutil/c_cpp/ResourceHelper.cpp
@@ -338,6 +338,169 @@ void ResourceHelper::printPayload(OCRepPayload* incomingPayload, OCRepresentatio
     }
 }
 
+void ResourceHelper::payloadToString(OCRepPayload* incomingPayload, std::string& stringPayload, int level)
+{
+    bool hasInterface = false;
+    bool hasType = false;
+    level++;
+
+    OCStringLL* interfaces = incomingPayload->interfaces;
+    string interfaceInfo = "Interfaces: \n[";
+    while (interfaces)
+    {
+        hasInterface = true;
+
+        interfaceInfo += string(interfaces->value) + " ";
+        interfaces = interfaces->next;
+    }
+
+    if (hasInterface)
+    {
+        stringPayload += interfaceInfo + "]\n";
+    }
+
+    OCStringLL* types = incomingPayload->types;
+    string typeInfo = "Types: \n[";
+    while (types)
+    {
+        hasType = true;
+
+        typeInfo += string(types->value) + " ";
+        types = types->next;
+    }
+
+    if (hasType)
+    {
+        stringPayload += typeInfo + "]\n";
+    }
+
+    if (level == 1)
+    {
+        stringPayload += "Attributes: \n{\n";
+    }
+
+    while (incomingPayload)
+    {
+        OCRepPayloadValue *repValue = incomingPayload->values;
+        while (repValue)
+        {
+            string value = "";
+            string tabValue = "";
+            for (int i = 1; i < level; i++)
+            {
+                tabValue += "\t\t";
+            }
+            stringPayload += "\t" + tabValue + repValue->name + ": ";
+
+            if (repValue->type == OCRepPayloadPropType::OCREP_PROP_INT)
+            {
+#ifdef __LINUX__
+                value = to_string(repValue->i);
+#endif
+
+#if defined(__ANDROID__) || defined(__TIZEN__)
+                std::stringstream strstream;
+                strstream << repValue->i;
+                strstream >> value;
+#endif
+            }
+            if (repValue->type == OCRepPayloadPropType::OCREP_PROP_DOUBLE)
+            {
+                value = to_string(repValue->d);
+            }
+            if (repValue->type == OCRepPayloadPropType::OCREP_PROP_BOOL)
+            {
+                value = repValue->b ? "true" : "false";
+            }
+            if (repValue->type == OCRepPayloadPropType::OCREP_PROP_STRING)
+            {
+                value = value = "\"" + string(repValue->str) + "\"";
+            }
+            if (repValue->type == OCRepPayloadPropType::OCREP_PROP_ARRAY)
+            {
+                if (repValue->arr.type == OCRepPayloadPropType::OCREP_PROP_OBJECT)
+                {
+                    stringPayload += "\n\t" + tabValue + "[\n";
+                    size_t arraySize = repValue->arr.dimensions[0];
+                    OCRepPayload** objectArray = repValue->arr.objArray;
+                    for (size_t sz = 0; sz < arraySize; sz++)
+                    {
+                        OCRepPayload* payload = *objectArray;
+                        stringPayload += "\t\t" + tabValue +"{\n";
+                        payloadToString(payload, stringPayload, level);
+                        stringPayload += "\t\t" + tabValue + "}\n";
+
+                        objectArray++;
+                    }
+                    stringPayload += "\t" + tabValue + "]\n";
+                }
+                else if (repValue->arr.type == OCRepPayloadPropType::OCREP_PROP_INT)
+                {
+                    stringPayload += "[";
+                    size_t arraySize = repValue->arr.dimensions[0];
+                    for (size_t sz = 0; sz < arraySize; sz++)
+                    {
+                        stringPayload += to_string(repValue->arr.iArray[sz]);
+                        if (sz != arraySize - 1) stringPayload += ", ";
+                    }
+                    stringPayload += "]";
+                }
+                else if (repValue->arr.type == OCRepPayloadPropType::OCREP_PROP_DOUBLE)
+                {
+                    stringPayload += "[";
+                    size_t arraySize = repValue->arr.dimensions[0];
+                    for (size_t sz = 0; sz < arraySize; sz++)
+                    {
+                        stringPayload += to_string(repValue->arr.dArray[sz]);
+                        if (sz != arraySize - 1) stringPayload += ", ";
+                    }
+                    stringPayload += "]";
+                }
+                else if (repValue->arr.type == OCRepPayloadPropType::OCREP_PROP_BOOL)
+                {
+                    stringPayload += "[";
+                    size_t arraySize = repValue->arr.dimensions[0];
+                    for (size_t sz = 0; sz < arraySize; sz++)
+                    {
+                        stringPayload += repValue->arr.bArray[sz] ? "true" : "false";
+                        if (sz != arraySize - 1) stringPayload += ", ";
+                    }
+                    stringPayload += "]";
+                }
+                else if (repValue->arr.type == OCRepPayloadPropType::OCREP_PROP_STRING)
+                {
+                    stringPayload += "[";
+                    size_t arraySize = repValue->arr.dimensions[0];
+                    for (size_t sz = 0; sz < arraySize; sz++)
+                    {
+                        stringPayload += "\"" + string(repValue->arr.strArray[sz]) + "\"";
+                        if (sz != arraySize - 1) stringPayload += ", ";
+                    }
+                    stringPayload += "]";
+                }
+            }
+            if (repValue->type == OCRepPayloadPropType::OCREP_PROP_OBJECT)
+            {
+                stringPayload += "\t{\n";
+                payloadToString(repValue->obj, stringPayload, level);
+                stringPayload += "\t}\n";
+            }
+            if (repValue->type == OCRepPayloadPropType::OCREP_PROP_NULL)
+            {
+                value = "null";
+            }
+
+            stringPayload += value + "\n";
+            repValue = repValue->next;
+        }
+        incomingPayload = incomingPayload->next;
+    }
+    if (level == 1)
+    {
+        stringPayload += "}";
+    }
+}
+
 void ResourceHelper::waitInSecond(unsigned int seconds)
 {
     sleep(seconds);
diff --git a/test/src/common/commonutil/c_cpp/ResourceServer.cpp b/test/src/common/commonutil/c_cpp/ResourceServer.cpp
index 0fb309fe5..8ab4ee6b4 100644
--- a/test/src/common/commonutil/c_cpp/ResourceServer.cpp
+++ b/test/src/common/commonutil/c_cpp/ResourceServer.cpp
@@ -1,505 +1,463 @@
-/******************************************************************
- *
- * Copyright 2017 Samsung Electronics All Rights Reserved.
- *
- *
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- ******************************************************************/
-
-#include "ResourceServer.h"
-#include "ocstack.h"
-#include "ocpayload.h"
-
-namespace PH = std::placeholders;
-
-bool ResourceServer::s_isServerConstructed = false;
-OCPlatformInfo ResourceServer::s_platformInfo;
-OCDeviceInfo ResourceServer::s_deviceInfo;
-ResourceHelper* ResourceServer::p_resourceHelper = ResourceHelper::getInstance();
-
-ResourceServer::ResourceServer(void) :
-        m_resourceHandle(NULL), m_platformConfig(
-        { OC::ServiceType::InProc, OC::ModeType::Both, "", (uint16_t) 0,
-                OC::QualityOfService::MidQos })
-{
-    m_resourceURI = "/device";
-    m_resourceTypeName = "core.mock";
-    m_resourceInterface = DEFAULT_INTERFACE;
-    m_isServerRunning = false;
-    s_isServerConstructed = false;
-    m_isRegisteredForPresence = false;
-    m_responseTimeType = ResponseTimeType::NORMAL;
-    m_resourceProperty = OC_ACTIVE;
-    m_resourceTypeNames.clear();
-    m_resourceInterfaces.clear();
-    m_childResourceList.clear();
-}
-
-ResourceServer::~ResourceServer(void)
-{
-    if (m_isServerRunning)
-    {
-        stopResource();
-    }
-}
-
-OCStackResult ResourceServer::constructServer(PlatformConfig &cfg)
-{
-    OCStackResult result = OC_STACK_OK;
-    try
-    {
-        OCPlatform::Configure(cfg);
-        s_isServerConstructed = true;
-
-        setPlatformInfo(PLATFORM_ID, MANUFACTURER_NAME, MANUFACTURER_URL, MODEL_NUMBER,
-        DATE_OF_MANUFACTURE, PLATFORM_VERSION, OPERATING_SYSTEM_VERSION,
-        HARDWARE_VERSION, FIRMWARE_VERSION, SUPPORT_URL, SYSTEM_TIME);
-
-        OCResourcePayloadAddStringLL(&s_deviceInfo.types, "oic.wk.d");
-        OCSetDeviceInfo(s_deviceInfo);
-
-        setDeviceInfo(DEVICE_NAME);
-
-        result = OCPlatform::registerPlatformInfo(s_platformInfo);
-
-        result = OCPlatform::registerDeviceInfo(s_deviceInfo);
-
-        cout << "Server Created..." << endl;
-    }
-    catch (OCException &e)
-    {
-        result = OC_STACK_ERROR;
-        cerr << "Error occurred while creating server, error code: " << e.what() << endl;
-    }
-
-    return result;
-}
-
-OCStackResult ResourceServer::constructServer(std::string ip, int port)
-{
-    OCStackResult result = OC_STACK_OK;
-
-    PlatformConfig cfg
-    { OC::ServiceType::InProc, OC::ModeType::Both, ip, (uint16_t) port, OC::QualityOfService::LowQos };
-
-    result = constructServer(cfg);
-
-    return result;
-}
-
-OCDeviceInfo ResourceServer::getDeviceInfo()
-{
-    return s_deviceInfo;
-}
-
-OCEntityHandlerResult ResourceServer::entityHandler(std::shared_ptr< OCResourceRequest > request)
-{
-
-    OCEntityHandlerResult result = OC_EH_OK;
-
-    cout << "\tIn Server entity handler:\n";
-
-    if (request)
-    {
-        if (m_responseTimeType == ResponseTimeType::SLOW)
-        {
-            thread t(bind(&ResourceServer::handleSlowResponse, this, PH::_1), request);
-            t.detach();
-            result = OC_EH_SLOW;
-        }
-        else
-        {
-            handleResponse(request);
-            result = OC_EH_OK;
-        }
-    }
-    else
-    {
-        cerr << "Request invalid" << endl;
-    }
-
-    return result;
-}
-
-OCRepresentation ResourceServer::getRepresentation(void)
-{
-    return getResourceRepresentation(m_representation);
-}
-
-OCResourceHandle ResourceServer::getResourceHandle(void)
-{
-    return m_resourceHandle;
-}
-
-OCStackResult ResourceServer::setResourceProperties(std::string resourceUri,
-        std::string resourceTypeName, std::string resourceInterface)
-{
-    m_resourceURI = resourceUri;
-    m_resourceTypeName = resourceTypeName;
-    m_resourceInterface = resourceInterface;
-
-    OCStackResult result = OC_STACK_OK;
-
-    if ((m_resourceURI.compare("") == 0) || (m_resourceTypeName.compare("") == 0)
-            || (m_resourceInterface.compare("") == 0))
-    {
-        result = OC_STACK_ERROR;
-    }
-
-    return result;
-}
-
-OCStackResult ResourceServer::startResource(uint8_t resourceProperty , HandlerType handlerType)
-{
-    OCStackResult result = OC_STACK_OK;
-
-    m_resourceProperty = m_resourceProperty | resourceProperty;
-
-    if (isObservableResource())
-    {
-        cout << "This resource is Observable" << endl;
-    }
-    if (isDiscoverableResource())
-    {
-        cout << "This resource is Discoverable" << endl;
-    }
-    if (isSecuredResource())
-    {
-        cout << "This resource is Secured" << endl;
-    }
-
-    if (m_resourceTypeName.find(" ") != string::npos)
-    {
-        stringstream typeStream(m_resourceTypeName);
-        string currentType = "";
-        while (typeStream >> currentType)
-        {
-            m_resourceTypeNames.push_back(currentType);
-        }
-        m_resourceTypeName = m_resourceTypeNames.at(0);
-    }
-    else
-    {
-        m_resourceTypeNames.push_back(m_resourceTypeName);
-    }
-
-    if (m_resourceInterface.find(" ") != string::npos)
-    {
-        stringstream interfaceStream(m_resourceInterface);
-        string currentInterface = "";
-        while (interfaceStream >> currentInterface)
-        {
-            m_resourceInterfaces.push_back(currentInterface);
-        }
-        m_resourceInterface = m_resourceInterfaces.at(0);
-    }
-    else
-    {
-        m_resourceInterfaces.push_back(m_resourceInterface);
-    }
-
-    // This will internally create and register the resource.
-    if (handlerType == HandlerType::DEFAULT)
-    {
-        result = OCPlatform::registerResource(m_resourceHandle, m_resourceURI, m_resourceTypeName,
-            m_resourceInterface, NULL,
-            m_resourceProperty);
-    }
-    else
-    {
-        result = OCPlatform::registerResource(m_resourceHandle, m_resourceURI, m_resourceTypeName,
-            m_resourceInterface, bind(&ResourceServer::entityHandler, this, PH::_1),
-            m_resourceProperty);
-    }
-
-    if (m_resourceTypeNames.size() > 1)
-    {
-        for (unsigned int i = 1; i < m_resourceTypeNames.size(); i++)
-        {
-            OCPlatform::bindTypeToResource(m_resourceHandle, m_resourceTypeNames.at(i));
-        }
-    }
-
-    if (m_resourceInterfaces.size() > 1)
-    {
-        for (unsigned int i = 1; i < m_resourceInterfaces.size(); i++)
-        {
-            OCPlatform::bindInterfaceToResource(m_resourceHandle, m_resourceInterfaces.at(i));
-        }
-    }
-
-    if (result != OC_STACK_OK)
-    {
-        cerr << "Device Resource failed to start, result code =  " << result << endl;
-        throw std::runtime_error(
-                std::string("Device Resource failed to start") + std::to_string(result));
-    }
-    else
-    {
-        m_isServerRunning = true;
-        cout << "Server Started" << endl;
-
-        m_isRegisteredForPresence = false;
-        int presenceInterval = 0;
-        onResourceServerStarted(m_isRegisteredForPresence, presenceInterval); // pure virtual method to implement task for child after resource server starts
-
-        if (m_isRegisteredForPresence)
-        {
-            OCPlatform::startPresence(presenceInterval);
-        }
-
-    }
-
-    return result;
-}
-
-OCStackResult ResourceServer::stopResource(void)
-{
-    OCStackResult result = OC_STACK_OK;
-
-    //check whether server is running
-    if (m_isServerRunning == false)
-    {
-        result = OC_STACK_ERROR;
-        cerr << "Resource server is not started; Please start it before stopping " << endl;
-
-        return result;
-    }
-
-    //stop presence
-    if (m_isRegisteredForPresence)
-    {
-        OC_UNUSED(OCPlatform::stopPresence());
-    }
-
-    //stop server
-    result = OCPlatform::unregisterResource(m_resourceHandle);
-
-    if (result == OC_STACK_OK)
-    {
-        m_isServerRunning = false;
-        for (auto resource : m_childResourceList)
-        {
-            resource->stopResource();
-            delete resource;
-            resource = nullptr;
-        }
-    }
-    else
-    {
-        cerr << "Unable to stop server" << endl;
-    }
-
-    return result;
-}
-
-void ResourceServer::setResourceRepresentation(OCRepresentation ocRepresentation)
-{
-    m_representation = ocRepresentation;
-}
-
-string ResourceServer::getUri(void)
-{
-    return m_resourceURI;
-}
-
-OCStackResult ResourceServer::setPlatformInfo(string platformID, string manufacturerName,
-        string manufacturerUrl, string modelNumber, string dateOfManufacture,
-        string platformVersion, string operatingSystemVersion, string hardwareVersion,
-        string firmwareVersion, string supportUrl, string systemTime)
-{
-    p_resourceHelper->duplicateString(&s_platformInfo.platformID, platformID);
-    p_resourceHelper->duplicateString(&s_platformInfo.manufacturerName, manufacturerName);
-    p_resourceHelper->duplicateString(&s_platformInfo.manufacturerUrl, manufacturerUrl);
-    p_resourceHelper->duplicateString(&s_platformInfo.modelNumber, modelNumber);
-    p_resourceHelper->duplicateString(&s_platformInfo.dateOfManufacture, dateOfManufacture);
-    p_resourceHelper->duplicateString(&s_platformInfo.platformVersion, platformVersion);
-    p_resourceHelper->duplicateString(&s_platformInfo.operatingSystemVersion,
-            operatingSystemVersion);
-    p_resourceHelper->duplicateString(&s_platformInfo.hardwareVersion, hardwareVersion);
-    p_resourceHelper->duplicateString(&s_platformInfo.firmwareVersion, firmwareVersion);
-    p_resourceHelper->duplicateString(&s_platformInfo.supportUrl, supportUrl);
-    p_resourceHelper->duplicateString(&s_platformInfo.systemTime, systemTime);
-    return OC_STACK_OK;
-}
-
-OCStackResult ResourceServer::setDeviceInfo(string deviceName, vector<string> deviceTypes, string specVersion)
-{
-    p_resourceHelper->duplicateString(&s_deviceInfo.deviceName, deviceName);
-    if (deviceTypes.size() > 0)
-    {
-        for (string deviceType : deviceTypes)
-        {
-            OCResourcePayloadAddStringLL(&s_deviceInfo.types, deviceType.c_str());
-        }
-
-        p_resourceHelper->duplicateString(&s_deviceInfo.specVersion, specVersion);
-        OCResourcePayloadAddStringLL(&s_deviceInfo.dataModelVersions, RESOURCE_TYPE_SPEC_VERSION);
-        if ((deviceName.find("Client") == string::npos)
-                && (deviceName.find("client") == string::npos)
-                && (deviceName.find("System") == string::npos)
-                && (deviceName.find("system") == string::npos))
-        {
-            OCResourcePayloadAddStringLL(&s_deviceInfo.dataModelVersions, SMART_HOME_SPEC_VERSION);
-            cout << "Added Smart Home Spec version: " << SMART_HOME_SPEC_VERSION << endl;
-        }
-    }
-
-    OCSetDeviceInfo(s_deviceInfo);
-    return OC_STACK_OK;
-}
-
-OCStackResult ResourceServer::setDeviceInfo(string deviceName, string deviceTypes, string specVersion)
-{
-    return setDeviceInfo(deviceName, vector<string>{deviceTypes}, specVersion);
-}
-
-void ResourceServer::handleResponse(std::shared_ptr< OCResourceRequest > request)
-{
-    auto pResponse = make_shared< OC::OCResourceResponse >();
-    pResponse->setRequestHandle(request->getRequestHandle());
-    pResponse->setResourceHandle(request->getResourceHandle());
-
-    // Get the request type and request flag
-    string requestType = request->getRequestType();
-    RequestHandlerFlag requestFlag = (RequestHandlerFlag) request->getRequestHandlerFlag();
-
-    if (requestFlag == RequestHandlerFlag::RequestFlag)
-    {
-        cout << "\t\trequestFlag : Request\n";
-        cout << "\t\t\trequestType : " << requestType << endl;
-
-        // If the request type is GET
-        if (requestType == "GET")
-        {
-            // Check for query params (if any)
-            QueryParamsMap queryParamsMap = request->getQueryParameters();
-
-            handleGetRequest(queryParamsMap, request, pResponse); // Process query params and do required operations ..
-
-        }
-        else if (requestType == "PUT")
-        {
-            OCRepresentation incomingRepresentation = request->getResourceRepresentation();
-
-            // Check for query params (if any)
-            QueryParamsMap queryParamsMap = request->getQueryParameters();
-
-            handlePutRequest(queryParamsMap, incomingRepresentation, request, pResponse); // Process query params and do required operations ..
-        }
-        else if (requestType == "POST")
-        {
-            // POST request operations
-            OCRepresentation incomingRepresentation = request->getResourceRepresentation();
-
-            // Check for query params (if any)
-            QueryParamsMap queryParamsMap = request->getQueryParameters();
-
-            handlePostRequest(queryParamsMap, incomingRepresentation, request, pResponse); // Process query params and do required operations ..
-        }
-        else if (requestType == "DELETE")
-        {
-            // DELETE request operations
-            OCRepresentation incomingRepresentation = request->getResourceRepresentation();
-            // Check for query params (if any)
-            QueryParamsMap queryParamsMap = request->getQueryParameters();
-
-            handleDeleteRequest(queryParamsMap, incomingRepresentation, request, pResponse); // Process query params and do required operations ..
-        }
-    }
-    else if (requestFlag & RequestHandlerFlag::ObserverFlag)
-    {
-        // Check for query params (if any)
-        QueryParamsMap queryParamsMap = request->getQueryParameters();
-
-        handleObserveRequest(queryParamsMap, request, pResponse); // Process query params and do required operations ..
-    }
-}
-
-void ResourceServer::handleSlowResponse(std::shared_ptr< OCResourceRequest > request)
-{
-    cout << "Acting as Slow Resource...." << endl;
-    p_resourceHelper->waitInSecond(CALLBACK_WAIT_MAX);
-    cout << "Slow working period is over" << endl;
-
-    handleResponse(request);
-}
-
-void ResourceServer::setResponseTimeType(ResponseTimeType responseTimeType)
-{
-    m_responseTimeType = responseTimeType;
-}
-
-void ResourceServer::setAsSlowResource()
-{
-    m_responseTimeType = ResponseTimeType::SLOW;
-}
-
-void ResourceServer::setAsNormalResource()
-{
-    m_responseTimeType = ResponseTimeType::NORMAL;
-}
-
-bool ResourceServer::isObservableResource(void)
-{
-    return m_resourceProperty & OC_OBSERVABLE;
-}
-
-bool ResourceServer::isDiscoverableResource(void)
-{
-    return m_resourceProperty & OC_DISCOVERABLE;
-}
-
-std::vector< std::string > ResourceServer::getResourceInterfaces(void)
-{
-    return m_resourceInterfaces;
-}
-
-std::vector< std::string > ResourceServer::getResourceTypes(void)
-{
-    return m_resourceTypeNames;
-}
-
-void ResourceServer::setAsSecuredResource(void)
-{
-    m_resourceProperty = m_resourceProperty | OC_SECURE;
-}
-
-void ResourceServer::setAsDiscoverableResource(void)
-{
-    m_resourceProperty = m_resourceProperty | OC_DISCOVERABLE;
-}
-
-void ResourceServer::setAsObservableResource(void)
-{
-    m_resourceProperty = m_resourceProperty | OC_OBSERVABLE;
-}
-
-bool ResourceServer::isSecuredResource(void)
-{
-    return m_resourceProperty & OC_SECURE;
-}
-
-void ResourceServer::addResourceType(string resourceType)
-{
-    OCPlatform::bindTypeToResource(getResourceHandle(), resourceType);
-    m_resourceTypeNames.push_back(resourceType);
-}
-
-void ResourceServer::addResourceInterface(string resourceInterface)
-{
-    OCPlatform::bindInterfaceToResource(getResourceHandle(), resourceInterface);
-    m_resourceInterfaces.push_back(resourceInterface);
+/******************************************************************
+ *
+ * Copyright 2017 Samsung Electronics All Rights Reserved.
+ *
+ *
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ******************************************************************/
+
+#include "ResourceServer.h"
+#include "ocstack.h"
+#include "ocpayload.h"
+#include "oic_malloc.h"
+
+namespace PH = std::placeholders;
+
+bool ResourceServer::s_isServerConstructed = false;
+ResourceHelper* ResourceServer::p_resourceHelper = ResourceHelper::getInstance();
+
+ResourceServer::ResourceServer(void) :
+        m_resourceHandle(NULL)
+{
+    m_resourceURI = "/device";
+    m_resourceTypeName = "core.mock";
+    m_resourceInterface = DEFAULT_INTERFACE;
+    m_isResourceRunning = false;
+    m_isRegisteredForPresence = false;
+    m_responseTimeType = ResponseTimeType::NORMAL;
+    m_resourceProperty = OC_ACTIVE;
+}
+
+ResourceServer::~ResourceServer(void)
+{
+}
+
+OCStackResult ResourceServer::constructServer(PlatformConfig &cfg, std::string deviceName, std::vector<string> deviceTypes, std::string specVersion)
+{
+    OCStackResult result = OC_STACK_OK;
+    try
+    {
+        OCPlatform::Configure(cfg);
+        OCPlatform::start();
+
+        setPlatformInfo(PLATFORM_ID, MANUFACTURER_NAME, MANUFACTURER_URL, MODEL_NUMBER,
+        DATE_OF_MANUFACTURE, PLATFORM_VERSION, OPERATING_SYSTEM_VERSION,
+        HARDWARE_VERSION, FIRMWARE_VERSION, SUPPORT_URL, SYSTEM_TIME);
+
+        setDeviceInfo(deviceName, deviceTypes, specVersion);
+
+        cout << "Server Created..." << endl;
+    }
+    catch (OCException &e)
+    {
+        result = OC_STACK_ERROR;
+        cerr << "Error occurred while creating server, error code: " << e.what() << endl;
+    }
+
+    s_isServerConstructed = true;
+    return result;
+}
+
+OCStackResult ResourceServer::stopServer()
+{
+    if(s_isServerConstructed)
+    {
+        s_isServerConstructed = false;
+        return OCPlatform::stop();
+    }
+
+    std::cout << "Server is not constructed!" << std::endl;
+    return OC_STACK_ERROR;
+}
+
+bool ResourceServer::isServerConstructed()
+{
+    return s_isServerConstructed;
+}
+
+std::string ResourceServer::getDeviceName()
+{
+    char* value = NULL;
+    OCGetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, (void **)&value);
+    std::string returnValue = std::string(value);
+    OICFree(value);
+
+    return returnValue;
+}
+
+std::string ResourceServer::getDeviceID()
+{
+    char* value = NULL;
+    OCGetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_ID, (void **)&value);
+    std::string returnValue = std::string(value);
+    OICFree(value);
+
+    return returnValue;
+}
+
+OCEntityHandlerResult ResourceServer::entityHandler(std::shared_ptr< OCResourceRequest > request)
+{
+
+    OCEntityHandlerResult result = OC_EH_OK;
+
+    cout << "\tIn Server entity handler:\n";
+
+    if (request)
+    {
+        if (m_responseTimeType == ResponseTimeType::SLOW)
+        {
+            thread t(bind(&ResourceServer::handleSlowResponse, this, PH::_1), request);
+            t.detach();
+            result = OC_EH_SLOW;
+        }
+        else
+        {
+            handleResponse(request);
+            result = OC_EH_OK;
+        }
+    }
+    else
+    {
+        cerr << "Request invalid" << endl;
+    }
+
+    return result;
+}
+
+OCRepresentation ResourceServer::getRepresentation(void)
+{
+    return getResourceRepresentation(m_representation);
+}
+
+OCResourceHandle ResourceServer::getResourceHandle(void)
+{
+    return m_resourceHandle;
+}
+
+OCStackResult ResourceServer::setResourceProperties(std::string resourceUri,
+        std::string resourceTypeName, std::string resourceInterface)
+{
+    m_resourceURI = resourceUri;
+    m_resourceTypeName = resourceTypeName;
+    m_resourceInterface = resourceInterface;
+
+    OCStackResult result = OC_STACK_OK;
+
+    if ((m_resourceURI.compare("") == 0) || (m_resourceTypeName.compare("") == 0)
+            || (m_resourceInterface.compare("") == 0))
+    {
+        result = OC_STACK_ERROR;
+    }
+
+    return result;
+}
+
+OCStackResult ResourceServer::startResource(uint8_t resourceProperty , HandlerType handlerType)
+{
+    OCStackResult result = OC_STACK_OK;
+
+    m_resourceProperty = m_resourceProperty | resourceProperty;
+
+    if (isObservableResource())
+    {
+        cout << "This resource is Observable" << endl;
+    }
+    if (isDiscoverableResource())
+    {
+        cout << "This resource is Discoverable" << endl;
+    }
+    if (isSecuredResource())
+    {
+        cout << "This resource is Secured" << endl;
+    }
+
+    if (m_resourceTypeName.find(" ") != string::npos)
+    {
+        stringstream typeStream(m_resourceTypeName);
+        string currentType = "";
+        while (typeStream >> currentType)
+        {
+            m_resourceTypeNames.push_back(currentType);
+        }
+        m_resourceTypeName = m_resourceTypeNames.at(0);
+    }
+    else
+    {
+        m_resourceTypeNames.push_back(m_resourceTypeName);
+    }
+
+    if (m_resourceInterface.find(" ") != string::npos)
+    {
+        stringstream interfaceStream(m_resourceInterface);
+        string currentInterface = "";
+        while (interfaceStream >> currentInterface)
+        {
+            m_resourceInterfaces.push_back(currentInterface);
+        }
+        m_resourceInterface = m_resourceInterfaces.at(0);
+    }
+    else
+    {
+        m_resourceInterfaces.push_back(m_resourceInterface);
+    }
+
+    // This will internally create and register the resource.
+    if (handlerType == HandlerType::DEFAULT)
+    {
+        result = OCPlatform::registerResource(m_resourceHandle, m_resourceURI, m_resourceTypeName,
+            m_resourceInterface, NULL,
+            m_resourceProperty);
+    }
+    else
+    {
+        result = OCPlatform::registerResource(m_resourceHandle, m_resourceURI, m_resourceTypeName,
+            m_resourceInterface, bind(&ResourceServer::entityHandler, this, PH::_1),
+            m_resourceProperty);
+    }
+
+    if (m_resourceTypeNames.size() > 1)
+    {
+        for (unsigned int i = 1; i < m_resourceTypeNames.size(); i++)
+        {
+            OCPlatform::bindTypeToResource(m_resourceHandle, m_resourceTypeNames.at(i));
+        }
+    }
+
+    if (m_resourceInterfaces.size() > 1)
+    {
+        for (unsigned int i = 1; i < m_resourceInterfaces.size(); i++)
+        {
+            OCPlatform::bindInterfaceToResource(m_resourceHandle, m_resourceInterfaces.at(i));
+        }
+    }
+
+    if (result != OC_STACK_OK)
+    {
+        cerr << "Device Resource failed to start, result code =  " << result << endl;
+        throw std::runtime_error(
+                std::string("Device Resource failed to start") + std::to_string(result));
+    }
+    else
+    {
+        m_isResourceRunning = true;
+        cout << "Resource Started" << endl;
+
+        m_isRegisteredForPresence = false;
+        int presenceInterval = 0;
+        onResourceServerStarted(m_isRegisteredForPresence, presenceInterval); // pure virtual method to implement task for child after resource server starts
+
+        if (m_isRegisteredForPresence)
+        {
+            OCPlatform::startPresence(presenceInterval);
+        }
+
+    }
+
+    return result;
+}
+
+void ResourceServer::setResourceRepresentation(OCRepresentation ocRepresentation)
+{
+    m_representation = ocRepresentation;
+}
+
+string ResourceServer::getUri(void)
+{
+    return m_resourceURI;
+}
+
+OCStackResult ResourceServer::setPlatformInfo(string platformID, string manufacturerName,
+        string manufacturerUrl, string modelNumber, string dateOfManufacture,
+        string platformVersion, string operatingSystemVersion, string hardwareVersion,
+        string firmwareVersion, string supportUrl, string systemTime)
+{
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_PLATFORM_ID, platformID.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MFG_NAME, manufacturerName.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MFG_URL, manufacturerUrl.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MODEL_NUM, modelNumber.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_MFG_DATE, dateOfManufacture.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_PLATFORM_VERSION, platformVersion.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_OS_VERSION, operatingSystemVersion.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_HARDWARE_VERSION, hardwareVersion.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_FIRMWARE_VERSION, firmwareVersion.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_SUPPORT_URL, supportUrl.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_PLATFORM, OC_RSRVD_SYSTEM_TIME, systemTime.c_str());
+
+    return OC_STACK_OK;
+}
+
+OCStackResult ResourceServer::setDeviceInfo(string deviceName, vector<string> deviceTypes, string specVersion)
+{
+    OCResourceHandle deviceResource = OCGetResourceHandleAtUri(OC_RSRVD_DEVICE_URI);
+    if (deviceResource == NULL)
+    {
+        std::cerr << "ERROR: Device Resource does not exist." << std::endl;
+        return OC_STACK_ERROR;
+    }
+
+    for (string deviceType : deviceTypes)
+    {
+        OCBindResourceTypeToResource(deviceResource, deviceType.c_str());
+    }
+
+    OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, deviceName.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_SPEC_VERSION, specVersion.c_str());
+    OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DATA_MODEL_VERSION, SMART_HOME_SPEC_VERSION);
+
+    return OC_STACK_OK;
+}
+
+OCStackResult ResourceServer::setDeviceInfo(string deviceName, string deviceTypes, string specVersion)
+{
+    return setDeviceInfo(deviceName, vector<string>{deviceTypes}, specVersion);
+}
+
+void ResourceServer::handleResponse(std::shared_ptr< OCResourceRequest > request)
+{
+    auto pResponse = make_shared< OC::OCResourceResponse >();
+    pResponse->setRequestHandle(request->getRequestHandle());
+    pResponse->setResourceHandle(request->getResourceHandle());
+
+    // Get the request type and request flag
+    string requestType = request->getRequestType();
+    RequestHandlerFlag requestFlag = (RequestHandlerFlag) request->getRequestHandlerFlag();
+
+    if (requestFlag == RequestHandlerFlag::RequestFlag)
+    {
+        cout << "\t\trequestFlag : Request\n";
+        cout << "\t\t\trequestType : " << requestType << endl;
+
+        // If the request type is GET
+        if (requestType == "GET")
+        {
+            // Check for query params (if any)
+            QueryParamsMap queryParamsMap = request->getQueryParameters();
+
+            handleGetRequest(queryParamsMap, request, pResponse); // Process query params and do required operations ..
+
+        }
+        else if (requestType == "PUT")
+        {
+            OCRepresentation incomingRepresentation = request->getResourceRepresentation();
+
+            // Check for query params (if any)
+            QueryParamsMap queryParamsMap = request->getQueryParameters();
+
+            handlePutRequest(queryParamsMap, incomingRepresentation, request, pResponse); // Process query params and do required operations ..
+        }
+        else if (requestType == "POST")
+        {
+            // POST request operations
+            OCRepresentation incomingRepresentation = request->getResourceRepresentation();
+
+            // Check for query params (if any)
+            QueryParamsMap queryParamsMap = request->getQueryParameters();
+
+            handlePostRequest(queryParamsMap, incomingRepresentation, request, pResponse); // Process query params and do required operations ..
+        }
+        else if (requestType == "DELETE")
+        {
+            // DELETE request operations
+            OCRepresentation incomingRepresentation = request->getResourceRepresentation();
+            // Check for query params (if any)
+            QueryParamsMap queryParamsMap = request->getQueryParameters();
+
+            handleDeleteRequest(queryParamsMap, incomingRepresentation, request, pResponse); // Process query params and do required operations ..
+        }
+    }
+    else if (requestFlag & RequestHandlerFlag::ObserverFlag)
+    {
+        // Check for query params (if any)
+        QueryParamsMap queryParamsMap = request->getQueryParameters();
+
+        handleObserveRequest(queryParamsMap, request, pResponse); // Process query params and do required operations ..
+    }
+}
+
+void ResourceServer::handleSlowResponse(std::shared_ptr< OCResourceRequest > request)
+{
+    cout << "Acting as Slow Resource...." << endl;
+    p_resourceHelper->waitInSecond(CALLBACK_WAIT_MAX);
+    cout << "Slow working period is over" << endl;
+
+    handleResponse(request);
+}
+
+void ResourceServer::setResponseTimeType(ResponseTimeType responseTimeType)
+{
+    m_responseTimeType = responseTimeType;
+}
+
+void ResourceServer::setAsSlowResource()
+{
+    m_responseTimeType = ResponseTimeType::SLOW;
+}
+
+void ResourceServer::setAsNormalResource()
+{
+    m_responseTimeType = ResponseTimeType::NORMAL;
+}
+
+bool ResourceServer::isObservableResource(void)
+{
+    return m_resourceProperty & OC_OBSERVABLE;
+}
+
+bool ResourceServer::isDiscoverableResource(void)
+{
+    return m_resourceProperty & OC_DISCOVERABLE;
+}
+
+std::vector< std::string > ResourceServer::getResourceInterfaces(void)
+{
+    return m_resourceInterfaces;
+}
+
+std::vector< std::string > ResourceServer::getResourceTypes(void)
+{
+    return m_resourceTypeNames;
+}
+
+void ResourceServer::setAsSecuredResource(void)
+{
+    m_resourceProperty = m_resourceProperty | OC_SECURE;
+}
+
+void ResourceServer::setAsDiscoverableResource(void)
+{
+    m_resourceProperty = m_resourceProperty | OC_DISCOVERABLE;
+}
+
+void ResourceServer::setAsObservableResource(void)
+{
+    m_resourceProperty = m_resourceProperty | OC_OBSERVABLE;
+}
+
+bool ResourceServer::isSecuredResource(void)
+{
+    return m_resourceProperty & OC_SECURE;
+}
+
+void ResourceServer::addResourceType(string resourceType)
+{
+    OCPlatform::bindTypeToResource(getResourceHandle(), resourceType);
+    m_resourceTypeNames.push_back(resourceType);
+}
+
+void ResourceServer::addResourceInterface(string resourceInterface)
+{
+    OCPlatform::bindInterfaceToResource(getResourceHandle(), resourceInterface);
+    m_resourceInterfaces.push_back(resourceInterface);
 }
\ No newline at end of file
diff --git a/test/src/common/commonutil/c_cpp/SampleCollection.cpp b/test/src/common/commonutil/c_cpp/SampleCollection.cpp
index dd9682e46..5de4bf010 100644
--- a/test/src/common/commonutil/c_cpp/SampleCollection.cpp
+++ b/test/src/common/commonutil/c_cpp/SampleCollection.cpp
@@ -30,14 +30,49 @@ SampleCollection::SampleCollection(void)
     m_isSecured = true;
     m_ipVer = CT_IP_USE_V4;
     m_collectionName = "";
-    m_listOfObservers.clear();
-    m_childResourceList.clear();
-    m_accessmodifier.clear();
 }
 
 SampleCollection::~SampleCollection(void)
 {
-    // child destructor
+    if (m_isResourceRunning)
+    {
+        stopResource();
+    }
+}
+
+OCStackResult SampleCollection::stopResource(void)
+{
+    OCStackResult result = OC_STACK_OK;
+
+    //check whether server is running
+    if (m_isResourceRunning == false)
+    {
+        result = OC_STACK_ERROR;
+        cerr << "Resource server is not started; Please start it before stopping " << endl;
+
+        return result;
+    }
+
+    //stop presence
+    if (m_isRegisteredForPresence)
+    {
+        OC_UNUSED(OCPlatform::stopPresence());
+    }
+
+    //stop server
+    result = OCPlatform::unregisterResource(m_resourceHandle);
+
+    if (result == OC_STACK_OK)
+    {
+        m_isResourceRunning = false;
+        m_childResources.clear();
+    }
+    else
+    {
+        cerr << "Unable to stop server" << endl;
+    }
+
+    return result;
 }
 
 void SampleCollection::handleObserveRequest(QueryParamsMap &queryParamsMap,
@@ -318,18 +353,18 @@ void SampleCollection::handleGetRequest(QueryParamsMap &queryParamsMap,
     epRep.setValue(EP_KEY, ep);
     epLiist.push_back(epRep);
     pRep.setValue(BITMASK_KEY, bm);
-    rep.setValue(URI_KEY, m_childResourceList[0]->getUri());
+    rep.setValue(URI_KEY, m_childResources[0]->getUri());
     rep.setValue(DEVICE_ID_KEY, m_di);
-    rep.setValue(RESOURCE_TYPE_KEY, m_childResourceList[0]->getResourceTypes());
-    rep.setValue(INTERFACE_KEY, m_childResourceList[0]->getResourceInterfaces());
+    rep.setValue(RESOURCE_TYPE_KEY, m_childResources[0]->getResourceTypes());
+    rep.setValue(INTERFACE_KEY, m_childResources[0]->getResourceInterfaces());
     rep.setValue(POLICY_KEY, pRep);
     rep.setValue(EPS_KEY, epLiist);
 
 //                addIntoLinksArray(allChildren, g_acSwitchResourceHidden);
 
-    for (unsigned int i = 1; i <  m_childResourceList.size(); i++)
+    for (unsigned int i = 1; i <  m_childResources.size(); i++)
     {
-        addIntoLinksArray(allChildren, m_childResourceList[i]);
+        addIntoLinksArray(allChildren, m_childResources[i]);
     }
 
     rep.setChildren(allChildren);
@@ -363,17 +398,17 @@ void SampleCollection::handleGetRequest(QueryParamsMap &queryParamsMap,
                 {
                     cout << "Responding to batch interface query" << endl;
                     OCRepresentation batchRep;
-                    batchRep.setValue(URI_KEY, m_childResourceList[0]->getUri());
+                    batchRep.setValue(URI_KEY, m_childResources[0]->getUri());
                     batchRep.setValue(REPRESENTATION_KEY,
-                            m_childResourceList[0]->getRepresentation());
+                            m_childResources[0]->getRepresentation());
 
                     OCRepresentation tempRep;
                     vector< OCRepresentation > tempRepList;
 
-                    for (unsigned int i = 1; i <  m_childResourceList.size(); i++)
+                    for (unsigned int i = 1; i <  m_childResources.size(); i++)
                     {
-                        tempRep.setValue(URI_KEY, m_childResourceList[i]->getUri());
-                        tempRep.setValue(REPRESENTATION_KEY, m_childResourceList[i]->getRepresentation());
+                        tempRep.setValue(URI_KEY, m_childResources[i]->getUri());
+                        tempRep.setValue(REPRESENTATION_KEY, m_childResources[i]->getRepresentation());
                         tempRepList.push_back(tempRep);
                     }
 
@@ -461,9 +496,9 @@ void SampleCollection::handleGetRequest(QueryParamsMap &queryParamsMap,
 void SampleCollection::setBaselineResponse(shared_ptr<OCResourceResponse> response)
 {
     vector< OCRepresentation > allLinks;
-    for (unsigned int i = 0; i <  m_childResourceList.size(); i++)
+    for (unsigned int i = 0; i <  m_childResources.size(); i++)
     {
-        addIntoLinksArray(allLinks, m_childResourceList[i]);
+        addIntoLinksArray(allLinks, m_childResources[i]);
     }
     OCRepresentation completeRep = m_representation;
     completeRep.setValue(LINKS_KEY, allLinks);
@@ -471,10 +506,10 @@ void SampleCollection::setBaselineResponse(shared_ptr<OCResourceResponse> respon
     completeRep.setResourceInterfaces(m_resourceInterfaces);
     completeRep.setResourceTypes(m_resourceTypeNames);
 
-    vector<string> allResourceTypes = m_childResourceList[0]->getResourceTypes();
-    for (unsigned int i = 1; i <  m_childResourceList.size(); i++)
+    vector<string> allResourceTypes = m_childResources[0]->getResourceTypes();
+    for (unsigned int i = 1; i <  m_childResources.size(); i++)
     {
-        vector<string> childResourceTypes = m_childResourceList[i]->getResourceTypes();
+        vector<string> childResourceTypes = m_childResources[i]->getResourceTypes();
         allResourceTypes.insert(allResourceTypes.end(), childResourceTypes.begin(), childResourceTypes.end());
     }
     completeRep.setValue("rts", allResourceTypes);
@@ -591,7 +626,7 @@ void SampleCollection::addChild(shared_ptr< SampleResource > childResource)
         if (expectedResult == OC_STACK_OK)
         {
             cout << "Joining to the group completed!!" << endl;
-            m_childResourceList.push_back(childResource);
+            m_childResources.push_back(childResource);
         }
         else
         {
@@ -623,7 +658,7 @@ bool SampleCollection::updateRepresentation(string key, OCRepresentation incomin
     if (key.compare(NAME_KEY) == 0)
     {
         string newDeviceName = incomingRep.getValueToString(key);
-        setDeviceInfo(newDeviceName);
+        OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, newDeviceName.c_str());
     }
     if (rep.getAttributeValue(configurationKey, configurationValue))
     {
@@ -741,7 +776,7 @@ void SampleCollection::addIntoLinksArray(vector< OCRepresentation >& childrenLis
 vector< shared_ptr< SampleResource > > SampleCollection::getChildResourcesFromType(string resourceType)
 {
     vector< shared_ptr< SampleResource > > matchedChildren;
-    for (shared_ptr< SampleResource > child : m_childResourceList )
+    for (shared_ptr< SampleResource > child : m_childResources )
     {
         for (string currentResourceType : child->getResourceTypes())
         {
@@ -760,7 +795,7 @@ vector< shared_ptr< SampleResource > > SampleCollection::getChildResourcesFromTy
 vector< shared_ptr< SampleResource > > SampleCollection::getChildResourcesFromRepKey(string key)
 {
     vector< shared_ptr< SampleResource > > matchedChildren;
-    for (shared_ptr< SampleResource > child : m_childResourceList )
+    for (shared_ptr< SampleResource > child : m_childResources )
     {
         OCRepresentation rep = child->getRepresentation();
         if (rep.hasAttribute(key))
diff --git a/test/src/common/commonutil/c_cpp/SampleResource.cpp b/test/src/common/commonutil/c_cpp/SampleResource.cpp
index a6282359e..b701ab200 100644
--- a/test/src/common/commonutil/c_cpp/SampleResource.cpp
+++ b/test/src/common/commonutil/c_cpp/SampleResource.cpp
@@ -86,7 +86,45 @@ SampleResource::SampleResource(std::string resourceUri,
 
 SampleResource::~SampleResource(void)
 {
-    // child destructor
+    if (m_isResourceRunning)
+    {
+        stopResource();
+    }
+}
+
+OCStackResult SampleResource::stopResource(void)
+{
+    OCStackResult result = OC_STACK_OK;
+
+    //check whether server is running
+    if (m_isResourceRunning == false)
+    {
+        result = OC_STACK_ERROR;
+        cerr << "Resource server is not started; Please start it before stopping " << endl;
+
+        return result;
+    }
+
+    //stop presence
+    if (m_isRegisteredForPresence)
+    {
+        OC_UNUSED(OCPlatform::stopPresence());
+    }
+
+    //stop server
+    result = OCPlatform::unregisterResource(m_resourceHandle);
+
+
+    if (result == OC_STACK_OK)
+    {
+        m_isResourceRunning = false;
+    }
+    else
+    {
+        cerr << "Unable to stop server" << endl;
+    }
+
+    return result;
 }
 
 void SampleResource::handleObserveRequest(QueryParamsMap &queryParamsMap,
@@ -633,7 +671,6 @@ void SampleResource::onResourceServerStarted(bool &isRegisteredForPresence, int
     cout << "Inside onResourceServerStarted... " << endl;
     isRegisteredForPresence = false;
     presenceInterval = PRESENCE_INTERVAL;
-
 }
 
 void SampleResource::handleInitRequest(QueryParamsMap &queryParamsMap,
@@ -759,7 +796,7 @@ bool SampleResource::updateRepresentation(string key, OCRepresentation incomingR
     if (key.compare(NAME_KEY) == 0)
     {
         string newDeviceName = incomingRep.getValueToString(key);
-        setDeviceInfo(newDeviceName);
+        OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, newDeviceName.c_str());
     }
     if (rep.getAttributeValue(configurationKey, configurationValue))
     {
@@ -944,7 +981,6 @@ void SampleResource::createResource(string initialUri, OCRepresentation incoming
             {
                 newResource = new SampleResource();
                 if(!newResource) return;
-                m_childResourceList.push_back(newResource);
                 cout << "constructor called!!" << endl;
                 result = (OCStackResult) ((int) result
                         + (int) newResource->setResourceProperties(resourceUri, resourceType,
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/include/HttpResources.h b/test/src/testapp/IUTSimulatorApp/c_cpp/include/HttpResources.h
new file mode 100644
index 000000000..b3172da4e
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/include/HttpResources.h
@@ -0,0 +1,48 @@
+#ifndef HTTP_RESOURCES_H
+#define HTTP_RESOURCES_H
+
+#include <string>
+#include <vector>
+#include <set>
+#include <condition_variable>
+#include <mutex>
+
+class HttpResources
+{
+private:
+    static std::vector< std::pair<std::string, std::string> > discoveryEndpoints;
+    static std::string state;
+    static std::string pinCode;
+
+    static std::condition_variable discoveryEndpointsConditionalVariable;
+    static std::mutex discoveryEndpointsMutex;
+
+    static std::condition_variable stateConditionalVariable;
+    static std::mutex stateMutex;
+
+    static bool discoveryEndpointsReady;
+    static bool isDiscoveryEndpointAvaliable();
+
+    static bool isStateAvaliable();
+
+public:
+    HttpResources() = delete;
+
+    static void setDiscoveryEndpointsToReady();
+
+    static void clearDiscoveryEndpoints();
+
+    static void addDiscoveryEndpoint(std::pair<std::string, std::string> state);
+
+    static std::vector< std::pair<std::string, std::string> > getDiscoveryEndpoints();
+
+    static void setState(std::string state);
+
+    static std::string getState();
+
+    static void setPinCode(std::string pinCode);
+
+    static std::string getPinCode();
+};
+
+#endif // HTTP_RESOURCES_H
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/include/IUTSimulatorUtils.h b/test/src/testapp/IUTSimulatorApp/c_cpp/include/IUTSimulatorUtils.h
index 7d3600618..51d11cbf0 100644
--- a/test/src/testapp/IUTSimulatorApp/c_cpp/include/IUTSimulatorUtils.h
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/include/IUTSimulatorUtils.h
@@ -20,17 +20,9 @@
 
 #include <iostream>
 #include <string>
-#include <sstream>
+
 #include <vector>
 #include <memory>
-#include <initializer_list>
-
-#ifdef __LINUX__
-#include <arpa/inet.h>
-#endif
-#ifdef __WINDOWS__
-#include <winsock2.h>
-#endif
 
 #include "ResourceHelper.h"
 #include "SampleResource.h"
@@ -43,7 +35,7 @@ class IUTSimulatorUtils
 public:
     IUTSimulatorUtils() = delete;
 
-    static int getSelectionFromUser(std::string what, int min, int max);
+    static int getSelectionFromUser(std::string context, std::string what, int min, int max);
 
     static std::shared_ptr< OCResource > getResourceFromUser(std::vector< std::shared_ptr< OCResource > > resources);
 
@@ -53,83 +45,22 @@ public:
 
     static std::shared_ptr< SampleResource > getResourceByURI(std::vector< std::shared_ptr< SampleResource > > resources, std::string resourceType);
 
+    static std::vector< std::shared_ptr< OCResource > > getResourcesWithResourceTypes(std::vector< std::shared_ptr< OCResource > > resources, std::vector< std::string> resourceTypes);
+
+    static bool isResourceInList(std::vector< std::shared_ptr< OCResource > > resources, std::shared_ptr< OCResource > resourceToCheck);
+
+    static QueryParamsMap getResourceInterfaceQueryFromUser(std::shared_ptr< OCResource > resource);
+
     static AttributeValue getAttributeValueFromUser();
 
-    static void setResourceHostEndpointFromUser(std::shared_ptr< OCResource > resource, bool isSecuredClient);
+    static void setResourceHostEndpointFromUser(std::shared_ptr< OCResource > resource);
 
-    static bool isValidIpAddress(std::string ipAddress, OCConnectivityType ipVersion);
+    static std::string getEndpointFromUser();
 
-    static std::string toLower(std::string str);
+    static bool isValidIpAddress(std::string ipAddress);
 
-    static OCRepresentation createRepresentation(std::vector< std::pair<std::string, AttributeValue> > keysValues  = {});
+    static bool isPortValid(std::string port);
 
+    static OCRepresentation createRepresentation(std::vector< std::pair<std::string, AttributeValue> > keysValues  = {});
 
-    template <class T>
-    static void printInput(T input)
-    {
-        time_t t = time(0);
-        struct tm *now = localtime(&t);
-
-        char time_str [150];
-        strftime(time_str, 150, "%Y-%m-%d-%H-%M-%S: ", now);
-        std::cout << time_str << "Recived input: " << input << std::endl;
-    }
-
-    template <class T>
-    static void getInputFromUser(T &input)
-    {
-        std::string userInput = "";
-
-        getline(std::cin, userInput);
-        while(!(stringstream(userInput) >> input))
-        {
-            if (userInput.empty())
-            {
-            }
-            else if (input <= std::numeric_limits<T>::min() || input >= std::numeric_limits<T>::max())
-            {
-                printInput(userInput);
-                std::cout << "This number is out of allowed scope!" << std::endl;
-            }
-            else
-            {
-                printInput(userInput);
-                std::cout << "Wrong type of input, should be number!" << std::endl;
-            }
-            userInput = "";
-            getline(std::cin, userInput);
-        }
-
-        printInput(input);
-    }
-
-    template <class T>
-    static T getInputFromUser()
-    {
-        T inputValue;
-        std::string userInput = "";
-
-        getline(std::cin, userInput);
-        while(!(stringstream(userInput) >> inputValue))
-        {
-            if (userInput.empty())
-            {
-            }
-            else if (inputValue <= std::numeric_limits<T>::min() || inputValue >= std::numeric_limits<T>::max())
-            {
-                printInput(userInput);
-                std::cout << "This number is out of allowed scope!" << std::endl;
-            }
-            else
-            {
-                printInput(userInput);
-                std::cout << "Wrong type of argument, should be number!" << std::endl;
-            }
-            userInput = "";
-            getline(std::cin, userInput);
-        }
-
-        printInput(inputValue);
-        return inputValue;
-    }
 };
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/include/InputHandler.h b/test/src/testapp/IUTSimulatorApp/c_cpp/include/InputHandler.h
new file mode 100644
index 000000000..4275557f1
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/include/InputHandler.h
@@ -0,0 +1,164 @@
+/******************************************************************
+*
+* Copyright 2018 Open Connectivity Foundation All Rights Reserved.
+*
+*
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*
+******************************************************************/
+
+#include <iostream>
+#include <string>
+#include <sstream>
+#include <queue>
+#include <condition_variable>
+#include <mutex>
+
+#include <HttpResources.h>
+
+class InputHandler
+{
+
+private:
+
+    static std::queue< std::string > inputSequence;
+
+    static std::condition_variable inputConditionalVariable;
+    static std::mutex inputMutex;
+
+    static std::string response;
+    static bool responseAvaliable;
+    static std::condition_variable responseConditionalVariable;
+    static std::mutex responseMutex;
+
+    static bool inputAvaliable();
+
+    static bool isResponseAvaliable();
+    static void releaseResponse();
+
+    static void extract(std::string& input);
+
+    static std::string toLower(std::string str);
+
+public:
+    enum class ResponseType
+    {
+        Error,
+        Info
+    };
+
+    static void setResponse(ResponseType responseType, std::string response);
+    static std::string getResponse();
+
+    static void insert(std::string output);
+
+    template <class T>
+    static void printInput(T input)
+    {
+        time_t t = time(0);
+        struct tm *now = localtime(&t);
+
+        char time_str [150];
+        strftime(time_str, 150, "%Y-%m-%d-%H-%M-%S: ", now);
+        std::cout << time_str << "Recived input: " << input << std::endl;
+    }
+
+    template <class T>
+    static void getInputFromUser(T &input, const std::string& context)
+    {
+        HttpResources::setState(context);
+        if (response.empty())
+        {
+            setResponse(InputHandler::ResponseType::Info, context);
+            releaseResponse();
+        }
+        else
+        {
+            releaseResponse();
+            std::cout << context << std::endl;
+        }
+
+        std::string textInput = "";
+        extract(textInput);
+
+        while(!(std::stringstream(textInput) >> input))
+        {
+            if (textInput.empty())
+            {
+                setResponse(InputHandler::ResponseType::Info, context);
+            }
+            else if (input <= std::numeric_limits<T>::min() || input >= std::numeric_limits<T>::max())
+            {
+                printInput(textInput);
+                setResponse(InputHandler::ResponseType::Error, "This number is out of allowed scope!");
+            }
+            else
+            {
+                printInput(textInput);
+                setResponse(InputHandler::ResponseType::Error, "Wrong type of input, should be number!");
+            }
+
+            releaseResponse();
+            extract(textInput);
+        }
+
+        HttpResources::setState("");
+        printInput(input);
+    }
+
+    template <class T>
+    static T getInputFromUser(const std::string& context)
+    {
+        HttpResources::setState(context);
+        if (response.empty())
+        {
+            setResponse(InputHandler::ResponseType::Info, context);
+            releaseResponse();
+        }
+        else
+        {
+            releaseResponse();
+            std::cout << context << std::endl;
+        }
+
+        T input;
+        std::string textInput;
+        extract(textInput);
+
+        while(!(std::stringstream(textInput) >> input))
+        {
+            if (textInput.empty())
+            {
+                setResponse(InputHandler::ResponseType::Info, context);
+            }
+            else if (input <= std::numeric_limits<T>::min() || input >= std::numeric_limits<T>::max())
+            {
+                printInput(textInput);
+                setResponse(InputHandler::ResponseType::Error, "This number is out of allowed scope!");
+            }
+            else
+            {
+                printInput(textInput);
+                setResponse(InputHandler::ResponseType::Error, "Wrong type of argument, should be number!");
+            }
+
+            releaseResponse();
+            extract(textInput);
+        }
+
+        HttpResources::setState("");
+        printInput(input);
+        return input;
+    }
+};
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Connection.hpp b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Connection.hpp
new file mode 100644
index 000000000..d0abe28f8
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Connection.hpp
@@ -0,0 +1,48 @@
+#ifndef HTTP_CONNECTION_HPP
+#define HTTP_CONNECTION_HPP
+
+#include <array>
+
+#include <boost/asio.hpp>
+
+#include "Request.hpp"
+#include "Response.hpp"
+
+
+namespace http {
+
+class ConnectionManager;
+
+class Connection
+    : public std::enable_shared_from_this< Connection >
+{
+public:
+    Connection(const Connection&) = delete;
+    Connection& operator=(const Connection&) = delete;
+
+    explicit Connection(boost::asio::ip::tcp::socket socket, ConnectionManager& manager, void (*requestHandler)(const Request&, Response&));
+
+    void start();
+
+    void stop();
+
+private:
+
+    boost::asio::ip::tcp::socket socket;
+
+    ConnectionManager& connectionManager;
+
+    std::array<char, Request::MAX_REQUEST_SIZE> requestBuffer;
+
+    Response response;
+
+    void (*requestHandler)(const Request&, Response&);
+
+    void read();
+
+    void write();
+};
+
+} // namespace http
+
+#endif // HTTP_CONNECTION_HPP
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/ConnectionManager.hpp b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/ConnectionManager.hpp
new file mode 100644
index 000000000..c2139df66
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/ConnectionManager.hpp
@@ -0,0 +1,33 @@
+#ifndef HTTP_CONNECTION_MANAGER_HPP
+#define HTTP_CONNECTION_MANAGER_HPP
+
+#include <set>
+
+#include "Connection.hpp"
+
+namespace http {
+
+class ConnectionManager
+{
+public:
+    ConnectionManager(const ConnectionManager&) = delete;
+    ConnectionManager& operator=(const ConnectionManager&) = delete;
+
+    ConnectionManager();
+
+    void start(std::shared_ptr< Connection > connection);
+
+
+    void stop(std::shared_ptr< Connection > connection);
+
+
+    void stopAll();
+
+private:
+
+    std::set< std::shared_ptr< Connection > > connections;
+};
+
+} // namespace http
+
+#endif // HTTP_CONNECTION_MANAGER_HPP
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/RequestParser.hpp b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/RequestParser.hpp
new file mode 100644
index 000000000..4b5296ed9
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/RequestParser.hpp
@@ -0,0 +1,34 @@
+#ifndef HTTP_REQUEST_PARSER_HPP
+#define HTTP_REQUEST_PARSER_HPP
+
+#include <string>
+#include <vector>
+
+#include "Request.hpp"
+
+namespace http {
+
+class RequestParser
+{
+public:
+    static bool parse(Request& request, std::array<char, Request::MAX_REQUEST_SIZE>::const_iterator requestBegin, std::array<char, Request::MAX_REQUEST_SIZE>::const_iterator requestEnd);
+
+private:
+    const static std::string FIRST_LINE_END;
+    const static std::string HEADERS_END;
+
+    static bool parseBody(Request& request, std::string body);
+    static bool parseHeaders(Request& request, std::string headers);
+    static bool parseFirstLine(Request& request, std::string firstLine);
+    static bool checkMethod(std::string method);
+    static bool checkHttpVersion(std::string httpVersion);
+    static bool checkUrl(std::string url);
+
+    static std::string toUpper(std::string text);
+    static std::vector<std::string> split(const std::string &text, char delimiter);
+
+};
+
+} // namespace http
+
+#endif // HTTP_REQUEST_PARSER_HPP
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Response.hpp b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Response.hpp
new file mode 100644
index 000000000..0a3fdcc5a
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Response.hpp
@@ -0,0 +1,41 @@
+#ifndef HTTP_RESPONSE_HPP
+#define HTTP_RESPONSE_HPP
+
+#include <string>
+#include <map>
+
+namespace http {
+
+struct Response
+{
+    enum class StatusCode
+    {
+        OK = 200,
+        NoContent = 204,
+        BadRequest = 400,
+        Forbidden = 403,
+        NotFound = 404,
+        ServiceUnavailable = 503
+    };
+
+    std::string version = "HTTP/1.1";
+    StatusCode status;
+    std::map<std::string, std::string> headers;
+    std::string body;
+
+    std::string toBuffer();
+
+    static Response generateResponse(StatusCode code);
+
+    static Response generateResponse(StatusCode code, std::string body);
+
+private:
+
+    static std::string getStatusText(StatusCode code);
+
+    static std::string toString(StatusCode code);
+};
+
+} // namespace http
+
+#endif // HTTP_RESPONSE_HPP
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Server.hpp b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Server.hpp
new file mode 100644
index 000000000..ff9589d68
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/include/http/Server.hpp
@@ -0,0 +1,43 @@
+#ifndef HTTP_SERVER_HPP
+#define HTTP_SERVER_HPP
+
+#include <string>
+
+#include <boost/asio.hpp>
+
+#include "Connection.hpp"
+#include "ConnectionManager.hpp"
+
+namespace http {
+
+class Server
+{
+public:
+    Server(const Server&) = delete;
+    Server& operator=(const Server&) = delete;
+
+    Server(const std::string& address, const std::string& port, void (*requestHandler)(const Request&, Response&));
+
+    ~Server();
+
+    void run();
+
+private:
+
+    boost::asio::io_service io_service;
+
+    boost::asio::ip::tcp::acceptor acceptor;
+
+    ConnectionManager connectionManager;
+
+    boost::asio::ip::tcp::socket socket;
+
+    void (*requestHandler)(const Request&, Response&);
+
+    void accept();
+
+};
+
+} // namespace http
+
+#endif // HTTP_SERVER_HPP
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/HttpResources.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/HttpResources.cpp
new file mode 100644
index 000000000..9befdfd06
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/HttpResources.cpp
@@ -0,0 +1,84 @@
+#include <HttpResources.h>
+
+#include <unistd.h>
+#include <chrono>
+#include <thread>
+#include <iostream>
+std::vector< std::pair<std::string, std::string> >  HttpResources::discoveryEndpoints;
+std::string HttpResources::state;
+std::string HttpResources::pinCode;
+
+bool HttpResources::discoveryEndpointsReady;
+
+std::condition_variable HttpResources::discoveryEndpointsConditionalVariable;
+std::mutex HttpResources::discoveryEndpointsMutex;
+
+std::condition_variable HttpResources::stateConditionalVariable;
+std::mutex HttpResources::stateMutex;
+
+void HttpResources::clearDiscoveryEndpoints()
+{
+    std::lock_guard<std::mutex> guard(discoveryEndpointsMutex);
+
+    HttpResources::discoveryEndpoints.clear();
+    discoveryEndpointsReady = false;
+
+    discoveryEndpointsConditionalVariable.notify_one();
+}
+
+void HttpResources::addDiscoveryEndpoint(std::pair<std::string, std::string> discoveryEndpoint)
+{
+    HttpResources::discoveryEndpoints.push_back(discoveryEndpoint);
+}
+
+void HttpResources::setDiscoveryEndpointsToReady()
+{
+    std::lock_guard<std::mutex> guard(discoveryEndpointsMutex);
+    discoveryEndpointsReady = true;
+    discoveryEndpointsConditionalVariable.notify_one();
+}
+
+bool HttpResources::isDiscoveryEndpointAvaliable()
+{
+    return discoveryEndpointsReady;
+}
+
+std::vector< std::pair<std::string, std::string> > HttpResources::getDiscoveryEndpoints()
+{
+    std::unique_lock<std::mutex> lock(discoveryEndpointsMutex);
+    discoveryEndpointsConditionalVariable.wait(lock, isDiscoveryEndpointAvaliable);
+
+    return discoveryEndpoints;
+}
+
+void HttpResources::setState(std::string state)
+{
+    std::lock_guard<std::mutex> guard(stateMutex);
+
+    HttpResources::state = state;
+
+    stateConditionalVariable.notify_one();
+}
+
+bool HttpResources::isStateAvaliable()
+{
+    return !state.empty();
+}
+
+std::string HttpResources::getState()
+{
+    std::unique_lock<std::mutex> lock(stateMutex);
+    stateConditionalVariable.wait(lock, isStateAvaliable);
+
+    return state;
+}
+
+void HttpResources::setPinCode(std::string pinCode)
+{
+    HttpResources::pinCode = pinCode;
+}
+
+std::string HttpResources::getPinCode()
+{
+    return pinCode;
+}
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulator.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulator.cpp
index f01a5865e..1c3031f54 100644
--- a/test/src/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulator.cpp
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulator.cpp
@@ -31,10 +31,6 @@
 #include <execinfo.h>
 #endif
 
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
 #include <signal.h>
 #include <stdlib.h>
 
@@ -47,6 +43,8 @@
 
 #include "experimental/logger.h"
 
+#include "InputHandler.h"
+#include "HttpResources.h"
 #include "IUTSimulatorUtils.h"
 #include "SampleResource.h"
 #include "MntResource.h"
@@ -63,6 +61,7 @@
 #include "OCApi.h"
 #include "pinoxmcommon.h"
 #include "cautilinterface.h"
+#include "doxmresource.h"
 #include "cacommon.h"
 #include "oic_malloc.h"
 
@@ -70,6 +69,8 @@
 #include "escommon.h"
 #include "ESEnrolleeCommon.h"
 
+#include <boost/program_options.hpp>
+
 #ifdef HAVE_WINDOWS_H
 #ifndef WIN32_LEAN_AND_MEAN
 #define WIN32_LEAN_AND_MEAN
@@ -85,6 +86,8 @@
 #include "RDClient.h"
 #include "rd_server.h"
 
+#include "Server.hpp"
+
 using namespace OC;
 using namespace std;
 
@@ -98,44 +101,17 @@ static const WIFI_AUTHTYPE WES_ENROLLER_AUTH_TYPE = WPA2_PSK;
 static const WIFI_ENCTYPE WES_ENROLLER_ENC_TYPE = AES;
 ///////////
 
-vector< shared_ptr< SampleResource > > g_createdResourceList;
-vector< shared_ptr< OCResource > > g_foundResourceList;
-vector< shared_ptr< OCResource > > g_foundCollectionList;
-shared_ptr< OCResource > g_introspectionResource;
-vector< string> g_rdServerHosts;
-vector< OCResourceHandle > g_handleList;
-OCResourceHandle g_childHandle = NULL;
-OCResourceHandle g_collectionHandle = NULL;
-OCRepresentation g_resourceRepresentation;
-OCConnectivityType g_ipVer = CT_DEFAULT;
-string g_ocfVer = "ocf.1.0.0";
-
-SampleCollection *g_extraLightCollection;
-SampleCollection *g_vendorCollectionResource;
-SampleCollection *g_sampleCollection;
+static const char CRED_FILE_SERVER[] = "oic_svr_db_server.dat";
+static const char CRED_FILE_CLIENT[] = "oic_svr_db_client.dat";
+static const char INTROSPECTION_SWAGGER_FILE[] = "introspection_swagger.dat";
+static const char SECURITY_FILE_JW[] = "../../oic_svr_db_server_justworks.dat";
+static const char SECURITY_FILE_RDP[] = "../../oic_svr_db_server_randompin.dat";
+static const char SECURITY_FILE_MFG[] = "../../oic_svr_db_server_mfg.dat" ;
 
 #define MAXLEN_STRING 100
-#define DEFAULT_HANDLER true
 #define USERPROPERTY_KEY_INT "x.user.property.int"
 #define USERPROPERTY_KEY_STR "x.user.property.str"
 
-bool g_hasCallbackArrived = false;
-bool g_isObservingResource = false;
-bool g_isGroupCreated = false;
-bool g_isSampleCollectionCreated = false;
-bool g_isExtraDeviceCreated = false;
-bool g_isSecuredClient = false;
-bool g_isSecuredServer = false;
-bool g_retainOldDB = false;
-bool isDeviceTypeSet = false;
-
-std::ofstream g_RDPPINLogFileStream;
-int g_RDPPINSeqNumber = 0;
-
-QualityOfService g_qos = QualityOfService::LowQos;
-ResourceHelper *g_resourceHelper;
-ESProvisioningCallbacks g_esCallbacks;
-
 typedef struct UserProperties_t
 {
     int userValue_int;  /**< User-specific property in WiFi resource **/
@@ -144,33 +120,60 @@ typedef struct UserProperties_t
 
 UserProperties g_userProperties;
 
+enum class IoTivityServerState
+{
+    CONTINUE,
+    RESET,
+    EXIT
+};
+
+struct IUTInfo
+{
+    enum class Mode {CLIENT, SERVER};
+    enum class SecurityType {JW, RDP, MFG, REUSE};
+
+    std::string httpServerIP;
+    std::string httpServerPort;
+
+    std::string deviceName;
+    std::vector<std::string> deviceTypes;
+    Mode mode;
+    SecurityType securityType;
+    std::string ocfVersion;
+    std::vector<int> startOptions;
+};
+
+IUTInfo g_IUTInfo;
+
+std::vector< std::shared_ptr< SampleResource > > g_createdResourceList;
+std::vector< std::shared_ptr< OCResource > > g_foundResourceList;
+
+SampleCollection *g_extraLightCollection;
+SampleCollection *g_sampleCollection;
+
+bool g_isDiscoveryAddressFound = false;
+bool g_areResourcesFound = false;
+bool g_hasResourceCallbackArrived = false;
+bool g_hasPlatformInfoCallbackArrived = false;
+bool g_hasDeviceInfoCallbackArrived = false;
+bool g_isSampleCollectionCreated = false;
+bool g_isExtraDeviceCreated = false;
+
+ESProvisioningCallbacks g_esCallbacks;
+
 static mutex s_mutex;
-static const char CRED_FILE_SERVER[] = "oic_svr_db_server.dat";
-static const char CRED_FILE_CLIENT[] = "oic_svr_db_client.dat";
-static const char INTROSPECTION_SWAGGER_FILE[] = "introspection_swagger.dat";
-static const string JUST_WORKS_DI = "12345678-1234-1234-1234-123456789012";
-static const string RANDOM_PIN_DI = "87654321-4321-4321-4321-CBA987654321";
-static const string MFG_DI = "4d617566-6163-7475-7265-724365727430";
-static const int CLIENT_MODE = 1;
-static const int SERVER_MODE = 2;
-static int g_modeType;
-static int g_securityType;
-static const char sourceFileNames[][100] =
-{ "None", "../../oic_svr_db_server_justworks.dat", "../../oic_svr_db_server_randompin.dat",
-        "../../oic_svr_db_server_mfg.dat" };
-string g_di = "";
-string g_collectionName = GROUP_NAME;
 
-void onObserve(const HeaderOptions headerOptions, const OCRepresentation &rep, const int &eCode,
-        const int &sequenceNumber);
-void onDelete(const HeaderOptions &headerOptions, const int eCode);
-void onPost(const HeaderOptions &headerOptions, const OCRepresentation &rep, const int eCode);
-void onPut(const HeaderOptions &headerOptions, const OCRepresentation &rep, const int eCode);
 void onGet(const HeaderOptions &headerOptions, const OCRepresentation &rep, const int eCode);
+void onPost(const HeaderOptions &headerOptions, const OCRepresentation &rep, const int eCode);
+void onObserve(const HeaderOptions headerOptions, const OCRepresentation &rep, const int &eCode, const int &sequenceNumber);
+void onDelete(const HeaderOptions &headerOptions, const int eCode);
+
 void onDeviceInfoReceived(const OCRepresentation& rep);
 void onPlatformInfoReceived(const OCRepresentation& rep);
-void onCollectionFound(shared_ptr< OCResource > collection);
-void onResourceFound(shared_ptr< OCResource > resource);
+
+void onResourceListFound(std::vector< std::shared_ptr< OCResource > > resources);
+
+void onGeneratePin(char* pin, size_t pinSize);
 
 void onDevConfProvReceived(ESDevConfData *eventData);
 void onWiFiConfProvReceived(ESWiFiConfData *eventData);
@@ -178,105 +181,142 @@ void onWiFiConfProvReceived(ESWiFiConfData *eventData);
 void onResourceRemoved(const int& eCode);
 void onResourcePublished(const OCRepresentation& rep, const int& eCode);
 
-void handleMenu(int argc, char* argv[]);
-void showMenu(int argc, char* argv[]);
-void selectMenu(int choice);
-void createTvDevice(bool secured = false);
-void createAirConDevice(bool secured = false);
-void createExtraDevice(bool secured = false);
-void createSingleAirConResource(bool secured = false);
-void createResourceForIntrospection(bool secured = false);
-void createVendorDefinedDevice(bool secured = false);
-void createResource(void);
-void createSecuredResource(void);
-void createInvisibleResource(void);
-void createResourceWithUrl(void);
-void createManyLightResources(void);
-void publishResourcesToRD(void);
-void updateResourcesToRD(void);
-void deleteResourcesFromRD(void);
-void deleteCreatedResource(void);
-void findCollection(string);
-void findResource(string resourceType, string host = "");
-void findAllResources(string host = "", string query = "");
-void discoverIntrospection(bool isMulticast = true);
-void discoverDevice(bool);
-void discoverPlatform(bool isMulticast = true);
-void sendGetRequest();
-void sendGetRequestWithQuery(string, string);
-void sendPutRequestUpdate(void);
-void sendPostRequestUpdate(void);
-void sendPostRequestUpdateUserInput(void);
-void sendPutRequestCreate(void);
-void sendPostRequestCreate(void);
-void sendDeleteRequest(void);
-void waitForCallback(void);
-void observeResource(void);
-void cancelObserveResource(void);
-void cancelObservePassively(void);
-void createGroup(string);
-void deleteGroup(void);
-void updateGroup(void);
-void updateLocalResource(void);
-void prepareForWES(void);
+void signalHandler(int signal);
+void parseArguments(int argc, char* argv[]);
+void userInputThread();
+void httpServerThread(const std::string ip, const std::string port);
+IoTivityServerState startIoTivityServer(
+    IUTInfo::Mode mode,
+    IUTInfo::SecurityType securityType,
+    std::string ocfVersion,
+    std::string deviceName,
+    std::vector<std::string> deviceTypes);
+void stopIoTivityServer();
+std::string mainMenu();
+IoTivityServerState selectMenu();
+void resetSecurityDatabase(IUTInfo::Mode mode, IUTInfo::SecurityType securityType);
+
+bool startResource(const std::shared_ptr<SampleResource>& resource);
+std::shared_ptr< SampleResource > startResource(
+    const std::string& resourceUri,
+    const std::string& resourceType,
+    const std::string& resourceInterface,
+    const uint8_t& resourceProperty,
+    const ResponseTimeType& responseTimeType = ResponseTimeType::NORMAL,
+    const HandlerType& handlerType = HandlerType::SAMPLE);
+std::shared_ptr< SampleResource > startResource(
+    const std::string& resourceUri,
+    const std::string& resourceType,
+    const std::string& resourceInterface,
+    const uint8_t& resourceProperty,
+    const HandlerType& handlerType);
+std::shared_ptr< SampleResource > startResource(
+    const std::string& resourceUri,
+    const std::string& resourceType,
+    const uint8_t& resourceProperty,
+    const ResponseTimeType& responseTimeType = ResponseTimeType::NORMAL,
+    const HandlerType& handlerType = HandlerType::SAMPLE);
+std::shared_ptr< SampleResource > startResource(
+    const std::string& resourceUri,
+    const std::string& resourceType,
+    const uint8_t& resourceProperty,
+    const HandlerType& handlerType);
+
+void createSampleCollection(bool secured);
+void createResourcesForTvDevice(bool secured);
+void createAirConResources_Type1(bool secured);
+void createAirConResources_Type2(bool secured);
+void createAirConResources_Type3(bool secured);
+void createExtraDevice(bool secured);
+void createManyLightResources(bool secured);
+
+void publishResourcesToRD();
+void deleteResourcesFromRD();
+
+void sendDiscoveryRequest(QualityOfService qualityOfService);
+
+void showDeviceInfo(void);
+void showPlatformInfo(void);
+
+void sendGetRequest(QualityOfService qualityOfService);
+void sendPostRequest(QualityOfService qualityOfService);
+void sendDeleteRequest(QualityOfService qualityOfService);
+void sendObserveRequest(QualityOfService qualityOfService);
+void sendCancelObserveRequest(QualityOfService qualityOfService);
+
+void updateCreatedResource(void);
+
+void prepareForWES(bool secured);
 void setDeviceWESInfo(void);
 void SetUserProperties(const UserProperties *prop);
 void ReadUserdataCb(OCRepPayload* payload,char* resourceType, void** userdata);
 void WriteUserdataCb(OCRepPayload* payload,char* resourceType);
 void SetCallbackForUserdata(void);
-string getHost();
+void updateLec(void);
+
 FILE* server_fopen(const char*, const char*);
 FILE* client_fopen(const char*, const char*);
-void updateLec(void);
-void openRDPLogFile(void);
-void closeRDPLogFile(void);
 
-uint8_t isSecure(bool secured)
+void waitForCallback(bool& callbackArrived);
+
+uint8_t isSecured(bool secured)
 {
     if (secured) return OC_SECURE;
     else return 0;
 }
 
-void openRDPLogFile()
+int main(int argc, char* argv[])
 {
-    time_t t = time(0);
-    struct tm *now = localtime(&t);
-
-    char time_str [150];
-    strftime(time_str, 150, "%Y-%m-%d-%H-%M-%S.log", now);
+    signal(SIGSEGV, signalHandler);
 
-    std::string file_name = "iut_RDP_PIN_tracker_log_";
-    file_name = file_name + time_str;
+    parseArguments(argc, argv);
 
-    g_RDPPINLogFileStream.open(file_name.c_str());
+    std::thread getUserInputs(userInputThread);
+    getUserInputs.detach();
 
-    if(g_RDPPINLogFileStream.is_open())
+    if (!g_IUTInfo.httpServerIP.empty() && !g_IUTInfo.httpServerPort.empty())
     {
-         std::cout << "Success to create g_RDPPINLogFileStream" << std::endl;
+        std::thread httpServer(httpServerThread, g_IUTInfo.httpServerIP, g_IUTInfo.httpServerPort);
+        httpServer.detach();
     }
 
-    g_RDPPINLogFileStream << "Start Time:" << time_str << std::endl;
-    g_RDPPINLogFileStream << "===================================" << std::endl;
-}
+    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
 
-void closeRDPLogFile()
-{
-    g_RDPPINLogFileStream.close();
-}
+    IoTivityServerState serverState = startIoTivityServer(
+        g_IUTInfo.mode,
+        g_IUTInfo.securityType,
+        g_IUTInfo.ocfVersion,
+        g_IUTInfo.deviceName,
+        g_IUTInfo.deviceTypes
+    );
 
-std::string getTimeNow()
-{
-    time_t t = time(0);
-    struct tm *now = localtime(&t);
+    while(serverState != IoTivityServerState::EXIT)
+    {
+        serverState = selectMenu();
+
+        if (serverState == IoTivityServerState::RESET)
+        {
+            std::cout << "Restarting IUT..." << std::endl;
+            stopIoTivityServer();
+            serverState = startIoTivityServer(
+                g_IUTInfo.mode,
+                g_IUTInfo.securityType,
+                g_IUTInfo.ocfVersion,
+                g_IUTInfo.deviceName,
+                g_IUTInfo.deviceTypes
+            );
+        }
+    }
+
+    stopIoTivityServer();
 
-    char time_str [150];
-    strftime(time_str, 150, "[%Y-%m-%d-%H-%M-%S]", now);
+    std::cout << "Iotivity Server stopped successfully" << std::endl;
+    std::cout << "Quitting IUT Simulator App.... Done!!" << std::endl;
 
-    std::string currTimeStr(time_str);
-    return currTimeStr;
+    return 0;
 }
 
-void handler(int sig)
+void signalHandler(int signal)
 {
     void *array[10];
     size_t size;
@@ -287,7 +327,7 @@ void handler(int sig)
 #endif
 
     // print out all the frames to stderr
-    fprintf(stderr, "Error: signal %d:\n", sig);
+    fprintf(stderr, "Error: signal %d:\n", signal);
 
 #ifdef __LINUX__
     backtrace_symbols_fd(array, size, STDERR_FILENO);
@@ -296,626 +336,665 @@ void handler(int sig)
     exit(1);
 }
 
-void SetUserProperties(const UserProperties *prop)
+void startResourceFromArgumentIndex(int resourceIndex)
 {
-    if(prop != NULL)
+    switch(resourceIndex)
     {
-        strncpy(g_userProperties.userValue_str, prop->userValue_str, MAXLEN_STRING);
-        g_userProperties.userValue_int = prop->userValue_int;
+        case 1:
+            startResource(
+                AC_SWITCH_URI,
+                SWITCH_RESOURCE_TYPE,
+                OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | OC_SECURE
+            );
+            break;
+        case 2:
+            startResource(
+                CON_URI,
+                CON_RESOURCE_TYPE,
+                OC_ACTIVE | OC_DISCOVERABLE | OC_SECURE
+            );
+            break;
+        case 3:
+            startResource(
+                MN_MAINTENANCE_URI,
+                MAINTENANCE_RESOURCE_TYPE,
+                OC_ACTIVE | OC_DISCOVERABLE | OC_SECURE
+            );
+            break;
+        case 4:
+            startResource(
+                NMON_NETWORK_MONITORING_URI,
+                NETWORK_MONITORING_RESOURCE_TYPE,
+                OC_ACTIVE | OC_DISCOVERABLE | OC_SECURE
+            );
+            break;
+        case 5:
+            DeleteCloudAccount();
+            DeInitCloudResource();
+            InitCloudResource();
+            break;
+        case 6:
+            createBP0Resource();
+            createBP1Resource();
+            createBP2Resource();
+            break;
+        case 7:
+            setDeviceWESInfo();
+            SetCallbackForUserdata();
+            prepareForWES(true);
+            break;
+        case 8:
+            createSampleCollection(true);
+            break;
     }
 }
 
-void ReadUserdataCb(OCRepPayload* payload, char*resourceType,void** userdata)
+void parseArguments(int argc, char* argv[])
 {
-    cout << "ReadUserdataCb IN" << endl;
-
-    if(payload != NULL)
+    try
     {
-        if(strstr(resourceType, OC_RSRVD_ES_RES_TYPE_WIFICONF))
-        {
-            int64_t value = -1;
-            if (OCRepPayloadGetPropInt(payload, USERPROPERTY_KEY_INT, &value))
+        boost::program_options::options_description defined_options("Allowed options");
+        defined_options.add_options()
+            ("help", "Print this description")
+            ("apiEndpoint", boost::program_options::value< std::string >(), "Specifies location of endpoint for http input server, default: 127.0.0.1:12345")
+            ("mode", boost::program_options::value< std::string >()->required(), "Mode: CLIENT/SERVER")
+            ("security", boost::program_options::value< std::string >()->required(), "Security type: JW/RDP/MFG/REUSE")
+            ("ocfVer", boost::program_options::value< std::string >()->required(), "OCF version, example: \"2.0.0\"")
+            ("devType", boost::program_options::value< std::string >(), "Device type, example: AP")
+            ("options", boost::program_options::value< std::vector<int> >()->multitoken(), "List of start options, example: 1 3 7");
+
+        boost::program_options::variables_map given_options;
+        boost::program_options::store(boost::program_options::parse_command_line(argc, argv, defined_options), given_options);
+
+        if (given_options.count("help") || argc == 1)
+        {
+            std::cout << std::endl << defined_options << std::endl;
+            std::cout << "Available device types:" << std::endl;
+            std::cout << "  DEFAULT - only " << DEFAULT_DEVICE_TYPE << std::endl;
+            std::cout << "  AP - [" << Device_TYPE_AP << "]" << std::endl;
+            std::cout << "  AC - [" << Device_TYPE_AC << ", " << Device_TYPE_VENDOR << "]" << std::endl;
+            std::cout << "  EC - [" << Device_TYPE_VENDOR << "]" << std::endl;
+            std::cout << "  BPM - [" << Device_TYPE_BPM << "]" << std::endl;
+            std::cout << std::endl;
+            std::cout << "Available start options:" << std::endl;
+            std::cout << "  1 - Create Binary Switch Resource" << std::endl;
+            std::cout << "  2 - Create Configuration Resource" << std::endl;
+            std::cout << "  3 - Create Network Monitoring Resource" << std::endl;
+            std::cout << "  4 - Create Maintenance Resource" << std::endl;
+            std::cout << "  5 - Initialize Cloud Resource" << std::endl;
+            std::cout << "  6 - Create Blood Pressure Atomic Measurements Resource" << std::endl;
+            std::cout << "  7 - Initialize Wi-Fi Easy Setup" << std::endl;
+            std::cout << "  8 - Create Collection with batch interface" << std::endl;
+            exit(1);
+        }
+
+        boost::program_options::notify(given_options);
+
+        if (given_options.count("apiEndpoint"))
+        {
+            std::string endpoint = given_options["apiEndpoint"].as<std::string>();
+
+            if (endpoint.find("[") == 0)
             {
-                if(*userdata != NULL)
-                {
-                    *userdata = (void*)OICMalloc(sizeof(UserProperties));
-                    ((UserProperties*)(*userdata))->userValue_int = value;
-                }
-
-                cout << "[User specific property]" << USERPROPERTY_KEY_INT << ":" <<  value;
-                g_userProperties.userValue_int = value;
+                g_IUTInfo.httpServerIP = endpoint.substr(1, endpoint.find("]") - 1);
+            }
+            else
+            {
+                g_IUTInfo.httpServerIP = endpoint.substr(0, endpoint.find_last_of(":"));
             }
-        }
-    }
-
-    cout << "ReadUserdataCb OUT" << endl;
-}
 
-void WriteUserdataCb(OCRepPayload* payload,char* resourceType)
-{
-    cout << "WriteUserdataCb IN" << endl;
+            g_IUTInfo.httpServerPort = endpoint.substr(endpoint.find_last_of(":") + 1);
 
-    if(payload != NULL)
-    {
-        if(strstr(resourceType,OC_RSRVD_ES_RES_TYPE_WIFICONF))
-        {
-             OCRepPayloadSetPropInt(payload,USERPROPERTY_KEY_INT,g_userProperties.userValue_int);
-        }
 
-        if(strstr(resourceType,OC_RSRVD_ES_RES_TYPE_DEVCONF))
-        {
-             OCRepPayloadSetPropString(payload,USERPROPERTY_KEY_STR,g_userProperties.userValue_str);
+            if (IUTSimulatorUtils::isValidIpAddress(g_IUTInfo.httpServerIP) && IUTSimulatorUtils::isPortValid(g_IUTInfo.httpServerPort))
+            {
+                std::cout << "Using http input server endpoint: [" << g_IUTInfo.httpServerIP << "]:" << g_IUTInfo.httpServerPort << std::endl;
+            }
+            else
+            {
+                std::cout << "Supplied http input server endpoint is invalid!"<< std::endl;
+                exit(1);
+            }
         }
-     }
-     cout<<"WriteUserdataCb OUT" << endl;
-}
-
-void SetCallbackForUserdata()
-{
-     ESSetCallbackForUserdata(&ReadUserdataCb,&WriteUserdataCb);
-}
-
-
-void replaceDatFile(int modeType, int securityType)
-{
-    int num;
-    char buffer[1000];
-
-    FILE *source;
-
-    source = fopen(sourceFileNames[securityType], "rb");
-    if (source == NULL)
-    {
-        cout << "Unable to read source file " << endl;
-        exit(-1);
-    }
-    else
-    {
-        cout << "Successfully open " << sourceFileNames[securityType] << endl;
-    }
-
-    FILE *destFile = NULL;
-    if (modeType == CLIENT_MODE)
-    {
-        destFile = fopen(CRED_FILE_CLIENT, "wb");
-        cout << "Copy to" << CRED_FILE_CLIENT << endl;
-    }
-    else if (modeType == SERVER_MODE)
-    {
-        destFile = fopen(CRED_FILE_SERVER, "wb");
-        cout << "Copy to " << CRED_FILE_SERVER << endl;
-    }
-    else
-    {
-        cout << "No mode found" << endl;
-    }
-
-    if (NULL == destFile)
-    {
-        fclose(source);
-        cout << "Unable to write dat file" << endl;
-        exit(-1);
-    }
-
-    while ((num = fread(buffer, sizeof(char), sizeof(buffer), source)) != 0)
-    {
-        fwrite(buffer, sizeof(char), num, destFile);
-    }
-
-    cout << "Dat File copy successfully" << endl;
-
-    fclose(destFile);
-    fclose(source);
-}
-
-void generatePinCB(char* pin, size_t pinSize)
-{
-    cout << "generatePinCB [IN]" << endl;
-    if (NULL == pin || pinSize <= 0)
-    {
-        cout << "Invalid PIN" << endl;
-    }
-    else
-    {
-        g_RDPPINSeqNumber++;
-
-        cout << "============================" << endl;
-        cout << "PIN CODE Sequence Number: " << g_RDPPINSeqNumber << " Time: " << getTimeNow() << endl;
-        cout << "    PIN CODE : " << string(pin) << endl;
-        cout << "============================" << endl;
-
-        g_RDPPINLogFileStream << "============================" << endl;
-        g_RDPPINLogFileStream << "PIN CODE Sequence Number: " << g_RDPPINSeqNumber << " Time: " << getTimeNow() << endl;
-        g_RDPPINLogFileStream << "    PIN CODE : " << string(pin) << endl;
-        g_RDPPINLogFileStream << "============================" << endl;
-        g_RDPPINLogFileStream.flush();
-    }
-    cout << "generatePinCB [OUT]" << endl;
-}
-
-int main(int argc, char* argv[])
-{
-    signal(SIGSEGV, handler);
-
-    g_createdResourceList.clear();
-    g_foundResourceList.clear();
-    g_handleList.clear();
-    g_resourceHelper = ResourceHelper::getInstance();
-
-    OCStackResult result = OC_STACK_OK;
 
-    if (argc > 1)
-    {
-        try
+        if (given_options.count("mode"))
         {
-            int optionSelected = stoi(argv[1]);
-
-            if (optionSelected == 1)
+            if (given_options["mode"].as<std::string>()  == "CLIENT")
             {
-                cout << "Using CON Server" << endl;
-                g_qos = QualityOfService::HighQos;
+                g_IUTInfo.mode = IUTInfo::Mode::CLIENT;
+                std::cout << "Using client mode" << std::endl;
             }
-            else if (optionSelected == 0)
+            else if (given_options["mode"].as<std::string>()  == "SERVER")
             {
-                cout << "Using NON Server" << endl;
+                g_IUTInfo.mode = IUTInfo::Mode::SERVER;
+                std::cout << "Using server mode" << std::endl;
             }
             else
             {
-                cout << "Supplied quality of service is invalid. Using default server type: NON"
-                        << endl;
+                g_IUTInfo.mode = IUTInfo::Mode::SERVER;
+                std::cout << "Supplied mode is invalid! Using default: SERVER" << std::endl;
             }
         }
-        catch (exception&)
-        {
-            cout << "Invalid input argument. Using default QoS: NON" << endl;
-        }
-    }
-    else
-    {
-        std::cout << "No QoS supplied. Using default: NON" << std::endl;
-    }
-    if (argc > 2)
-    {
-        try
-        {
-            int optionSelected = stoi(argv[2]);
 
-            if (optionSelected == 6)
+        if (given_options.count("security"))
+        {
+            if (given_options["security"].as<std::string>()  == "JW")
+            {
+                g_IUTInfo.securityType = IUTInfo::SecurityType::JW;
+                std::cout << "Supported Security Mode: justworks" << std::endl;
+            }
+            else if (given_options["security"].as<std::string>()  == "RDP")
+            {
+                g_IUTInfo.securityType = IUTInfo::SecurityType::RDP;
+                std::cout << "Supported Security Mode: randompin" << std::endl;
+            }
+            else if (given_options["security"].as<std::string>()  == "MFG")
             {
-                cout << "Using IP version: IPv6" << endl;
-                g_ipVer = CT_IP_USE_V6;
+                g_IUTInfo.securityType = IUTInfo::SecurityType::MFG;
+                std::cout << "Supported Security Mode: manufacturing certificate" << std::endl;
             }
-            else if (optionSelected == 4)
+            else if (given_options["security"].as<std::string>() == "REUSE")
             {
-                cout << "Using IP version: IPv4" << endl;
-                g_ipVer = CT_IP_USE_V4;
+                g_IUTInfo.securityType = IUTInfo::SecurityType::REUSE;
+                std::cout << "Using previous Security Mode" << std::endl;
             }
             else
             {
-                cout << "Supplied IP version is not a valid IP version. Using default: IPv6" << endl;
+                g_IUTInfo.securityType = IUTInfo::SecurityType::JW;
+                std::cout << "Supplied security type is invalid! Using default: justworks" << std::endl;
             }
         }
-        catch (exception&)
+
+        if (given_options.count("ocfVer"))
         {
-            cout << "Invalid input argument. Using default: IPv6" << endl;
+            g_IUTInfo.ocfVersion = "ocf." + given_options["ocfVer"].as<std::string>();
+            std::cout << "Using OCF version: " << g_IUTInfo.ocfVersion<< std::endl;
         }
-    }
-    else
-    {
-        cout << "No IP version supplied. Using default: IPv6" << endl;
-    }
 
-    if (argc > 3)
-    {
-        try
+        if (given_options.count("devType"))
         {
-            int optionSelected = stoi(argv[3]);
-            g_securityType = optionSelected % 10;
-
-            if (optionSelected / 10 == 1)
+            if (given_options["devType"].as<std::string>() == "AP")
             {
-                cout << "Using fresh secured client...." << endl;
-                g_isSecuredClient = true;
-                g_modeType = CLIENT_MODE;
+                g_IUTInfo.deviceName = VENDOR_AIR_PUR_DEVICE_NAME;
+                g_IUTInfo.deviceTypes.push_back(Device_TYPE_AP);
             }
-            else if (optionSelected / 10 == 2)
+            else if (given_options["devType"].as<std::string>() == "AC")
             {
-                cout << "Using fresh secured server...." << endl;
-                g_isSecuredServer = true;
-                g_modeType = SERVER_MODE;
+                g_IUTInfo.deviceName = VENDOR_AIR_CON_DEVICE_NAME;
+                g_IUTInfo.deviceTypes.push_back(Device_TYPE_AC);
+                g_IUTInfo.deviceTypes.push_back(Device_TYPE_VENDOR);
             }
-            else if (optionSelected / 10 == 3)
+            else if (given_options["devType"].as<std::string>() == "EP")
             {
-                cout << "Retaining old secured client...." << endl;
-                g_isSecuredClient = true;
-                g_modeType = CLIENT_MODE;
-                g_retainOldDB = true;
+                g_IUTInfo.deviceName = VENDOR_ECO_POW_DEVICE_NAME;
+                g_IUTInfo.deviceTypes.push_back(Device_TYPE_VENDOR);
             }
-            else if (optionSelected / 10 == 4)
+            else if (given_options["devType"].as<std::string>() == "BPM")
             {
-                cout << "Retaining old secured server...." << endl;
-                g_isSecuredServer = true;
-                g_modeType = SERVER_MODE;
-                g_retainOldDB = true;
+                g_IUTInfo.deviceName = VENDOR_BPM_DEVICE_NAME;
+                g_IUTInfo.deviceTypes.push_back(Device_TYPE_BPM);
             }
-            else
-            {
-                cout << "Using unsecured server & client...." << endl;
-            }
-
-            if (g_isSecuredClient || g_isSecuredServer)
+            else if (given_options["devType"].as<std::string>() == "DEFAULT")
             {
-                if (g_securityType == 1 )
+                if (g_IUTInfo.mode == IUTInfo::Mode::SERVER)
                 {
-                    cout << "Supported Security Mode: justworks" << endl;
-                    g_di = JUST_WORKS_DI;
+                    g_IUTInfo.deviceName = DEFAULT_SERVER_DEVICE_NAME;
                 }
-                else if (g_securityType == 2 )
+                else
                 {
-#ifdef __SECURED__
-                    SetGeneratePinCB(generatePinCB);
-#endif
-                    cout << "Supported Security Mode: randompin" << endl;
-                    g_di = RANDOM_PIN_DI;
-
-                    openRDPLogFile();
+                    g_IUTInfo.deviceName = DEFAULT_CLIENT_DEVICE_NAME;
                 }
-                else if (g_securityType == 3 )
+            }
+            else
+            {
+                std::cout << "Supplied device type argument is invalid! Using default name for selected mode" << std::endl;
+
+                if (g_IUTInfo.mode == IUTInfo::Mode::SERVER)
                 {
-                    cout << "Supported Security Mode: manufacturing certificate" << endl;
-                    g_di = MFG_DI;
+                    g_IUTInfo.deviceName = DEFAULT_SERVER_DEVICE_NAME;
                 }
                 else
                 {
-                    cout << "Unsupported Security Mode Specified, Using Default Mode: justworks" << endl;
-                    g_di = JUST_WORKS_DI;
-                    g_securityType = 1;
-                }
-
-                if (!g_retainOldDB)
-                {
-                    replaceDatFile(g_modeType, g_securityType);
+                    g_IUTInfo.deviceName = DEFAULT_CLIENT_DEVICE_NAME;
                 }
             }
         }
-        catch (std::exception&)
+        else
         {
-            cout << "Invalid input argument. Using default: unsecured server & client" << endl;
-        }
-    }
-    else
-    {
-        cout << "Security mode not specified. Using default: unsecured server & client" << endl;
-    }
+            if (g_IUTInfo.mode == IUTInfo::Mode::SERVER)
+            {
+                g_IUTInfo.deviceName = DEFAULT_SERVER_DEVICE_NAME;
+            }
+            else
+            {
+                g_IUTInfo.deviceName = DEFAULT_CLIENT_DEVICE_NAME;
+            }
+        }
 
-    if (argc > 4)
-    {
-        string ocfArg = string(argv[4]);
-        if (std::regex_match(ocfArg, std::regex("\\d+\\.\\d+\\.\\d+")))
+        std::cout << "Device Name: " << g_IUTInfo.deviceName << std::endl;
+        std::cout << "Device Types: [" << DEFAULT_DEVICE_TYPE;
+        for (std::string deviceType : g_IUTInfo.deviceTypes)
         {
-            cout << "Using OCF version: " << ocfArg << endl;
-            g_ocfVer = "ocf." + ocfArg;
+            std::cout << ", " << deviceType;
         }
-        else
+        std::cout << "]" << std::endl;
+
+        if (given_options.count("options"))
         {
-            cout << "Invalid input argument. Using default: 1.0.0" << endl;
+            g_IUTInfo.startOptions = given_options["options"].as< std::vector<int> >();
         }
-    }
-    else
+
+    } catch(std::exception &e)
     {
-        std::cout << "No OCF version supplied. Using default: 1.0.0" << std::endl;
+        cerr << "Error: " <<  e.what() << std::endl;
+        exit(0);
     }
+}
 
-    if (g_isSecuredClient)
+void httpRequestHandler(const http::Request& request, http::Response& response)
+{
+    if (!ResourceServer::isServerConstructed())
     {
-        vector<string> clientDeviceTypes;
-        clientDeviceTypes.push_back(DEFAULT_DEVIE_TYPE);
+        std::string message = "IoTivity server has not been started yet...";
 
-        OCPersistentStorage ps =
-        { client_fopen, fread, fwrite, fclose, unlink };
-        PlatformConfig cfg
-        { OC::ServiceType::InProc, OC::ModeType::Both, g_ipVer, g_ipVer, g_qos, &ps };
-        result = SampleResource::constructServer(cfg);
-        SampleResource::setDeviceInfo("Smart Home Client Device", clientDeviceTypes, g_ocfVer);
+        response.status = http::Response::StatusCode::ServiceUnavailable;
+        response.headers["Content-Length"] = std::to_string(message.size());
+        response.body = message;
+        return;
     }
-    else if (g_isSecuredServer)
+
+    if (request.method == "POST")
     {
-        OCPersistentStorage ps =
-        { server_fopen, fread, fwrite, fclose, unlink };
-        PlatformConfig cfg
-        { OC::ServiceType::InProc, OC::ModeType::Both, g_ipVer, g_ipVer, g_qos, &ps };
-        result = SampleResource::constructServer(cfg);
+        if (request.url == "/command")
+        {
+            HttpResources::setState("");
+            InputHandler::insert(request.body);
+            std::string message = InputHandler::getResponse();
+
+            response.status = http::Response::StatusCode::OK;
+            if (!message.empty())
+            {
+                response.headers["Content-Length"] = std::to_string(message.size());
+                response.body = message;
+            }
+        }
+        else
+        {
+            response.status = http::Response::StatusCode::BadRequest;
+        }
     }
-    else
+    if (request.method == "GET")
     {
-        OCPersistentStorage ps =
-        { server_fopen, fread, fwrite, fclose, unlink };
-        PlatformConfig cfg
-        { OC::ServiceType::InProc, OC::ModeType::Both, g_ipVer, g_ipVer, g_qos, &ps };
-        result = SampleResource::constructServer(cfg);
+        if (request.url == "/state")
+        {
+            std::string message = HttpResources::getState();
+            response.status = http::Response::StatusCode::OK;
+            response.headers["Content-Length"] = std::to_string(message.size());
+            response.body = message;
+        }
+        else if (request.url == "/pin")
+        {
+            std::string message = HttpResources::getPinCode();
+            response.status = http::Response::StatusCode::OK;
+            response.headers["Content-Length"] = std::to_string(message.size());
+            response.body = message;
+        }
+        else if (request.url == "/info")
+        {
+            std::string message = "IUT device info:\n"
+                "\tDevice ID: " + ResourceServer::getDeviceID() + "\n"
+                "\tEndpoints: [\n";
+            for(std::pair<std::string, std::string> endpoint : HttpResources::getDiscoveryEndpoints())
+            {
+                message += "\t\tEndpoint: [" + endpoint.first + "]:" + endpoint.second + "\n";
+            }
+            message += "\t]";
+
+            response.status = http::Response::StatusCode::OK;
+            response.headers["Content-Length"] = std::to_string(message.size());
+            response.body = message;
+        }
+        else
+        {
+            response.status = http::Response::StatusCode::BadRequest;
+        }
     }
+}
 
-    if (result != OC_STACK_OK)
+void httpServerThread(std::string ip, std::string port)
+{
+    try
     {
-        cout << "Unable to start Iotivity servers" << endl;
-        return 1;
+        http::Server server(ip, port, &httpRequestHandler);
+        server.run();
     }
-    else
+    catch (std::exception & e)
     {
-        cout << "Iotivity Server started successfully" << endl;
+        std::cerr << "Could not start http input server: " << e.what() << std::endl;
+        exit(1);
     }
+}
 
-#ifdef RD_SERVER
-    if (OCRDStart() == OC_STACK_OK)
-    {
-        cout << "RD Server started successfully..." << endl;
-    }
-    else
+void userInputThread()
+{
+    std::string userInput;
+    while (std::getline(std::cin, userInput))
     {
-        cout << "Failed to start RD Server..." << endl;
+        InputHandler::insert(userInput);
     }
-#endif
-
-    cout << "IUT Simulator started successfully" << endl;
-    cout << endl;
+}
 
-    for (int i = 5; i < argc; i++)
+OCStackApplicationResult onFoundDiscoveryEndpoint(void *ctx, OCDoHandle handle, OCClientResponse *clientResponse)
+{
+    if (!clientResponse)
     {
-        int choice = atoi(argv[i]);
-        selectMenu(choice);
+        std::cout << "Payload is NULL, No resources found" << std::endl;
+        return OC_STACK_DELETE_TRANSACTION;
     }
 
-    showMenu(argc, argv);
+    std::cout << "Found Discovery endpoint: IP:[" << clientResponse->devAddr.addr << "] Port:[" << clientResponse->devAddr.port << "]" << std::endl;
+    HttpResources::addDiscoveryEndpoint({clientResponse->devAddr.addr, std::to_string(clientResponse->devAddr.port)});
+    g_isDiscoveryAddressFound = true;
 
-    cout << "Iotivity Server stopped successfully" << endl;
-    cout << "Quitting IUT Simulator App.... Done!!" << endl;
-
-    return 0;
+    return OC_STACK_DELETE_TRANSACTION;
 }
 
-void ESWorkerThreadRoutine(string ssid, string pwd)
+bool findDiscoveryEndpoint(OCConnectivityType ipVersion)
 {
-    cout << "ESWorkerThreadRoutine IN" << endl;
-    std::this_thread::sleep_for(std::chrono::seconds(1));
-    cout << "ESWorkerThreadRoutine Woke up from sleep" << endl;
-
-    cout << "ssid: " << ssid << endl;
-    cout << "password: " << pwd << endl;
-
-#ifdef __LINUX__
+    std::cout << "Getting /oic/res address" << std::endl;
+    OCCallbackData cbData = {(void *)0x99, &onFoundDiscoveryEndpoint, NULL};
 
-    cout << "#1. Stopping Soft AP" << endl;
-
-    string outputString = g_resourceHelper->executeCommand("sudo service hostapd stop");
-    cout << "outputString 1:" << outputString << endl;
-    outputString = g_resourceHelper->executeCommand("sudo nmcli nm wifi on");
-    cout << "outputString 2:" << outputString << endl;
-
-    std::this_thread::sleep_for(std::chrono::seconds(1));
+    g_isDiscoveryAddressFound = false;
+    if (OCDoResource(NULL, OC_REST_DISCOVER, "/oic/res", NULL, 0, ipVersion, OC_HIGH_QOS, &cbData, NULL, 0) == OC_STACK_OK)
+    {
+        std::cout << "Discovery request for /oic/res has been sent!" << std::endl;
 
-    string nmcliCommand = "nmcli d wifi connect ";
-    nmcliCommand += ssid.c_str();
-    nmcliCommand += " password ";
-    nmcliCommand += pwd.c_str();
+        waitForCallback(g_isDiscoveryAddressFound);
 
-    cout << "executing command:" << nmcliCommand << endl;
+        if (g_isDiscoveryAddressFound)
+        {
+            return true;
+        }
+        else
+        {
+            std::cout << "ERROR: Could not find discovery address" << std::endl;
+            return false;
+        }
+    }
+    else
+    {
+        std::cout << "ERROR: Discovery request for /oic/res failed!" << std::endl;
+        return false;
+    }
+}
 
-    outputString = g_resourceHelper->executeCommand(nmcliCommand.c_str());
-    cout << "outputString 3:" << outputString << endl;
-    if (outputString == "")
+FILE* server_fopen(const char *path, const char *mode)
+{
+    if (0 == strcmp(path, OC_INTROSPECTION_FILE_NAME))
     {
-        ESSetErrorCode(ES_ERRCODE_NO_ERROR);
+        return fopen(INTROSPECTION_SWAGGER_FILE, mode);
+    }
+#ifdef __SECURED__
+    else if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    {
+        return fopen(CRED_FILE_SERVER, mode);
     }
 #endif
-
-    cout << "ESWorkerThreadRoutine OUT" << endl;
+    return fopen(path, mode);
 }
 
-void onWiFiConfProvReceived(ESWiFiConfData *eventData)
+FILE* client_fopen(const char *path, const char *mode)
 {
-    cout << "WiFiConfProvCbInApp IN" << endl;
-
-    if(eventData == NULL)
+    if (0 == strcmp(path, OC_INTROSPECTION_FILE_NAME))
     {
-        cout << "ESWiFiConfData is NULL" << endl;
-        return ;
+        return fopen(INTROSPECTION_SWAGGER_FILE, mode);
+    }
+#ifdef __SECURED__
+    else if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    {
+        return fopen(CRED_FILE_CLIENT, mode);
     }
+#endif
+    return fopen(path, mode);
+}
 
-    cout << "SSID : " << eventData->ssid << endl;
-    cout << "Password : " << eventData->pwd << endl;
-    cout << "AuthType : " << eventData->authtype << endl;
-    cout << "EncType : " << eventData->enctype << endl;
+IoTivityServerState startIoTivityServer(
+    IUTInfo::Mode mode,
+    IUTInfo::SecurityType securityType,
+    std::string ocfVersion,
+    std::string deviceName,
+    std::vector<std::string> deviceTypes)
+{
+    if (securityType != IUTInfo::SecurityType::REUSE)
+    {
+        resetSecurityDatabase(mode, securityType);
+    }
 
-    cout << "Authentication Type : " << eventData->authtype << endl;
+    static OCPersistentStorage presistantStorage;
 
-    if(0 != strcmp(eventData->ssid, WES_ENROLLER_SSID))
+    if (mode == IUTInfo::Mode::CLIENT)
     {
-        cout << "SSID Received is Invalid" << endl;
-        ESSetErrorCode((ESErrorCode)1);
-
-        cout << "WiFiConfProvCbInApp OUT 1" << endl;
-        return;
+        presistantStorage = { client_fopen, fread, fwrite, fclose, unlink };
     }
-
-    if(0 != strcmp(eventData->pwd, WES_ENROLLER_PASSWORD))
+    else if (mode == IUTInfo::Mode::SERVER)
     {
-        cout << "Password Received is Invalid" << endl;
-        ESSetErrorCode((ESErrorCode)2);
-
-        cout << "WiFiConfProvCbInApp OUT 2" << endl;
-        return;
+        presistantStorage = { server_fopen, fread, fwrite, fclose, unlink };
     }
 
-    if(WES_ENROLLER_AUTH_TYPE != eventData->authtype)
-    {
-        cout << "AUTH Type Received is Invalid" << endl;
-        ESSetErrorCode((ESErrorCode)8);
+    PlatformConfig platformConfig { OC::ServiceType::InProc, OC::ModeType::Both, &presistantStorage };
 
-        cout << "WiFiConfProvCbInApp OUT 3" << endl;
-        return;
+    if (SampleResource::constructServer(platformConfig, deviceName, deviceTypes, ocfVersion) == OC_STACK_OK)
+    {
+        std::cout << "Iotivity Server started successfully" << std::endl;
     }
-
-    if(WES_ENROLLER_ENC_TYPE != eventData->enctype)
+    else
     {
-        cout << "ENC Type Received is Invalid" << endl;
-        ESSetErrorCode((ESErrorCode)9);
+        std::cout << "Unable to start Iotivity servers" << std::endl;
+        return IoTivityServerState::EXIT;
+    }
 
-        cout << "WiFiConfProvCbInApp OUT 4" << endl;
-        return;
+    if (securityType == IUTInfo::SecurityType::REUSE)
+    {
+        if (GetDoxmResourceData()->oxmSel == OIC_JUST_WORKS)
+        {
+            g_IUTInfo.securityType = IUTInfo::SecurityType::JW;
+            std::cout << "Current reused security option is: justworks" << std::endl;
+        }
+        else if (GetDoxmResourceData()->oxmSel == OIC_RANDOM_DEVICE_PIN)
+        {
+            g_IUTInfo.securityType = IUTInfo::SecurityType::RDP;
+            std::cout << "Current reused security option is: randompin" << std::endl;
+        }
+        else if (GetDoxmResourceData()->oxmSel == OIC_MANUFACTURER_CERTIFICATE)
+        {
+            g_IUTInfo.securityType = IUTInfo::SecurityType::MFG;
+            std::cout << "Current reused security option is: manufacturing certificate" << std::endl;
+        }
     }
 
-    cout << "" << endl;
-    cout << "===========================" << endl;
-    cout << "Connect To Network --> [" << eventData->ssid << "]" << endl;
-    cout << "ALSO SWITCH OFF SOFT AP Network" << endl;
-    cout << "===========================" << endl;
-    cout << "" << endl;
+    if (g_IUTInfo.securityType == IUTInfo::SecurityType::RDP)
+    {
+        std::cout << "Start Generating Random Pin." << std::endl;
+        SetGeneratePinCB(onGeneratePin);
+    }
 
-    ESSetErrorCode(ES_ERRCODE_NO_ERROR);
+#ifdef RD_SERVER
+    if (OCRDStart() == OC_STACK_OK)
+    {
+        std::cout << "RD Server started successfully..." << std::endl;
+    }
+    else
+    {
+        std::cout << "Failed to start RD Server..." << std::endl;
+    }
+#endif
 
-    string ssid(eventData->ssid);
-    string password(eventData->pwd);
+    if (findDiscoveryEndpoint(CT_IP_USE_V4) && findDiscoveryEndpoint(CT_IP_USE_V6))
+    {
+        HttpResources::setDiscoveryEndpointsToReady();
+    }
+    else
+    {
+        return IoTivityServerState::EXIT;
+    }
 
-    std::thread esThread(ESWorkerThreadRoutine, ssid, password);
-    esThread.detach();
+    for(int option : g_IUTInfo.startOptions)
+    {
+        startResourceFromArgumentIndex(option);
+    }
 
-    cout << "WiFiConfProvCbInApp OUT" << endl;
+    std::cout << "IUT Simulator started successfully" << std::endl;
+    return IoTivityServerState::CONTINUE;
 }
 
-void onDevConfProvReceived(ESDevConfData *eventData)
+void stopIoTivityServer()
 {
-    cout << "DevConfProvCbInApp IN" << endl;
-
-    if(eventData == NULL)
+    HttpResources::clearDiscoveryEndpoints();
+    g_createdResourceList.clear();
+    if (g_isSampleCollectionCreated)
     {
-        cout << "ESDevConfData is NULL" << endl;
-        return ;
+        g_sampleCollection->stopResource();
+        g_isSampleCollectionCreated = false;
     }
+    ResourceServer::stopServer();
+    g_foundResourceList.clear();
 
-    cout << "DevConfProvCbInApp OUT" << endl;
+    //UnsetGeneratePinCB();
+
+    std::cout << "Iotivity Server stopped successfully" << std::endl;
 }
 
-void onResourceFound(shared_ptr< OCResource > resource)
+void resetSecurityDatabase(IUTInfo::Mode mode, IUTInfo::SecurityType securityType)
 {
-    s_mutex.lock();
-    cout << "Found a resource!!" << endl;
+    static const std::map<IUTInfo::SecurityType, std::string> SecurityTypeToFile =
+    {
+        std::make_pair(IUTInfo::SecurityType::JW, SECURITY_FILE_JW),
+        std::make_pair(IUTInfo::SecurityType::RDP, SECURITY_FILE_RDP),
+        std::make_pair(IUTInfo::SecurityType::MFG, SECURITY_FILE_MFG)
+    };
 
-    if (resource)
+    static const std::map<IUTInfo::Mode, std::string> ModeToFile =
     {
-        g_foundResourceList.push_back(resource);
-        cout << "uri of the found resource is " << resource->uri() << endl;
-        g_hasCallbackArrived = true;
+        std::make_pair(IUTInfo::Mode::CLIENT, CRED_FILE_CLIENT),
+        std::make_pair(IUTInfo::Mode::SERVER, CRED_FILE_SERVER)
+    };
+
+    std::cout << "Opening " << SecurityTypeToFile.at(securityType) << " security database file" << std::endl;
+    std::ifstream securityDatabaseFile(SecurityTypeToFile.at(securityType), std::ios::binary);
 
-        cout << "Host of found resource: ";
-        cout << resource->host() << endl;
-        cout << "di( OCResource.sid() ) of found resource is = ";
-        cout << resource->sid() << endl;
-        cout << "unique identifier of found resource is = ";
-        cout << resource->uniqueIdentifier() << endl;
+    if (securityDatabaseFile.is_open())
+    {
+        std::cout << "Opening local " << ModeToFile.at(mode) << " security database file" << std::endl;
+        std::ofstream localSecurityDatabaseFile(ModeToFile.at(mode), std::ios::binary);
 
-        string resourceType = resource->getResourceTypes().front();
-        if(resourceType.compare(OC_RSRVD_RESOURCE_TYPE_INTROSPECTION) == 0)
+        if (localSecurityDatabaseFile.is_open())
         {
-            g_introspectionResource = resource;
+            std::cout << "Copying security database file to local file" << std::endl;
+            localSecurityDatabaseFile << securityDatabaseFile.rdbuf();
         }
-
-        if (resourceType == OC_RSRVD_RESOURCE_TYPE_RDPUBLISH || resourceType == OC_RSRVD_RESOURCE_TYPE_RD)
+        else
         {
-            vector<string> allHosts = resource->getAllHosts();
-            if (allHosts.size() > 0)
-            {
-                for (string host : allHosts)
-                {
-                    g_rdServerHosts.push_back(host);
-                }
-            }
-            else
-            {
-                g_rdServerHosts.push_back(resource->host());
-            }
-
+            std::cout << "Unable to write to local security database file" << std::endl;
+            exit(-1);
         }
-
     }
     else
     {
-        cout << "Found resource is invalid!!" << endl;
+        std::cout << "Unable to read security database file " << std::endl;
+        exit(-1);
     }
-
-    s_mutex.unlock();
 }
 
-void onCollectionFound(shared_ptr< OCResource > collection)
+void onGeneratePin(char* pin, size_t pinSize)
 {
-    cout << "Found a Collection!!" << endl;
+    static int RDPPINSeqNumber = 0;
 
-    if (collection)
+    if (NULL == pin || pinSize <= 0)
     {
-        g_foundCollectionList.push_back(collection);
-        cout << "uri of the found collection is " << collection->uri() << endl;
-        g_hasCallbackArrived = true;
-
-        cout << "Host of found resource: " << collection->host() << endl;
-        cout << "sid of found resource is = " << collection->sid() << endl;
-        cout << "unique identifier of found resource is = " << collection->uniqueIdentifier()
-                << endl;
-        collection->get("", DEFAULT_INTERFACE, QueryParamsMap(), onGet);
-        collection->get("", BATCH_INTERFACE, QueryParamsMap(), onGet);
+        std::cout << "Invalid PIN" << std::endl;
     }
+    else
+    {
+        RDPPINSeqNumber++;
+
+        HttpResources::setPinCode(pin);
 
+        std::cout << "============================\n"
+                     "PIN CODE Sequence Number: " + std::to_string(RDPPINSeqNumber) + "\n" +
+                     "PIN CODE : " << std::string(pin) + "\n" +
+                     "============================\n";
+    }
 }
 
-void onPlatformInfoReceived(const OCRepresentation& rep)
+void onResourceListFound(std::vector< std::shared_ptr< OCResource > > resources)
 {
-    cout << "\nPlatform Information received ---->\n";
-    string value;
-    string values[] =
-    { "pi", "Platform ID                    ", "mnmn", "Manufacturer name              ", "mnml",
-            "Manufacturer url               ", "mnmo", "Manufacturer Model No          ", "mndt",
-            "Manufactured Date              ", "mnpv", "Manufacturer Platform Version  ", "mnos",
-            "Manufacturer OS version        ", "mnhw", "Manufacturer hardware version  ", "mnfv",
-            "Manufacturer firmware version  ", "mnsl", "Manufacturer support url       ", "st",
-            "Manufacturer system time       " };
+    s_mutex.lock();
+    std::cout << "Found resources!" << std::endl;
 
-    for (unsigned int i = 0; i < sizeof(values) / sizeof(values[0]); i += 2)
+    if (resources.size() > 0)
     {
-        if (rep.getValue(values[i], value))
+        if (resources[0]->sid() == ResourceServer::getDeviceID())
         {
-            std::cout << values[i + 1] << " : " << value << std::endl;
+            std::cout << "Resources from own device are ignored." << std::endl;
+            s_mutex.unlock();
+            return;
         }
     }
-    g_resourceHelper->printRepresentation(rep);
-    g_hasCallbackArrived = true;
-}
-
-void onDeviceInfoReceived(const OCRepresentation& rep)
-{
-    cout << "\nDevice Information received ---->\n";
-    string value;
-    string values[] =
-    { "di", "Device ID        ", NAME_KEY, "Device name      ", "lcv", "Spec version url ", "dmv",
-            "Data Model Model ", };
 
-    for (unsigned int i = 0; i < sizeof(values) / sizeof(values[0]); i += 2)
+    for (std::shared_ptr< OCResource > resource : resources)
     {
-        if (rep.getValue(values[i], value))
+        if (resource)
+        {
+            std::cout << "Found resource: " << resource->uri() << std::endl;
+            std::cout << "\tHost: " << resource->host() << std::endl;
+            std::cout << "\tUnique Identifier: " << resource->uniqueIdentifier() << std::endl;
+
+            if (IUTSimulatorUtils::isResourceInList(g_foundResourceList, resource))
+            {
+                std::cout << "This resource is already found!" << std::endl;
+                break;
+            }
+
+            g_foundResourceList.push_back(resource);
+        }
+        else
         {
-            std::cout << values[i + 1] << " : " << value << std::endl;
+            std::cout << "Found resource is invalid!" << std::endl;
         }
     }
 
-    g_resourceHelper->printRepresentation(rep);
-    g_hasCallbackArrived = true;
+    g_areResourcesFound = true;
+
+    s_mutex.unlock();
+}
+
+void onPlatformInfoReceived(const OCRepresentation& rep)
+{
+    std::string payload = "Platform Information:\n";
+    ResourceHelper::payloadToString(rep.getPayload(), payload);
+    InputHandler::setResponse(InputHandler::ResponseType::Info, payload);
+
+    g_hasPlatformInfoCallbackArrived = true;
+}
+
+void onDeviceInfoReceived(const OCRepresentation& rep)
+{
+    std::string payload = "Device Information:\n";
+    ResourceHelper::payloadToString(rep.getPayload(), payload);
+    InputHandler::setResponse(InputHandler::ResponseType::Info, payload);
+
+    g_hasDeviceInfoCallbackArrived = true;
 }
 
 // callback handler on GET request
 void onGet(const HeaderOptions &headerOptions, const OCRepresentation &rep, const int eCode)
 {
+    std::cout << "In onGet handler" << std::endl;
     if (eCode == SUCCESS_RESPONSE || eCode == OC_STACK_OK)
     {
-        cout << "Response: GET request was successful" << endl;
+        std::cout << "Response: GET request was successful" << std::endl;
 
-        vector< string > interfaceList = rep.getResourceInterfaces();
+        std::vector< std::string > interfaceList = rep.getResourceInterfaces();
 
         bool isCollection = false;
         for (auto resourceInterface : interfaceList)
@@ -929,84 +1008,81 @@ void onGet(const HeaderOptions &headerOptions, const OCRepresentation &rep, cons
 
         if (isCollection)
         {
-            vector< OCRepresentation > children = rep.getChildren();
+            std::vector< OCRepresentation > children = rep.getChildren();
 
-            cout << "\nChild Resource List of Collectection:" << endl;
+            std::cout << "\nChild Resource List of Collectection:" << std::endl;
             for (auto child : children)
             {
-                cout << "\tURI :: " << child.getUri() << endl;
+                std::cout << "\tURI :: " << child.getUri() << std::endl;
             }
-            cout << endl;
+            std::cout << std::endl;
         }
         else
         {
-            g_resourceRepresentation = rep;
-            cout << "The GET Response has the following representation:" << endl;
-            g_resourceHelper->printRepresentation(rep);
+            std::string payload = "The GET response has the following representation:\n";
+            ResourceHelper::payloadToString(rep.getPayload(), payload);
+            InputHandler::setResponse(InputHandler::ResponseType::Info, payload);
         }
 
-        if(rep.hasAttribute(OC_RSRVD_INTROSPECTION_URL_INFO))
+        if (rep.hasAttribute(OC_RSRVD_INTROSPECTION_URL_INFO))
         {
-            vector<OCRepresentation> urlInfo;
-            rep.getValue(string(OC_RSRVD_INTROSPECTION_URL_INFO), urlInfo);
-            string url;
-            urlInfo.front().getValue(string(OC_RSRVD_INTROSPECTION_URL), url);
-            url = url.substr(url.find_first_of("/") + 2);
-            url = url.substr(url.find_first_of("/") );
-            cout << "URI to send is: " << url << endl;
-
-            vector<string> resourceTypes;
-            resourceTypes.push_back(OC_RSRVD_RESOURCE_TYPE_INTROSPECTION_PAYLOAD);
-
-            OCResource::Ptr payloadResource = OCPlatform::constructResourceObject(g_introspectionResource->host(),
-                    url, g_introspectionResource->connectivityType(),
-                    true, resourceTypes, g_introspectionResource->getResourceInterfaces());
-
-            payloadResource->get(QueryParamsMap(), onGet, g_qos);
-            cout << "GET request sent to introspection payload resource!!" << endl;
-            waitForCallback();
+            std::shared_ptr<OCResource> introspectionResource = IUTSimulatorUtils::getResourceByURI(g_foundResourceList, "/introspection");
+
+            if (introspectionResource)
+            {
+                std::vector<OCRepresentation> urlInfo;
+                rep.getValue(std::string(OC_RSRVD_INTROSPECTION_URL_INFO), urlInfo);
+                std::string url;
+                urlInfo.front().getValue(std::string(OC_RSRVD_INTROSPECTION_URL), url);
+                url = url.substr(url.find_first_of("/") + 2);
+                url = url.substr(url.find_first_of("/") );
+                std::cout << "URI to send is: " << url << std::endl;
+
+                std::vector<std::string> resourceTypes;
+                resourceTypes.push_back(OC_RSRVD_RESOURCE_TYPE_INTROSPECTION_PAYLOAD);
+
+                OCResource::Ptr payloadResource = OCPlatform::constructResourceObject(introspectionResource->host(),
+                        url, introspectionResource->connectivityType(),
+                        true, resourceTypes, introspectionResource->getResourceInterfaces());
+
+                payloadResource->get(QueryParamsMap(), onGet, QualityOfService::HighQos);
+                std::cout << "GET request sent to introspection payload resource!!" << std::endl;
+            }
+            else
+            {
+                std::cout << "No introspection resource to sent GET request to payload!" << std::endl;
+            }
         }
     }
     else
     {
-        cout << "onGET Response error: " << eCode << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "GET Response error: " + std::to_string(eCode));
     }
-    g_hasCallbackArrived = true;
+    g_hasResourceCallbackArrived = true;
+    std::cout << "Out onGet handler" << std::endl;
 }
 
-// callback handler on PUT request
-void onPut(const HeaderOptions &headerOptions, const OCRepresentation &rep, const int eCode)
-{
-    if (eCode == SUCCESS_RESPONSE || eCode == OC_STACK_RESOURCE_CHANGED
-            || eCode == OC_STACK_RESOURCE_CREATED)
-    {
-        cout << "Response: PUT request was successful" << endl;
-        cout << "The PUT response has the following representation:" << endl;
-        g_resourceHelper->printRepresentation(rep);
-    }
-    else
-    {
-        cout << "onPUT Response error: " << eCode << endl;
-    }
-    g_hasCallbackArrived = true;
-}
 
 // callback handler on POST request
 void onPost(const HeaderOptions &headerOptions, const OCRepresentation &rep, const int eCode)
 {
+    std::cout << "In onPost handler" << std::endl;
     if (eCode == SUCCESS_RESPONSE || eCode == OC_STACK_RESOURCE_CHANGED
             || eCode == OC_STACK_RESOURCE_CREATED)
     {
-        cout << "Response: POST request was successful" << endl;
-        cout << "The POST Response has the following representation:" << endl;
-        g_resourceHelper->printRepresentation(rep);
+        std::cout << "Response: POST request was successful" << std::endl;
+
+        std::string payload = "The POST response has the following representation:\n";
+        ResourceHelper::payloadToString(rep.getPayload(), payload);
+        InputHandler::setResponse(InputHandler::ResponseType::Info, payload);
     }
     else
     {
-        cout << "onPOST Response error: " << eCode << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "POST response error: " + std::to_string(eCode));
     }
-    g_hasCallbackArrived = true;
 
+    g_hasResourceCallbackArrived = true;
+    std::cout << "Out onPost handler" << std::endl;
 }
 
 // callback handler on DELETE request
@@ -1014,13 +1090,14 @@ void onDelete(const HeaderOptions &headerOptions, const int eCode)
 {
     if (eCode == SUCCESS_RESPONSE || eCode == OC_STACK_RESOURCE_DELETED)
     {
-        cout << "Response: DELETE request was successful" << endl;
+        std::cout << "Response: DELETE request was successful" << std::endl;
     }
     else
     {
-        cout << "onDELETE Response error: " << eCode << endl;
+        std::cout << "onDELETE Response error: " << eCode << std::endl;
     }
-    g_hasCallbackArrived = true;
+
+    g_hasResourceCallbackArrived = true;
 }
 
 void onObserve(const HeaderOptions headerOptions, const OCRepresentation &rep, const int &eCode,
@@ -1039,43 +1116,44 @@ void onObserve(const HeaderOptions headerOptions, const OCRepresentation &rep, c
     {
         std::cout << "Exception: " << e.what() << " in onObserve" << std::endl;
     }
-    g_hasCallbackArrived = true;
+
+    g_hasResourceCallbackArrived = true;
 
 }
 
 
 void onResourceRemoved(const int& eCode)
 {
-    cout << "Received Delete Resource Response From RD" << endl;
+    std::cout << "Received Delete Resource Response From RD" << std::endl;
     try
     {
         if (OC_STACK_RESOURCE_DELETED == eCode)
         {
-            cout << "Resource delete was successful" << endl;
+            std::cout << "Resource delete was successful" << std::endl;
         }
         else
         {
-            cout << "onDelete Response error: " << eCode << endl;
+            std::cout << "onDelete Response error: " << eCode << std::endl;
         }
     }
     catch(std::exception& e)
     {
-        cout << "Exception: " << e.what() << " in onDelete" << endl;
+        std::cout << "Exception: " << e.what() << " in onDelete" << std::endl;
     }
 }
 
 void onResourcePublished(const OCRepresentation& rep, const int& eCode)
 {
-    cout << endl <<"Received Publish Resource Response From RD" << endl;
+    std::cout << std::endl <<"Received Publish Resource Response From RD" << std::endl;
 
     try
     {
         if (OC_STACK_RESOURCE_CHANGED == eCode)
         {
-            cout << "=========== Published Resource ===========" << endl;
+            std::cout << "=========== Published Resource ===========" << std::endl;
             if (rep.hasAttribute("di"))
             {
-                cout << " di: " << rep.getValue<std::string>("di") << endl;
+                std::cout << " di: " << rep.getValue<std::string>("di") << std::endl;
             }
 
             // Published Resource is included as the child resource.
@@ -1083,45 +1161,51 @@ void onResourcePublished(const OCRepresentation& rep, const int& eCode)
 
             for (auto oit = children.begin(); oit != children.end(); ++oit)
             {
-                string m_href;
+                std::string m_href;
                 oit->getValue("href", m_href);
-                cout << "   href : " << m_href << endl;
+                std::cout << "   href : " << m_href << std::endl;
 
-                cout << "   resource type : " << endl;
+                std::cout << "   resource type : " << std::endl;
                 for(const std::string& type : oit->getResourceTypes())
                 {
-                    cout << "       " <<  type << "\n";
+                    std::cout << "       " <<  type << "\n";
                 }
 
-                cout << "   resource interface : " << endl;
+                std::cout << "   resource interface : " << std::endl;
                 for(const std::string& type : oit->getResourceInterfaces())
                 {
-                    cout << "       " <<  type << "\n";
+                    std::cout << "       " <<  type << "\n";
                 }
 
                 int m_ins;
                 oit->getValue("ins", m_ins);
-                cout << "   ins : " << m_ins << endl;
+                std::cout << "   ins : " << m_ins << std::endl;
             }
-            cout << "=========================================" << endl;
+            std::cout << "=========================================" << std::endl;
         }
         else
         {
-            cout << "onPublish Response error: " << eCode << endl;
+            std::cout << "onPublish Response error: " << eCode << std::endl;
         }
     }
     catch(std::exception& e)
     {
-        cout << "Exception: " << e.what() << " in onPublish" << endl;
+        std::cout << "Exception: " << e.what() << " in onPublish" << std::endl;
     }
 }
 
-void waitForCallback()
+OCStackApplicationResult onPong(void* ctx, OCDoHandle handle, OCClientResponse* clientResponse)
+{
+    std::cout << "Pong received! Address: " << clientResponse->devAddr.addr << std::endl;
+    return OC_STACK_DELETE_TRANSACTION;
+}
+
+void waitForCallback(bool& callbackArrived)
 {
     int elapsedSecond = 0;
-    while (g_hasCallbackArrived == false)
+    while (callbackArrived == false)
     {
-        g_resourceHelper->waitInSecond(CALLBACK_WAIT_MIN);
+        std::this_thread::sleep_for(std::chrono::seconds(CALLBACK_WAIT_MIN));
         elapsedSecond++;
         if (elapsedSecond > CALLBACK_WAIT_MAX)
         {
@@ -1130,479 +1214,386 @@ void waitForCallback()
     }
 }
 
-FILE* server_fopen(const char *path, const char *mode)
+void SetUserProperties(const UserProperties *prop)
 {
-    if (0 == strcmp(path, OC_INTROSPECTION_FILE_NAME))
-    {
-        return fopen(INTROSPECTION_SWAGGER_FILE, mode);
-    }
-#ifdef __SECURED__
-    else if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    if (prop != NULL)
     {
-        return fopen(CRED_FILE_SERVER, mode);
+        strncpy(g_userProperties.userValue_str, prop->userValue_str, MAXLEN_STRING);
+        g_userProperties.userValue_int = prop->userValue_int;
     }
-#endif
-    return fopen(path, mode);
 }
 
-FILE* client_fopen(const char *path, const char *mode)
+void ReadUserdataCb(OCRepPayload* payload, char*resourceType,void** userdata)
 {
-    if (0 == strcmp(path, OC_INTROSPECTION_FILE_NAME))
-    {
-        return fopen(INTROSPECTION_SWAGGER_FILE, mode);
-    }
-#ifdef __SECURED__
-    else if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    std::cout << "ReadUserdataCb IN" << std::endl;
+
+    if (payload != NULL)
     {
-        return fopen(CRED_FILE_CLIENT, mode);
-    }
-#endif
-    return fopen(path, mode);
-}
-
-void createResourceWithUrl()
-{
-    if (g_childHandle == NULL)
-    {
-        cout << "Creating Resource with complete URL" << endl;
-        findResource(RESOURCE_TYPE_LIGHT);
-        if (!g_foundResourceList.empty())
-        {
-            OCPlatform::registerResource(g_childHandle, g_foundResourceList.at(0));
-        }
-    }
-    else
-    {
-        cout << "Resource with complete URL already created!!" << endl;
-    }
-}
-
-bool startResource(const std::shared_ptr<SampleResource>& resource)
-{
-    if (!IUTSimulatorUtils::getResourceByURI(g_createdResourceList, resource->getUri()))
-    {
-        cout << "Creating " << resource->getUri() << " Resource!" << endl;
-
-        if (resource->startResource() == OC_STACK_OK)
+        if (strstr(resourceType, OC_RSRVD_ES_RES_TYPE_WIFICONF))
         {
-            cout << resource->getUri() << " Resource created successfully!" << endl;
-            g_createdResourceList.push_back(resource);
+            int64_t value = -1;
+            if (OCRepPayloadGetPropInt(payload, USERPROPERTY_KEY_INT, &value))
+            {
+                if (*userdata != NULL)
+                {
+                    *userdata = (void*)OICMalloc(sizeof(UserProperties));
+                    ((UserProperties*)(*userdata))->userValue_int = value;
+                }
 
-            return true;
-        }
-        else
-        {
-            cout << "Unable to create " << resource->getUri() << " Resource!" << endl;
+                std::cout << "[User specific property]" << USERPROPERTY_KEY_INT << ":" <<  value;
+                g_userProperties.userValue_int = value;
+            }
         }
     }
-    else
-    {
-        cout << "Resource with URI \"" << resource->getUri() << "\" is already created!" << endl;
-    }
 
-    return false;
+    std::cout << "ReadUserdataCb OUT" << std::endl;
 }
 
-std::shared_ptr<SampleResource> startResource(
-    const std::string& resourceUri,
-    const std::string& resourceType,
-    const std::string& resourceInterface,
-    const uint8_t& resourceProperty,
-    const ResponseTimeType& responseTimeType = ResponseTimeType::NORMAL,
-    const HandlerType& handlerType = HandlerType::SAMPLE)
+void WriteUserdataCb(OCRepPayload* payload,char* resourceType)
 {
-    if (!IUTSimulatorUtils::getResourceByURI(g_createdResourceList, resourceUri))
-    {
-        cout << "Creating " << resourceUri << " Resource!" << endl;
-        std::shared_ptr< SampleResource > resource = SampleResourceFactory::createResource(
-            resourceUri,
-            resourceType,
-            resourceInterface,
-            resourceProperty
-        );
-        resource->setResponseTimeType(responseTimeType);
+    std::cout << "WriteUserdataCb IN" << std::endl;
 
-        if (resource->startResource(resourceProperty, handlerType) == OC_STACK_OK)
+    if (payload != NULL)
+    {
+        if (strstr(resourceType,OC_RSRVD_ES_RES_TYPE_WIFICONF))
         {
-            cout << resourceUri << " Resource created successfully!" << endl;
-            g_createdResourceList.push_back(resource);
-
-            return resource;
+             OCRepPayloadSetPropInt(payload,USERPROPERTY_KEY_INT,g_userProperties.userValue_int);
         }
-        else
+
+        if (strstr(resourceType,OC_RSRVD_ES_RES_TYPE_DEVCONF))
         {
-            cout << "Unable to create " << resourceUri << " Resource!" << endl;
+             OCRepPayloadSetPropString(payload,USERPROPERTY_KEY_STR,g_userProperties.userValue_str);
         }
-    }
-    else
-    {
-        cout << "Resource with URI \"" << resourceUri<< "\" is already created!" << endl;
-    }
-
-    return nullptr;
+     }
+     std::cout << "WriteUserdataCb OUT" << std::endl;
 }
 
-std::shared_ptr<SampleResource> startResource(
-    const std::string& resourceUri,
-    const std::string& resourceType,
-    const std::string& resourceInterface,
-    const uint8_t& resourceProperty,
-    const HandlerType& handlerType)
+void SetCallbackForUserdata()
 {
-    return startResource(resourceUri, resourceType, "", resourceProperty, ResponseTimeType::NORMAL, handlerType);
+     ESSetCallbackForUserdata(&ReadUserdataCb,&WriteUserdataCb);
 }
 
-std::shared_ptr<SampleResource> startResource(
-    const std::string& resourceUri,
-    const std::string& resourceType,
-    const uint8_t& resourceProperty,
-    const ResponseTimeType& responseTimeType = ResponseTimeType::NORMAL,
-    const HandlerType& handlerType = HandlerType::SAMPLE)
+void ESWorkerThreadRoutine(std::string ssid, std::string pwd)
 {
-    return startResource(resourceUri, resourceType, "", resourceProperty, responseTimeType, handlerType);
-}
+    std::cout << "ESWorkerThreadRoutine IN" << std::endl;
+    std::this_thread::sleep_for(std::chrono::seconds(1));
+    std::cout << "ESWorkerThreadRoutine Woke up from sleep" << std::endl;
 
-std::shared_ptr<SampleResource> startResource(
-    const std::string& resourceUri,
-    const std::string& resourceType,
-    const uint8_t& resourceProperty,
-    const HandlerType& handlerType)
-{
-    return startResource(resourceUri, resourceType, "", resourceProperty, ResponseTimeType::NORMAL, handlerType);
-}
+    std::cout << "ssid: " << ssid << std::endl;
+    std::cout << "password: " << pwd << std::endl;
 
-std::shared_ptr< SampleResource > startTemperatureSensorResource(const std::string& sensorUri, const uint8_t& sensorResourceProperty)
-{
-    std::shared_ptr< SampleResource > temperatureSensorResource = std::make_shared< SampleResource >(
-        sensorUri,
-        TEMPERATURE_RESOURCE_TYPE,
-        TEMPERATURE_SENSOR_INTERFACE,
-        sensorResourceProperty,
-        IUTSimulatorUtils::createRepresentation({
-            {UNITS_KEY, string(UNITS_VALUE)},
-            {TEMPERATURE_KEY, DEFAULT_TEMPERATURE_VALUE}
-        })
-    );
-    temperatureSensorResource->setAsReadOnly(UNITS_KEY);
-    temperatureSensorResource->setAsReadOnly(TEMPERATURE_KEY);
+#ifdef __LINUX__
 
-    if(startResource(temperatureSensorResource))
-    {
-        return temperatureSensorResource;
-    }
-    else
-    {
-        return nullptr;
-    }
-}
+    std::cout << "#1. Stopping Soft AP" << std::endl;
 
-std::shared_ptr< SampleResource > startTimerResourceWithLongLocation(const std::string& resourceUri, const uint8_t& resourceProperty)
-{
-    std::shared_ptr< SampleResource > timerResource = SampleResourceFactory::createResource(
-        resourceUri,
-        TIMER_RESOURCE_TYPE,
-        resourceProperty
-    );
-    timerResource->updateRepresentation(TIMER_LOCATION_KEY, string(VERY_BIG_VALUE));
-    timerResource->setResponseTimeType(ResponseTimeType::SLOW);
+    std::string outputString = ResourceHelper::executeCommand("sudo pkill create_ap");
+    std::cout << "outputString 1:" << outputString << std::endl;
+    outputString = ResourceHelper::executeCommand("sudo nmcli r wifi on");
+    std::cout << "outputString 2:" << outputString << std::endl;
 
-    if(startResource(timerResource))
-    {
-        return timerResource;
-    }
-    else
-    {
-        return nullptr;
-    }
-}
+    std::this_thread::sleep_for(std::chrono::seconds(1));
 
-std::shared_ptr< SampleResource > startVendorSwingResource(const std::string& resourceUri, const uint8_t& resourceProperty)
-{
-    std::shared_ptr< SampleResource > vendorSwingResource = SampleResourceFactory::createResource(
-        resourceUri,
-        SWING_RESOURCE_TYPE,
-        resourceProperty
-    );
-    vendorSwingResource->setResourceRepresentation(
-        IUTSimulatorUtils::createRepresentation({
-            {"x.com.vendor.swing.on", false},
-            {"x.com.vendor.swing.blade.movement.direction", string("horizontal")},
-            {"x.com.vendor.swing.supported.direction", vector<string>{"horizontal", "vertical"}}
-        })
-    );
-    vendorSwingResource->setAsReadOnly("x.com.vendor.swing.supported.direction");
+    std::string nmcliCommand = "nmcli d wifi connect ";
+    nmcliCommand += ssid.c_str();
+    nmcliCommand += " password ";
+    nmcliCommand += pwd.c_str();
 
-    if(startResource(vendorSwingResource))
-    {
-        return vendorSwingResource;
-    }
-    else
+    std::cout << "executing command:" << nmcliCommand << std::endl;
+
+    outputString = ResourceHelper::executeCommand(nmcliCommand.c_str());
+    std::cout << "outputString 3:" << outputString << std::endl;
+    if (outputString == "")
     {
-        return nullptr;
+        ESSetErrorCode(ES_ERRCODE_NO_ERROR);
     }
+#endif
+
+    std::cout << "ESWorkerThreadRoutine OUT" << std::endl;
 }
 
-std::shared_ptr< SampleResource > startExtraLightResource(const std::string& resourceUri, const uint8_t& resourceProperty)
+void onWiFiConfProvReceived(ESWiFiConfData *eventData)
 {
-    std::shared_ptr< SampleResource > extraLightResource = SampleResourceFactory::createResource(
-        resourceUri,
-        Device_TYPE_LIGHT,
-        resourceProperty
-    );
-    extraLightResource->updateRepresentation(DEVICE_ID_KEY, g_di);
+    std::cout << "WiFiConfProvCbInApp IN" << std::endl;
 
-    if(startResource(extraLightResource))
-    {
-        return extraLightResource;
-    }
-    else
+    if (eventData == NULL)
     {
-        return nullptr;
+        std::cout << "ESWiFiConfData is NULL" << std::endl;
+        return ;
     }
-}
 
-void createCollectionWithBatch(bool secured)
-{
-    cout << "Creating Batch Collection!!" << endl;
-    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecure(secured);
-    uint8_t resourcePropertyHidden = OC_ACTIVE | OC_OBSERVABLE | isSecure(secured);
+    std::cout << "SSID : " << eventData->ssid << std::endl;
+    std::cout << "Password : " << eventData->pwd << std::endl;
+    std::cout << "AuthType : " << eventData->authtype << std::endl;
+    std::cout << "EncType : " << eventData->enctype << std::endl;
 
-    if (g_isSampleCollectionCreated == false)
+    std::cout << "Authentication Type : " << eventData->authtype << std::endl;
+
+    if (0 != strcmp(eventData->ssid, WES_ENROLLER_SSID))
     {
-        g_sampleCollection = new SampleCollection();
-        g_sampleCollection->setResourceProperties(COLLECTION_URI, GROUP_TYPE_DEFAULT, LINK_INTERFACE);
-        g_sampleCollection->setDI(g_di);
-        g_sampleCollection->setIPVer(g_ipVer);
-        g_sampleCollection->setSecured(true);
-        g_sampleCollection->setName("Sample Collection Device");
+        std::cout << "SSID Received is Invalid" << std::endl;
+        ESSetErrorCode((ESErrorCode)1);
 
-        if (g_sampleCollection->startResource(resourceProperty, HandlerType::DEFAULT) == OC_STACK_OK)
-        {
-            cout << "Batch collection created successfully" << endl;
-            g_sampleCollection->addResourceInterface(DEFAULT_INTERFACE);
-            g_sampleCollection->addResourceInterface(BATCH_INTERFACE);
-            g_sampleCollection->addChild(
-                startResource(COLLECTION_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourcePropertyHidden, HandlerType::DEFAULT)
-            );
-            g_isSampleCollectionCreated = true;
-        }
-        else
-        {
-            cout << "Unable to create Batch Collection" << endl;
-        }
+        std::cout << "WiFiConfProvCbInApp OUT 1" << std::endl;
+        return;
     }
-    else
+
+    if (0 != strcmp(eventData->pwd, WES_ENROLLER_PASSWORD))
     {
-        cout << "Already Batch Collection is created!!" << endl;
+        std::cout << "Password Received is Invalid" << std::endl;
+        ESSetErrorCode((ESErrorCode)2);
+
+        std::cout << "WiFiConfProvCbInApp OUT 2" << std::endl;
+        return;
     }
-}
 
-void createResource()
-{
-    cout << "createResource called!!" << endl;
+    if (WES_ENROLLER_AUTH_TYPE != eventData->authtype)
+    {
+        std::cout << "AUTH Type Received is Invalid" << std::endl;
+        ESSetErrorCode((ESErrorCode)8);
 
-    startResource(LIGHT_1_URI, RESOURCE_TYPE_LIGHT, OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE);
-    startResource(FAN_1_URI, RESOURCE_TYPE_FAN, OC_ACTIVE | OC_DISCOVERABLE);
-}
+        std::cout << "WiFiConfProvCbInApp OUT 3" << std::endl;
+        return;
+    }
 
-void createSecuredResource()
-{
-    cout << "createSecuredResource called!!" << endl;
+    if (WES_ENROLLER_ENC_TYPE != eventData->enctype)
+    {
+        std::cout << "ENC Type Received is Invalid" << std::endl;
+        ESSetErrorCode((ESErrorCode)9);
 
-    startResource(LIGHT_SECURED_URI, RESOURCE_TYPE_LIGHT, OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | OC_SECURE);
-    startResource(FAN_SECURED_URI, RESOURCE_TYPE_FAN, OC_ACTIVE | OC_DISCOVERABLE | OC_SECURE);
-}
+        std::cout << "WiFiConfProvCbInApp OUT 4" << std::endl;
+        return;
+    }
 
-void createInvisibleResource()
-{
-    cout << "createInvisibleResource called!!" << endl;
+    std::cout << "" << std::endl;
+    std::cout << "===========================" << std::endl;
+    std::cout << "Connect To Network --> [" << eventData->ssid << "]" << std::endl;
+    std::cout << "ALSO SWITCH OFF SOFT AP Network" << std::endl;
+    std::cout << "===========================" << std::endl;
+    std::cout << "" << std::endl;
 
-    startResource(
-        LIGHT_INVISIBLE_URI,
-        RESOURCE_TYPE_LIGHT,
-        string(ACTUATOR_INTERFACE) + " " + string(DEFAULT_INTERFACE),
-        OC_ACTIVE | OC_OBSERVABLE | OC_EXPLICIT_DISCOVERABLE
-    );
-    startResource(FAN_INVISIBLE_URI, RESOURCE_TYPE_FAN, OC_ACTIVE);
-}
+    ESSetErrorCode(ES_ERRCODE_NO_ERROR);
 
-void createSingleAirConResource(bool secured)
-{
-    cout << "Creating Single Air Conditioner Device Resource!!" << endl;
-    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecure(secured);
+    std::string ssid(eventData->ssid);
+    std::string password(eventData->pwd);
 
-    startResource(AC_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourceProperty);
+    std::thread esThread(ESWorkerThreadRoutine, ssid, password);
+    esThread.detach();
 
-    SampleResource::setDeviceInfo(ENGLISH_NAME_VALUE, vector<string>{Device_TYPE_LIGHT, Device_TYPE_VENDOR}, g_ocfVer);
+    std::cout << "WiFiConfProvCbInApp OUT" << std::endl;
 }
 
-void createTvDevice(bool secured)
+void onDevConfProvReceived(ESDevConfData *eventData)
 {
-    cout << "Creating TV Device Resources!!" << endl;
-    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecure(secured);
+    std::cout << "DevConfProvCbInApp IN" << std::endl;
 
-    startResource(TV_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourceProperty);
-    startResource(TV_MEDIA_SOURCE_LIST_URI, MEDIA_SOURCE_LIST_RESOURCE_TYPE, resourceProperty, ResponseTimeType::SLOW);
-    startResource(TV_AUDIO_URI, AUDIO_RESOURCE_TYPE, resourceProperty);
+    if (eventData == NULL)
+    {
+        std::cout << "ESDevConfData is NULL" << std::endl;
+        return ;
+    }
 
-    SampleResource::setDeviceInfo("Vendor Smart Home TV Device", Device_TYPE_TV, g_ocfVer);
+    std::cout << "DevConfProvCbInApp OUT" << std::endl;
 }
 
-void createResourceForIntrospection(bool secured)
+void updateLec()
 {
-    cout << "Creating AirCon Device Resources!!" << endl;
-    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecure(secured);
+    ESErrorCode errCode = ES_ERRCODE_NO_ERROR;
 
-    startResource(AC_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourceProperty);
-    startResource(AC_TEMPERATURE_URI, TEMPERATURE_RESOURCE_TYPE, resourceProperty)->setSensorTwin(
-        startTemperatureSensorResource(AC_SENSOR_URI, resourceProperty)
-    );
-    startResource(AC_DIMMING_URI, DIMMING_RESOURCE_TYPE, resourceProperty);
-    startResource(AC_CHROMA_URI, CHROMA_RESOURCE_TYPE, resourceProperty);
+    std::string errorCodeMenu =
+        "\tPlease select ErrorCode as reported by Enrollee and press Enter: \n"
+        "\t\t 0. Cancel update\n"
+        "\t\t 1. WiFi's SSID is not found\n"
+        "\t\t 2. WiFi's password is wrong\n"
+        "\t\t 3. IP Address not allocated\n"
+        "\t\t 4. No Internet Connection\n"
+        "\t\t 5. Timeout occured\n"
+        "\t\t 6. Cloud server is not reachable\n"
+        "\t\t 7. No response is arrived from cloud server\n"
+        "\t\t 8. Delivered authcode is not valid\n"
+        "\t\t 9. Given access token is not valid due to its expiration\n"
+        "\t\t 10. Refresh of expired access token is failed\n"
+        "\t\t 11. Target device is not discovered in cloud server\n"
+        "\t\t 12. Target user does not exist in cloud server\n"
+        "\t\t 13. Unsupported WiFi frequency\n";
+
+    switch(IUTSimulatorUtils::getSelectionFromUser(errorCodeMenu, "ErrorCode", 0, 13))
+    {
+        case 0:
+                return;
 
-    SampleResource::setDeviceInfo(ENGLISH_NAME_VALUE, vector<string>{Device_TYPE_AC, Device_TYPE_VENDOR}, g_ocfVer);
-}
+    /**
+     * Error Code that given WiFi's SSID is not found
+     */
+        case 1:
+                errCode = ES_ERRCODE_SSID_NOT_FOUND;
+                break;
 
-void createAirConDevice(bool secured)
-{
-    cout << "Creating AirCon Device Resources!!" << endl;
-    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecure(secured);
-    uint8_t resourcePropertyHidden = OC_ACTIVE | OC_OBSERVABLE | isSecure(secured);
+    /**
+     * Error Code that given WiFi's Password is wrong
+     */
+        case 2:
+                errCode = ES_ERRCODE_PW_WRONG;
+                break;
+    /**
+     * Error Code that IP address is not allocated
+     */
+        case 3:
+                errCode = ES_ERRCODE_IP_NOT_ALLOCATED;
+                break;
 
-    startResource(AC_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourceProperty);
-    startResource(AC_SWITCH_URI_CHILD, SWITCH_RESOURCE_TYPE, resourcePropertyHidden);
+    /**
+     * Error Code that there is no Internet connection
+     */
+        case 4:
+                errCode = ES_ERRCODE_NO_INTERNETCONNECTION;
+                break;
 
-    startResource(AC_TEMPERATURE_URI, TEMPERATURE_RESOURCE_TYPE, resourceProperty);
-    startResource(AC_TEMPERATURE_URI_CHILD, TEMPERATURE_RESOURCE_TYPE, resourcePropertyHidden);
+    /**
+     * Error Code that Timeout occured
+     */
+        case 5:
+                errCode = ES_ERRCODE_TIMEOUT;
+                break;
 
-    setlocale(LC_ALL, "");
-    startResource(AC_AIR_FLOW_URI, AIR_FLOW_RESOURCE_TYPE, resourceProperty);
-    startResource(AC_AIR_FLOW_URI_CHILD, AIR_FLOW_RESOURCE_TYPE, resourcePropertyHidden);
+    /**
+     * Error Code that cloud server is not reachable due to wrong URL of cloud server, for example.
+     */
+        case 6:
+                errCode = ES_ERRCODE_FAILED_TO_ACCESS_CLOUD_SERVER;
+                break;
 
-    setlocale(LC_ALL, "");
-    startTimerResourceWithLongLocation(AC_TIMER_URI, resourceProperty);
-    startTimerResourceWithLongLocation(AC_TIMER_URI_CHILD, resourcePropertyHidden);
+    /**
+     * Error Code that no response is arrived from cloud server
+     */
+       case 7:
+               errCode = ES_ERRCODE_NO_RESPONSE_FROM_CLOUD_SERVER;
+                break;
 
-    startResource(AC_SWING_URI, SWING_RESOURCE_TYPE, OC_ACTIVE | OC_DISCOVERABLE);
-    startResource(AC_SWING_URI_CHILD, SWING_RESOURCE_TYPE, resourcePropertyHidden);
+    /**
+     * Error Code that a delivered authcode is not valid.
+     */
+       case 8:
+                errCode = ES_ERRCODE_INVALID_AUTHCODE;
+                break;
 
-    startResource(AC_CON_URI, CON_RESOURCE_TYPE, OC_ACTIVE | OC_DISCOVERABLE | isSecure(secured));
+    /**
+     * Error Code that a given access token is not valid due to its expiration, for example.
+     */
+       case 9:
+                errCode = ES_ERRCODE_INVALID_ACCESSTOKEN;
+                break;
 
-    SampleResource::setDeviceInfo(ENGLISH_NAME_VALUE, vector<string>{Device_TYPE_AC, Device_TYPE_VENDOR}, g_ocfVer);
-}
+    /**
+     * Error Code that a refresh of expired access token is failed due to some reasons.
+     */
+       case 10:
+                errCode = ES_ERRCODE_FAILED_TO_REFRESH_ACCESSTOKEN;
+                break;
 
-void createExtraDevice(bool secured)
-{
-    cout << "Creating Extra Collection Device Resources!!" << endl;
-    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecure(secured);
+    /**
+     * Error Code that a target device is not discovered in cloud server
+     */
+       case 11:
+                errCode = ES_ERRCODE_FAILED_TO_FIND_REGISTERED_DEVICE_IN_CLOUD;
+                break;
 
-    startResource(EXTRA_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourceProperty);
-    startExtraLightResource(EXTRA_LIGHT_URI, resourceProperty);
+    /**
+     * Error Code that a target user does not exist in cloud server.
+     */
+       case 12:
+                errCode = ES_ERRCODE_FAILED_TO_FIND_REGISTERED_USER_IN_CLOUD;
+                break;
 
-    if (g_isExtraDeviceCreated == false)
-    {
-        g_extraLightCollection = new SampleCollection();
-        g_extraLightCollection->setResourceProperties(EXTRA_COLLECTION_URI, GROUP_TYPE_DEFAULT, LINK_INTERFACE);
-        g_extraLightCollection->setResourceRepresentation(
-            IUTSimulatorUtils::createRepresentation({
-                {NAME_KEY, string(ENGLISH_NAME_VALUE)},
-                {DEVICE_ID_KEY, g_di},
-                {ICV_KEY, string(CORE_SPEC_VERSION)},
-                {DMV_KEY, string(RESOURCE_TYPE_SPEC_VERSION) + "," + string(SMART_HOME_SPEC_VERSION)},
-                {PIID_KEY, string(PLATFORM_ID)}
-        }));
-        g_extraLightCollection->setDI(g_di);
-        g_extraLightCollection->setIPVer(g_ipVer);
-        g_extraLightCollection->setSecured(true);
-        g_extraLightCollection->setName(ENGLISH_NAME_VALUE);
+    /**
+     * Error Code that an enrollee can not connect to a target WiFi AP because the AP resides in
+     * an unsupported WiFi frequency.
+     */
+       case 13:
+                errCode = ES_ERRCODE_UNSUPPORTED_WIFI_FREQUENCY;
+                break;
 
-        if (g_extraLightCollection->startResource(resourceProperty) == OC_STACK_OK)
-        {
-            cout << "Extra Light Resource created successfully" << endl;
-            g_extraLightCollection->addResourceType(Device_TYPE_LIGHT);
-            g_extraLightCollection->addResourceInterface(READ_ONLY_INTERFACE);
-            g_extraLightCollection->addResourceInterface(DEFAULT_INTERFACE);
-            g_extraLightCollection->addChild(
-                startResource(EXTRA_BRIGHTNESS_URI, BRIGHTNESS_RESOURCE_TYPE, resourceProperty)
-            );
-            g_isExtraDeviceCreated = true;
-        }
-        else
-        {
-            cout << "Unable to create Extra Collection" << endl;
-        }
+       default:
+                errCode = ES_ERRCODE_UNKNOWN;
+                break;
     }
-
-    SampleResource::setDeviceInfo(ENGLISH_NAME_VALUE);
+    ESSetErrorCode(errCode);
 }
 
-void createVendorDefinedDevice(bool secured)
+void setDeviceWESInfo()
 {
-    cout << "Creating AirCon Device Resources!!" << endl;
-    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecure(secured);
-    uint8_t resourcePropertyHidden = OC_ACTIVE | OC_OBSERVABLE | isSecure(secured);
-
-    setlocale(LC_ALL, "");
-    startResource(AC_TIMER_URI, TIMER_RESOURCE_TYPE, resourceProperty, ResponseTimeType::SLOW);
-    startResource(AC_TIMER_URI_CHILD, TIMER_RESOURCE_TYPE, resourcePropertyHidden, ResponseTimeType::SLOW);
-
-    startVendorSwingResource(AC_SWING_URI, resourceProperty);
-    startVendorSwingResource(AC_SWING_URI, resourcePropertyHidden);
+    std::cout << "SetDeviceInfo IN" << std::endl;
+    ESDeviceProperty deviceProperty =
+    {
+        {
+            {WIFI_11G, WIFI_11N, WIFI_11AC},3,
+            {WIFI_24G, WIFI_5G},2,
+            {WPA_PSK, WPA2_PSK},2,
+            {AES,TKIP_AES},2
+        },
+        { "Test Device"}
+    };
 
-    SampleResource::setDeviceInfo("Vendor Defined System Server", Device_TYPE_VENDOR, g_ocfVer);
-}
+    // Set user properties if needed
+    char userValue_str[] = "user_str";
+    g_userProperties.userValue_int = 0;
 
-void createManyLightResources()
-{
-    cout << "Creating many Light Resources!!" << endl;
-    int lightCount = 2;
+    strncpy(g_userProperties.userValue_str, userValue_str, strlen(userValue_str) + 1);
+    SetUserProperties(&g_userProperties);
 
-    for (int i = 0; i < MAX_LIGHT_RESOURCE_COUNT; i++)
+    if (ESSetDeviceProperty(&deviceProperty) == ES_ERROR)
     {
-        startResource("/device/light-" + to_string(lightCount++), RESOURCE_TYPE_LIGHT, OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE);
+        std::cout << "ESSetDeviceProperty Error" << std::endl;
     }
+
+    std::cout << "SetDeviceInfo OUT" << std::endl;
 }
 
-void publishResourcesToRD()
+void prepareForWES(bool secured)
 {
-    ResourceHandles handlesToPublish;
-    for (std::shared_ptr< SampleResource > resource : g_createdResourceList)
-    {
-        handlesToPublish.push_back(resource->getResourceHandle());
-    }
+    std::cout << "Getting ready for Wifi Easy SetuUp" << std::endl;
+    std::cout << "Please wait patiently..." << std::endl;
+
+    ESResourceMask resourcemMask = (ESResourceMask) (ES_WIFICONF_RESOURCE | ES_DEVCONF_RESOURCE);
+
+    g_esCallbacks.WiFiConfProvCb = &onWiFiConfProvReceived;
+    g_esCallbacks.DevConfProvCb = &onDevConfProvReceived;
 
-    if (g_rdServerHosts.size() > 0)
+    if (ESInitEnrollee(secured, resourcemMask, g_esCallbacks) != ES_OK)
     {
-        for ( string rdHost : g_rdServerHosts)
-        {
-            cout << "Publishingg all resources to RD Host: " << rdHost << endl;
-            RDClient::Instance().publishResourceToRD( rdHost, g_ipVer, handlesToPublish, &onResourcePublished);
-        }
+        std::cout << "Unable to initiate device to be Wifi Easy SetUp ready!!" << std::endl;
     }
     else
     {
-        cout << "No RD server available" << endl;
+        std::cout << "Device is now ready for Wifi Easy SetUp" << std::endl;
     }
+
 }
 
-void updateResourcesToRD()
+void publishResourcesToRD()
 {
     ResourceHandles handlesToPublish;
-    g_createdResourceList.at(0)->addResourceType("x.org.vendor.type.random");
-    handlesToPublish.push_back(g_createdResourceList.at(0)->getResourceHandle());
+    for (std::shared_ptr< SampleResource > resource : g_createdResourceList)
+    {
+        handlesToPublish.push_back(resource->getResourceHandle());
+    }
 
-    if (g_rdServerHosts.size() > 0)
+    std::vector< std::shared_ptr< OCResource > > rdResources =
+        IUTSimulatorUtils::getResourcesWithResourceTypes(g_foundResourceList, {OC_RSRVD_RESOURCE_TYPE_RDPUBLISH, OC_RSRVD_RESOURCE_TYPE_RD});
+
+    if (!rdResources.empty())
     {
-        for ( string rdHost : g_rdServerHosts)
+        for (std::shared_ptr< OCResource > rdResource : rdResources)
         {
-            cout << "Publishingg all resources to RD Host: " << rdHost << endl;
-            RDClient::Instance().publishResourceToRD( rdHost, g_ipVer, handlesToPublish,
-                    &onResourcePublished);
+            for (std::string rdHost : rdResource->getAllHosts())
+            {
+                std::cout << "Publishingg all resources to RD Host: " << rdHost << std::endl;
+                RDClient::Instance().publishResourceToRD(rdHost, CT_DEFAULT, handlesToPublish, &onResourcePublished);
+            }
         }
     }
     else
     {
-        cout << "No RD server available" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "No RD server available!");
     }
 }
 
@@ -1614,1510 +1605,967 @@ void deleteResourcesFromRD()
         handlesToDelete.push_back(resource->getResourceHandle());
     }
 
-    if (g_rdServerHosts.size() > 0)
+    std::vector< std::shared_ptr< OCResource > > rdResources =
+        IUTSimulatorUtils::getResourcesWithResourceTypes(g_foundResourceList, {OC_RSRVD_RESOURCE_TYPE_RDPUBLISH, OC_RSRVD_RESOURCE_TYPE_RD});
+
+    if (!rdResources.empty())
     {
-        for ( string rdHost : g_rdServerHosts)
+        for (std::shared_ptr< OCResource > rdResource : rdResources)
         {
-            cout << "Publishingg all resources to RD Host: " << rdHost << endl;
-            RDClient::Instance().deleteResourceFromRD( rdHost, g_ipVer, handlesToDelete, &onResourceRemoved);
+            for (std::string rdHost : rdResource->getAllHosts())
+            {
+                std::cout << "Publishingg all resources to RD Host: " << rdHost << std::endl;
+                RDClient::Instance().deleteResourceFromRD(rdHost, CT_DEFAULT, handlesToDelete, &onResourceRemoved);
+            }
         }
     }
     else
     {
-        cout << "No RD server available" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "No RD server available!");
     }
 }
 
-void createGroup(string groupType)
+bool startResource(const std::shared_ptr<SampleResource>& resource)
 {
-    if (g_isGroupCreated)
-    {
-        cout << "Group already created!!" << endl;
-    }
-    else
+    if (!IUTSimulatorUtils::getResourceByURI(g_createdResourceList, resource->getUri()))
     {
-        try
-        {
-            string resourceURI = COLLECTION_RESOURCE_URI;
-            string resourceInterface = BATCH_INTERFACE;
-            uint8_t collectionProperty = OC_ACTIVE | OC_DISCOVERABLE;
-            if (g_isSecuredServer)
-            {
-                collectionProperty = collectionProperty | OC_SECURE;
-            }
+        std::cout << "Creating " << resource->getUri() << " Resource!" << std::endl;
 
-            g_vendorCollectionResource = new SampleCollection();
-            g_vendorCollectionResource->setResourceProperties(resourceURI, groupType, LINK_INTERFACE);
-            g_vendorCollectionResource->setResourceRepresentation(IUTSimulatorUtils::createRepresentation());
-            g_vendorCollectionResource->setDI(g_di);
-            g_vendorCollectionResource->setIPVer(g_ipVer);
-            g_vendorCollectionResource->setSecured(true);
-            g_vendorCollectionResource->setName(ENGLISH_NAME_VALUE);
-
-            if (g_vendorCollectionResource->startResource(collectionProperty) == OC_STACK_OK)
-            {
-                cout << "Successfully Created Group!!" << endl;
-                g_vendorCollectionResource->addResourceType(GROUP_TYPE_AIRCON_VENDOR);
-                g_vendorCollectionResource->addResourceInterface(BATCH_INTERFACE);
-                g_vendorCollectionResource->addResourceInterface(DEFAULT_INTERFACE);
-                g_isGroupCreated = true;
-            }
-            else
-            {
-                cout << "Unable to create Extra Collection" << endl;
-            }
-
-            if (g_createdResourceList.size() > 0)
-            {
-                for (shared_ptr< SampleResource > resource : g_createdResourceList)
-                {
-                    if (resource->getUri().find("Children") != string::npos)
-                    {
-                        cout << "Joining resource " << resource->getUri()
-                                << " to vendor handled group" << endl;
-                        g_vendorCollectionResource->addChild(resource);
-                    }
-                    else if (resource->getUri().find("Child") != string::npos)
-                    {
-                        cout << "Joining resource " << resource->getUri()
-                                << " to vendor handled group" << endl;
-                    }
-                }
+        if (resource->startResource() == OC_STACK_OK)
+        {
+            std::cout << resource->getUri() << " Resource created successfully!" << std::endl;
+            g_createdResourceList.push_back(resource);
 
-            }
+            return true;
         }
-        catch (OCException& e)
+        else
         {
-            oclog() << "Exception in main: " << e.what();
-            g_isGroupCreated = false;
-            cout << "Unable to Create Group!!" << endl;
+            std::cout << "Unable to create " << resource->getUri() << " Resource!" << std::endl;
         }
-
+    }
+    else
+    {
+        std::cout << "Resource with URI \"" << resource->getUri() << "\" is already created!" << std::endl;
     }
 
+    return false;
 }
 
-void deleteGroup()
+std::shared_ptr< SampleResource > startResource(
+    const std::string& resourceUri,
+    const std::string& resourceType,
+    const std::string& resourceInterface,
+    const uint8_t& resourceProperty,
+    const ResponseTimeType& responseTimeType,
+    const HandlerType& handlerType)
 {
-    if (g_isGroupCreated)
+    if (!IUTSimulatorUtils::getResourceByURI(g_createdResourceList, resourceUri))
     {
-        try
+        std::cout << "Creating " << resourceUri << " Resource!" << std::endl;
+        std::shared_ptr< SampleResource > resource = SampleResourceFactory::createResource(
+            resourceUri,
+            resourceType,
+            resourceInterface,
+            resourceProperty
+        );
+        resource->setResponseTimeType(responseTimeType);
+
+        if (resource->startResource(resourceProperty, handlerType) == OC_STACK_OK)
         {
-            OCStackResult result = OCPlatform::unregisterResource(g_collectionHandle);
-            if (result == OC_STACK_OK)
-            {
-                cout << "Successfully Deleted Group!!" << endl;
-                g_isGroupCreated = false;
-            }
-            else
-            {
-                cout << "Unable to delete group!!" << endl;
-            }
+            std::cout << resourceUri << " Resource created successfully!" << std::endl;
+            g_createdResourceList.push_back(resource);
+
+            return resource;
         }
-        catch (exception& e)
+        else
         {
-            std::cout << "Exception occurred while deleting group, exception is :  " << e.what()
-                    << std::endl;
+            std::cout << "Unable to create " << resourceUri << " Resource!" << std::endl;
         }
-
     }
     else
     {
-        cout << "No group exists to delete!!" << endl;
+        std::cout << "Resource with URI \"" << resourceUri<< "\" is already created!" << std::endl;
     }
 
-    while (g_handleList.size() > 0)
-    {
-        int index = g_handleList.size() - 1;
-        OCPlatform::unregisterResource(g_handleList[index]);
-        g_handleList.pop_back();
-    }
+    return nullptr;
 }
 
-void deleteCreatedResource()
+std::shared_ptr< SampleResource > startResource(
+    const std::string& resourceUri,
+    const std::string& resourceType,
+    const std::string& resourceInterface,
+    const uint8_t& resourceProperty,
+    const HandlerType& handlerType)
 {
-    while (g_handleList.size() > 0)
-    {
-        int index = g_handleList.size() - 1;
-        OCPlatform::unregisterResource(g_handleList[index]);
-        g_handleList.pop_back();
-    }
-
-    g_createdResourceList.clear();
+    return startResource(resourceUri, resourceType, "", resourceProperty, ResponseTimeType::NORMAL, handlerType);
 }
 
-void findResource(string resourceType, string host)
+std::shared_ptr< SampleResource > startResource(
+    const std::string& resourceUri,
+    const std::string& resourceType,
+    const uint8_t& resourceProperty,
+    const ResponseTimeType& responseTimeType,
+    const HandlerType& handlerType)
 {
-    g_foundResourceList.clear();
-    std::ostringstream requestURI;
-
-    try
-    {
-        // makes it so that all boolean values are printed as 'true/false' in this stream
-        std::cout.setf(std::ios::boolalpha);
-        // Find all resources
-        requestURI << OC_RSRVD_WELL_KNOWN_URI << resourceType;
-
-        OCPlatform::findResource(host, requestURI.str(), OCConnectivityType::CT_DEFAULT,
-                &onResourceFound, g_qos);
-        cout << "Finding Resource...." << endl;
+    return startResource(resourceUri, resourceType, "", resourceProperty, responseTimeType, handlerType);
+}
 
-    }
-    catch (OCException &e)
-    {
-        oclog() << "Exception in main: " << e.what();
-    }
-    waitForCallback();
+std::shared_ptr< SampleResource > startResource(
+    const std::string& resourceUri,
+    const std::string& resourceType,
+    const uint8_t& resourceProperty,
+    const HandlerType& handlerType)
+{
+    return startResource(resourceUri, resourceType, "", resourceProperty, ResponseTimeType::NORMAL, handlerType);
 }
 
-void findCollection(string collectionType)
+std::shared_ptr< SampleResource > startTemperatureSensorResource(const std::string& sensorUri, const uint8_t& sensorResourceProperty)
 {
-    g_foundCollectionList.clear();
-    ostringstream requestURI;
+    std::shared_ptr< SampleResource > temperatureSensorResource = std::make_shared< SampleResource >(
+        sensorUri,
+        TEMPERATURE_RESOURCE_TYPE,
+        TEMPERATURE_SENSOR_INTERFACE,
+        sensorResourceProperty,
+        IUTSimulatorUtils::createRepresentation({
+            {UNITS_KEY, std::string(UNITS_VALUE)},
+            {TEMPERATURE_KEY, DEFAULT_TEMPERATURE_VALUE}
+        })
+    );
+    temperatureSensorResource->setAsReadOnly(UNITS_KEY);
+    temperatureSensorResource->setAsReadOnly(TEMPERATURE_KEY);
 
-    try
+    if (startResource(temperatureSensorResource))
     {
-        // makes it so that all boolean values are printed as 'true/false' in this stream
-        std::cout.setf(std::ios::boolalpha);
-        // Find all colletion
-        requestURI << OC_RSRVD_WELL_KNOWN_URI << "?rt=" << collectionType;
-
-        OCPlatform::findResource("", requestURI.str(), OCConnectivityType::CT_DEFAULT,
-                &onCollectionFound, g_qos);
-        cout << "Finding Collection...." << endl;
-
+        return temperatureSensorResource;
     }
-    catch (OCException &e)
+    else
     {
-        oclog() << "Exception when finding collection: " << e.what();
+        return nullptr;
     }
-    waitForCallback();
 }
 
-void findAllResources(string host, string query)
+std::shared_ptr< SampleResource > startTimerResourceWithLongLocation(const std::string& resourceUri, const uint8_t& resourceProperty)
 {
-    g_foundResourceList.clear();
-    std::ostringstream requestURI;
+    std::shared_ptr< SampleResource > timerResource = SampleResourceFactory::createResource(
+        resourceUri,
+        TIMER_RESOURCE_TYPE,
+        resourceProperty
+    );
+    timerResource->updateRepresentation(TIMER_LOCATION_KEY, std::string(VERY_BIG_VALUE));
+    timerResource->setResponseTimeType(ResponseTimeType::SLOW);
 
-    try
+    if (startResource(timerResource))
     {
-        // makes it so that all boolean values are printed as 'true/false' in this stream
-        std::cout.setf(std::ios::boolalpha);
-        // Find all resources
-        if (query.compare("") == 0)
-        {
-            requestURI << OC_RSRVD_WELL_KNOWN_URI;
-        }
-        else
-        {
-            requestURI << OC_RSRVD_WELL_KNOWN_URI << "?" << query;
-        }
-
-        OCPlatform::findResource(host, requestURI.str(), OCConnectivityType::CT_DEFAULT,
-                &onResourceFound, g_qos);
-        cout << "Finding Resource...." << endl;
-
+        return timerResource;
     }
-    catch (OCException &e)
+    else
     {
-        oclog() << "Exception in main: " << e.what();
+        return nullptr;
     }
-    waitForCallback();
 }
 
-void discoverIntrospection(bool isMulticast)
+std::shared_ptr< SampleResource > startVendorSwingResource(const std::string& resourceUri, const uint8_t& resourceProperty)
 {
-    string host = "";
-    g_hasCallbackArrived = false;
-    ostringstream introspectionDiscoveryRequest;
-    if (isMulticast)
+    std::shared_ptr< SampleResource > vendorSwingResource = SampleResourceFactory::createResource(
+        resourceUri,
+        SWING_RESOURCE_TYPE,
+        resourceProperty
+    );
+    vendorSwingResource->setResourceRepresentation(
+        IUTSimulatorUtils::createRepresentation({
+            {"x.com.vendor.swing.on", false},
+            {"x.com.vendor.swing.blade.movement.direction", std::string("horizontal")},
+            {"x.com.vendor.swing.supported.direction", std::vector<std::string>{"horizontal", "vertical"}}
+        })
+    );
+    vendorSwingResource->setAsReadOnly("x.com.vendor.swing.supported.direction");
+
+    if (startResource(vendorSwingResource))
     {
-        introspectionDiscoveryRequest << "rt=" << OC_RSRVD_RESOURCE_TYPE_INTROSPECTION;
-        cout << "Discovering Introspection using Multicast... " << endl;
+        return vendorSwingResource;
     }
-    findAllResources(host, introspectionDiscoveryRequest.str());
-
-    if (g_foundResourceList.size() == 0)
+    else
     {
-        cout << "No resource found!!" << endl;
+        return nullptr;
     }
 }
 
-void discoverDevice(bool isMulticast)
+void createSampleCollection(bool secured)
 {
-    string host = "";
-    g_hasCallbackArrived = false;
-    ostringstream deviceDiscoveryRequest;
-    string deviceDiscoveryURI = "/oic/d";
-    OCStackResult result = OC_STACK_ERROR;
+    std::cout << "Creating Batch Collection!!" << std::endl;
+    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecured(secured);
+    uint8_t resourcePropertyHidden = OC_ACTIVE | OC_OBSERVABLE | isSecured(secured);
 
-    if (isMulticast)
-    {
-        deviceDiscoveryRequest << OC_MULTICAST_PREFIX << deviceDiscoveryURI;
-        cout << "Discovering Device using Multicast... " << endl;
-    }
-    else
+    if (g_isSampleCollectionCreated == false)
     {
-        if (g_foundResourceList.size() == 0)
-        {
-            cout << "Finding OIC Servers to send Unicast Discovery Request" << endl;
-            findAllResources();
-        }
+        g_sampleCollection = new SampleCollection();
+        g_sampleCollection->setResourceProperties(COLLECTION_URI, GROUP_TYPE_DEFAULT, LINK_INTERFACE);
+        g_sampleCollection->setDI(ResourceServer::getDeviceID());
+        g_sampleCollection->setIPVer(CT_DEFAULT);
+        g_sampleCollection->setSecured(true);
+        g_sampleCollection->setName("Sample Collection Device");
 
-        g_hasCallbackArrived = false;
-        if (g_foundResourceList.size() > 0)
+        if (g_sampleCollection->startResource(resourceProperty, HandlerType::DEFAULT) == OC_STACK_OK)
         {
-            host = g_foundResourceList.at(0)->host();
-            deviceDiscoveryRequest << deviceDiscoveryURI;
-            cout << "Discovering Device using Unicast... " << endl;
-            cout << "Sending Unicast device discovery to the host: " << host << endl;
+            std::cout << "Batch collection created successfully" << std::endl;
+            g_sampleCollection->addResourceInterface(DEFAULT_INTERFACE);
+            g_sampleCollection->addResourceInterface(BATCH_INTERFACE);
+            g_sampleCollection->addChild(
+                startResource(COLLECTION_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourcePropertyHidden)
+            );
+            g_isSampleCollectionCreated = true;
         }
         else
         {
-            cout << "No server found to send Unicast device discovery" << endl;
-            cout << "Sending Multicast Device discovery request..." << endl;
-            deviceDiscoveryRequest << OC_MULTICAST_PREFIX << deviceDiscoveryURI;
+            std::cout << "Unable to create Batch Collection" << std::endl;
         }
-
     }
-
-    try
+    else
     {
-        result = OCPlatform::getDeviceInfo(host, deviceDiscoveryRequest.str(),
-                OCConnectivityType::CT_DEFAULT, &onDeviceInfoReceived);
+        std::cout << "Already Batch Collection is created!!" << std::endl;
+    }
+}
 
-        if (result == OC_STACK_OK)
-        {
-            cout << "Device discovery done successfully" << endl;
-            waitForCallback();
-        }
-        else
-        {
-            cout << "Device discovery failed." << endl;
-        }
+void createResourcesForTvDevice(bool secured)
+{
+    std::cout << "Creating TV Device Resources!!" << std::endl;
+    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecured(secured);
 
-    }
-    catch (OCException& e)
-    {
-        cerr << "Exception occurred while discovering device, reason is: " << e.reason() << endl;
-    }
+    startResource(TV_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourceProperty);
+    startResource(TV_MEDIA_SOURCE_LIST_URI, MEDIA_SOURCE_LIST_RESOURCE_TYPE, resourceProperty, ResponseTimeType::SLOW);
+    startResource(TV_AUDIO_URI, AUDIO_RESOURCE_TYPE, resourceProperty);
+}
+
+void createAirConResources_Type1(bool secured)
+{
+    std::cout << "Creating AirCon Resource!!" << std::endl;
+    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecured(secured);
 
+    startResource(AC_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourceProperty);
 }
-void discoverPlatform(bool isMulticast)
+
+void createAirConResources_Type2(bool secured)
 {
-    string host = "";
-    ostringstream platformDiscoveryRequest;
-    string platformDiscoveryURI = "/oic/p";
+    std::cout << "Creating AirCon Resources!!" << std::endl;
+    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecured(secured);
+    uint8_t resourcePropertyHidden = OC_ACTIVE | OC_OBSERVABLE | isSecured(secured);
 
-    if (isMulticast)
-    {
-        platformDiscoveryRequest << OC_MULTICAST_PREFIX << platformDiscoveryURI;
-        cout << "Discovering Platform using Multicast... " << endl;
+    startResource(AC_TIMER_URI, TIMER_RESOURCE_TYPE, resourceProperty, ResponseTimeType::SLOW);
+    startResource(AC_TIMER_URI_CHILD, TIMER_RESOURCE_TYPE, resourcePropertyHidden, ResponseTimeType::SLOW);
 
-    }
-    else
-    {
-        if (g_foundResourceList.size() == 0)
-        {
-            findAllResources();
-            g_hasCallbackArrived = false;
-        }
+    startVendorSwingResource(AC_SWING_URI, resourceProperty);
+    startVendorSwingResource(AC_SWING_URI, resourcePropertyHidden);
+}
 
-        host = g_foundResourceList.at(0)->host();
-        platformDiscoveryRequest << platformDiscoveryURI;
-        cout << "Discovering Platform using Unicast... " << endl;
-    }
+void createAirConResources_Type3(bool secured)
+{
+    std::cout << "Creating AirCon Resources!!" << std::endl;
+    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecured(secured);
+    uint8_t resourcePropertyHidden = OC_ACTIVE | OC_OBSERVABLE | isSecured(secured);
 
-    try
-    {
-        OCStackResult ret = OC_STACK_ERROR;
-        ret = OCPlatform::getPlatformInfo(host, platformDiscoveryRequest.str(),
-                OCConnectivityType::CT_DEFAULT, &onPlatformInfoReceived);
+    startResource(AC_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourceProperty);
+    startResource(AC_SWITCH_URI_CHILD, SWITCH_RESOURCE_TYPE, resourcePropertyHidden);
 
-        cout << "Platform discovery ";
-        if (ret == OC_STACK_OK)
-        {
-            cout << "done." << endl;
-            waitForCallback();
-        }
-        else
-        {
-            cout << "failed." << endl;
-        }
+    startResource(AC_TEMPERATURE_URI, TEMPERATURE_RESOURCE_TYPE, resourceProperty);
+    startResource(AC_TEMPERATURE_URI_CHILD, TEMPERATURE_RESOURCE_TYPE, resourcePropertyHidden);
 
-    }
-    catch (OCException& e)
-    {
-        cerr << "Failure in main thread: " << e.reason() << endl;
-    }
+    startResource(AC_AIR_FLOW_URI, AIR_FLOW_RESOURCE_TYPE, resourceProperty);
+    startResource(AC_AIR_FLOW_URI_CHILD, AIR_FLOW_RESOURCE_TYPE, resourcePropertyHidden);
+
+    startTimerResourceWithLongLocation(AC_TIMER_URI, resourceProperty);
+    startTimerResourceWithLongLocation(AC_TIMER_URI_CHILD, resourcePropertyHidden);
+
+    startResource(AC_SWING_URI, SWING_RESOURCE_TYPE, OC_ACTIVE | OC_DISCOVERABLE);
+    startResource(AC_SWING_URI_CHILD, SWING_RESOURCE_TYPE, resourcePropertyHidden);
+
+    startResource(AC_CON_URI, CON_RESOURCE_TYPE, OC_ACTIVE | OC_DISCOVERABLE | isSecured(secured));
 }
 
-void sendGetRequest()
+void createExtraDevice(bool secured)
 {
-    std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
+    std::cout << "Creating Extra Collection Device Resources!!" << std::endl;
+    uint8_t resourceProperty = OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecured(secured);
 
-    if (selectedResource)
+    startResource(EXTRA_SWITCH_URI, SWITCH_RESOURCE_TYPE, resourceProperty);
+    startResource(EXTRA_LIGHT_URI, Device_TYPE_LIGHT, resourceProperty);
+
+    if (g_isExtraDeviceCreated == false)
     {
-        IUTSimulatorUtils::setResourceHostEndpointFromUser(selectedResource, g_isSecuredClient);
-        cout << "Sending Get Request to the resource with: " << selectedResource->host() << selectedResource->uri() << endl;
+        g_extraLightCollection = new SampleCollection();
+        g_extraLightCollection->setResourceProperties(EXTRA_COLLECTION_URI, GROUP_TYPE_DEFAULT, LINK_INTERFACE);
+        g_extraLightCollection->setResourceRepresentation(
+            IUTSimulatorUtils::createRepresentation({
+                {NAME_KEY, std::string(VENDOR_AIR_CON_DEVICE_NAME)},
+                {DEVICE_ID_KEY, ResourceServer::getDeviceID()},
+                {ICV_KEY, std::string(CORE_SPEC_VERSION)},
+                {DMV_KEY, std::string(RESOURCE_TYPE_SPEC_VERSION) + "," + std::string(SMART_HOME_SPEC_VERSION)},
+                {PIID_KEY, std::string(PLATFORM_ID)}
+        }));
+        g_extraLightCollection->setDI(ResourceServer::getDeviceID());
+        g_extraLightCollection->setIPVer(CT_DEFAULT);
+        g_extraLightCollection->setSecured(true);
+        g_extraLightCollection->setName(VENDOR_AIR_CON_DEVICE_NAME);
 
-        if (selectedResource->getResourceTypes().front().compare(OC_RSRVD_RESOURCE_TYPE_INTROSPECTION) == 0)
+        if (g_extraLightCollection->startResource(resourceProperty) == OC_STACK_OK)
+        {
+            std::cout << "Extra Light Resource created successfully" << std::endl;
+            g_extraLightCollection->addResourceType(Device_TYPE_LIGHT);
+            g_extraLightCollection->addResourceInterface(READ_ONLY_INTERFACE);
+            g_extraLightCollection->addResourceInterface(DEFAULT_INTERFACE);
+            g_extraLightCollection->addChild(
+                startResource(EXTRA_BRIGHTNESS_URI, BRIGHTNESS_RESOURCE_TYPE, OC_ACTIVE | OC_OBSERVABLE | isSecured(secured))
+            );
+            g_isExtraDeviceCreated = true;
+        }
+        else
         {
-            g_introspectionResource->setHost(selectedResource->host());
+            std::cout << "Unable to create Extra Collection" << std::endl;
         }
-
-        QueryParamsMap qpMap;
-        selectedResource->get(qpMap, onGet, g_qos);
-        cout << "GET request sent!!" << endl;
     }
 }
 
-void sendGetRequestWithQuery(string key, string value)
+void createManyLightResources(bool secured)
 {
-    std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
-
-    if (selectedResource)
-    {
-        QueryParamsMap qpMap;
-        qpMap[key] = value;
-        selectedResource->get(qpMap, onGet, g_qos);
-        cout << "GET request sent!!" << endl;
-        waitForCallback();
+    std::cout << "Creating many Light Resources!!" << std::endl;
+    int lightCount = 2;
 
-    }
-    else
+    for (int i = 0; i < MAX_LIGHT_RESOURCE_COUNT; i++)
     {
-        cout << "No resource to send GET!!" << endl;
+        startResource("/device/light-" + to_string(lightCount++), RESOURCE_TYPE_LIGHT, OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecured(secured));
     }
 }
 
-void sendPutRequestUpdate()
+void updateCreatedResource()
 {
-    std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
+    std::shared_ptr< SampleResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_createdResourceList);
 
     if (selectedResource)
     {
-        cout << "Sending Complete Update Message(PUT)..." << endl;
+        OCRepresentation representation = selectedResource->getRepresentation();
 
-        OCRepresentation representation =
-            IUTSimulatorUtils::createRepresentation({
-                {"region", string("Rajshahi, Bangladesh")},
-                {POWER_KEY, string("on")},
-                {INTENSITY_KEY, string("50")},
-                {MANUFACTURER_KEY, string("SRBD")}
-        });
+        std::string attributeKey = InputHandler::getInputFromUser<std::string>("Please provide Attribute Key:");
 
-        selectedResource->put(representation, QueryParamsMap(), &onPut, g_qos);
-        cout << "PUT request sent!!" << endl;
-        waitForCallback();
+        if (representation.hasAttribute(attributeKey))
+        {
+            representation.setValue(attributeKey, IUTSimulatorUtils::getAttributeValueFromUser());
+            selectedResource->setResourceRepresentation(representation);
+            std::cout << "Successfully updated resource attribute!!" << std::endl;
+            ResourceHelper::getInstance()->printRepresentation(representation);
+            selectedResource->notifyObservers();
+        }
+        else
+        {
+            InputHandler::setResponse(InputHandler::ResponseType::Error, "The resource does not have " + attributeKey + " attribute!");
+        }
     }
-    else
+    else if (g_createdResourceList.empty())
     {
-        cout << "No resource to send PUT!!" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "There are no created local resources!");
     }
 }
 
-void sendPutRequestCreate()
+void showCreatedResource()
 {
-    std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
+    std::shared_ptr< SampleResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_createdResourceList);
 
     if (selectedResource)
     {
-        cout << "Sending Create Resource Message(PUT)..." << endl;
-
-        OCRepresentation representation =
-            IUTSimulatorUtils::createRepresentation({
-                {POWER_KEY, string("off")},
-                {INTENSITY_KEY, string("0")}
-        });
-        representation.setUri("/new-device/created-light-1");
-        representation.setResourceTypes(vector<string>{"core.light"});
-
-        selectedResource->put(representation, QueryParamsMap(), &onPut, g_qos);
-        cout << "PUT request sent!!" << endl;
-        waitForCallback();
+        std::string payload = "Resource " + selectedResource->getUri() + " has the following representation:\n";
+        ResourceHelper::payloadToString(selectedResource->getRepresentation().getPayload(), payload);
 
+        InputHandler::setResponse(InputHandler::ResponseType::Info, payload);
     }
-    else
+    else if (g_createdResourceList.empty())
     {
-        cout << "No resource to send PUT!!" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "There are no created local resources!");
     }
 }
 
-void sendPostRequestUpdate()
+void sendDiscoveryRequest(QualityOfService qualityOfService)
 {
-    std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
-
-    if (selectedResource)
-    {
-        cout << "Sending Partial Update Message(POST)..." << endl;
-
-        OCRepresentation representation =
-            IUTSimulatorUtils::createRepresentation({
-                {REGION_KEY, string("Rajshahi, Bangladesh")},
-                {INTENSITY_KEY, 100}
-        });
+    std::string host = "";
+    std::string resourceTypeQuery = "";
 
-        selectedResource->post(representation, QueryParamsMap(), &onPost, g_qos);
-        cout << "POST request sent!!" << endl;
-        waitForCallback();
+    std::string sendDiscoveryMenu = "Choose way to send discovery request:\n"
+        "\t0. Cancel\n"
+        "\t1. Multicast\n"
+        "\t2. Unicast - select host\n";
 
-    }
-    else
+    switch (IUTSimulatorUtils::getSelectionFromUser(sendDiscoveryMenu, "option", 0, 2))
     {
-        cout << "No resource to send POST!!" << endl;
-    }
-}
+        case 0:
+            return;
 
-void updateGroup()
-{
-    cout << "Please select only Collection resource" << endl;
-    std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
+        case 1:
+            break;
 
-    if (selectedResource)
-    {
-        cout << "Sending Partial Update Message(POST) to Collection..." << endl;
+        case 2:
+            host = IUTSimulatorUtils::getEndpointFromUser();
 
-        OCRepresentation representation =
-            IUTSimulatorUtils::createRepresentation({
-                {RESOURCE_TYPE_KEY, string(RESOURCE_TYPE_ROOM)},
-                {INTERFACE_KEY, string("oic.if.baseline oic.if.b oic.mi.grp")},
-                {URI_KEY, string("/core/a/collection")}
-        });
-        representation.setChildren(
-            vector< OCRepresentation > {
-                IUTSimulatorUtils::createRepresentation({
-                    {INTENSITY_KEY, 100},
-                    {RESOURCE_TYPE_KEY, string("core.light")},
-                    {INTERFACE_KEY, string(ACTUATOR_INTERFACE)},
-                    {URI_KEY, string("/device/light-1")}
-                })
+            if (host.empty())
+            {
+                InputHandler::setResponse(InputHandler::ResponseType::Error, "Wrong input for host endpoint!");
+                return;
             }
-        );
-
-        selectedResource->post(RESOURCE_TYPE_ROOM, GROUP_INTERFACE, representation, QueryParamsMap(), &onPost, g_qos);
-        cout << "POST request sent!!" << endl;
-        waitForCallback();
-
+            break;
     }
-}
 
-void updateLec()
-{
-    ESErrorCode errCode = ES_ERRCODE_NO_ERROR;
+    std::string resourceTypeMenu = "Choose wanted option for Resource Type in requet query:\n"
+        "\t0. Cancel\n"
+        "\t1. Find all resources\n"
+        "\t2. Find resources with selected Resource Type\n";
 
-    cout << "Please select ErrorCode as reported by Enrollee and press Enter: " << endl;
-    cout << "\t\t 0. Cancel update" << endl;
-    cout << "\t\t 1. WiFi's SSID is not found" << endl;
-    cout << "\t\t 2. WiFi's password is wrong" << endl;
-    cout << "\t\t 3. IP Address not allocated" << endl;
-    cout << "\t\t 4. No Internet Connection" << endl;
-    cout << "\t\t 5. Timeout occured" << endl;
-    cout << "\t\t 6. Cloud server is not reachable" << endl;
-    cout << "\t\t 7. No response is arrived from cloud server" << endl;
-    cout << "\t\t 8. Delivered authcode is not valid" << endl;
-    cout << "\t\t 9. Given access token is not valid due to its expiration" << endl;
-    cout << "\t\t 10. Refresh of expired access token is failed" << endl;
-    cout << "\t\t 11. Target device is not discovered in cloud server" << endl;
-    cout << "\t\t 12. Target user does not exist in cloud server" << endl;
-    cout << "\t\t 13. Unsupported WiFi frequency" << endl;
-
-    switch(IUTSimulatorUtils::getSelectionFromUser("ErrorCode", 0, 13))
+    switch (IUTSimulatorUtils::getSelectionFromUser(resourceTypeMenu, "option", 0, 2))
     {
         case 0:
-                return;
+            return;
 
-    /**
-     * Error Code that given WiFi's SSID is not found
-     */
         case 1:
-                errCode = ES_ERRCODE_SSID_NOT_FOUND;
-                break;
+            break;
 
-    /**
-     * Error Code that given WiFi's Password is wrong
-     */
         case 2:
-                errCode = ES_ERRCODE_PW_WRONG;
-                break;
-    /**
-     * Error Code that IP address is not allocated
-     */
-        case 3:
-                errCode = ES_ERRCODE_IP_NOT_ALLOCATED;
-                break;
-
-    /**
-     * Error Code that there is no Internet connection
-     */
-        case 4:
-                errCode = ES_ERRCODE_NO_INTERNETCONNECTION;
-                break;
-
-    /**
-     * Error Code that Timeout occured
-     */
-        case 5:
-                errCode = ES_ERRCODE_TIMEOUT;
-                break;
-
-    /**
-     * Error Code that cloud server is not reachable due to wrong URL of cloud server, for example.
-     */
-        case 6:
-                errCode = ES_ERRCODE_FAILED_TO_ACCESS_CLOUD_SERVER;
-                break;
-
-    /**
-     * Error Code that no response is arrived from cloud server
-     */
-       case 7:
-               errCode = ES_ERRCODE_NO_RESPONSE_FROM_CLOUD_SERVER;
-                break;
-
-    /**
-     * Error Code that a delivered authcode is not valid.
-     */
-       case 8:
-                errCode = ES_ERRCODE_INVALID_AUTHCODE;
-                break;
-
-    /**
-     * Error Code that a given access token is not valid due to its expiration, for example.
-     */
-       case 9:
-                errCode = ES_ERRCODE_INVALID_ACCESSTOKEN;
-                break;
-
-    /**
-     * Error Code that a refresh of expired access token is failed due to some reasons.
-     */
-       case 10:
-                errCode = ES_ERRCODE_FAILED_TO_REFRESH_ACCESSTOKEN;
-                break;
-
-    /**
-     * Error Code that a target device is not discovered in cloud server
-     */
-       case 11:
-                errCode = ES_ERRCODE_FAILED_TO_FIND_REGISTERED_DEVICE_IN_CLOUD;
-                break;
-
-    /**
-     * Error Code that a target user does not exist in cloud server.
-     */
-       case 12:
-                errCode = ES_ERRCODE_FAILED_TO_FIND_REGISTERED_USER_IN_CLOUD;
-                break;
-
-    /**
-     * Error Code that an enrollee can not connect to a target WiFi AP because the AP resides in
-     * an unsupported WiFi frequency.
-     */
-       case 13:
-                errCode = ES_ERRCODE_UNSUPPORTED_WIFI_FREQUENCY;
-                break;
-
-       default:
-                errCode = ES_ERRCODE_UNKNOWN;
-                break;
+            resourceTypeQuery = "?rt=" + InputHandler::getInputFromUser<std::string>("Please provide Resource Type:");
+            break;
     }
-    ESSetErrorCode(errCode);
-}
-
-void updateLocalResource()
-{
-    std::shared_ptr< SampleResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_createdResourceList);
 
-    if (selectedResource)
+    try
     {
-        cout << "Please provide Attribute Key: ";
-        string attributeKey = IUTSimulatorUtils::getInputFromUser<string>();
+        g_areResourcesFound = false;
 
-        OCRepresentation representation = selectedResource->getRepresentation();
-        if (representation.hasAttribute(attributeKey))
+        if (OCPlatform::findResourceList(host, OC_RSRVD_WELL_KNOWN_URI + resourceTypeQuery, OCConnectivityType::CT_DEFAULT, &onResourceListFound, qualityOfService) == OC_STACK_OK)
         {
-            representation.setValue(attributeKey, IUTSimulatorUtils::getAttributeValueFromUser());
-            selectedResource->setResourceRepresentation(representation);
-            cout << "Successfully updated resource attribute!!" << endl;
-            ResourceHelper::getInstance()->printRepresentation(representation);
-            selectedResource->notifyObservers();
+            waitForCallback(g_areResourcesFound);
         }
         else
         {
-            cout << "The resource does not have the mentioned attribute" << endl;
+            InputHandler::setResponse(InputHandler::ResponseType::Error, "Failed to send discovery request!");
         }
-
     }
-    else
+    catch(OCException& e)
     {
-        cout << "No resource to Update!!" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "Exception: " + e.reason());
     }
 }
 
-void updateLocalResourceAutomatically()
+void showDeviceInfo()
 {
-    static bool binaryValue = false;
-    static double temperatureValue = 25;
-    static string directionValue = "left";
-    static int hourValue = 1;
-    static bool swingerValue = true;
+    std::string host = HttpResources::getDiscoveryEndpoints().at(0).first + ":" + HttpResources::getDiscoveryEndpoints().at(0).second;
 
-    std::shared_ptr< SampleResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_createdResourceList);
-    if (selectedResource)
+    try
     {
-        string attributeKey = "";
-        AttributeValue attributValue;
-
-        string uri = selectedResource->getUri();
+        g_hasDeviceInfoCallbackArrived = false;
 
-        if (!uri.compare(AC_SWITCH_URI) || !uri.compare(AC_SWITCH_URI_CHILD))
-        {
-            attributeKey = string(ON_OFF_KEY);
-            attributValue = binaryValue = !binaryValue;
-        }
-        else if (!uri.compare(AC_TEMPERATURE_URI) || !uri.compare(AC_TEMPERATURE_URI_CHILD)  || !uri.compare(AC_SENSOR_URI))
-        {
-            attributeKey = string(TEMPERATURE_KEY);
-            attributValue = temperatureValue =
-                    temperatureValue > 0 ? (temperatureValue - 26) : (temperatureValue + 26);
-        }
-        else if (!uri.compare(AC_AIR_FLOW_URI) || !uri.compare(AC_AIR_FLOW_URI_CHILD))
+        if (OCPlatform::getDeviceInfo(host, OC_RSRVD_DEVICE_URI, OCConnectivityType::CT_DEFAULT, &onDeviceInfoReceived) == OC_STACK_OK)
         {
-            attributeKey = string(DIRECTION_KEY);
-            attributValue = directionValue = directionValue.compare("left") ? "left" : "right";
+            waitForCallback(g_hasDeviceInfoCallbackArrived);
         }
-        else if (!uri.compare(AC_TIMER_URI) || !uri.compare(AC_TIMER_URI_CHILD))
-        {
-            attributeKey = string("x.com.vendor.timer.hour");
-            attributValue = (hourValue % 2) ? (hourValue * 2) : (hourValue / 2);
-        }
-        else if (!uri.compare(AC_SWING_URI) || !uri.compare(AC_SWING_URI_CHILD))
+        else
         {
-            attributeKey = string(SWING_STATE_KEY);
-            attributValue = swingerValue = !swingerValue;
+            InputHandler::setResponse(InputHandler::ResponseType::Error, "Failed to discover device");
         }
 
-        OCRepresentation representation = selectedResource->getRepresentation();
-        if (representation.hasAttribute(attributeKey))
+    }
+    catch (OCException& e)
+    {
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "Exception: " + e.reason());
+    }
+
+}
+void showPlatformInfo()
+{
+    std::string host = HttpResources::getDiscoveryEndpoints().at(0).first + ":" + HttpResources::getDiscoveryEndpoints().at(0).second;
+
+    try
+    {
+        g_hasPlatformInfoCallbackArrived = false;
+
+        if (OCPlatform::getPlatformInfo(host, OC_RSRVD_PLATFORM_URI, OCConnectivityType::CT_DEFAULT, &onPlatformInfoReceived) == OC_STACK_OK)
         {
-            representation.setValue(attributeKey, attributValue);
-            selectedResource->setResourceRepresentation(representation);
-            cout << "Successfully updated resource attribute!!" << endl;
-            ResourceHelper::getInstance()->printRepresentation(representation);
-            selectedResource->notifyObservers();
+            waitForCallback(g_hasPlatformInfoCallbackArrived);
         }
         else
         {
-            cout << "The resource does not have the mentioned attribute" << endl;
+            InputHandler::setResponse(InputHandler::ResponseType::Error, "Failed to discover platform");
         }
 
     }
-    else
+    catch (OCException& e)
     {
-        cout << "No resource to Update!!" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "Exception: " + e.reason());
     }
 }
 
-void sendPostRequestUpdateUserInput()
+void sendRequestToFoundResourceMenu(QualityOfService qualityOfService)
 {
-    std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
+    std::string requestMenu = "Select request type:\n"
+        "\t0. Cancel\n"
+        "\t1. Send Get Request\n"
+        "\t2. Send Post Request\n"
+        "\t3. Send Put Request\n"
+        "\t4. Send Delete Request\n"
+        "\t5. Send Observe Request\n"
+        "\t6. Send Cancel Observe Request\n";
 
-    if (selectedResource)
+    switch (IUTSimulatorUtils::getSelectionFromUser(requestMenu, "request type", 0, 6))
     {
-        IUTSimulatorUtils::setResourceHostEndpointFromUser(selectedResource, g_isSecuredClient);
+        case 0:
+            return;
 
-        cout << "Please provide Attribute Key: ";
-        OCRepresentation representation;
-        string key = IUTSimulatorUtils::getInputFromUser<string>();
-        AttributeValue value = IUTSimulatorUtils::getAttributeValueFromUser();
-        representation.setValue(key, value);
+        case 1:
+            sendGetRequest(qualityOfService);
+            break;
 
-        g_hasCallbackArrived = false;
+        case 2:
+            sendPostRequest(qualityOfService);
+            break;
 
-        cout << "Sending Partial Update Message(POST)..." << endl;
-        QueryParamsMap query;
-        query[INTERFACE_KEY] = DEFAULT_INTERFACE;
-        selectedResource->post(representation, query, &onPost, g_qos);
-        cout << "POST request sent!!" << endl;
-        waitForCallback();
-    }
-    else
-    {
-        cout << "No resource to send POST!!" << endl;
+        case 3:
+            std::cout << "This request is currently not supported" << std::endl;
+            break;
+
+        case 4:
+            sendDeleteRequest(qualityOfService);
+            break;
+
+        case 5:
+            sendObserveRequest(qualityOfService);
+            break;
+
+        case 6:
+            sendCancelObserveRequest(qualityOfService);
+            break;
     }
 }
 
-void sendPostRequestCreate()
+void sendGetRequest(QualityOfService qualityOfService)
 {
     std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
 
     if (selectedResource)
     {
-        cout << "Sending Subordinate Resource Create Message(POST)..." << endl;
-
-        OCRepresentation representation =
-            IUTSimulatorUtils::createRepresentation({
-                {POWER_KEY, string("off")},
-                {INTENSITY_KEY, string("0")}
-        });
-        representation.setUri("/subordinate-device/subordinate-light-1");
-        representation.setResourceTypes(vector<string>{"core.light"});
-
-        selectedResource->post(representation, QueryParamsMap(), &onPost, g_qos);
-        cout << "POST request sent!!" << endl;
-        waitForCallback();
-    }
-    else
-    {
-        cout << "No resource to send POST!!" << endl;
-    }
-}
+        IUTSimulatorUtils::setResourceHostEndpointFromUser(selectedResource);
 
-void sendPostCloudConfiguration()
-{
-    std::shared_ptr< OCResource > cloudConfigurationResource = IUTSimulatorUtils::getResourceByURI(g_foundResourceList, COAP_CLOUD_CONF_URI);
+        QueryParamsMap query = IUTSimulatorUtils::getResourceInterfaceQueryFromUser(selectedResource);
 
-    if (cloudConfigurationResource)
-    {
-        OCRepresentation representation =
-            IUTSimulatorUtils::createRepresentation({
-                {CIS_KEY, string(CIS_VALUE)},
-                {SID_KEY, string(SID_VALUE)},
-                {AT_KEY, string(AT_VALUE)},
-                {APN_KEY, string(APN_VALUE)}
-        });
+        std::cout << "Sending Get Request to the resource with: " << selectedResource->host() << selectedResource->uri() << std::endl;
+        selectedResource->get(query, onGet, qualityOfService);
+        std::cout << "GET request sent!!" << std::endl;
 
-        cloudConfigurationResource->post(representation, QueryParamsMap(), &onPost, g_qos);
-        cout << "POST Cloud Configuration request sent!" << endl;
-        waitForCallback();
+        g_hasResourceCallbackArrived = false;
+        waitForCallback(g_hasResourceCallbackArrived);
     }
-    else
+    else if (g_foundResourceList.empty())
     {
-        cout << "Could not find " << COAP_CLOUD_CONF_URI << " resource, perhaps you need to find all resources first." << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "There are no found resources!");
     }
 }
 
-void sendDeleteRequest()
+void sendPostRequest(QualityOfService qualityOfService)
 {
     std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
 
     if (selectedResource)
     {
-        cout << "Sending Delete Request..." << endl;
+        IUTSimulatorUtils::setResourceHostEndpointFromUser(selectedResource);
 
-        selectedResource->deleteResource(&onDelete);
-        cout << "DELETE request sent!!" << endl;
-        waitForCallback();
-        if (selectedResource->uri().compare("/device/fan-1") == 0)
-        {
-            g_foundResourceList.clear();
-            g_createdResourceList.clear();
-        }
+        QueryParamsMap query = IUTSimulatorUtils::getResourceInterfaceQueryFromUser(selectedResource);
+
+        std::string key = InputHandler::getInputFromUser<std::string>("Please provide Attribute Key:");
+        AttributeValue value = IUTSimulatorUtils::getAttributeValueFromUser();
+        OCRepresentation representation;
+        representation.setValue(key, value);
+
+        std::cout << "Sending Post Request to the resource with: " << selectedResource->host() << selectedResource->uri() << std::endl;
+        selectedResource->post(representation, query, &onPost, qualityOfService);
+        std::cout << "POST request sent!!" << std::endl;
+
+        g_hasResourceCallbackArrived = false;
+        waitForCallback(g_hasResourceCallbackArrived);
     }
-    else
+    else if (g_foundResourceList.empty())
     {
-        cout << "No resource to send DELETE!!" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "There are no found resources!");
     }
 }
 
-void observeResource()
+void sendDeleteRequest(QualityOfService qualityOfService)
 {
     std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
 
     if (selectedResource)
     {
-        cout << "Observing resource..." << endl;
+        std::cout << "Sending Delete Request to the resource with: " << selectedResource->host() << selectedResource->uri() << std::endl;
+        selectedResource->deleteResource(&onDelete, qualityOfService);
+        std::cout << "DELETE request sent!!" << std::endl;
 
-        IUTSimulatorUtils::setResourceHostEndpointFromUser(selectedResource, g_isSecuredClient);
-        cout << "Sending Get Request to the resource with: " << selectedResource->host() << selectedResource->uri() << endl;
-
-        selectedResource->observe(ObserveType::Observe, QueryParamsMap(), &onObserve, g_qos);
-        cout << "Observe request sent!!" << endl;
-        g_isObservingResource = true;
-        waitForCallback();
+        g_hasResourceCallbackArrived = false;
+        waitForCallback(g_hasResourceCallbackArrived);
     }
-    else
+    else if (g_foundResourceList.empty())
     {
-        cout << "No resource to Observe!!" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "There are no found resources!");
     }
 }
 
-void cancelObserveResource()
+void sendObserveRequest(QualityOfService qualityOfService)
 {
     std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
 
     if (selectedResource)
     {
-        if (g_isObservingResource)
-        {
-            cout << "Canceling Observe resource..." << endl;
+        IUTSimulatorUtils::setResourceHostEndpointFromUser(selectedResource);
 
-            IUTSimulatorUtils::setResourceHostEndpointFromUser(selectedResource, g_isSecuredClient);
-            cout << "Sending Get Request to the resource with: " << selectedResource->host() << selectedResource->uri() << endl;
+        QueryParamsMap query = IUTSimulatorUtils::getResourceInterfaceQueryFromUser(selectedResource);
 
-            selectedResource->cancelObserve(g_qos);
-            cout << "Cancel Observe request sent!!" << endl;
-            g_isObservingResource = false;
-            g_resourceHelper->waitInSecond(CALLBACK_WAIT_DEFAULT);
-        }
-        else
-        {
-            cout << "No resource is being Observed currently!!" << endl;
-        }
+        std::cout << "Sending Observe Request to the resource with: " << selectedResource->host() << selectedResource->uri() << std::endl;
+        selectedResource->observe(ObserveType::Observe, query, &onObserve, qualityOfService);
+        std::cout << "Observe request sent!!" << std::endl;
+
+        g_hasResourceCallbackArrived = false;
+        waitForCallback(g_hasResourceCallbackArrived);
     }
-    else
+    else if (g_foundResourceList.empty())
     {
-        cout << "No resource to cancel Observe!!" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "There are no found resources!");
     }
 }
 
-void cancelObservePassively()
+void sendCancelObserveRequest(QualityOfService qualityOfService)
 {
     std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
 
     if (selectedResource)
     {
-        if (g_isObservingResource)
-        {
-            cout << "Canceling Observe passively..." << endl;
+        IUTSimulatorUtils::setResourceHostEndpointFromUser(selectedResource);
 
-            // Currently, there is no api to cancel observe passively
-            cout << "Cancel Observe request not sent!! Currently there is no API!!" << endl;
-        }
-        else
-        {
-            cout << "No resource is being Observed currently!!" << endl;
-        }
+        std::cout << "Sending Cancel Observe Request to the resource with: " << selectedResource->host() << selectedResource->uri() << std::endl;
+        selectedResource->cancelObserve(qualityOfService);
+        std::cout << "Cancel Observe request sent!!" << std::endl;
+
+        ResourceHelper::waitInSecond(CALLBACK_WAIT_DEFAULT);
     }
-    else
+    else if (g_foundResourceList.empty())
     {
-        cout << "No resource to cancel Observe!!" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "There are no found resources!");
     }
 }
 
-void setDeviceWESInfo()
+void sendPostCloudConfiguration(QualityOfService qualityOfService)
 {
-    cout << "SetDeviceInfo IN" << endl;
-    ESDeviceProperty deviceProperty =
-    {
-        {
-            {WIFI_11G, WIFI_11N, WIFI_11AC},3,
-            {WIFI_24G, WIFI_5G},2,
-            {WPA_PSK, WPA2_PSK},2,
-            {AES,TKIP_AES},2
-        },
-        { "Test Device"}
-    };
-
-    // Set user properties if needed
-    char userValue_str[] = "user_str";
-    g_userProperties.userValue_int = 0;
-
-    strncpy(g_userProperties.userValue_str, userValue_str, strlen(userValue_str) + 1);
-    SetUserProperties(&g_userProperties);
+    std::shared_ptr< OCResource > cloudConfigurationResource = IUTSimulatorUtils::getResourceByURI(g_foundResourceList, COAP_CLOUD_CONF_URI);
 
-    if(ESSetDeviceProperty(&deviceProperty) == ES_ERROR)
+    if (cloudConfigurationResource)
     {
-        cout << "ESSetDeviceProperty Error" << endl;
-    }
-
-    cout << "SetDeviceInfo OUT" << endl;
-}
-
-void prepareForWES()
-{
-    cout << "Getting ready for Wifi Easy SetuUp" << endl;
-    cout << "Please wait patiently..." << endl;
-
-    ESResourceMask resourcemMask = (ESResourceMask) (ES_WIFICONF_RESOURCE | ES_DEVCONF_RESOURCE);
-
-    g_esCallbacks.WiFiConfProvCb = &onWiFiConfProvReceived;
-    g_esCallbacks.DevConfProvCb = &onDevConfProvReceived;
+        OCRepresentation representation =
+            IUTSimulatorUtils::createRepresentation({
+                {CIS_KEY, std::string(CIS_VALUE)},
+                {SID_KEY, std::string(SID_VALUE)},
+                {AT_KEY, std::string(AT_VALUE)},
+                {APN_KEY, std::string(APN_VALUE)}
+        });
 
-    if(ESInitEnrollee(g_isSecuredServer, resourcemMask, g_esCallbacks) != ES_OK)
-    {
-        cout << "Unable to initiate device to be Wifi Easy SetUp ready!!" << endl;
+        cloudConfigurationResource->post(representation, QueryParamsMap(), &onPost, qualityOfService);
+        std::cout << "POST Cloud Configuration request sent!" << std::endl;
+        g_hasResourceCallbackArrived = false;
+        waitForCallback(g_hasResourceCallbackArrived);
     }
     else
     {
-        cout << "Device is now ready for Wifi Easy SetUp" << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "Resource " + std::string(COAP_CLOUD_CONF_URI) + " is not found!");
     }
-
 }
 
 void sendPingMessage()
 {
-    string address;
-    uint16_t port;
+    std::string hostEndpoint = IUTSimulatorUtils::getEndpointFromUser();
+
+    if (!hostEndpoint.empty())
+    {
+        OCDevAddr devAddr;
+        devAddr.adapter = OCTransportAdapter::OC_ADAPTER_TCP;
+        devAddr.flags = OC_DEFAULT_FLAGS;
+        strncpy(devAddr.addr, hostEndpoint.substr(0, hostEndpoint.find_last_of(":")).c_str(), MAX_ADDR_STR_SIZE);
+        devAddr.port = std::stoi(hostEndpoint.substr(hostEndpoint.find_last_of(":") + 1));
 
-    cout << "Please provide IP address (with interface after '%' if you are using IPv6) to which send ping to." << endl;
-    IUTSimulatorUtils::getInputFromUser(address);
-    if (!IUTSimulatorUtils::isValidIpAddress(address.substr(0, address.find("%")), g_ipVer))
+        std::cout << "Sending the ping message now to address: " << hostEndpoint << std::endl;
+        OCCallbackData cbData = {NULL, onPong, [](void* ctx) {}};
+        OCSendPingMessage(&devAddr, false, &cbData);
+    }
+    else
     {
-        cout << "Invalid IP address." << endl;
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "Invalid endpoint address!");
         return;
     }
-    cout << "Please provide port." << endl;
-    IUTSimulatorUtils::getInputFromUser(port);
-
-    OCDevAddr devAddr;
-    devAddr.adapter = OCTransportAdapter::OC_ADAPTER_TCP;
-    devAddr.flags = OC_IP_USE_V4;
-    if (g_ipVer == CT_IP_USE_V6)
-        devAddr.flags = OC_IP_USE_V6;
-    strncpy(devAddr.addr, address.c_str(), MAX_ADDR_STR_SIZE);
-    devAddr.port = port;
-    devAddr.ifindex = 0;
-    strncpy(devAddr.remoteId, JUST_WORKS_DI.c_str(), MAX_IDENTITY_SIZE);
-
-
-    OCCallbackData cbData;
-    cbData.context = NULL;
-    cbData.cb = [](void* ctx,OCDoHandle hd,OCClientResponse* clientResponse) -> OCStackApplicationResult {
-        std::cout << "Pong received! addr: " << clientResponse->devAddr.addr << std::endl;
-        return OC_STACK_DELETE_TRANSACTION;
-    };
-    cbData.cd = [](void* ctx) {};
-
-    std::cout << "Sending the ping message now to address: " << address << std::endl;
-    OCSendPingMessage(&devAddr, false, &cbData);
 }
 
-string getHost()
+IoTivityServerState resetOptionMenu()
 {
-    std::shared_ptr< OCResource > selectedResource = IUTSimulatorUtils::getResourceFromUser(g_foundResourceList);
+    std::string resetMenu =
+        "\tPlease select IUT reset type and press Enter:\n"
+        "\t\t 0. Cancel\n"
+        "\t\t 1. Full reset\n"
+        "\t\t 2. Reset with current SVR\n";
 
-    if (selectedResource)
-    {
-        return selectedResource->host();
-    }
-    else
-    {
-        string ip = "";
-        string port = "";
-
-        cout << "Please enter the IP of the Resource host, then press Enter: ";
-        IUTSimulatorUtils::getInputFromUser(ip);
-        cout << "Please enter the port of the Resource host, then press Enter: ";
-        IUTSimulatorUtils::getInputFromUser(port);
-
-        return ip + ":" + port;
-    }
-}
-
-void showMenu(int argc, char* argv[])
-{
-    cout << "Please Select an option from the menu and press Enter" << endl;
-    cout << "\t\t " << setw(3) << "0" << ". Quit IUT Emulator App" << endl;
-    cout << "\t Server Operations:" << endl;
-    cout << "\t\t " << setw(3) << "1" << ". Create Normal Resource" << endl;
-    cout << "\t\t " << setw(3) << "2" << ". Create Invisible Resource" << endl;
-    cout << "\t\t " << setw(3) << "3" << ". Create Resource With Complete URL" << endl;
-    cout << "\t\t " << setw(3) << "4" << ". Create Secured Resource" << endl;
-    cout << "\t\t " << setw(3) << "5" << ". Create " << MAX_LIGHT_RESOURCE_COUNT << " Light Resources" << endl;
-    cout << "\t\t " << setw(3) << "6" << ". Create Group Resource" << endl;
-    cout << "\t\t " << setw(3) << "7" << ". Delete Created Resources" << endl;
-    cout << "\t\t " << setw(3) << "8" << ". Delete Created Group" << endl;
-    cout << "\t Client Operations:" << endl;
-    cout << "\t\t " << setw(3) << "9" << ". Find Introspection" << endl;
-    cout << "\t\t " << setw(3) << "10" << ". Find Resource using Interface Query" << endl;
-    cout << "\t\t " << setw(3) << "11" << ". Find Specific Type Of Resource" << endl;
-    cout << "\t\t " << setw(3) << "12" << ". Find All Resources" << endl;
-    cout << "\t\t " << setw(3) << "13" << ". Find All Resources using Baseline Query - Unicast" << endl;
-    cout << "\t\t " << setw(3) << "14" << ". Find Specific Type Of Resource - Unicast" << endl;
-    cout << "\t\t " << setw(3) << "15" << ". Find All Resources - Unicast" << endl;
-    cout << "\t\t " << setw(3) << "16" << ". Join Found Resource To The Group" << endl;
-    cout << "\t\t " << setw(3) << "17" << ". Send GET Request" << endl;
-    cout << "\t\t " << setw(3) << "18" << ". Send GET Request with query" << endl;
-    cout << "\t\t " << setw(3) << "19" << ". Send PUT Request - Create Resource" << endl;
-    cout << "\t\t " << setw(3) << "20" << ". Send PUT Request - Complete Update" << endl;
-    cout << "\t\t " << setw(3) << "21" << ". Send POST Request - Partial Update - Default" << endl;
-    cout << "\t\t " << setw(3) << "22" << ". Send POST Request - Partial Update - User Input" << endl;
-    cout << "\t\t " << setw(3) << "23" << ". Send POST Request - Create Sub-Ordinate Resource" << endl;
-    cout << "\t\t " << setw(3) << "24" << ". Send Delete Request" << endl;
-    cout << "\t\t " << setw(3) << "25" << ". Observe Resource - Retrieve Request with Observe" << endl;
-    cout << "\t\t " << setw(3) << "26" << ". Cancel Observing Resource" << endl;
-    cout << "\t\t " << setw(3) << "27" << ". Cancel Observing Resource Passively" << endl;
-    cout << "\t\t " << setw(3) << "28" << ". Discover Device - Unicast" << endl;
-    cout << "\t\t " << setw(3) << "29" << ". Discover Device - Multicast" << endl;
-    cout << "\t\t " << setw(3) << "30" << ". Discover Platform - Multicast" << endl;
-    cout << "\t\t " << setw(3) << "31" << ". Find Group" << endl;
-    cout << "\t\t " << setw(3) << "32" << ". Join Found Resource To Found Group" << endl;
-    cout << "\t\t " << setw(3) << "33" << ". Update Collection" << endl;
-    cout << "\t\t " << setw(3) << "34" << ". Update Local Resource Manually" << endl;
-    cout << "\t\t " << setw(3) << "35" << ". Update Local Resource Automatically" << endl;
-    cout << "\t\t " << setw(3) << "36" << ". Set Quality of Service - CON(Confirmable)" << endl;
-    cout << "\t\t " << setw(3) << "37" << ". Set Quality of Service - NON(Non-Confirmable)" << endl;
-    cout << "\t\t " << setw(3) << "38" << ". Reset Secure Storage" << endl;
-    cout << "\t\t " << setw(3) << "39" << ". Send Post Request for Cloud Configuration" << endl;
-    cout << "\t Smart Home Vertical Resource Creation:" << endl;
-    cout << "\t\t " << setw(3) << "101" << ". Create Smart TV Device" << endl;
-    cout << "\t\t " << setw(3) << "102" << ". Create Air Conditioner Device" << endl;
-#ifdef __SECURED__
-    cout << "\t\t " << setw(3) << "103" << ". Create Secured Smart TV Device" << endl;
-    cout << "\t\t " << setw(3) << "104" << ". Create Secured Air Conditioner Device" << endl;
-    cout << "\t\t " << setw(3) << "105" << ". Create Secured Air Conditioner Single Resource" << endl;
-    cout << "\t\t " << setw(3) << "106" << ". Create Secured Vendor Defined Resource" << endl;
-#endif
-    cout << "\t\t " << setw(3) << "107" << ". Create Air Conditioner Single Resource" << endl;
-    cout << "\t\t " << setw(3) << "108" << ". Create  Vendor Defined Resource" << endl;
-    cout << "\t\t " << setw(3) << "109" << ". Prepare for Wifi Easy Setup" << endl;
-    cout << "\t\t " << setw(3) << "110" << ". Publish Created Resources To RD" << endl;
-    cout << "\t\t " << setw(3) << "111" << ". Update Published Resources To RD" << endl;
-    cout << "\t\t " << setw(3) << "112" << ". Delete Published Resources From RD" << endl;
-    cout << "\t\t " << setw(3) << "113" << ". Create Extra Device" << endl;
-    cout << "\t\t " << setw(3) << "114" << ". Update Last Error Code" << endl;
-    cout << "\t\t " << setw(3) << "115" << ". Create Complex Device For Introspection" << endl;
-    cout << "\t\t " << setw(3) << "116" << ". Create Binary Switch Resource" << endl;
-    cout << "\t\t " << setw(3) << "117" << ". Create Network Monitoring and Maintaince Resources" << endl;
-    cout << "\t\t " << setw(3) << "118" << ". Create Sample Batch collection" << endl;
-    cout << "\t\t " << setw(3) << "119" << ". Create Atomic Measurement Resource - Blood Pressure" << endl;
-    cout << "\t\t " << setw(3) << "120" << ". Cloud Configuration - Initialize cloud configuration resource" << endl;
-    cout << "\t\t " << setw(3) << "121" << ". Cloud Configuration - Sign out" << endl;
-    cout << "\t\t " << setw(3) << "122" << ". Cloud Configuration - Deregister and reinitialize cloud configuration resource" << endl;
-    cout << "\t\t " << setw(3) << "123" << ". Create Configuration Resource" << endl;
-    cout << "\t\t " << setw(3) << "124" << ". Send Ping Message" << endl;
-    cout << "\t\t " << setw(3) << "125" << ". Create Air Purifier Device" << endl;
-    cout << "\t\t " << setw(3) << "126" << ". Create Blood Pressure Monitor Device" << endl;
-
-    g_hasCallbackArrived = false;
-    handleMenu(argc, argv);
-}
-
-void selectMenu(int choice)
-{
-    string userResourceType;
-    string userInterfaceType;
-    string resourceHost = "";
-    string collectionType = "";
-    string queryKey = "";
-    string queryValue = "";
-    AttributeValue attrVal;
-    OCRepresentation linkRep;
-    bool isMulticast = false;
-
-    switch (choice)
+    switch(IUTSimulatorUtils::getSelectionFromUser(resetMenu, "reset option", 0, 2))
     {
+        case 0:
+            return IoTivityServerState::CONTINUE;
+
         case 1:
-            createResource();
-            break;
+            return IoTivityServerState::RESET;
 
         case 2:
-            createInvisibleResource();
-            break;
-
-        case 3:
-            createResourceWithUrl();
-            break;
-
-        case 4:
-            createSecuredResource();
-            break;
-
-        case 5:
-            createManyLightResources();
-            break;
-
-        case 6:
-            createGroup(GROUP_TYPE_DEFAULT);
-            break;
-
-        case 7:
-            deleteCreatedResource();
-            break;
+            g_IUTInfo.securityType = IUTInfo::SecurityType::REUSE;
+            return IoTivityServerState::RESET;
 
-        case 8:
-            deleteGroup();
-            break;
+        default:
+            return IoTivityServerState::CONTINUE;
+    }
+}
+
+std::string mainMenu()
+{
+    std::stringstream stream;
+
+    stream << "Please Select an option from the main menu and press Enter" << std::endl;
+    stream << "\t IUT Operations:" << std::endl;
+    stream << "\t\t\t " << setw(3) << "0" << ". Quit IUT Emulator App" << std::endl;
+    stream << "\t\t\t " << setw(3) << "1" << ". Restart IUT Emulator App" << std::endl;
+    stream << "\t Client Operations:" << std::endl;
+    stream << "\t\t\t " << setw(3) << "10" << ". Clear found resources" << std::endl;
+    stream << "\t\t\t " << setw(3) << "11" << ". Send Discovery request to find resources" << std::endl;
+    stream << "\t\t\t " << setw(3) << "12" << ". Send Request to found resources" << std::endl;
+    stream << "\t\t\t " << setw(3) << "13" << ". Set Quality of Service - CON(Confirmable)"  << std::endl;
+    stream << "\t\t\t " << setw(3) << "14" << ". Set Quality of Service - NON(Non-Confirmable)"<< std::endl;
+    stream << "\t\t\t " << setw(3) << "15" << ". Show Device Info" << std::endl;
+    stream << "\t\t\t " << setw(3) << "16" << ". Show Platform Info" << std::endl;
+    stream << "\t\t Client special Operations:" << std::endl;
+    stream << "\t\t\t " << setw(3) << "20" << ". Send Post Request to /CoAPCloudConf Resource" << std::endl;
+    stream << "\t Server Operations:" << std::endl;
+    stream << "\t\t\t " << setw(3) << "100" << ". Send Ping Message" << std::endl;
+    stream << "\t\t Server Resources Operations:" << std::endl;
+    stream << "\t\t\t " << setw(3) << "110" << ". Delete created Resources" << std::endl;
+    stream << "\t\t\t " << setw(3) << "111" << ". Create Resource - NOT IMPLEMENTED" << std::endl;
+    stream << "\t\t\t " << setw(3) << "112" << ". Create Collecion - NOT IMPLEMENTED" << std::endl;
+    stream << "\t\t\t " << setw(3) << "113" << ". Set creating Resources as secured" << std::endl;
+    stream << "\t\t\t " << setw(3) << "114" << ". Set creating Resources as unsecured" << std::endl;
+    stream << "\t\t\t " << setw(3) << "115" << ". Update created Resources" << std::endl;
+    stream << "\t\t\t " << setw(3) << "116" << ". Show created Resources" << std::endl;
+    stream << "\t\t Server Could Operations:" << std::endl;
+    stream << "\t\t\t " << setw(3) << "120" << ". Cloud Configuration - Initialize cloud configuration resource" << std::endl;
+    stream << "\t\t\t " << setw(3) << "121" << ". Cloud Configuration - Sign out" << std::endl;
+    stream << "\t\t\t " << setw(3) << "122" << ". Cloud Configuration - Deregister and reinitialize cloud configuration resource" << std::endl;
+    stream << "\t\t Server WES Operations:" << std::endl;
+    stream << "\t\t\t " << setw(3) << "130" << ". Prepare for Wifi Easy Setup" << std::endl;
+    stream << "\t\t\t " << setw(3) << "131" << ". Update Last Error Code" << std::endl;
+    stream << "\t\t Server RD Operations:" << std::endl;
+    stream << "\t\t\t " << setw(3) << "140" << ". Publish Created Resources To RD" << std::endl;
+    stream << "\t\t\t " << setw(3) << "141" << ". Delete Published Resources From RD" << std::endl;
+    stream << "\t\t Server Create specific Resources Operations:" << std::endl;
+    stream << "\t\t\t " << setw(3) << "200" << ". Create Binary Switch Resource" << std::endl;
+    stream << "\t\t\t " << setw(3) << "201" << ". Create Network Monitoring Resource" << std::endl;
+    stream << "\t\t\t " << setw(3) << "202" << ". Create Maintaince Resource" << std::endl;
+    stream << "\t\t\t " << setw(3) << "203" << ". Create Configuration Resource" << std::endl;
+    stream << "\t\t\t " << setw(3) << "204" << ". Create Atomic Measurement Resource - Blood Pressure" << std::endl;
+    stream << "\t\t\t " << setw(3) << "205" << ". Create Sample collection with Binary Switch" << std::endl;
+    stream << "\t\t\t " << setw(3) << "206" << ". Create Smart TV Resources" << std::endl;
+    stream << "\t\t\t " << setw(3) << "207" << ". Create Air Conditioner Single Resource" << std::endl;
+    stream << "\t\t\t " << setw(3) << "208" << ". Create Vendor Defined Resources" << std::endl;
+    stream << "\t\t\t " << setw(3) << "209" << ". Create Air Conditioner Resources" << std::endl;
+    stream << "\t\t\t " << setw(3) << "210" << ". Create " << MAX_LIGHT_RESOURCE_COUNT << " Light Resources" << std::endl;
+    stream << "\t\t\t " << setw(3) << "211" << ". Create Extra Device" << std::endl;
+    return stream.str();
+}
+
+IoTivityServerState selectMenu()
+{
+    static QualityOfService qualityOfService = QualityOfService::HighQos;
+    static bool secured = true;
+
+    switch (InputHandler::getInputFromUser<int>(mainMenu()))
+    {
+        case 0:
+            return IoTivityServerState::EXIT;
 
-        case 9:
-            discoverIntrospection(true);
-            break;
+        case 1:
+            return resetOptionMenu();
 
         case 10:
-            cout << "Please type query(key=value), then press Enter: ";
-            IUTSimulatorUtils::getInputFromUser(userInterfaceType);
-            resourceHost = "";
-            findAllResources(resourceHost, userInterfaceType);
-            if (g_foundResourceList.size() == 0)
-            {
-                cout << "No resource found!!" << endl;
-            }
+            g_foundResourceList.clear();
+            std::cout << "All found resources have been cleared" << std::endl;
             break;
 
         case 11:
-            cout << "Please type the Resource Type to find, then press Enter: ";
-            IUTSimulatorUtils::getInputFromUser(userResourceType);
-            userResourceType = "?rt=" + userResourceType;
-            findResource(userResourceType);
-            if (g_foundResourceList.size() == 0)
-            {
-                cout << "No resource found!!" << endl;
-            }
+            sendDiscoveryRequest(qualityOfService);
             break;
 
         case 12:
-            findAllResources();
-            if (g_foundResourceList.size() == 0)
-            {
-                cout << "No resource found!!" << endl;
-            }
+            sendRequestToFoundResourceMenu(qualityOfService);
             break;
 
         case 13:
-            resourceHost = getHost();
-            findResource("?if=oic.if.baseline", resourceHost);
-            if (g_foundResourceList.size() == 0)
-            {
-                cout << "No resource found!!" << endl;
-            }
+            qualityOfService = QualityOfService::HighQos;
+            std::cout << "CON Type Message Selected for Client Requests" << std::endl;
             break;
 
         case 14:
-            resourceHost = getHost();
-            cout << "Please type the Resource Type to find, then press Enter: ";
-            IUTSimulatorUtils::getInputFromUser(userResourceType);
-            userResourceType = "?rt=" + userResourceType;
-            findResource(userResourceType, resourceHost);
-            if (g_foundResourceList.size() == 0)
-            {
-                cout << "No resource found!!" << endl;
-            }
+            qualityOfService = QualityOfService::LowQos;
+            std::cout << "NON Type Message Selected for Client Requests" << std::endl;
             break;
 
         case 15:
-            resourceHost = getHost();
-            findAllResources(resourceHost);
-            if (g_foundResourceList.size() == 0)
-            {
-                cout << "No resource found!!" << endl;
-            }
+            showDeviceInfo();
             break;
 
         case 16:
-            break;
-
-        case 17:
-            sendGetRequest();
-            break;
-
-        case 18:
-            cout << "Please type query key, then press Enter: ";
-            IUTSimulatorUtils::getInputFromUser(queryKey);
-            cout << "Please type query value, then press Enter: ";
-            IUTSimulatorUtils::getInputFromUser(queryValue);
-            sendGetRequestWithQuery(queryKey, queryValue);
-            break;
-
-        case 19:
-            sendPutRequestCreate();
+            showPlatformInfo();
             break;
 
         case 20:
-            sendPutRequestUpdate();
-            break;
-
-        case 21:
-            sendPostRequestUpdate();
-            break;
-
-        case 22:
-            sendPostRequestUpdateUserInput();
-            break;
-
-        case 23:
-            sendPostRequestCreate();
-            break;
-
-        case 24:
-            sendDeleteRequest();
-            break;
-
-        case 25:
-            observeResource();
-            break;
-
-        case 26:
-            try
-            {
-                cancelObserveResource();
-            }
-            catch (exception& e)
-            {
-                cout << "Unable to cancel observing resource." << endl;
-                cout << "Error is: " << e.what() << endl;
-            }
-
-            break;
-
-        case 27:
-            cancelObservePassively();
-            break;
-
-        case 28:
-            isMulticast = false;
-            discoverDevice(isMulticast);
-            break;
-
-        case 29:
-            isMulticast = true;
-            discoverDevice(isMulticast);
-            break;
-
-        case 30:
-            discoverPlatform();
+            sendPostCloudConfiguration(qualityOfService);
             break;
 
-        case 31:
-            collectionType = GROUP_TYPE_DEFAULT;
-            findCollection(collectionType);
-            if (g_foundCollectionList.size() == 0)
-            {
-                cout << "No collection found!!" << endl;
-            }
+        case 100:
+            sendPingMessage();
             break;
 
-        case 32:
-            collectionType = GROUP_TYPE_DEFAULT;
-            if (g_foundCollectionList.size() == 0)
-            {
-                cout << "No Group available, starting find Group." << endl;
-                findCollection(collectionType);
-                if (g_foundCollectionList.size() == 0)
-                {
-                    cout << "Still no Resource found, quitting join resource to group." << endl;
-                    break;
-                }
-                else
-                {
-                    g_hasCallbackArrived = false;
-                }
-            }
-
-            g_foundResourceList.at(0)->get(QueryParamsMap(), onGet);
-            waitForCallback();
-
-            if (g_resourceRepresentation.hasAttribute("links"))
-            {
-                cout << "link is available." << endl;
-                g_resourceRepresentation.getAttributeValue("links", attrVal);
-                linkRep["links"] = attrVal;
-            }
-            else
+        case 110:
+            g_createdResourceList.clear();
+            if (g_isSampleCollectionCreated)
             {
-                cout << "link is not available. creating link..." << endl;
-                linkRep.setValue("links",
-                        (string) "[{\"href\":\"/device/light-1\",\"rt\":\"core.light\",\"if\":\"oic.if.baseline\",\"ins\":\"123\",\"p\":{\"bm\":3}}]");
+                g_sampleCollection->stopResource();
+                g_isSampleCollectionCreated = false;
             }
-
-            g_foundResourceList.at(0)->post(collectionType, LINK_INTERFACE, linkRep,
-                    QueryParamsMap(), onPost, g_qos);
-
+            std::cout << "All created resources have been deleted" << std::endl;
             break;
 
-        case 33:
-            updateGroup();
-            break;
-
-        case 34:
-            updateLocalResource();
-            break;
-
-        case 35:
-            updateLocalResourceAutomatically();
-            break;
-
-        case 36:
-            g_qos = QualityOfService::HighQos;
-            cout << "CON Type Message Selected for Client" << endl;
-            break;
-
-        case 37:
-            g_qos = QualityOfService::LowQos;
-            cout << "NON Type Message Selected for Client" << endl;
-            break;
-
-        case 38:
-            replaceDatFile(g_modeType, g_securityType);
-            cout << "Replaced Secure Storage" << endl;
-            break;
-
-        case 39:
-            sendPostCloudConfiguration();
+        case 111:
+            std::cout << "NOT IMPLEMENTED" << std::endl;
             break;
 
-        case 101:
-            createTvDevice();
+        case 112:
+            std::cout << "NOT IMPLEMENTED" << std::endl;
             break;
 
-        case 102:
-            createAirConDevice();
+        case 113:
+            secured = true;
+            std::cout << "Creating resources as secured is set for Server" << std::endl;
             break;
 
-#ifdef __SECURED__
-        case 103:
-            createTvDevice(true);
+        case 114:
+            secured = false;
+            std::cout << "Creating resources as unsecured is set for Server" << std::endl;
             break;
 
-        case 104:
-            createAirConDevice(true);
+        case 115:
+            updateCreatedResource();
             break;
 
-        case 105:
-            createSingleAirConResource(true);
+        case 116:
+            showCreatedResource();
             break;
 
-        case 106:
-            createVendorDefinedDevice(true);
+        case 120:
+            InitCloudResource();
             break;
-#endif
 
-        case 107:
-            createSingleAirConResource();
+        case 121:
+            CloudsSignOut();
             break;
 
-        case 108:
-            createVendorDefinedDevice();
+        case 122:
+            DeleteCloudAccount();
+            DeInitCloudResource();
+            InitCloudResource();
             break;
 
-        case 109:
+        case 130:
             setDeviceWESInfo();
             SetCallbackForUserdata();
-            prepareForWES();
+            prepareForWES(isSecured(secured));
             break;
 
-        case 110:
-            publishResourcesToRD();
+        case 131:
+            updateLec();
             break;
 
-        case 111:
-            updateResourcesToRD();
+        case 140:
+            publishResourcesToRD();
             break;
 
-        case 112:
+        case 141:
             deleteResourcesFromRD();
             break;
 
-        case 113:
-            createExtraDevice(true);
-            break;
-
-        case 114:
-            updateLec();
-            break;
-
-        case 115:
-            createResourceForIntrospection(g_isSecuredServer);
-            break;
-
-        case 116:
+        case 200:
             startResource(
                 AC_SWITCH_URI,
                 SWITCH_RESOURCE_TYPE,
-                OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecure(g_isSecuredServer)
+                OC_ACTIVE | OC_DISCOVERABLE | OC_OBSERVABLE | isSecured(secured)
             );
             break;
 
-        case 117:
-            startResource(
-                MN_MAINTENANCE_URI,
-                MAINTENANCE_RESOURCE_TYPE,
-                OC_ACTIVE | OC_DISCOVERABLE | isSecure(g_isSecuredServer)
-            );
+        case 201:
             startResource(
                 NMON_NETWORK_MONITORING_URI,
                 NETWORK_MONITORING_RESOURCE_TYPE,
-                OC_ACTIVE | OC_DISCOVERABLE | isSecure(g_isSecuredServer)
+                OC_ACTIVE | OC_DISCOVERABLE | isSecured(secured)
+            );
+            break;
+
+        case 202:
+            startResource(
+                MN_MAINTENANCE_URI,
+                MAINTENANCE_RESOURCE_TYPE,
+                OC_ACTIVE | OC_DISCOVERABLE | isSecured(secured)
             );
             break;
 
-        case 118:
-            createCollectionWithBatch(g_isSecuredServer);
+        case 203:
+            startResource(
+                CON_URI,
+                CON_RESOURCE_TYPE,
+                OC_ACTIVE | OC_DISCOVERABLE | isSecured(secured)
+            );
             break;
 
-        case 119:
+        case 204:
             createBP0Resource();
             createBP1Resource();
             createBP2Resource();
             break;
 
-        case 120:
-            InitCloudResource();
+        case 205:
+            createSampleCollection(isSecured(secured));
             break;
 
-        case 121:
-            CloudsSignOut();
+        case 206:
+            createResourcesForTvDevice(secured);
             break;
 
-        case 122:
-            DeleteCloudAccount();
-            DeInitCloudResource();
-            InitCloudResource();
+        case 207:
+            createAirConResources_Type1(secured);
             break;
 
-        case 123:
-            startResource(
-                CON_URI,
-                CON_RESOURCE_TYPE,
-                uint8_t(OC_ACTIVE | OC_DISCOVERABLE | isSecure(g_isSecuredServer))
-            );
+        case 208:
+            createAirConResources_Type2(secured);
             break;
 
-        case 124:
-            sendPingMessage();
+        case 209:
+            createAirConResources_Type3(secured);
             break;
 
-        case 125:
-            if (!isDeviceTypeSet)
-            {
-                SampleResource::setDeviceInfo(AP_ENGLISH_NAME_VALUE, Device_TYPE_AP, g_ocfVer);
-                isDeviceTypeSet = true;
-            }
-            else
-            {
-                cout << "Device type is already set." << endl;
-            }
+        case 210:
+            createManyLightResources(secured);
             break;
 
-        case 126:
-            if (!isDeviceTypeSet)
-            {
-                SampleResource::setDeviceInfo("Blood Pressure Monitor Device", Device_TYPE_BPM, g_ocfVer);
-                isDeviceTypeSet = true;
-            }
-            else
-            {
-                cout << "Device type is already set." << endl;
-            }
+        case 211:
+            createExtraDevice(secured);
             break;
 
-        case 0:
-            if (g_createdResourceList.size() > 0)
-            {
-                deleteCreatedResource();
-            }
-            if (g_isGroupCreated)
-            {
-                deleteGroup();
-            }
-            if (g_childHandle != NULL)
-            {
-                OCPlatform::unregisterResource(g_childHandle);
-            }
-            g_createdResourceList.clear();
-            g_foundResourceList.clear();
-
-            closeRDPLogFile();
-            exit(0);
-
         default:
-            cout << "Invalid Input. Please input your choice again" << endl;
+            InputHandler::setResponse(InputHandler::ResponseType::Error, "Invalid Input. Please input your choice again");
     }
-}
 
-void handleMenu(int argc, char* argv[])
-{
-    selectMenu(IUTSimulatorUtils::getInputFromUser<int>());
-    showMenu(0, NULL);
-}
\ No newline at end of file
+    return IoTivityServerState::CONTINUE;
+}
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulatorUtils.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulatorUtils.cpp
index 0e4d962cb..86159e02b 100644
--- a/test/src/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulatorUtils.cpp
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/IUTSimulatorUtils.cpp
@@ -20,114 +20,43 @@
 
 #include "IUTSimulatorUtils.h"
 
-template <>
-void IUTSimulatorUtils::getInputFromUser(bool &input)
-{
-    std::string userInput = "";
+#include <sstream>
+#include <algorithm>
 
-    while (userInput.empty())
-    {
-        getline(std::cin, userInput);
+#ifdef __LINUX__
+#include <arpa/inet.h>
+#endif
+#ifdef __WINDOWS__
+#include <winsock2.h>
+#endif
 
-        if (userInput == "1" || toLower(userInput) == "true")
-        {
-            input = true;
-        }
-        else if (userInput == "0" || toLower(userInput) == "false")
-        {
-            input = false;
-        }
-        else
-        {
-            printInput(userInput);
-            std::cout << "Please provide boolean value, either 1 or 0 or equivalently true or false" << std::endl;
-            userInput = "";
-        }
-    }
-
-    printInput(input);
-}
+#include "InputHandler.h"
 
-template <>
-void IUTSimulatorUtils::getInputFromUser(std::string &input)
+int IUTSimulatorUtils::getSelectionFromUser(std::string context, std::string what, int min, int max)
 {
-    std::string userInput = "";
-    while (userInput.empty())
-    {
-        getline(std::cin, userInput);
-        input = userInput;
-    }
-
-    printInput(input);
-}
-
-template <>
-bool IUTSimulatorUtils::getInputFromUser()
-{
-    bool inputValue;
-    std::string userInput = "";
-
-    while (userInput.empty())
-    {
-        getline(std::cin, userInput);
-
-        if (userInput == "1" || toLower(userInput) == "true")
-        {
-            inputValue = true;
-        }
-        else if (userInput == "0" || toLower(userInput) == "false")
-        {
-            inputValue = false;
-        }
-        else
-        {
-            printInput(userInput);
-            std::cout << "Please provide boolean value, either 1 or 0 or equivalently true or false" << std::endl;
-            userInput = "";
-        }
-    }
-    printInput(inputValue);
-    return inputValue;
-}
-
-
-template <>
-std::string IUTSimulatorUtils::getInputFromUser()
-{
-    std::string userInput = "";
-    while (userInput.empty())
-    {
-        getline(std::cin, userInput);
-    }
-
-    printInput(userInput);
-    return userInput;
-}
-
-int IUTSimulatorUtils::getSelectionFromUser(string what, int min, int max)
-{
-    int selection = getInputFromUser<int>();
+    int selection = InputHandler::getInputFromUser<int>(context);
     while (selection < min || selection > max)
     {
-        cout << "Invalid selection of " << what << ". Please select " << what << " no. between " << min << " & " << max << endl;
-        getInputFromUser(selection);
+        InputHandler::setResponse(InputHandler::ResponseType::Error, "Please select " + what + " no. between " + std::to_string(min) + " & " + std::to_string(max));
+        InputHandler::getInputFromUser(selection, context);
     }
 
     return selection;
 }
 
-shared_ptr< OCResource > IUTSimulatorUtils::getResourceFromUser(vector< shared_ptr< OCResource > > resources)
+std::shared_ptr< OCResource > IUTSimulatorUtils::getResourceFromUser(std::vector< std::shared_ptr< OCResource > > resources)
 {
     if (resources.size() > 0)
     {
-        cout << "\t" << "Please select resource no. and press Enter:" << endl;
-        cout << "\t\t" << "0. Cancel" << endl;
+        std::string resourceMenu;
+        resourceMenu += "\tPlease select resource no. and press Enter:\n";
+        resourceMenu += "\t\t0. Cancel\n";
         for (unsigned i = 1; i <= resources.size(); i++)
         {
-            cout << "\t\t" << i << ". " << resources.at(i - 1)->uniqueIdentifier() << "    (" << resources.at(i - 1)->host() << ")" << endl;
+            resourceMenu +=  "\t\t" + std::to_string(i) + ". " + resources.at(i - 1)->sid()  + resources.at(i - 1)->uri() + "    (" + resources.at(i - 1)->host() + ")\n";
         }
 
-        int selection = getSelectionFromUser("resource", 0, resources.size());
+        int selection = getSelectionFromUser(resourceMenu, "resource", 0, resources.size());
         if (selection != 0)
         {
             return resources.at(selection - 1);
@@ -137,19 +66,19 @@ shared_ptr< OCResource > IUTSimulatorUtils::getResourceFromUser(vector< shared_p
     return nullptr;
 }
 
-shared_ptr< SampleResource > IUTSimulatorUtils::getResourceFromUser(vector< shared_ptr< SampleResource > > resources)
+std::shared_ptr< SampleResource > IUTSimulatorUtils::getResourceFromUser(std::vector< std::shared_ptr< SampleResource > > resources)
 {
     if (resources.size() > 0)
     {
-        setlocale(LC_ALL, "");
-        cout << "\t" << "Please select resource no. and press Enter:" << endl;
-        cout << "\t\t" << "0. Cancel" << endl;
+        std::string resourceMenu;
+        resourceMenu += "\tPlease select resource no. and press Enter:\n";
+        resourceMenu += "\t\t0. Cancel\n";
         for (unsigned i = 1; i <= resources.size(); i++)
         {
-            cout << "\t\t" << i << ". " << resources.at(i - 1)->getUri() << endl;
+            resourceMenu += "\t\t" + std::to_string(i) + ". " + resources.at(i - 1)->getUri() + "\n";
         }
 
-        int selection = getSelectionFromUser("resource", 0, resources.size());
+        int selection = getSelectionFromUser(resourceMenu, "resource", 0, resources.size());
         if (selection != 0)
         {
             return resources.at(selection - 1);
@@ -159,24 +88,44 @@ shared_ptr< SampleResource > IUTSimulatorUtils::getResourceFromUser(vector< shar
     return nullptr;
 }
 
-shared_ptr< OCResource > IUTSimulatorUtils::getResourceByURI(vector< shared_ptr< OCResource > > resources, string resourceURI)
+std::shared_ptr< OCResource > IUTSimulatorUtils::getResourceByURI(std::vector< std::shared_ptr< OCResource > > resources, std::string resourceURI)
 {
-    for (unsigned i = 0; i < resources.size(); i++)
+    for (std::shared_ptr< OCResource > resource : resources)
     {
-        std::ostringstream stream;
-        stream << resources.at(i)->uniqueIdentifier();
-        if (stream.str().find(resourceURI) != std::string::npos)
+        if (resource->uri() == resourceURI)
         {
-            return resources.at(i);
+            return resource;
         }
     }
 
     return nullptr;
 }
 
-shared_ptr< SampleResource > IUTSimulatorUtils::getResourceByURI(vector< shared_ptr< SampleResource > > resources, string resourceURI)
+std::vector< std::shared_ptr< OCResource > > IUTSimulatorUtils::getResourcesWithResourceTypes(std::vector< std::shared_ptr< OCResource > > resources, std::vector< std::string> resourceTypes)
+{
+    std::vector< std::shared_ptr< OCResource > > resourcesByType;
+
+    for (std::shared_ptr< OCResource > resource : resources)
+    {
+        std::vector< std::string > resourceRTs = resource->getResourceTypes();
+
+        for(std::string resourceType : resourceTypes)
+        {
+            if (std::find(resourceRTs.begin(), resourceRTs.end(), resourceType) != resourceRTs.end())
+            {
+                std::cout << resource->uri() << std::endl;
+                resourcesByType.push_back(resource);
+                break;
+            }
+        }
+    }
+
+    return resourcesByType;
+}
+
+std::shared_ptr< SampleResource > IUTSimulatorUtils::getResourceByURI(std::vector< std::shared_ptr< SampleResource > > resources, std::string resourceURI)
 {
-    for (shared_ptr< SampleResource > resource : resources)
+    for (std::shared_ptr< SampleResource > resource : resources)
     {
         if (resource->getUri() == resourceURI)
         {
@@ -187,87 +136,105 @@ shared_ptr< SampleResource > IUTSimulatorUtils::getResourceByURI(vector< shared_
     return nullptr;
 }
 
+bool IUTSimulatorUtils::isResourceInList(std::vector< std::shared_ptr< OCResource > > resources, std::shared_ptr< OCResource > resourceToCheck)
+{
+    for (std::shared_ptr< OCResource > resource : resources)
+    {
+        if (resource->uniqueIdentifier() == resourceToCheck->uniqueIdentifier())
+        {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+QueryParamsMap IUTSimulatorUtils::getResourceInterfaceQueryFromUser(std::shared_ptr< OCResource > resource)
+{
+    std::vector< std::string > resourceInterfaces = resource->getResourceInterfaces();
+
+    std::string resourceInterfaceMenu;
+    resourceInterfaceMenu += "\tSelect one of the resource Interface:\n";
+    resourceInterfaceMenu += "\t\t0. None\n";
+    for (unsigned i = 1; i <= resourceInterfaces.size(); i++)
+    {
+        resourceInterfaceMenu += "\t\t" + std::to_string(i) + ". " + resourceInterfaces[i - 1] + "\n";
+    }
+
+    int selection = getSelectionFromUser(resourceInterfaceMenu, "resource Interface", 0, resourceInterfaces.size());
+    if (selection != 0)
+    {
+        return QueryParamsMap{std::make_pair(INTERFACE_KEY, resourceInterfaces[selection - 1])};
+    }
+    else
+    {
+        return QueryParamsMap();
+    }
+}
+
 AttributeValue IUTSimulatorUtils::getAttributeValueFromUser()
 {
     AttributeValue attributeValue;
-    string valueString = "";
-    string valueArray = "";
-    char valueLine[MAX_ATTRIBUTE_VALUE_LENGTH];
 
-    cout << "Please select attribute data type no. and press Enter: " << endl;
-    cout << "\t\t 1. Integer" << endl;
-    cout << "\t\t 2. Floating Point - Single Precision" << endl;
-    cout << "\t\t 3. Floating Point - Double Precision" << endl;
-    cout << "\t\t 4. Boolean" << endl;
-    cout << "\t\t 5. String" << endl;
-    cout << "\t\t 6. Array" << endl;
+    std::string attributeValueMenu =
+        "\tPlease select attribute data type no. and press Enter:\n"
+        "\t\t 0. Null\n"
+        "\t\t 1. Integer\n"
+        "\t\t 2. Double\n"
+        "\t\t 3. Boolean\n"
+        "\t\t 4. String\n"
+        "\t\t 5. Array\n";
 
-    int selection = getSelectionFromUser("data type", 1, 6);
+    int selection = getSelectionFromUser(attributeValueMenu, "data type", 0, 5);
 
-    cout << "Please provide Attribute Value: ";
     switch (selection)
     {
+        case 0:
+            attributeValue = NullType();
+            break;
         case 1:
-            attributeValue = getInputFromUser<int>();
+            attributeValue = InputHandler::getInputFromUser<int>("Please provide Integer Value:");
             break;
         case 2:
-            attributeValue = getInputFromUser<float>();
+            attributeValue = InputHandler::getInputFromUser<double>("Please provide Double Value:");
             break;
         case 3:
-            attributeValue = getInputFromUser<double>();
+            attributeValue = InputHandler::getInputFromUser<bool>("Please provide Boolean Value:");
             break;
         case 4:
-            attributeValue = getInputFromUser<bool>();
+            attributeValue = InputHandler::getInputFromUser<std::string>("Please provide String Value:");
             break;
         case 5:
-            cin.getline(valueLine, sizeof(attributeValue));
-            getline(cin, valueString);
-            printInput(valueString);
-            attributeValue = valueString;
-            break;
-        case 6:
-            cin.getline(valueLine, sizeof(attributeValue));
-            getline(cin, valueArray);
-            printInput(valueArray);
-            attributeValue = valueArray;
+            attributeValue = InputHandler::getInputFromUser<std::string>("Please provide Array Value:");
             break;
     }
 
     return attributeValue;
 }
 
-void IUTSimulatorUtils::setResourceHostEndpointFromUser(shared_ptr< OCResource > resource, bool isSecuredClient)
+void IUTSimulatorUtils::setResourceHostEndpointFromUser(std::shared_ptr< OCResource > resource)
 {
-    vector< std::string > endpointHosts = resource->getAllHosts();
-    if (isSecuredClient && endpointHosts.size() > 0)
-    {
-        resource->setHost(ResourceHelper::getOnlySecuredHost(endpointHosts));
-    }
+    std::vector< std::string > endpointHosts = resource->getAllHosts();
 
-    cout << "Select one of the endpoint:" << endl;
-    cout << "\t\t" << "0. Default Endpoint: " << resource->host() << endl;
+    std::string endpointMenu;
+    endpointMenu += "\tSelect one of the endpoint:\n";
+    endpointMenu += "\t\t0. default: " + resource->host() + "\n";
     for (unsigned i = 1; i <= endpointHosts.size(); i++)
     {
-        cout << "\t\t" << (i) << ". " << endpointHosts[i - 1] << endl;
+        endpointMenu += "\t\t" + std::to_string(i) + ". " + endpointHosts[i - 1] + "\n";
     }
 
-    int selection = getSelectionFromUser("endpoint", 0, endpointHosts.size());
+    int selection = getSelectionFromUser(endpointMenu, "endpoint", 0, endpointHosts.size());
     if (selection != 0)
     {
         resource->setHost(endpointHosts[selection - 1]);
     }
 }
 
-string IUTSimulatorUtils::toLower(string str)
-{
-    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
-    return str;
-}
-
-
 OCRepresentation IUTSimulatorUtils::createRepresentation(std::vector< std::pair<std::string, AttributeValue> > keysValues)
 {
     OCRepresentation representation;
+
     for (std::pair<std::string, AttributeValue> keyValue : keysValues)
     {
         representation.setValue(keyValue.first, keyValue.second);
@@ -276,17 +243,48 @@ OCRepresentation IUTSimulatorUtils::createRepresentation(std::vector< std::pair<
     return representation;
 }
 
-bool IUTSimulatorUtils::isValidIpAddress(string ipAddress, OCConnectivityType ipVersion)
+std::string IUTSimulatorUtils::getEndpointFromUser()
+{
+    std::string ip = InputHandler::getInputFromUser<std::string>("Please provide ip:");
+
+    if (isValidIpAddress(ip.substr(0, ip.find("%"))))
+    {
+        std::string port = InputHandler::getInputFromUser<std::string>("Please provide port:");
+
+        if (isPortValid(port))
+        {
+            return ip + ":" + port;
+        }
+    }
+
+    return "";
+}
+
+bool IUTSimulatorUtils::isValidIpAddress(std::string ipAddress)
+{
+    struct in6_addr buf6;
+    struct in_addr buf4;
+
+    if (inet_pton(AF_INET, ipAddress.c_str(), &buf4) || inet_pton(AF_INET6, ipAddress.c_str(), &buf6))
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+bool IUTSimulatorUtils::isPortValid(std::string port)
 {
-    switch(ipVersion)
+    u_int16_t uint16;
+
+    if(std::stringstream(port) >> uint16)
+    {
+        return true;
+    }
+    else
     {
-        case CT_IP_USE_V4:
-            struct sockaddr_in sa;
-            return  (inet_pton(AF_INET, ipAddress.c_str(), &(sa.sin_addr)) != 0);
-        case CT_IP_USE_V6:
-            struct sockaddr_in6 sa6;
-            return  (inet_pton(AF_INET6, ipAddress.c_str(), &(sa6.sin6_addr)) != 0);
-        default:
-            return false;
+        return false;
     }
 }
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/InputHandler.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/InputHandler.cpp
new file mode 100644
index 000000000..be7f5fa3c
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/InputHandler.cpp
@@ -0,0 +1,250 @@
+#include "InputHandler.h"
+
+#include <algorithm>
+#include <chrono>
+#include <thread>
+
+std::queue< std::string > InputHandler::inputSequence;
+
+std::condition_variable InputHandler::inputConditionalVariable;
+std::mutex InputHandler::inputMutex;
+
+std::string InputHandler::response;
+bool InputHandler::responseAvaliable = false;
+std::condition_variable InputHandler::responseConditionalVariable;
+std::mutex InputHandler::responseMutex;
+
+bool InputHandler::isResponseAvaliable()
+{
+    return responseAvaliable;
+}
+
+void InputHandler::releaseResponse()
+{
+    std::cout << response << std::endl;
+    responseAvaliable = true;
+    responseConditionalVariable.notify_one();
+    std::this_thread::sleep_for(std::chrono::milliseconds(50));
+    responseAvaliable = false;
+    response = "";
+}
+
+void InputHandler::setResponse(InputHandler::ResponseType responseType, std::string response)
+{
+    std::lock_guard<std::mutex> guard(responseMutex);
+
+    if (responseType == InputHandler::ResponseType::Error)
+    {
+        InputHandler::response = "Error: ";
+    }
+    else
+    {
+        InputHandler::response = "";
+    }
+
+    InputHandler::response += response;
+}
+
+std::string InputHandler::getResponse()
+{
+    std::unique_lock<std::mutex> lock(responseMutex);
+    responseConditionalVariable.wait(lock, isResponseAvaliable);
+
+    responseAvaliable = false;
+
+    return response;
+}
+
+bool InputHandler::inputAvaliable()
+{
+    return !inputSequence.empty();
+}
+
+void InputHandler::extract(std::string& input)
+{
+    std::unique_lock<std::mutex> lock(inputMutex);
+    inputConditionalVariable.wait(lock, inputAvaliable);
+
+    input = inputSequence.front();
+
+    inputSequence.pop();
+}
+
+void InputHandler::insert(std::string output)
+{
+    std::lock_guard<std::mutex> guard(inputMutex);
+
+    inputSequence.push(output);
+
+    inputConditionalVariable.notify_one();
+}
+
+template <>
+void InputHandler::getInputFromUser(bool &input, const std::string& context)
+{
+    HttpResources::setState(context);
+    if (response.empty())
+    {
+        setResponse(InputHandler::ResponseType::Info, context);
+        releaseResponse();
+    }
+    else
+    {
+        releaseResponse();
+        std::cout << context << std::endl;
+    }
+
+    std::string textInput = "";
+
+    while (textInput.empty())
+    {
+        extract(textInput);
+
+        if (textInput == "1" || toLower(textInput) == "true")
+        {
+            input = true;
+        }
+        else if (textInput == "0" || toLower(textInput) == "false")
+        {
+            input = false;
+        }
+        else if (textInput.empty())
+        {
+            setResponse(InputHandler::ResponseType::Info, context);
+            releaseResponse();
+        }
+        else
+        {
+            printInput(textInput);
+            textInput = "";
+            setResponse(InputHandler::ResponseType::Error, "Please provide boolean value, either 1 or 0 or equivalently true or false");
+            releaseResponse();
+        }
+    }
+
+    HttpResources::setState("");
+    printInput(input);
+}
+
+template <>
+void InputHandler::getInputFromUser(std::string &input, const std::string& context)
+{
+    HttpResources::setState(context);
+    if (response.empty())
+    {
+        setResponse(InputHandler::ResponseType::Info, context);
+        releaseResponse();
+    }
+    else
+    {
+        releaseResponse();
+        std::cout << context << std::endl;
+    }
+
+    extract(input);
+
+    while (input.empty())
+    {
+        if (input.empty())
+        {
+            setResponse(InputHandler::ResponseType::Info, context);
+            releaseResponse();
+
+            extract(input);
+        }
+    }
+
+    HttpResources::setState("");
+    printInput(input);
+}
+
+template <>
+bool InputHandler::getInputFromUser(const std::string& context)
+{
+    HttpResources::setState(context);
+    if (response.empty())
+    {
+        setResponse(InputHandler::ResponseType::Info, context);
+        releaseResponse();
+    }
+    else
+    {
+        releaseResponse();
+        std::cout << context << std::endl;
+    }
+
+    bool input;
+    std::string textInput = "";
+
+    while (textInput.empty())
+    {
+        extract(textInput);
+
+        if (textInput == "1" || toLower(textInput) == "true")
+        {
+            input = true;
+        }
+        else if (textInput == "0" || toLower(textInput) == "false")
+        {
+            input = false;
+        }
+        else if (textInput.empty())
+        {
+            setResponse(InputHandler::ResponseType::Info, context);
+            releaseResponse();
+        }
+        else
+        {
+            printInput(textInput);
+
+            textInput = "";
+            setResponse(InputHandler::ResponseType::Error, "Please provide boolean value, either 1 or 0 or equivalently true or false");
+            releaseResponse();
+        }
+    }
+
+    HttpResources::setState("");
+    printInput(textInput);
+    return input;
+}
+
+
+template <>
+std::string InputHandler::getInputFromUser(const std::string& context)
+{
+    HttpResources::setState(context);
+    if (response.empty())
+    {
+        setResponse(InputHandler::ResponseType::Info, context);
+        releaseResponse();
+    }
+    else
+    {
+        releaseResponse();
+        std::cout << context << std::endl;
+    }
+
+    std::string input;
+    extract(input);
+
+    while (input.empty())
+    {
+        if (input.empty())
+        {
+            setResponse(InputHandler::ResponseType::Info, context);
+            releaseResponse();
+        }
+
+        extract(input);
+    }
+
+    HttpResources::setState("");
+    printInput(input);
+    return input;
+}
+
+std::string InputHandler::toLower(std::string str)
+{
+    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
+    return str;
+}
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/SampleResourceFactory.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/SampleResourceFactory.cpp
index 8d450c63e..b756dcc59 100644
--- a/test/src/testapp/IUTSimulatorApp/c_cpp/src/SampleResourceFactory.cpp
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/SampleResourceFactory.cpp
@@ -51,7 +51,7 @@ std::shared_ptr< SampleResource > SampleResourceFactory::createResource(
             (resourceInterface.empty() ? CON_RESOURCE_INTERFACE : resourceInterface),
             resourceProperty,
             IUTSimulatorUtils::createRepresentation({
-                {NAME_KEY, string(SampleResource::getDeviceInfo().deviceName)},
+                {NAME_KEY, SampleResource::getDeviceName()},
                 {LOCATION_KEY, vector<double>{LATTITUDE_VALUE, LONGITUDE_VALUE}},
                 {CURRENCY_KEY, string(CURRENCY_VALUE)},
                 {DEFAULT_LANGUAGE_KEY, string(DEFAULT_LANGUAGE_VALUE)}
@@ -212,8 +212,8 @@ std::shared_ptr< SampleResource > SampleResourceFactory::createResource(
             (resourceInterface.empty() ? LIGHT_DEVICE_INTERFACE : resourceInterface),
             resourceProperty,
             IUTSimulatorUtils::createRepresentation({
-                {NAME_KEY, string(ENGLISH_NAME_VALUE)},
-                {DEVICE_ID_KEY, string("")},
+                {NAME_KEY, string(VENDOR_AIR_CON_DEVICE_NAME)},
+                {DEVICE_ID_KEY, ResourceServer::getDeviceID()},
                 {ICV_KEY, string(CORE_SPEC_VERSION)},
                 {DMV_KEY, string(RESOURCE_TYPE_SPEC_VERSION) + "," + string(SMART_HOME_SPEC_VERSION)},
                 {PIID_KEY, string(PLATFORM_ID)}
@@ -266,7 +266,7 @@ std::shared_ptr< SampleResource > SampleResourceFactory::createResource(
     else if (resourceType == MAINTENANCE_RESOURCE_TYPE)
     {
         resource = std::make_shared< MntResource >(
-            MN_MAINTENANCE_URI,
+            resourceUri,
             MAINTENANCE_RESOURCE_TYPE,
             (resourceInterface.empty() ? MAINTENANCE_RESOURCE_INTERFACE : resourceInterface),
             resourceProperty,
@@ -282,7 +282,7 @@ std::shared_ptr< SampleResource > SampleResourceFactory::createResource(
     else if (resourceType == NETWORK_MONITORING_RESOURCE_TYPE)
     {
         resource = std::make_shared< NmonResource >(
-            NMON_NETWORK_MONITORING_URI,
+            resourceUri,
             NETWORK_MONITORING_RESOURCE_TYPE,
             (resourceInterface.empty() ? NETWORK_MONITORING_RESOURCE_INTERFACE : resourceInterface),
             resourceProperty,
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Connection.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Connection.cpp
new file mode 100644
index 000000000..3a8624aed
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Connection.cpp
@@ -0,0 +1,81 @@
+#include "Connection.hpp"
+
+#include "ConnectionManager.hpp"
+#include "RequestParser.hpp"
+
+namespace http {
+
+Connection::Connection(boost::asio::ip::tcp::socket socket, ConnectionManager& manager, void (*requestHandler)(const Request&, Response&))
+    : socket(std::move(socket)),
+      connectionManager(manager),
+      requestHandler(requestHandler)
+{
+}
+
+void Connection::start()
+{
+    read();
+}
+
+void Connection::stop()
+{
+    socket.close();
+}
+
+void Connection::read()
+{
+    auto self(shared_from_this());
+
+    socket.async_read_some(
+        boost::asio::buffer(requestBuffer),
+        [this, self](boost::system::error_code error_code, std::size_t bytes_transferred)
+        {
+            if (!error_code)
+            {
+                Request request;
+
+                if (RequestParser::parse(request, requestBuffer.data(), requestBuffer.data() + bytes_transferred))
+                {
+                    requestHandler(request, response);
+                    write();
+                }
+                else
+                {
+                    response = Response::generateResponse(Response::StatusCode::BadRequest);
+                    write();
+                }
+
+                read();
+            }
+            else if (error_code != boost::asio::error::operation_aborted)
+            {
+                connectionManager.stop(shared_from_this());
+            }
+        }
+    );
+}
+
+void Connection::write()
+{
+    auto self(shared_from_this());
+
+    boost::asio::async_write(
+        socket,
+        boost::asio::buffer(response.toBuffer()),
+        [this, self](boost::system::error_code error_code, std::size_t)
+        {
+            if (!error_code)
+            {
+                boost::system::error_code ignored_ec;
+                socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);
+            }
+
+            if (error_code != boost::asio::error::operation_aborted)
+            {
+                connectionManager.stop(shared_from_this());
+            }
+        }
+    );
+}
+
+} // namespace http
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/ConnectionManager.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/ConnectionManager.cpp
new file mode 100644
index 000000000..27ae23e00
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/ConnectionManager.cpp
@@ -0,0 +1,31 @@
+#include "ConnectionManager.hpp"
+
+namespace http {
+
+ConnectionManager::ConnectionManager()
+{
+}
+
+void ConnectionManager::start(std::shared_ptr< Connection > connection)
+{
+    connections.insert(connection);
+    connection->start();
+}
+
+void ConnectionManager::stop(std::shared_ptr< Connection > connection)
+{
+    connections.erase(connection);
+    connection->stop();
+}
+
+void ConnectionManager::stopAll()
+{
+    for (auto connection: connections)
+    {
+        connection->stop();
+    }
+
+    connections.clear();
+}
+
+} // namespace http
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/RequestParser.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/RequestParser.cpp
new file mode 100644
index 000000000..d47a033bc
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/RequestParser.cpp
@@ -0,0 +1,152 @@
+#include "RequestParser.hpp"
+
+#include <sstream>
+#include <algorithm>
+#include <iterator>
+
+namespace http {
+
+const std::string RequestParser::FIRST_LINE_END = "\r\n";
+const std::string RequestParser::HEADERS_END = "\r\n\r\n";
+
+bool RequestParser::parse(Request& request, std::array<char, Request::MAX_REQUEST_SIZE>::const_iterator requestBegin, std::array<char, Request::MAX_REQUEST_SIZE>::const_iterator requestEnd)
+{
+    auto firstLineEnd = std::search(requestBegin, requestEnd, FIRST_LINE_END.begin(), FIRST_LINE_END.end());
+    auto headersEnd = std::search(requestBegin, requestEnd, HEADERS_END.begin(), HEADERS_END.end());
+
+    std::string firstLine(requestBegin, firstLineEnd);
+    std::string headers(firstLineEnd + FIRST_LINE_END.size(), headersEnd);
+    std::string body(headersEnd + HEADERS_END.size(), requestEnd);
+
+    if (parseFirstLine(request, firstLine) &&
+        parseHeaders(request, headers) &&
+        parseBody(request, body))
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+bool RequestParser::parseBody(Request& request, std::string body)
+{
+    if(request.method == "POST")
+    {
+        request.body = body;
+    }
+
+    return true;
+}
+
+bool RequestParser::parseHeaders(Request& request, std::string headers)
+{
+    std::istringstream stream(headers);
+    std::string line;
+
+    while(std::getline(stream, line))
+    {
+        auto headerSeperator = std::find(std::begin(line), std::end(line), ':');
+        std::string key(std::begin(line), headerSeperator);
+        std::string value(headerSeperator + 1, std::end(line));
+
+        request.headers[key] = value;
+    }
+
+    return true;
+}
+
+
+
+bool RequestParser::parseFirstLine(Request& request, std::string firstLine)
+{
+    std::vector<std::string> firstLineParams = split(firstLine, ' ');
+
+    if(firstLineParams.size() == 2)
+    {
+        if (checkMethod(firstLineParams[0]) &&
+            checkHttpVersion(firstLineParams[1]))
+        {
+            request.method = toUpper(firstLineParams[0]);
+            request.version = toUpper(firstLineParams[1]);
+        }
+        else
+        {
+            return false;
+        }
+    }
+    else if (firstLineParams.size() == 3)
+    {
+        if (checkMethod(firstLineParams[0]) &&
+            checkUrl(firstLineParams[1]) &&
+            checkHttpVersion(firstLineParams[2]))
+        {
+            request.method = toUpper(firstLineParams[0]);
+            request.url = firstLineParams[1];
+            request.version = toUpper(firstLineParams[2]);
+        }
+        else
+        {
+            return false;
+        }
+    }
+    else
+    {
+        return false;
+    }
+
+    return true;
+}
+
+bool RequestParser::checkMethod(std::string method)
+{
+    if (!method.empty() &&
+        Request::SUPPORTED_METHODES.find(toUpper(method)) != std::string::npos)
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+bool RequestParser::checkHttpVersion(std::string httpVersion)
+{
+    if (!httpVersion.empty() &&
+        Request::SUPPORTED_HTTP_VERSION.find(toUpper(httpVersion)) != std::string::npos)
+    {
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+
+bool RequestParser::checkUrl(std::string url)
+{
+    return true;
+}
+
+std::string RequestParser::toUpper(std::string text)
+{
+    std::transform(text.begin(), text.end(),text.begin(), ::toupper);
+    return text;
+}
+
+std::vector<std::string> RequestParser::split(const std::string &text, char delimiter)
+{
+    std::stringstream stream(text);
+    std::string item;
+    std::vector<std::string> elements;
+
+    while (std::getline(stream, item, delimiter)) {
+        elements.push_back(std::move(item));
+    }
+
+    return elements;
+}
+
+} // namespace http
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Response.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Response.cpp
new file mode 100644
index 000000000..50f8b8eef
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Response.cpp
@@ -0,0 +1,92 @@
+#include "Response.hpp"
+
+namespace http {
+
+std::string Response::getStatusText(StatusCode code)
+{
+    switch(code)
+    {
+        case StatusCode::OK:
+            return "OK";
+
+        case StatusCode::NoContent:
+            return "No Content";
+
+        case StatusCode::BadRequest:
+            return "Bad Request";
+
+        case StatusCode::Forbidden:
+            return "Forbidden";
+
+        case StatusCode::NotFound:
+            return "Not Found";
+
+        case StatusCode::ServiceUnavailable:
+            return "503";
+
+        default:
+            return "";
+    }
+}
+
+std::string Response::toString(StatusCode code)
+{
+    switch(code)
+    {
+        case StatusCode::OK:
+            return "200";
+
+        case StatusCode::NoContent:
+            return "204";
+
+        case StatusCode::BadRequest:
+            return "400";
+
+        case StatusCode::Forbidden:
+            return "403";
+
+        case StatusCode::NotFound:
+            return "404";
+
+        case StatusCode::ServiceUnavailable:
+            return "503";
+
+        default:
+            return "";
+    }
+}
+
+std::string Response::toBuffer()
+{
+    std::string responseData;
+
+    responseData = version + " " + toString(status) + " " + getStatusText(status) + "\r\n";
+    for (auto const& header : headers)
+    {
+        responseData += header.first + ": " + header.second + "\r\n";
+    }
+    responseData += "\r\n";
+    responseData += body;
+
+    return responseData;
+}
+
+Response Response::generateResponse(StatusCode status)
+{
+    Response response;
+    response.status = status;
+
+    return response;
+}
+
+Response Response::generateResponse(StatusCode status, std::string body)
+{
+    Response response;
+    response.status = status;
+    response.headers["Content-Length"] = std::to_string(body.size());
+    response.body = body;
+
+    return response;
+}
+
+} // namespace http
\ No newline at end of file
diff --git a/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Server.cpp b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Server.cpp
new file mode 100644
index 000000000..54795f06f
--- /dev/null
+++ b/test/src/testapp/IUTSimulatorApp/c_cpp/src/http/Server.cpp
@@ -0,0 +1,54 @@
+#include "Server.hpp"
+
+namespace http {
+
+Server::Server(const std::string& address, const std::string& port, void (*requestHandler)(const Request&, Response&))
+    : io_service(),
+      acceptor(io_service),
+      connectionManager(),
+      socket(io_service),
+      requestHandler(requestHandler)
+{
+    boost::asio::ip::tcp::resolver resolver(io_service);
+    boost::asio::ip::tcp::endpoint endpoint = *resolver.resolve({address, port});
+    acceptor.open(endpoint.protocol());
+    acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
+    acceptor.bind(endpoint);
+    acceptor.listen();
+
+    accept();
+}
+
+void Server::run()
+{
+    io_service.run();
+}
+
+void Server::accept()
+{
+    acceptor.async_accept(socket,
+        [this](boost::system::error_code ec)
+        {
+            if (!acceptor.is_open())
+            {
+                return;
+            }
+
+            if (!ec)
+            {
+                connectionManager.start(
+                    std::make_shared< Connection >(std::move(socket), connectionManager, requestHandler)
+                );
+            }
+
+            accept();
+        });
+}
+
+Server::~Server()
+{
+    acceptor.close();
+    connectionManager.stopAll();
+}
+
+} // namespace http
-- 
2.16.1.windows.1

