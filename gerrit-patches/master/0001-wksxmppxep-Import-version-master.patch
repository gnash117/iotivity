From 29f7a71ffebeb7628c33cf05552351f5212c1eb6 Mon Sep 17 00:00:00 2001
From: Philippe Coval <philippe.coval@osg.samsung.com>
Date: Wed, 15 Nov 2017 11:18:26 +0100
Subject: [PATCH] wksxmppxep: Import version 'master'

Change-Id: Ia34efd37f6884ae133132c1084c2b94c16867239
Origin: https://github.com/tizenteam/iotivity
Forwarded: https://gerrit.iotivity.org/gerrit/#/c/23783/
Signed-off-by: Philippe Coval <philippe.coval@osg.samsung.com>
---
 extlibs/wksxmppxep/wks_xep0047/.gitattributes      |  17 +
 extlibs/wksxmppxep/wks_xep0047/.gitignore          |  10 +
 extlibs/wksxmppxep/wks_xep0047/Makefile            |  63 +++
 extlibs/wksxmppxep/wks_xep0047/SConstruct          |  26 ++
 extlibs/wksxmppxep/wks_xep0047/build/Makefile      |  52 +++
 extlibs/wksxmppxep/wks_xep0047/example/Makefile    |  41 ++
 extlibs/wksxmppxep/wks_xep0047/example/main.c      | 369 +++++++++++++++
 extlibs/wksxmppxep/wks_xep0047/example/main_chat.c | 120 +++++
 extlibs/wksxmppxep/wks_xep0047/example/main_ibb.c  | 190 ++++++++
 .../wksxmppxep/wks_xep0047/example/main_ibb_data.c | 255 ++++++++++
 extlibs/wksxmppxep/wks_xep0047/include/xmpp_chat.h |  24 +
 .../wksxmppxep/wks_xep0047/include/xmpp_helper.h   |  36 ++
 extlibs/wksxmppxep/wks_xep0047/include/xmpp_ibb.h  | 232 ++++++++++
 .../wksxmppxep/wks_xep0047/include/xmpp_types.h    |  39 ++
 .../wksxmppxep/wks_xep0047/include/xmpp_utils.h    |  49 ++
 extlibs/wksxmppxep/wks_xep0047/source/xmpp_chat.c  |  72 +++
 .../wksxmppxep/wks_xep0047/source/xmpp_common.c    | 164 +++++++
 .../wksxmppxep/wks_xep0047/source/xmpp_common.h    |  50 ++
 .../wksxmppxep/wks_xep0047/source/xmpp_helper.c    | 173 +++++++
 extlibs/wksxmppxep/wks_xep0047/source/xmpp_ibb.c   | 512 +++++++++++++++++++++
 extlibs/wksxmppxep/wks_xep0047/source/xmpp_utils.c | 243 ++++++++++
 21 files changed, 2737 insertions(+)
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/.gitattributes
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/.gitignore
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/Makefile
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/SConstruct
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/build/Makefile
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/example/Makefile
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/example/main.c
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/example/main_chat.c
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/example/main_ibb.c
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/example/main_ibb_data.c
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/include/xmpp_chat.h
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/include/xmpp_helper.h
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/include/xmpp_ibb.h
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/include/xmpp_types.h
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/include/xmpp_utils.h
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/source/xmpp_chat.c
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/source/xmpp_common.c
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/source/xmpp_common.h
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/source/xmpp_helper.c
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/source/xmpp_ibb.c
 create mode 100644 extlibs/wksxmppxep/wks_xep0047/source/xmpp_utils.c

diff --git a/extlibs/wksxmppxep/wks_xep0047/.gitattributes b/extlibs/wksxmppxep/wks_xep0047/.gitattributes
new file mode 100644
index 000000000..bdb0cabc8
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/.gitattributes
@@ -0,0 +1,17 @@
+# Auto detect text files and perform LF normalization
+* text=auto
+
+# Custom for Visual Studio
+*.cs     diff=csharp
+
+# Standard to msysgit
+*.doc	 diff=astextplain
+*.DOC	 diff=astextplain
+*.docx diff=astextplain
+*.DOCX diff=astextplain
+*.dot  diff=astextplain
+*.DOT  diff=astextplain
+*.pdf  diff=astextplain
+*.PDF	 diff=astextplain
+*.rtf	 diff=astextplain
+*.RTF	 diff=astextplain
diff --git a/extlibs/wksxmppxep/wks_xep0047/.gitignore b/extlibs/wksxmppxep/wks_xep0047/.gitignore
new file mode 100644
index 000000000..59907ee4a
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/.gitignore
@@ -0,0 +1,10 @@
+# for projects that use SCons for building: http://http://www.scons.org/
+.sconsign.dblite
+.cproject
+.project
+.settings
+*.o
+*.os
+*.so
+*.a
+
diff --git a/extlibs/wksxmppxep/wks_xep0047/Makefile b/extlibs/wksxmppxep/wks_xep0047/Makefile
new file mode 100644
index 000000000..8d64b17ee
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/Makefile
@@ -0,0 +1,63 @@
+LIBSTROPHE_BASE ?= ../libstrophe
+
+SRCPATH = ./source
+HDRPATH = ./include
+EXMPATH = ./example
+
+XMPPLIB_LIB = ${LIBSTROPHE_BASE}/.libs
+XMPPLIB_INC = ${LIBSTROPHE_BASE}
+INC_DIRS += -I${XMPPLIB_INC}
+INC_DIRS += -I${HDRPATH}
+
+
+LIBNAME=wksxmppxep
+SHAREDLIB=lib${LIBNAME}.so
+STATICLIB=lib${LIBNAME}.a
+
+CC = gcc
+AR = ar
+CFLAGS = -Wall -Werror -Wno-unused -fPIC
+LDFLAGS =-Wl,-rpath=./ -Wl,-rpath=${XMPPLIB_LIB} -L./ -L${XMPPLIB_LIB} -l${LIBNAME} -lstrophe -lssl -lcrypto -lexpat -lm -lpthread
+
+VPATH = ${SRCPATH}
+SRCS=${wildcard ${SRCPATH}/*.c} 
+HEADERS=${wildcard ${HDRPATH}/*.h}
+OBJS = ${patsubst %.c,%.o,${SRCS}}
+
+MSRCS=${wildcard ${EXMPATH}/*.c} 
+MOBJS = ${patsubst %.c,%.o,${MSRCS}}
+
+#TESTTARGET=main main_chat main_ibb
+TESTTARGET=main_chat main_ibb main_ibb_data
+
+all: libraries testprogram
+
+testprogram: ${TESTTARGET}
+
+main: example/main.o
+	${CC} -o $@ $^ ${LDFLAGS}
+
+main_chat: example/main_chat.o
+	${CC} -o $@ $^ ${LDFLAGS}
+
+main_ibb: example/main_ibb.o
+	${CC} -o $@ $^ ${LDFLAGS}
+
+main_ibb_data: example/main_ibb_data.o
+	${CC} -o $@ $^ ${LDFLAGS}
+
+libraries: ${SHAREDLIB} ${STATICLIB}
+
+${STATICLIB}: ${OBJS}
+	${AR} rcs $@ $^
+	@echo Compile $@ successful....
+
+${SHAREDLIB}: ${OBJS}
+	${CC} -o $@ -shared $^
+	@echo Compile $@ successful....
+
+.c.o:
+	${CC} ${CFLAGS} -o $@ -c $< ${INC_DIRS}
+
+clean:
+	rm -rf ${OBJS} ${SHAREDLIB} ${STATICLIB} ${TESTTARGET} ${MOBJS}
diff --git a/extlibs/wksxmppxep/wks_xep0047/SConstruct b/extlibs/wksxmppxep/wks_xep0047/SConstruct
new file mode 100644
index 000000000..5165df84f
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/SConstruct
@@ -0,0 +1,26 @@
+import os
+
+LIBSTROPHE_BASE='../libstrophe'
+if ARGUMENTS.get('LIBSTROPHE_BASE') is not None :
+	LIBSTROPHE_BASE=ARGUMENTS.get('LIBSTROPHE_BASE')
+
+INC_PATH=[LIBSTROPHE_BASE, 'include']
+LIB_PATH=[LIBSTROPHE_BASE + '/.libs/', '.']
+
+sources = Glob('source/*.c')
+env = Environment()
+env.AppendUnique(CPPPATH = INC_PATH, CCFLAGS = ['-Wall', '-Werror', '-Wno-unused'])
+sharedlib = env.SharedLibrary('wksxmppxep', sources)
+staticlib = env.StaticLibrary('wksxmppxep', sources)
+
+
+menv = Environment()
+menv.AppendUnique(CPPPATH = INC_PATH, CCFLAGS = ['-Wall', '-Werror'])
+menv.AppendUnique(LIBS = ['wksxmppxep', 'strophe', 'ssl', 'crypto', 'expat'])
+menv.AppendUnique(LIBS = ['pthread', 'm'])
+menv.AppendUnique(LIBPATH = LIB_PATH, RPATH = LIB_PATH)
+#menv.Program('example/main.c')
+menv.Program('example/main_chat.c')
+menv.Program('example/main_ibb.c')
+menv.Program('example/main_ibb_data.c')
+
diff --git a/extlibs/wksxmppxep/wks_xep0047/build/Makefile b/extlibs/wksxmppxep/wks_xep0047/build/Makefile
new file mode 100644
index 000000000..5c67514a7
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/build/Makefile
@@ -0,0 +1,52 @@
+.PHONY: all clean
+
+XMPPLIB  ?= /root/libstrophe-2
+
+SRCPATH = ../source
+HDRPATH = ../include
+
+BUILDPATH = ../build
+OBJPATH = $(BUILDPATH)/obj
+RLSPATH = $(BUILDPATH)/release
+LIBPATH = $(BUILDPATH)/lib
+
+XMPPLIB_INC = $(XMPPLIB)
+INC_DIRS += -I$(XMPPLIB_INC)
+INC_DIRS += -I$(HDRPATH)
+
+
+CC = gcc
+AR = ar
+CFLAGS = -O -Wall  -Wl,--gc-sections -Wl,-s -std=gnu99 -fPIC
+DEFS = #-DTB_LOG
+
+VPATH = $(SRCPATH)
+SRCS=$(wildcard $(SRCPATH)/*.c) 
+HEADERS=$(wildcard $(HDRPATH)/*.h)
+NOTDIRSRCS=$(notdir $(SRCS))
+OBJS = $(patsubst %.c,$(OBJPATH)/%.o,$(NOTDIRSRCS))
+
+all: libraries
+
+libraries: libwksxep0047.a libwksxep0047.so
+
+libwksxep0047.a: ${LIBPATH}/libwksxep0047.a
+
+${LIBPATH}/libwksxep0047.a: $(OBJS)
+	@mkdir -p $(LIBPATH)
+	$(AR) rcs $@ $^
+	@echo Compile $@ successful....
+
+libwksxep0047.so: ${LIBPATH}/libwksxep0047.so
+
+${LIBPATH}/libwksxep0047.so: $(OBJS)
+	@mkdir -p $(LIBPATH)
+	$(CC) -o $@ -shared $^
+	@echo Compile $@ successful....
+
+$(OBJS): $(OBJPATH)/%.o: %.c
+	@mkdir -p $(OBJPATH)
+	$(CC) $(CFLAGS) -c -o $@  $< $(INC_DIRS) $(DEFS)
+
+clean:
+	rm -rf $(LIBPATH)/wks_xep0047 $(OBJPATH) $(LIBPATH)
diff --git a/extlibs/wksxmppxep/wks_xep0047/example/Makefile b/extlibs/wksxmppxep/wks_xep0047/example/Makefile
new file mode 100644
index 000000000..dafa01a7e
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/example/Makefile
@@ -0,0 +1,41 @@
+.HONY: all clean
+
+XMPPLIB   = /root/libstrophe-2
+
+HDRPATH = ../include
+RLSPATH = ./release
+
+OBJPATH = ./obj
+BUILDPATH = ../build
+LIBPATH = $(BUILDPATH)/lib
+XMPPLIBPATH = $(XMPPLIB)/.libs
+
+XMPPLIB_INC = $(XMPPLIB)
+INC_DIRS += -I$(XMPPLIB_INC)
+INC_DIRS += -I$(HDRPATH)
+
+
+CC = gcc
+AR = ar
+CFLAGS = -O -Wall -Wl,--gc-sections -Wl,-s -std=gnu99
+DEFS = #-DTB_LOG
+
+VPATH = $(SRCPATH)
+SRCS=$(wildcard $(SRCPATH)/*.c) 
+HEADERS=$(wildcard $(HDRPATH)/*.h)
+NOTDIRSRCS=$(notdir $(SRCS))
+OBJS = $(patsubst %.c,$(OBJPATH)/%.o,$(NOTDIRSRCS))
+
+LIBS = -L$(LIBPATH) -L$(XMPPLIBPATH) -lwksxep0047 -lstrophe -lcrypto -lssl -lexpat -lresolv -lpthread -lm
+
+
+all: wks_xep0047
+
+wks_xep0047:
+	@mkdir -p $(OBJPATH) $(RLSPATH)
+	$(CC) $(CFLAGS) -c main.c -o $(OBJPATH)/main.o $(INC_DIRS) $(DEFS)
+	$(CC) -o $(RLSPATH)/$@ $(OBJPATH)/main.o $(LIBS) 
+	@echo Compile WKS-OIC-RACLIENT successful....
+
+clean:
+	rm -rf $(OBJPATH) $(RLSPATH)
diff --git a/extlibs/wksxmppxep/wks_xep0047/example/main.c b/extlibs/wksxmppxep/wks_xep0047/example/main.c
new file mode 100644
index 000000000..2d3080db2
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/example/main.c
@@ -0,0 +1,369 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <limits.h>
+#include <signal.h>
+#include <unistd.h>
+
+#define __STDC_FORMAT_MACROS
+#include <inttypes.h>
+#include <string.h>
+#include <signal.h>
+#include <unistd.h>
+
+#include <strophe.h>
+
+#include "xmppclient.h"
+#include "xmpp_ibb.h"
+
+#define CTX_VAL 0x99
+char xmpp_un[MAX_XMPPUN_LEN] = "";
+char xmpp_pw[MAX_XMPPPW_LEN] = "";
+char xmpp_server[MAX_XMPPSV_LEN] = "cloud01.workssys.com";
+int bQuit = 1;
+
+extern time_t glast_ping_time;
+int gQuitFlag = 0;
+
+typedef enum
+{
+    CMD_ESTABLISH,
+    CMD_SEND,
+    CMD_CLOSE
+} CMD_TYPE;
+
+typedef struct _itf_cmd
+{
+    CMD_TYPE type;
+    char peer[MAX_XMPPUN_LEN];
+    char message[256];
+    xmpp_ibb_session_t *handle;
+    struct _itf_cmd *next;
+} itf_cmd;
+
+itf_cmd *cmd_head = NULL, *cmd_tail = NULL;
+xmpp_ibb_session_t *handle_head = NULL, *handle_tail = NULL;
+
+void add_handle(xmpp_ibb_session_t *handle)
+{
+    xmpp_ibb_session_t *handle_temp = handle_head;
+    while (handle_temp != NULL) {
+        if (handle_temp == handle)
+            return;
+        else
+            handle_temp = handle_temp->next;
+    }
+    if (handle_head == NULL) {
+        handle_head = handle;
+    } else {
+        handle_tail->next = handle;
+    }
+    handle_tail = handle;
+}
+void delete_handle(xmpp_ibb_session_t *handle)
+{
+    xmpp_ibb_session_t *handle_temp = handle_head, *handle_last = handle_temp;
+    while (handle_temp != NULL) {
+        if (handle_temp == handle) {
+            if (handle_temp == handle_head) {
+                handle_head = handle_head->next;
+            } else if (handle_temp == handle_tail) {
+                handle_tail = handle_last;
+                handle_last->next = NULL;
+            } else {
+                handle_last->next = handle_temp->next;
+            }
+            free(handle);
+            return;
+        } else {
+            handle_last = handle_temp;
+            handle_temp = handle_temp->next;
+        }
+    }
+}
+void add_cmd(itf_cmd *cmd)
+{
+    if (cmd_head == NULL) {
+        cmd_head = cmd;
+    } else {
+        cmd_tail->next = cmd;
+    }
+    cmd_tail = cmd;
+}
+
+void itf()
+{
+    char cmd[4] = "";
+    while (printf("input e for establish, s for send, c for close and q for quit: ") && fgets(cmd, sizeof(cmd), stdin)) {
+        itf_cmd *cmd_temp = NULL;
+        xmpp_ibb_session_t *handle_temp;
+        int count = 0;
+        char countc[8] = "";
+
+        switch (cmd[0])
+        {
+            case 'e':
+                cmd_temp = (itf_cmd*) malloc(sizeof(itf_cmd));
+                cmd_temp->type = CMD_ESTABLISH;
+                printf("input receiver's xmpp account: ");
+                fgets(cmd_temp->peer, sizeof(cmd_temp->peer), stdin);
+                cmd_temp->peer[strlen(cmd_temp->peer) - 1] = '\0';
+                //scanf( "%s", cmd_temp->peer );
+                cmd_temp->next = NULL;
+                add_cmd(cmd_temp);
+                break;
+            case 's':
+                cmd_temp = (itf_cmd*) malloc(sizeof(itf_cmd));
+                cmd_temp->type = CMD_SEND;
+                printf("handle:\n");
+                handle_temp = handle_head;
+                while (handle_temp != NULL) {
+                    printf("%d, account: %s, id, %s, sid: %s\n", count, handle_temp->peer, handle_temp->id, handle_temp->sid);
+                    handle_temp = handle_temp->next;
+                    count++;
+                }
+                printf("input which session you're sending to: ");
+                //scanf("%d", &count);
+                fgets(countc, sizeof(countc), stdin);
+                count = atoi(countc);
+                handle_temp = handle_head;
+                while (count > 0) {
+                    handle_temp = handle_temp->next;
+                    count--;
+                    if (handle_temp == NULL)
+                        break;
+                }
+                cmd_temp->handle = handle_temp;
+                if (cmd_temp->handle == NULL) {
+                    free(cmd_temp);
+                    break;
+                }
+                printf("input the message: ");
+                fgets(cmd_temp->message, sizeof(cmd_temp->message), stdin);
+                cmd_temp->message[strlen(cmd_temp->message) - 1] = '\0';
+                //scanf( cmd_temp->message );
+                cmd_temp->next = NULL;
+                add_cmd(cmd_temp);
+                break;
+            case 'c':
+                cmd_temp = (itf_cmd*) malloc(sizeof(itf_cmd));
+                cmd_temp->type = CMD_CLOSE;
+                printf("handle:\n");
+                handle_temp = handle_head;
+                while (handle_temp != NULL) {
+                    printf("%d, account: %s, id: %s, sid: %s\n", count, handle_temp->peer, handle_temp->id, handle_temp->sid);
+                    handle_temp = handle_temp->next;
+                    count++;
+                }
+                printf("input which session you're closing: ");
+                //scanf("%d", &count);
+                fgets(countc, sizeof(countc), stdin);
+                count = atoi(countc);
+                handle_temp = handle_head;
+                while (count > 0) {
+                    handle_temp = handle_temp->next;
+                    count--;
+                    if (handle_temp == NULL)
+                        break;
+                }
+                cmd_temp->handle = handle_temp;
+                if (cmd_temp->handle == NULL) {
+                    free(cmd_temp);
+                    break;
+                }
+                cmd_temp->next = NULL;
+                add_cmd(cmd_temp);
+                break;
+            case 'h':
+                printf("handle:\n");
+                handle_temp = handle_head;
+                while (handle_temp != NULL) {
+                    printf("%d, account: %s, id: %s, sid: %s\n", count, handle_temp->peer, handle_temp->id, handle_temp->sid);
+                    handle_temp = handle_temp->next;
+                    count++;
+                }
+                break;
+            case 'q':
+                break;
+            default:
+                printf("unrecognized command\n");
+                break;
+        }
+    }
+}
+
+/* SIGINT handler: set gQuitFlag to 1 for graceful termination */
+void handleSigInt(int signum)
+{
+
+    if (signum == SIGINT) {
+        gQuitFlag = 1;
+    }
+}
+
+static int _ibb_open_cb(xmpp_ibb_session_t *session_handle)
+{
+    printf("====Open CB====\n");
+    printf("id: %s\n", session_handle->id);
+    printf("sid: %s\n", session_handle->sid);
+    printf("peer: %s\n", session_handle->peer);
+    printf("state: %d\n", session_handle->state);
+    printf("===============\n");
+
+    if (session_handle->state == STATE_READY)
+        add_handle(session_handle);
+    return 0;
+}
+
+static void _ibb_send_cb(xmpp_ibb_session_t *session_handle)
+{
+    printf("====Send CB====\n");
+    printf("id: %s\n", session_handle->id);
+    printf("sid: %s\n", session_handle->sid);
+    printf("peer: %s\n", session_handle->peer);
+    printf("recv_seq: %d\n", session_handle->recv_seq);
+    printf("send_seq: %d\n", session_handle->send_seq);
+    printf("data_ack_count: %d\n", session_handle->data_ack_count);
+    printf("state: %d\n", session_handle->state);
+    printf("===============\n");
+}
+
+static void _ibb_recv_cb(xmpp_ibb_session_t *session_handle)
+{
+    printf("====Recv CB====\n");
+    printf("id: %s\n", session_handle->id);
+    printf("sid: %s\n", session_handle->sid);
+    printf("peer: %s\n", session_handle->peer);
+    printf("state: %d\n", session_handle->state);
+    printf("seq: %d\n", session_handle->recv_seq);
+    printf("msg: %s\n", session_handle->recv_data);
+    printf("===============\n");
+}
+
+static void _ibb_close_cb(xmpp_ibb_session_t *session_handle)
+{
+    printf("====Close CB====\n");
+    printf("id: %s\n", session_handle->id);
+    printf("sid: %s\n", session_handle->sid);
+    printf("peer: %s\n", session_handle->peer);
+    printf("state: %d\n", session_handle->state);
+    printf("===============\n");
+
+    delete_handle(session_handle);
+}
+
+void init_argument(int argc, char* argv[]);
+
+int main(int argc, char* argv[])
+{
+    xmpp_ctx_t *ctx = NULL;
+    xmpp_conn_t* conn = NULL;
+    XMPP_IBB_Ops_t xmpp_ibb_ops;
+
+    pthread_t pid;
+
+    init_argument(argc, argv);
+
+    if (strlen(xmpp_un) < 1 || strlen(xmpp_pw) < 1) {
+        printf("input xmpp acoount: ");
+        scanf("%s", xmpp_un);
+        printf("input xmpp password: ");
+        scanf("%s", xmpp_pw);
+    }
+
+    conn = XMPP_Init(xmpp_un, xmpp_pw, xmpp_server, &ctx);
+    XMPP_IBB_Init(conn, &xmpp_ibb_ops);
+    //Hash_Init( ctx, HASH_TABLE_SIZE, xmpp_free );
+    time(&glast_ping_time);
+
+    xmpp_ibb_ops.ibb_open_fp = _ibb_open_cb;
+    xmpp_ibb_ops.ibb_recv_fp = _ibb_recv_cb;
+    xmpp_ibb_ops.ibb_send_fp = _ibb_send_cb;
+    xmpp_ibb_ops.ibb_close_fp = _ibb_close_cb;
+
+    pthread_create(&pid, NULL, (void*) itf, NULL);
+
+    while ((!gQuitFlag) || (bQuit == 0)) {
+
+        if (cmd_head != NULL) {
+            xmpp_ibb_session_t *handle;
+            switch (cmd_head->type)
+            {
+                case CMD_ESTABLISH:
+                    handle = (xmpp_ibb_session_t*) malloc(sizeof(xmpp_ibb_session_t));
+                    XMPP_IBB_Establish(conn, cmd_head->peer, handle);
+                    add_handle(handle);
+                    break;
+                case CMD_SEND:
+                    XMPP_IBB_Send(cmd_head->handle, cmd_head->message);
+                    break;
+                case CMD_CLOSE:
+                    XMPP_IBB_Close(cmd_head->handle);
+                    delete_handle(cmd_head->handle);
+                    break;
+            }
+            itf_cmd *temp = cmd_head;
+            cmd_head = cmd_head->next;
+            free(temp);
+        }
+        xmpp_run_once(ctx, 500);
+        usleep(5 * 1000);
+    }
+
+    printf("Quit\n");
+
+    xmpp_stop(ctx);
+    sleep(1);
+    XMPP_IBB_Release(conn);
+    XMPP_Close(conn, ctx);
+
+    return 0;
+}
+
+void PrintUsage()
+{
+
+    printf("Usage: main \n\
+        -q : Enable Quit by Ctrl+C or SIGINT\n\
+        -h : This Help\n");
+
+}
+
+void init_argument(int argc, char* argv[])
+{
+    char c;
+
+    while ((c = getopt(argc, argv, "u:t:q:h")) != -1) {
+        switch (c)
+        {
+            case 'u':
+                if (strcmp(optarg, "1") == 0) {
+                    snprintf(xmpp_un, sizeof(xmpp_un), "andreac\\40workssys.com@cloud01.workssys.com/resource1");
+                    snprintf(xmpp_pw, sizeof(xmpp_pw), "947c2c96o13cnjmujfh4l5i3is");
+                } else if (strcmp(optarg, "2") == 0) {
+                    snprintf(xmpp_un, sizeof(xmpp_un), "andreac\\40workssys.com@cloud01.workssys.com/resource2");
+                    snprintf(xmpp_pw, sizeof(xmpp_pw), "947c2c96o13cnjmujfh4l5i3is");
+                } else if (strcmp(optarg, "3") == 0) {
+                    snprintf(xmpp_un, sizeof(xmpp_un), "andreac\\40workssys.com@cloud01.workssys.com/resource3");
+                    snprintf(xmpp_pw, sizeof(xmpp_pw), "947c2c96o13cnjmujfh4l5i3is");
+                }
+
+            case 'q':
+
+                bQuit = atoi(optarg);
+                if (bQuit == 0)
+                    printf("No Ctrl+C used\n");
+
+                break;
+
+            case 'h':
+                PrintUsage();
+                exit(-1);
+                break;
+            default:
+
+                return;
+        }
+
+    }
+}
diff --git a/extlibs/wksxmppxep/wks_xep0047/example/main_chat.c b/extlibs/wksxmppxep/wks_xep0047/example/main_chat.c
new file mode 100644
index 000000000..8942528b2
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/example/main_chat.c
@@ -0,0 +1,120 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdbool.h>
+#include <xmpp_helper.h>
+
+#include "xmpp_chat.h"
+#include "xmpp_utils.h"
+
+char g_rejid[256];
+
+static int chat_recv_handler(xmpp_conn_t *xmpp, xmppdata_t *xdata, void *udata)
+{
+    char *decdata;
+    size_t decsize;
+    fprintf(stderr, "\n  chat_recv_handler(conn<%p>, from'%s', msg'%s'\n\n", xmpp, xdata->from, (char *) xdata->data);
+    xmpp_b64decode((char *) xdata->data, &decdata, &decsize);
+    fprintf(stderr, "\n    try decode(decdata'%s', decsize(%ld))\n", decdata, decsize);
+    strcpy(g_rejid, xdata->from);
+    return 0;
+}
+
+static int conn_handler(xmpp_t *xmpp, xmppconn_info_t *conninfo, void *udata)
+{
+    if (conninfo->connevent != 0) {
+        fprintf(stderr, "  status(%d) error(%d) errorType(%d) errorText '%s'\n",
+                conninfo->connevent, conninfo->error, conninfo->errortype,
+                conninfo->errortext);
+        return -1;
+    }
+    printf( "\n\n       login full JID: %s\n\n\n", xmpphelper_get_bound_jid(xmpp));
+    return 0;
+}
+
+void print_usage()
+{
+    printf("Usage: command [-s host -p port -j jid -w password -t tojid]\n");
+}
+
+int main(int argc, char *argv[])
+{
+    bool looping = true;
+    int c, opt;
+    xmpp_t *xmpp;
+    xmppdata_t xdata;
+
+    char *host = "localhost", *jid = "user1@localhost/res1", *pass = "1234", *tojid = "user1@localhost/res1";
+    int port = 5222;
+
+    while ((opt = getopt(argc, argv, "s:p:w:j:t:h")) != -1) {
+        switch (opt)
+        {
+            case 's':
+                host = optarg;
+                break;
+            case 'p':
+                port = atoi(optarg);
+                break;
+            case 'w':
+                pass = optarg;
+                break;
+            case 'j':
+                jid = optarg;
+                break;
+            case 't':
+                tojid = optarg;
+                break;
+            case 'h':
+            default:
+                print_usage();
+                return -1;
+        }
+    }
+
+    xmpp_log_t *log = xmpp_get_default_logger(XMPP_LEVEL_DEBUG);
+    xmpp = xmpphelper_new(conn_handler, NULL, log, NULL);
+    xmpphelper_connect(xmpp, host, port, jid, pass);
+    xmppchat_handler_add(xmpphelper_get_conn(xmpp), chat_recv_handler, xmpp);
+    xmpphelper_run(xmpp);
+
+    while (looping) {
+        c = getchar();
+        switch (c)
+        {
+            case 'q':
+                xmpphelper_stop(xmpp);
+                looping = false;
+                break;
+            case 's':
+                xdata.data = "hello world";
+                xdata.tojid = tojid;
+                xmppchat_send_message(xmpphelper_get_conn(xmpp), &xdata);
+                break;
+            case 'e':
+            {
+                char *data = "hello world base64!!";
+                char *encdata;
+                xmpp_b64encode(data, strlen(data), &encdata);
+                xdata.data = encdata;
+                xdata.tojid = tojid;
+                xmppchat_send_message(xmpphelper_get_conn(xmpp), &xdata);
+                xmpp_b64free(encdata);
+                break;
+            }
+            case 'r':
+                xdata.data = "reply message ";
+                xdata.tojid = g_rejid;
+                xmppchat_send_message(xmpphelper_get_conn(xmpp), &xdata);
+                break;
+            default:
+                break;
+        }
+    }
+    xmpphelper_join(xmpp);
+    xmppchat_handler_del(xmpphelper_get_conn(xmpp), chat_recv_handler);
+
+    xmpphelper_release(xmpp);
+    return 0;
+}
diff --git a/extlibs/wksxmppxep/wks_xep0047/example/main_ibb.c b/extlibs/wksxmppxep/wks_xep0047/example/main_ibb.c
new file mode 100644
index 000000000..9a4e4650a
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/example/main_ibb.c
@@ -0,0 +1,190 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdbool.h>
+#include <xmpp_helper.h>
+
+#include "xmpp_chat.h"
+#include "xmpp_utils.h"
+#include "xmpp_ibb.h"
+
+char g_tojid[256] = "";
+xmpp_ibb_session_t *g_session;
+bool g_looping = true;
+
+static int conn_handler(xmpp_t *xmpp, xmppconn_info_t *conninfo, void *udata)
+{
+    if (conninfo->connevent != 0) {
+        fprintf(stderr, "  status(%d) error(%d) errorType(%d) errorText '%s'\n",
+                conninfo->connevent, conninfo->error, conninfo->errortype,
+                conninfo->errortext);
+        g_looping = false;
+        return -1;
+    }
+    printf( "\n\n       login full JID: %s\n\n\n", xmpphelper_get_bound_jid(xmpp));
+    return 0;
+}
+
+static int open_cb(xmpp_ibb_session_t *sess, char *type)
+{
+    printf("\n  %s() type '%s'\n", __FUNCTION__, type);
+    strncpy(g_tojid, xmpp_ibb_get_remote_jid(sess), sizeof(g_tojid));
+    g_session = sess;
+    if (strncmp("result", type, 6) == 0)
+        printf("%s() result\n", __FUNCTION__);
+    return 0;
+}
+
+static int close_cb(xmpp_ibb_session_t *sess, char *type)
+{
+    printf("\n  %s() type '%s'\n", __FUNCTION__, type);
+//    xmpp_ibb_release(sess);
+    g_session = NULL;
+    g_tojid[0] = '\0';
+    if (strncmp("result", type, 6) == 0)
+        printf("%s() result\n", __FUNCTION__);
+    return 0;
+}
+
+static int recv_cb(xmpp_ibb_session_t *sess, xmppdata_t *xdata)
+{
+    printf("\n  %s()\n", __FUNCTION__);
+    if (xdata != NULL)
+        printf("    data'%s' size(%d)\n", (char *) xdata->data, xdata->size);
+    else
+        printf("  %s() result\n", __FUNCTION__);
+    return 0;
+}
+
+static int error_cb(xmpp_ibb_session_t *sess, xmpperror_t *xerr)
+{
+    printf("\n  %s() code(%d) type '%s' msg '%s'\n", __FUNCTION__, xerr->code, xerr->type, xerr->mesg);
+//    xmpp_ibb_release(sess);
+    g_session = NULL;
+    g_tojid[0] = '\0';
+    return 0;
+}
+
+void print_usage()
+{
+    printf("Usage: command [-s host -p port -j jid -w password]\n");
+    printf("      -s host, xmpp server hostname or ip address\n");
+    printf("      -p port, xmpp service port\n");
+    printf("      -j jid, login bare JID\n");
+    printf("      -w password, login passowrd\n");
+    printf("      -f ,force TLS\n");
+}
+
+static bool doCmd(xmpp_t *xmpp, char cmd)
+{
+    int looping = true;
+    xmpp_conn_t *conn = xmpphelper_get_conn(xmpp);
+    switch (cmd)
+    {
+        case 'r':
+//            xmpp_ibb_release(g_session);
+            break;
+        case 'q':
+            xmpphelper_stop(xmpp);
+            looping = false;
+            break;
+        case 'e':
+            printf("input target jid to establish session: ");
+            fgets(g_tojid, sizeof(g_tojid), stdin);
+            fprintf(stderr, "tojid '%s' size(%ld)", g_tojid, strlen(g_tojid));
+            g_tojid[strlen(g_tojid) - 1] = '\0';
+            g_session = xmpp_ibb_open(conn, g_tojid, NULL);
+            break;
+        case 'c':
+            if (g_session == NULL || strlen(g_tojid) == 0) {
+                printf("session is not setup. session<%p> target'%s'.", g_session, g_tojid);
+                return looping;
+            }
+            xmpp_ibb_close(g_session);
+            g_session = NULL;
+            g_tojid[0] = '\0';
+            break;
+        case 's':
+        {
+            xmppdata_t xdata;
+            char msg[4096] = "";
+            if (g_session == NULL || strlen(g_tojid) == 0) {
+                printf("session is not setup. session<%p> target'%s'.", g_session, g_tojid);
+                return looping;
+            }
+            printf("input messages to target jid '%s': ", g_tojid);
+            fgets(msg, sizeof(msg), stdin);
+            xdata.data = msg;
+            xdata.size = strlen(msg);
+            xmpp_ibb_send_data(g_session, &xdata);
+            break;
+        }
+        default:
+            printf("\n 'q' to quit, 'e' establish ibb session, 's' send message to '%s', 'c' close ibb session: ", g_tojid);
+            break;
+    }
+    return looping;
+}
+
+int main(int argc, char *argv[])
+{
+    bool looping = true;
+    int opt;
+    int force_tls = 0;
+    xmpp_t *xmpp;
+    char msg[1024] = "";
+    char *host = "localhost", *jid = "user1@localhost", *pass = "1234";
+    int port = 5222;
+
+    while ((opt = getopt(argc, argv, "s:p:w:j:t:hf")) != -1) {
+        switch (opt)
+        {
+            case 's':
+                host = optarg;
+                break;
+            case 'p':
+                port = atoi(optarg);
+                break;
+            case 'w':
+                pass = optarg;
+                break;
+            case 'f':
+                force_tls = 1;
+                break;
+            case 'j':
+                jid = optarg;
+                break;
+            case 'h':
+            default:
+                print_usage();
+                return -1;
+        }
+    }
+    //xmpp_log_t *log = xmpp_get_default_logger(XMPP_LEVEL_DEBUG);
+    xmpp_log_t *log = NULL;
+    xmpp = xmpphelper_new(conn_handler, NULL, log, NULL);
+    if (force_tls == 1) {
+        xmpphelper_force_tls(xmpp);
+    }
+    xmpphelper_connect(xmpp, host, port, jid, pass);
+    xmpp_ibb_reg_funcs_t regfuncs;
+    regfuncs.open_cb = open_cb;
+    regfuncs.close_cb = close_cb;
+    regfuncs.recv_cb = recv_cb;
+    regfuncs.error_cb = error_cb;
+    xmpp_ibb_register(xmpphelper_get_conn(xmpp), &regfuncs);
+    xmpphelper_run(xmpp);
+
+    while (looping && g_looping) {
+        looping = doCmd(xmpp, msg[0]);
+        fgets(msg, sizeof(msg), stdin);
+    }
+    xmpphelper_join(xmpp);
+
+    xmpp_ibb_unregister(xmpphelper_get_conn(xmpp));
+
+    xmpphelper_release(xmpp);
+    return 0;
+}
+
diff --git a/extlibs/wksxmppxep/wks_xep0047/example/main_ibb_data.c b/extlibs/wksxmppxep/wks_xep0047/example/main_ibb_data.c
new file mode 100644
index 000000000..4387b5abe
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/example/main_ibb_data.c
@@ -0,0 +1,255 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdbool.h>
+#include <xmpp_helper.h>
+
+#include "xmpp_chat.h"
+#include "xmpp_utils.h"
+#include "xmpp_ibb.h"
+
+char g_tojid[256] = "";
+xmpp_ibb_session_t *g_session;
+bool g_looping = true;
+FILE *g_send_fs = NULL;
+FILE *g_recv_fs = NULL;
+int   g_send_off = 0;
+
+static void _send(int off)
+{
+    fprintf(stderr, "%s(%d)\n", __FUNCTION__, off);
+    if (feof(g_send_fs)) {
+        xmpp_ibb_close(g_session);
+        return;
+    }
+    char msg[xmpp_ibb_get_blocksize(g_session) * 3 / 4];
+    xmppdata_t xdata;
+    fseek(g_send_fs, off, SEEK_SET);
+    xdata.size = fread(msg, 1, sizeof(msg), g_send_fs);
+    fprintf(stderr, "xdata.size(%d) = fread(msg, sizeof(msg)(%ld), 1, g_send_fs\n", xdata.size, sizeof(msg));
+    xdata.data = msg;
+    xmpp_ibb_send_data(g_session, &xdata);
+    g_send_off += xdata.size;
+}
+
+static void _recv(xmppdata_t *xdata)
+{
+    fwrite(xdata->data, 1, xdata->size, g_recv_fs);
+}
+
+
+static int conn_handler(xmpp_t *xmpp, xmppconn_info_t *conninfo, void *udata)
+{
+    if (conninfo->connevent != 0) {
+        fprintf(stderr, "  status(%d) error(%d) errorType(%d) errorText '%s'\n",
+                conninfo->connevent, conninfo->error, conninfo->errortype,
+                conninfo->errortext);
+        g_looping = false;
+        return -1;
+    }
+    printf( "\n\n       login full JID: %s\n\n\n", xmpphelper_get_bound_jid(xmpp));
+    return 0;
+}
+
+static int open_cb(xmpp_ibb_session_t *sess, char *type)
+{
+    printf("\n  %s() type '%s'\n", __FUNCTION__, type);
+    strncpy(g_tojid, xmpp_ibb_get_remote_jid(sess), sizeof(g_tojid));
+    g_session = sess;
+    if (g_recv_fs == NULL) {
+        char fname[64];
+        xmpp_conn_t *conn = xmpp_ibb_get_conn(sess);
+        const char *bjid = xmpp_conn_get_bound_jid(conn);
+        char *sid = xmpp_ibb_get_sid(sess);
+        snprintf(fname, sizeof(fname), "%s-%s.dat", bjid, sid);
+        char *pos;
+        while ((pos=strchr(fname, '/')) != NULL || (pos=strchr(fname, '@')) != NULL) {
+            *pos = '-';
+        }
+        fprintf(stderr, "fopen(%s, 'a')\n", fname);
+        g_recv_fs = fopen(fname, "a");
+        if (g_recv_fs == NULL) {
+            perror("fopen() recv failed.\n");
+        }
+    }
+    if (strncmp("result", type, 6) == 0)
+        printf("%s() result\n", __FUNCTION__);
+    return 0;
+}
+
+static int close_cb(xmpp_ibb_session_t *sess, char *type)
+{
+    printf("\n  %s() type '%s'\n", __FUNCTION__, type);
+//    xmpp_ibb_release(sess);
+    g_session = NULL;
+    g_tojid[0] = '\0';
+    if (g_recv_fs != NULL) {
+        fclose(g_recv_fs);
+        g_recv_fs = NULL;
+    }
+    if (g_send_fs != NULL) {
+        fclose(g_send_fs);
+        g_send_fs = NULL;
+    }
+    if (strncmp("result", type, 6) == 0)
+        printf("%s() result\n", __FUNCTION__);
+    return 0;
+}
+
+static int recv_cb(xmpp_ibb_session_t *sess, xmppdata_t *xdata)
+{
+    printf("\n  %s()\n", __FUNCTION__);
+    if (xdata != NULL) {
+        printf("    data'%p' size(%d)\n", (char *) xdata->data, xdata->size);
+        _recv(xdata);
+    } else {
+        printf("  %s() result\n", __FUNCTION__);
+        _send(g_send_off);
+    }
+    return 0;
+}
+
+static int error_cb(xmpp_ibb_session_t *sess, xmpperror_t *xerr)
+{
+    printf("\n  %s() code(%d) type '%s' msg '%s'\n", __FUNCTION__, xerr->code, xerr->type, xerr->mesg);
+//    xmpp_ibb_release(sess);
+    g_session = NULL;
+    g_tojid[0] = '\0';
+    return 0;
+}
+
+void print_usage()
+{
+    printf("Usage: command [-s host -p port -j jid -w password]\n");
+    printf("      -s host, xmpp server hostname or ip address\n");
+    printf("      -p port, xmpp service port\n");
+    printf("      -j jid, login bare JID\n");
+    printf("      -w password, login passowrd\n");
+    printf("      -f ,force TLS\n");
+}
+
+static bool doCmd(xmpp_t *xmpp, char cmd)
+{
+    int looping = true;
+    xmpp_conn_t *conn = xmpphelper_get_conn(xmpp);
+    switch (cmd)
+    {
+        case 'r':
+//            xmpp_ibb_release(g_session);
+            break;
+        case 'q':
+            xmpphelper_stop(xmpp);
+            looping = false;
+            break;
+        case 'e':
+            printf("input target jid to establish session: ");
+            fgets(g_tojid, sizeof(g_tojid), stdin);
+            fprintf(stderr, "tojid '%s' size(%ld)", g_tojid, strlen(g_tojid));
+            g_tojid[strlen(g_tojid) - 1] = '\0';
+            g_session = xmpp_ibb_open(conn, g_tojid, NULL);
+            break;
+        case 'c':
+            if (g_session == NULL || strlen(g_tojid) == 0) {
+                printf("session is not setup. session<%p> target'%s'.", g_session, g_tojid);
+                return looping;
+            }
+            xmpp_ibb_close(g_session);
+            if (g_send_fs != NULL) {
+                fclose(g_send_fs);
+                g_send_fs = NULL;
+            }
+            if (g_recv_fs != NULL) {
+                fclose(g_recv_fs);
+                g_recv_fs = NULL;
+            }
+            g_session = NULL;
+            g_tojid[0] = '\0';
+            break;
+        case 's':
+        {
+            if (g_session == NULL || strlen(g_tojid) == 0) {
+                printf("session is not setup. session<%p> target'%s'.", g_session, g_tojid);
+                return looping;
+            }
+            printf("select file send to target jid '%s': ", g_tojid);
+            char msg[1024] = "";
+            fgets(msg, sizeof(msg), stdin);
+            char *pos;
+            if ((pos=strchr(msg, '\n')) != NULL)
+                    *pos = '\0';
+            g_send_fs = fopen(msg, "r");
+            if (g_send_fs == NULL) {
+                perror("fopen() send failed.\n");
+                return -1;
+            }
+            _send(g_send_off);
+            break;
+        }
+        default:
+            printf("\n 'q' to quit, 'e' establish ibb session, 's' send data to '%s', 'c' close ibb session: ", g_tojid);
+            break;
+    }
+    return looping;
+}
+
+int main(int argc, char *argv[])
+{
+    bool looping = true;
+    int opt;
+    int force_tls = 0;
+    xmpp_t *xmpp;
+    char msg[1024] = "";
+    char *host = "localhost", *jid = "user1@localhost", *pass = "1234";
+    int port = 5222;
+
+    while ((opt = getopt(argc, argv, "s:p:w:j:t:hf")) != -1) {
+        switch (opt)
+        {
+            case 's':
+                host = optarg;
+                break;
+            case 'p':
+                port = atoi(optarg);
+                break;
+            case 'w':
+                pass = optarg;
+                break;
+            case 'f':
+                force_tls = 1;
+                break;
+            case 'j':
+                jid = optarg;
+                break;
+            case 'h':
+            default:
+                print_usage();
+                return -1;
+        }
+    }
+    xmpp_log_t *log = xmpp_get_default_logger(XMPP_LEVEL_DEBUG);
+    xmpp = xmpphelper_new(conn_handler, NULL, log, NULL);
+    if (force_tls == 1) {
+        xmpphelper_force_tls(xmpp);
+    }
+    xmpphelper_connect(xmpp, host, port, jid, pass);
+    xmpp_ibb_reg_funcs_t regfuncs;
+    regfuncs.open_cb = open_cb;
+    regfuncs.close_cb = close_cb;
+    regfuncs.recv_cb = recv_cb;
+    regfuncs.error_cb = error_cb;
+    xmpp_ibb_register(xmpphelper_get_conn(xmpp), &regfuncs);
+    xmpphelper_run(xmpp);
+
+    while (looping && g_looping) {
+        looping = doCmd(xmpp, msg[0]);
+        fgets(msg, sizeof(msg), stdin);
+    }
+    xmpphelper_join(xmpp);
+
+    xmpp_ibb_unregister(xmpphelper_get_conn(xmpp));
+
+    xmpphelper_release(xmpp);
+    return 0;
+}
+
diff --git a/extlibs/wksxmppxep/wks_xep0047/include/xmpp_chat.h b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_chat.h
new file mode 100644
index 000000000..4116c9da8
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_chat.h
@@ -0,0 +1,24 @@
+#ifndef __XMPPCHAT__
+#define __XMPPCHAT__
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "strophe.h"
+#include "xmpp_types.h"
+
+typedef int (*xmppchat_handler)(xmpp_conn_t *conn, xmppdata_t *msgdata, void *udata);
+
+int xmppchat_send_message(xmpp_conn_t *conn, xmppdata_t *msgdata);
+
+void xmppchat_handler_add(xmpp_conn_t *conn, xmppchat_handler handler, void *udata);
+
+void xmppchat_handler_del(xmpp_conn_t *conn, xmppchat_handler handler);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//__XMPPCHAT__
diff --git a/extlibs/wksxmppxep/wks_xep0047/include/xmpp_helper.h b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_helper.h
new file mode 100644
index 000000000..f14feae44
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_helper.h
@@ -0,0 +1,36 @@
+#ifndef _STROPHE_HELPER_
+#define _STROPHE_HELPER_
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#include "strophe.h"
+#include "xmpp_types.h"
+
+typedef int (*xmppconn_handler)(xmpp_t *xmpp, xmppconn_info_t *conninfo, void *userdata);
+
+xmpp_t *xmpphelper_new(xmppconn_handler callback, xmpp_mem_t *mem, xmpp_log_t *log, void *userdata);
+
+int xmpphelper_connect(xmpp_t *xmpp, char *host, int port, char *jid, char *pass);
+
+int xmpphelper_run(xmpp_t *xmpp);
+
+int xmpphelper_stop(xmpp_t *xmpp);
+
+int xmpphelper_join(xmpp_t *xmpp);
+
+int xmpphelper_release(xmpp_t *xmpp);
+
+xmpp_conn_t *xmpphelper_get_conn(xmpp_t *xmpp);
+
+const char * xmpphelper_get_bound_jid(xmpp_t *xmpp);
+
+int xmpphelper_force_tls(xmpp_t *xmpp);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//_STROPHE_HELPER_
diff --git a/extlibs/wksxmppxep/wks_xep0047/include/xmpp_ibb.h b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_ibb.h
new file mode 100644
index 000000000..6444cc39c
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_ibb.h
@@ -0,0 +1,232 @@
+#ifndef __XMPP_IBB_H__
+#define __XMPP_IBB_H__
+
+#include "strophe.h"
+#include "xmpp_types.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define MAX_XMPPUN_LEN  128
+#define MAX_XMPPPW_LEN  128
+#define MAX_XMPPSV_LEN  128
+#define MAX_ID_LEN      128
+#define MAX_JID_LEN     255
+#define MAX_SID_LEN     128
+
+#define XMLNS_IBB "http://jabber.org/protocol/ibb"
+typedef enum
+{
+    STATE_NONE,
+    STATE_OPENING,
+    STATE_READY,
+    STATE_SENDING,
+    STATE_CLOSING,
+    STATE_FAILED
+} xmpp_ibb_state_t;
+
+/* xmpp_ibb_data_t and xmpp_ibb_session_t is not used in version 1.0 now.
+ It is used for multi IBB session handle
+ */
+typedef struct _xmpp_ibb_session_t
+{
+    //for session
+    xmpp_conn_t* conn;
+    char id[MAX_ID_LEN];
+    char sid[MAX_SID_LEN];
+    int block_size;
+    char peer[MAX_JID_LEN];
+    xmpp_ibb_state_t state;
+
+    //for data
+    int send_seq;
+    int recv_seq;
+    int data_ack_count; //how many data ack has been received
+    unsigned char *recv_data;
+    void *userdata;
+
+    struct _xmpp_ibb_session_t *next;
+    struct _xmpp_ibb_session_t *internal_next;
+
+} xmpp_ibb_session_t;
+
+/**
+ * xmpp_ibb_open_cb
+ *
+ * callback function, when open required or ack result of open.
+ *
+ * @param sess session of IBB
+ * @param type type of stanza, set or result
+ * @return
+ */
+typedef int (*xmpp_ibb_open_cb)(xmpp_ibb_session_t *sess, char *type);
+
+/**
+ * xmpp_ibb_close_cb
+ *
+ * callback function, when close required or ack result of close,
+ *   IBB session freed after called.
+ *
+ * @param sess session of IBB
+ * @param type type of stanza set or result
+ * @return 0 is OK, others error.
+ */
+typedef int (*xmpp_ibb_close_cb)(xmpp_ibb_session_t *sess, char *type);
+
+/**
+ * xmpp_ibb_data_cb
+ *
+ * callback function, when data received or ack result of send data.
+ *
+ * @param sess session of IBB
+ * @param xdata xdata if NULL, means stanza type is 'result',
+ *          otherwise stanza type is set, and message data in xdata
+ * @return 0 is OK, others error.
+ */
+typedef int (*xmpp_ibb_data_cb)(xmpp_ibb_session_t *sess, xmppdata_t *xdata);
+
+/**
+ * xmpp_ibb_error_cb
+ *
+ * callback function, when error occurred,
+ *   IBB session freed after called.
+ *
+ * @param sess session of IBB
+ * @param xerror error information
+ * @return 0 is OK, others error.
+ */
+typedef int (*xmpp_ibb_error_cb)(xmpp_ibb_session_t *sess, xmpperror_t *xerror);
+
+typedef struct _xmpp_ibb_reg_funcs_t {
+    xmpp_ibb_open_cb open_cb;
+    xmpp_ibb_close_cb close_cb;
+    xmpp_ibb_data_cb recv_cb;
+    xmpp_ibb_error_cb error_cb;
+} xmpp_ibb_reg_funcs_t;
+
+/**
+ * xmpp_ibb_register
+ *
+ * register callback functions for IBB.
+ *
+ * @param conn conn of libstrophe.
+ * @param reg_funcs register functions for IBB
+ */
+void xmpp_ibb_register(xmpp_conn_t * const conn, xmpp_ibb_reg_funcs_t *reg_funcs);
+
+/**
+ * xmpp_ibb_unregister
+ *
+ * unregister callback for IBB.
+ *
+ * @param conn conn of libstrophe.
+ */
+void xmpp_ibb_unregister(xmpp_conn_t * const conn);
+
+/**
+ * xmpp_ibb_open
+ *
+ * establish an IBB session.
+ *
+ * @param conn conn of libstrophe
+ * @param jid target jid to establish
+ * @param sid if set, specific session id, otherwise use random generate.
+ * @return session of IBB
+ */
+xmpp_ibb_session_t *xmpp_ibb_open(xmpp_conn_t * const conn, char * const jid, char * const sid);
+
+/**
+ * xmpp_ibb_close
+ *
+ * close an IBB session.
+ *
+ * @param sess session of IBB
+ * @return 0 is OK, others error.
+ */
+int xmpp_ibb_close(xmpp_ibb_session_t *sess);
+
+/**
+ * xmpp_ibb_send_data
+ *
+ * send data.
+ *
+ * @param sess session of IBB
+ * @param xdata message data to send
+ * @return 0 is OK, others error.
+ */
+int xmpp_ibb_send_data(xmpp_ibb_session_t *sess, xmppdata_t *xdata);
+
+/**
+ * xmpp_ibb_get_conn
+ *
+ * get conn of libstrophe.
+ *
+ * @param sess session of IBB
+ * @return conn of libstrophe
+ */
+xmpp_conn_t * xmpp_ibb_get_conn(xmpp_ibb_session_t *sess);
+
+/**
+ * xmpp_ibb_get_sid
+ *
+ * get session id.
+ *
+ * @param sess session of IBB
+ * @return session id
+ */
+char * xmpp_ibb_get_sid(xmpp_ibb_session_t *sess);
+
+/**
+ * xmpp_ibb_get_remote_jid
+ *
+ * get remote JID.
+ *
+ * @param sess session of IBB
+ * @return remote jid
+ */
+char * xmpp_ibb_get_remote_jid(xmpp_ibb_session_t *sess);
+
+/**
+ * xmpp_ibb_get_session_by_sid
+ *
+ * get IBB session by session id.
+ *
+ * @param sid session id
+ * @return session of IBB, if not found, return NULL
+ */
+xmpp_ibb_session_t *xmpp_ibb_get_session_by_sid(char *sid);
+
+/**
+ * xmpp_ibb_userdata_alloc
+ *
+ * allocate memory for user data, memory will be released in xmpp_ibb_release()
+ *
+ * @param sess session of IBB
+ * @param udata [OUT] memory pointer for user data
+ * @param size memory size required
+ * @return 0 is OK, others error.
+ */
+int xmpp_ibb_userdata_alloc(xmpp_ibb_session_t *sess, void **udata, int size);
+
+/**
+ * get block size of IBB session
+ *
+ * @param sess session of IBB
+ * @return block size
+ */
+int xmpp_ibb_get_blocksize(xmpp_ibb_session_t *sess);
+
+/**
+ * set block size for IBB session
+ * @param sess session of IBB
+ * @param bsize block size
+ */
+void xmpp_ibb_set_blocksize(xmpp_ibb_session_t *sess, int bsize);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//__XMPP_IBB_H__
diff --git a/extlibs/wksxmppxep/wks_xep0047/include/xmpp_types.h b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_types.h
new file mode 100644
index 000000000..5a55f25ab
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_types.h
@@ -0,0 +1,39 @@
+/*
+ * xmpp_types.h
+ *
+ *  Created on: Aug 5, 2015
+ *      Author: user
+ */
+
+#ifndef INC_XMPP_TYPES_H_
+#define INC_XMPP_TYPES_H_
+
+#define XMPP_NS_STANZAS "urn:ietf:params:xml:ns:xmpp-stanzas"
+
+typedef struct _xmpp_t xmpp_t;
+
+typedef struct _xmppdata_t
+{
+    void *data;
+    int size;
+    char *tojid;
+    char *from;
+} xmppdata_t;
+
+typedef struct _xmppconn_info_t
+{
+    int connevent;
+    int error;
+    int errortype;
+    char *errortext;
+} xmppconn_info_t;
+
+typedef struct _xmpperror_t
+{
+    int  code;
+    char type[8];
+    char mesg[64];
+    char *desc;
+} xmpperror_t;
+
+#endif /* INC_XMPP_TYPES_H_ */
diff --git a/extlibs/wksxmppxep/wks_xep0047/include/xmpp_utils.h b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_utils.h
new file mode 100644
index 000000000..8230a3dc3
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/include/xmpp_utils.h
@@ -0,0 +1,49 @@
+#ifndef __XMPP_UTILS_H__
+#define __XMPP_UTILS_H__
+
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+char *xmpp_b64encode(const char *data, size_t dlen, char **encdata);
+
+char *xmpp_b64decode(const char *encdata, char **decdata, size_t *dlen);
+
+void xmpp_b64free(void *ptr);
+
+/**
+ * generate a nmtoken string
+ *
+ * @param dst [OUT] output string
+ * @param length nmtoken length
+ */
+void nmtoken_generate(char *dst, int length);
+
+/**
+ * item list function set
+ */
+typedef struct _ilist_t ilist_t;
+typedef bool (*find_fp)(void *item, void *key);
+
+ilist_t * ilist_new();
+
+void ilist_destroy(ilist_t *il);
+
+void ilist_add(ilist_t *il, void *item);
+
+void ilist_remove(ilist_t *il, void *item);
+
+void * ilist_finditem_func(ilist_t *il, find_fp ff, void *key);
+
+bool ilist_foundinlist(ilist_t *il, void * item);
+
+int ilist_size(ilist_t *il);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//__XMPP_UTILS_H__
diff --git a/extlibs/wksxmppxep/wks_xep0047/source/xmpp_chat.c b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_chat.c
new file mode 100644
index 000000000..fffb8d72c
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_chat.c
@@ -0,0 +1,72 @@
+#include <string.h>
+#include <xmpp_chat.h>
+#include "xmpp_common.h"
+
+typedef struct _xmppchat_userdata_t
+{
+    xmppchat_handler handler;
+    void *userdata;
+} xmppchat_userdata_t;
+
+static xmppchat_userdata_t s_chat_udata;
+
+int xmppchat_send_message(xmpp_conn_t *conn, xmppdata_t *xdata)
+{
+    xmpp_stanza_t *szmsg, *szbody, *sztext;
+    xmpp_ctx_t *ctx;
+
+    ctx = xmpp_conn_get_context(conn);
+
+    sztext = xmpp_stanza_new(ctx);
+    xmpp_stanza_set_text(sztext, xdata->data);
+
+    szbody = xmpp_stanza_new(ctx);
+    xmpp_stanza_set_name(szbody, "body");
+    xmpp_stanza_add_child(szbody, sztext);
+
+    szmsg = xmpp_stanza_new(ctx);
+    xmpp_stanza_set_name(szmsg, "message");
+    xmpp_stanza_set_type(szmsg, "chat");
+    xmpp_stanza_set_attribute(szmsg, "to", xdata->tojid);
+    xmpp_stanza_add_child(szmsg, szbody);
+
+    xmpp_send(conn, szmsg);
+    xmpp_stanza_release(szmsg);
+
+    return 0;
+}
+
+static int _chat_handler(xmpp_conn_t * const conn, xmpp_stanza_t * const stanza, void * const userdata)
+{
+    xmppdata_t xdata;
+    char *intext;
+
+    xmppchat_userdata_t *udata = (xmppchat_userdata_t *) userdata;
+
+    if (!xmpp_stanza_get_child_by_name(stanza, "body"))
+        return 1;
+    if (xmpp_stanza_get_attribute(stanza, "type") != NULL && !strcmp(xmpp_stanza_get_attribute(stanza, "type"), "error"))
+        return 1;
+    intext = xmpp_stanza_get_text(xmpp_stanza_get_child_by_name(stanza, "body"));
+
+    //printf("Incoming message from %s: %s\n", xmpp_stanza_get_attribute(stanza, "from"), intext);
+    xdata.from = xmpp_stanza_get_attribute(stanza, "from");
+    xdata.data = (void *) intext;
+    if (udata != NULL && udata->handler != NULL)
+        udata->handler(conn, &xdata, udata->userdata);
+    return 1;
+}
+
+void xmppchat_handler_add(xmpp_conn_t *conn, xmppchat_handler handler, void *userdata)
+{
+    //xmppchat_userdata_t *udata;
+    //udata = (xmppchat_userdata_t *) malloc(sizeof(xmppchat_userdata_t));
+    s_chat_udata.handler = handler;
+    s_chat_udata.userdata = userdata;
+    xmpp_handler_add(conn, _chat_handler, NULL, "message", "chat", &s_chat_udata);
+}
+
+void xmppchat_handler_del(xmpp_conn_t *conn, xmppchat_handler handler)
+{
+    xmpp_handler_delete(conn, _chat_handler);
+}
diff --git a/extlibs/wksxmppxep/wks_xep0047/source/xmpp_common.c b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_common.c
new file mode 100644
index 000000000..52c8df993
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_common.c
@@ -0,0 +1,164 @@
+/*
+ * xmpp_common.c
+ *
+ *  Created on: Aug 7, 2015
+ *      Author: user
+ */
+#include <string.h>
+#include <stdlib.h>
+
+#include "xmpp_common.h"
+
+void xmpp_presence(xmpp_conn_t *conn, char *to)
+{
+    xmpp_ctx_t *ctx;
+    xmpp_stanza_t *szpres;
+
+    ctx = xmpp_conn_get_context(conn);
+    szpres = xmpp_stanza_new(ctx);
+    xmpp_stanza_set_name(szpres, "presence");
+    if (to != NULL && strlen(to) > 0) {
+        xmpp_stanza_set_attribute(szpres, "to", to);
+    }
+    xmpp_send(conn, szpres);
+    xmpp_stanza_release(szpres);
+}
+
+void xmpp_ping(xmpp_conn_t * const conn, char* const id, char * const to,
+        char * const type)
+{
+    if (type != NULL && strcmp(type, "result") == 0) {
+        xmpp_iq_ack_result(conn, id, to);
+    } else {
+        xmpp_stanza_t *iq = NULL, *ping = NULL;
+        xmpp_ctx_t *ctx;
+        const char *jid = xmpp_conn_get_bound_jid(conn);
+
+        ctx = xmpp_conn_get_context(conn);
+        iq = xmpp_stanza_new(ctx);
+
+        xmpp_stanza_set_name(iq, "iq");
+        if (type != NULL && strlen(type) > 0) {
+            xmpp_stanza_set_type(iq, type);
+        } else {
+            xmpp_stanza_set_type(iq, "get");
+        }
+        if (id != NULL && strlen(id) > 0) {
+            xmpp_stanza_set_id(iq, id);
+        } else {
+            xmpp_stanza_set_id(iq, jid);
+        }
+        xmpp_stanza_set_attribute(iq, "from", jid);
+        xmpp_stanza_set_attribute(iq, "to", to);
+
+        ping = xmpp_stanza_new(ctx);
+        xmpp_stanza_set_name(ping, "ping");
+        xmpp_stanza_set_ns(ping, XMLNS_PING);
+        xmpp_stanza_add_child(iq, ping);
+
+        xmpp_send(conn, iq);
+        if (ping != NULL)
+            xmpp_stanza_release(ping);
+        if (iq != NULL)
+            xmpp_stanza_release(iq);
+    }
+}
+
+void xmpp_error_stanza(xmpp_stanza_t * const error, xmpperror_t *xerr)
+{
+    char *mesg = NULL;
+    char *code = NULL;
+    xmpp_stanza_t *stanza = NULL;
+
+    if (error == NULL || xerr == NULL) return;
+
+    code = xmpp_stanza_get_attribute(error, "code");
+    if (code == NULL)
+        xerr->code = -1;
+    else
+        xerr->code = atoi(code);
+    strncpy(xerr->type, xmpp_stanza_get_type(error), sizeof(xerr->type));
+    stanza = xmpp_stanza_get_child_by_ns(error, XMPP_NS_STANZAS);
+    if (stanza != NULL) mesg = xmpp_stanza_get_name(stanza);
+    if (mesg != NULL) strncpy(xerr->mesg, mesg, sizeof(xerr->mesg));
+}
+
+void xmpp_iq_ack_result(xmpp_conn_t * const conn, char * const id,
+        char * const to)
+{
+    xmpp_stanza_t *iq = NULL;
+    xmpp_ctx_t *ctx;
+
+    ctx = xmpp_conn_get_context(conn);
+    iq = xmpp_stanza_new(ctx);
+
+    if (iq == NULL || to == NULL) {
+        fprintf(stderr, "%s() failed.\n", __FUNCTION__);
+        return;
+    }
+
+    if (iq != NULL) {
+        xmpp_stanza_set_name(iq, "iq");
+        xmpp_stanza_set_type(iq, "result");
+        xmpp_stanza_set_id(iq, id);
+        xmpp_stanza_set_attribute(iq, "from", xmpp_conn_get_bound_jid(conn));
+        xmpp_stanza_set_attribute(iq, "to", to);
+        xmpp_send(conn, iq);
+        xmpp_stanza_release(iq);
+    }
+}
+
+void xmpp_iq_ack_error(xmpp_conn_t * const conn, char * const id,
+        char * const to, char * const etype, char * const emesg)
+{
+    xmpp_stanza_t *iq = NULL;
+    xmpp_stanza_t *stanza = NULL;
+    xmpp_stanza_t *error = NULL;
+    xmpp_ctx_t *ctx;
+
+    ctx = xmpp_conn_get_context(conn);
+    iq = xmpp_stanza_new(ctx);
+
+    if (iq == NULL || to == NULL) {
+        fprintf(stderr, "%s() failed.\n", __FUNCTION__);
+        return;
+    }
+
+    if (iq != NULL) {
+        xmpp_stanza_set_name(iq, "iq");
+        xmpp_stanza_set_type(iq, "error");
+        if (id != NULL)
+            xmpp_stanza_set_id(iq, id);
+        xmpp_stanza_set_attribute(iq, "from", xmpp_conn_get_bound_jid(conn));
+        xmpp_stanza_set_attribute(iq, "to", to);
+
+        error = xmpp_stanza_new(ctx);
+        if (error != NULL) {
+            xmpp_stanza_set_name(error, "error");
+            xmpp_stanza_set_type(error, etype);
+            xmpp_stanza_add_child(iq, error);
+        }
+    }
+
+    if (error != NULL) {
+        stanza = xmpp_stanza_new(ctx);
+        if (stanza != NULL) {
+            xmpp_stanza_set_name(stanza, emesg);
+            xmpp_stanza_set_ns(stanza, XMPP_NS_STANZAS);
+            xmpp_stanza_add_child(error, stanza);
+        }
+    }
+
+    if (iq != NULL) {
+        xmpp_send(conn, iq);
+        xmpp_stanza_release(iq);
+    }
+
+    if (error != NULL) {
+        xmpp_stanza_release(error);
+    }
+
+    if (stanza != NULL) {
+        xmpp_stanza_release(stanza);
+    }
+}
diff --git a/extlibs/wksxmppxep/wks_xep0047/source/xmpp_common.h b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_common.h
new file mode 100644
index 000000000..72edb49af
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_common.h
@@ -0,0 +1,50 @@
+#ifndef __XMPP_COMMON__
+#define __XMPP_COMMON__
+
+#include <pthread.h>
+
+#include "../include/xmpp_helper.h"
+#include "strophe.h"
+
+#define XMLNS_PING "urn:xmpp:ping"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+struct _xmpp_t
+{
+    xmpp_ctx_t *ctx;
+    xmpp_conn_t *conn;
+    xmpp_mem_t *mem;
+    xmpp_log_t *log;
+    pthread_t pth;
+    xmppconn_handler callback;
+    int force_tls;
+    void *userdata;
+};
+
+/**
+ *
+ * @param conn conn for libstrophe
+ * @param to to target, if null or "", will not specific target.
+ */
+void xmpp_presence(xmpp_conn_t * const conn, char * const to);
+
+void xmpp_ping(xmpp_conn_t * const conn, char* const id, char * const to,
+        char * const type);
+
+void xmpp_iq_ack_result(xmpp_conn_t * const conn, char * const id,
+        char * const to);
+
+void xmpp_iq_ack_error(xmpp_conn_t * const conn, char * const id,
+        char * const to, char * const etype, char * const emesg);
+
+void xmpp_error_stanza(xmpp_stanza_t * const error, xmpperror_t *xerr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//__XMPP_COMMON__
diff --git a/extlibs/wksxmppxep/wks_xep0047/source/xmpp_helper.c b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_helper.c
new file mode 100644
index 000000000..f5a7e05cf
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_helper.c
@@ -0,0 +1,173 @@
+#include <stdlib.h>
+#include <pthread.h>
+#include <xmpp_helper.h>
+#include "xmpp_common.h"
+
+time_t glast_ping_time;
+
+static int _ping_handler(xmpp_conn_t * const conn, xmpp_stanza_t * const stanza, void * const userdata)
+{
+    char *to;
+    char *id;
+    to = xmpp_stanza_get_attribute(stanza, "from");
+    id = xmpp_stanza_get_attribute(stanza, "id");
+    xmpp_ping(conn, id, to, "result");
+    //xmpp_ping(conn, NULL, to, NULL);
+    return 1;
+}
+
+static int _stanza_handler(xmpp_conn_t * const conn, xmpp_stanza_t * const stanza, void * const userdata)
+{
+    //fprintf(stderr, "    %s-%d: %s() name '%s' id '%s'\n", __FILE__, __LINE__, __FUNCTION__, xmpp_stanza_get_name(stanza), xmpp_stanza_get_id(stanza));
+    return 1;
+}
+
+static void _conn_handler(xmpp_conn_t * const conn, const xmpp_conn_event_t status, const int error, xmpp_stream_error_t * const stream_error, void * const userdata)
+{
+    xmpp_t *xmpp;
+
+    xmpp = (xmpp_t *) userdata;
+
+    if (status == XMPP_CONN_CONNECT) {
+        if (xmpp != NULL && xmpp->force_tls == 1 && xmpp_conn_is_secured(conn) == 0) {
+            xmpphelper_stop(xmpp);
+            if (xmpp->callback != NULL) {
+                xmppconn_info_t conninfo;
+                conninfo.connevent = (int) XMPP_CONN_DISCONNECT;
+                conninfo.error = -1;
+                conninfo.errortext = NULL;
+                conninfo.errortype = 0;
+                xmpp->callback(xmpp, &conninfo, xmpp->userdata);
+            }
+            return;
+        } else {
+            xmpp_presence(conn, "");
+            xmpp_handler_add(conn, _ping_handler, XMLNS_PING, "iq", "get", xmpp);
+            xmpp_handler_add(conn, _stanza_handler, NULL, NULL, NULL, xmpp);
+        }
+    } else if (status == XMPP_CONN_DISCONNECT) {
+        xmpp_handler_delete(conn, _ping_handler);
+        xmpp_handler_delete(conn, _stanza_handler);
+        xmpp_stop(xmpp->ctx);
+    } else {
+        fprintf(stderr, "\n    unknown status(%d) \n\n", status);
+    }
+
+    if (xmpp != NULL && xmpp->callback != NULL) {
+        xmppconn_info_t conninfo;
+        conninfo.connevent = (int) status;
+        conninfo.error = error;
+        if (stream_error != NULL) {
+            conninfo.errortype = (int) stream_error->type;
+            conninfo.errortext = stream_error->text;
+        } else {
+            conninfo.errortext = NULL;
+            conninfo.errortype = 0;
+        }
+        xmpp->callback(xmpp, &conninfo, xmpp->userdata);
+    }
+}
+
+static void *pth_func(void *arg)
+{
+    xmpp_t *xmpp;
+    xmpp = (xmpp_t *) arg;
+    xmpp_run(xmpp->ctx);
+    return NULL;
+}
+
+xmpp_t *xmpphelper_new(xmppconn_handler cb, xmpp_mem_t *mem, xmpp_log_t *log, void *userdata)
+{
+    xmpp_t *xmpp;
+    xmpp = (xmpp_t *) malloc(sizeof(struct _xmpp_t));
+
+    if (xmpp == NULL) {
+        return NULL;
+    }
+
+    xmpp_initialize();
+    xmpp->mem = mem;
+    xmpp->log = log;
+    xmpp->ctx = xmpp_ctx_new(NULL, xmpp->log);
+    xmpp->conn = xmpp_conn_new(xmpp->ctx);
+    xmpp->force_tls = 0;
+    xmpp->callback = cb;
+    xmpp->userdata = userdata;
+
+    return xmpp;
+}
+
+int xmpphelper_connect(xmpp_t *xmpp, char *host, int port, char *jid, char *pass)
+{
+    if (xmpp == NULL) return -1;
+
+    xmpp_conn_set_jid(xmpp->conn, jid);
+    xmpp_conn_set_pass(xmpp->conn, pass);
+    xmpp_connect_client(xmpp->conn, host, port, _conn_handler, xmpp);
+
+    return 0;
+}
+
+int xmpphelper_run(xmpp_t *xmpp)
+{
+    if (xmpp == NULL) return -1;
+
+    pthread_create(&xmpp->pth, NULL, pth_func, xmpp);
+
+    return 0;
+}
+
+int xmpphelper_stop(xmpp_t *xmpp)
+{
+    if (xmpp == NULL) return -1;
+
+    xmpp_disconnect(xmpp->conn);
+    xmpp_stop(xmpp->ctx);
+
+    return 0;
+}
+
+int xmpphelper_join(xmpp_t *xmpp)
+{
+    if (xmpp == NULL) return -1;
+
+    pthread_join(xmpp->pth, NULL);
+
+    return 0;
+}
+
+int xmpphelper_release(xmpp_t *xmpp)
+{
+    if (xmpp == NULL) return -1;
+
+    xmpp_conn_release(xmpp->conn);
+    xmpp->conn = NULL;
+    xmpp_ctx_free(xmpp->ctx);
+    xmpp->ctx = NULL;
+    xmpp_shutdown();
+    free(xmpp);
+    return 0;
+}
+
+xmpp_conn_t *xmpphelper_get_conn(xmpp_t *xmpp)
+{
+    if (xmpp == NULL) return NULL;
+
+    return xmpp->conn;
+}
+
+const char * xmpphelper_get_bound_jid(xmpp_t *xmpp)
+{
+    if (xmpp == NULL) return NULL;
+
+    return xmpp_conn_get_bound_jid(xmpp->conn);
+}
+
+int xmpphelper_force_tls(xmpp_t *xmpp)
+{
+    if (xmpp == NULL) return -1;
+
+    xmpp->force_tls = 1;
+
+    return 0;
+}
diff --git a/extlibs/wksxmppxep/wks_xep0047/source/xmpp_ibb.c b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_ibb.c
new file mode 100644
index 000000000..7d4fa5a84
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_ibb.c
@@ -0,0 +1,512 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+
+#include "strophe.h"
+#include "xmpp_ibb.h"
+#include "xmpp_utils.h"
+#include "xmpp_common.h"
+
+#define IBB_DEFAULT_BLOCK_SIZE 4096
+
+extern time_t glast_ping_time;
+xmpp_ibb_session_t *gXMPP_IBB_handle_head = NULL, *gXMPP_IBB_handle_tail = NULL;
+ilist_t *g_list = NULL;
+
+typedef struct _xmpp_ibb_userdata_t
+{
+    xmpp_ibb_open_cb open_cb;
+    xmpp_ibb_close_cb close_cb;
+    xmpp_ibb_data_cb recv_cb;
+    xmpp_ibb_error_cb error_cb;
+    ilist_t *ilist;
+} xmpp_ibb_userdata_t;
+
+static bool _find_id(void *item, void *key)
+{
+    xmpp_ibb_session_t *sess;
+    sess = (xmpp_ibb_session_t *) item;
+    if (strncmp(sess->id, (char *) key, strlen(key)) == 0)
+        return true;
+    return false;
+}
+
+static bool _find_sid(void *item, void *key)
+{
+    xmpp_ibb_session_t *sess;
+    sess = (xmpp_ibb_session_t *) item;
+    if (strncmp(sess->sid, (char *) key, strlen(key)) == 0)
+        return true;
+    return false;
+}
+
+static bool _find_peer(void *item, void *key)
+{
+    xmpp_ibb_session_t *sess;
+    sess = (xmpp_ibb_session_t *) item;
+    if (strncmp(sess->peer, (char *) key, strlen(key)) == 0)
+        return true;
+    return false;
+}
+
+static void _ibb_session_release(xmpp_ibb_session_t *sess)
+{
+    if (sess == NULL) { return; }
+
+    ilist_remove(g_list, sess);
+    if (sess->userdata != NULL) {
+        free(sess->userdata);
+    }
+    free(sess);
+    //printf("%s(): list size %d.", __FUNCTION__, ilist_size(g_list));
+}
+
+static xmpp_ibb_session_t * _ibb_session_init(xmpp_conn_t * const conn, char * const peer, char * const sid)
+{
+    xmpp_ibb_session_t *sess = NULL;
+    if (conn == NULL || peer == NULL) {
+        return NULL;
+    }
+    sess = malloc(sizeof(struct _xmpp_ibb_session_t));
+    if (sess == NULL) {
+        return NULL;
+    }
+    sess->conn = conn;
+    nmtoken_generate(sess->id, 8);
+    if (sid != NULL && strlen(sid) > 0) {
+        strncpy(sess->sid, sid, sizeof(sess->sid));
+    } else {
+        nmtoken_generate(sess->sid, 8);
+    }
+    sess->block_size = IBB_DEFAULT_BLOCK_SIZE;
+    sess->conn = conn;
+    strncpy(sess->peer, peer, sizeof(sess->peer));
+    sess->state = STATE_OPENING;
+    sess->send_seq = -1;
+    sess->recv_seq = -1;
+    sess->data_ack_count = -1;
+    sess->recv_data = NULL;
+    sess->next = NULL;
+    sess->internal_next = NULL;
+    sess->userdata = NULL;
+    return sess;
+}
+
+static int _ibb_set_handler(xmpp_conn_t * const conn, xmpp_stanza_t * const stanza, void * const userdata)
+{
+    xmpp_stanza_t *child;
+    xmpp_ibb_userdata_t * udata = (xmpp_ibb_userdata_t *) userdata;
+    xmpp_ibb_session_t * sess;
+    char *from, *id, *type;
+
+    id = xmpp_stanza_get_id(stanza);
+    from = xmpp_stanza_get_attribute(stanza, "from");
+    type = xmpp_stanza_get_type(stanza);
+    if ((child = xmpp_stanza_get_child_by_name(stanza, "open")) != NULL) {
+        char *sid = xmpp_stanza_get_attribute(child, "sid");
+        char *bsize = xmpp_stanza_get_attribute(child, "block-size");
+        if (sid == NULL || bsize == NULL) {
+            xmpp_iq_ack_error(conn, id, from, "cancel", "not-acceptable");
+            return 1;
+        } else {
+            xmpp_iq_ack_result(conn, id, from);
+        }
+        sess = _ibb_session_init(conn, from, sid);
+        strncpy(sess->id, id, sizeof(sess->id));
+        strncpy(sess->peer, from, sizeof(sess->peer));
+        sess->state = STATE_READY;
+        sess->block_size = atoi(bsize);
+        if (udata != NULL && udata->open_cb != NULL)
+            udata->open_cb(sess, type);
+        ilist_add(g_list, sess);
+    } else if ((child = xmpp_stanza_get_child_by_name(stanza, "data")) != NULL) {
+        char *sid = xmpp_stanza_get_attribute(child, "sid");
+        sess = ilist_finditem_func(g_list, _find_sid, sid);
+        if (sess != NULL) {
+            xmppdata_t xdata;
+            int seq = 0;
+            char *intext = xmpp_stanza_get_text(child);
+            xmpp_iq_ack_result(conn, id, from);
+            xdata.from = from;
+            strncpy(sess->id, id, sizeof(sess->id));
+            seq = atoi(xmpp_stanza_get_attribute(child, "seq"));
+            if (seq != (sess->recv_seq + 1)) {
+                //printf("sequence number is not continue. new seq %d last seq %d\n", seq, sess->recv_seq);
+            }
+            sess->recv_seq = seq;
+            xmpp_b64decode(intext, (char **) &xdata.data, (size_t *) &xdata.size);
+            if (udata != NULL && udata->recv_cb != NULL)
+                udata->recv_cb(sess, &xdata);
+            xmpp_b64free(sess->recv_data);
+            sess->recv_data = NULL;
+        } else {
+            //printf("unknown session is not in handle.\n");
+            xmpp_iq_ack_error(conn, id, from, "cancel", "item-not-found");
+        }
+    } else if ((child = xmpp_stanza_get_child_by_name(stanza, "close")) != NULL) {
+        char *sid = xmpp_stanza_get_attribute(child, "sid");
+        sess = ilist_finditem_func(g_list, _find_sid, sid);
+        if (sess != NULL) {
+            xmpp_iq_ack_result(conn, id, from);
+            strncpy(sess->id, id, sizeof(sess->id));
+            sess->state = STATE_NONE;
+            if (udata != NULL && udata->close_cb != NULL)
+                udata->close_cb(sess, type);
+            _ibb_session_release(sess);
+        }
+    }
+
+    time(&glast_ping_time);
+
+    return 1;
+}
+
+static int _ibb_result_handler(xmpp_conn_t * const conn, xmpp_stanza_t * const stanza, void * const userdata)
+{
+    xmpp_ibb_session_t * sess;
+    xmpp_ibb_userdata_t * udata = (xmpp_ibb_userdata_t *) userdata;
+    char *id, *type;
+
+    id = xmpp_stanza_get_id(stanza);
+    type = xmpp_stanza_get_type(stanza);
+    sess = ilist_finditem_func(g_list, _find_id, id);
+    if (sess != NULL) {
+        if (sess->state == STATE_OPENING) {
+            //session created ack
+            sess->state = STATE_READY;
+            if (udata != NULL && udata->open_cb != NULL)
+                udata->open_cb(sess, type);
+        } else if (sess->state == STATE_SENDING) {
+            sess->state = STATE_READY;
+            if (udata != NULL && udata->recv_cb != NULL)
+                udata->recv_cb(sess, NULL);
+            //data sent ack
+        } else if (sess->state == STATE_CLOSING) {
+            sess->state = STATE_NONE;
+            if (udata != NULL && udata->close_cb != NULL)
+                udata->close_cb(sess, type);
+            _ibb_session_release(sess);
+        }
+    }
+
+    time(&glast_ping_time);
+    return 1;
+}
+
+static int _ibb_pres_handler(xmpp_conn_t * const conn, xmpp_stanza_t * const stanza, void * const userdata)
+{
+    char *type;
+
+    type = xmpp_stanza_get_type(stanza);
+    if (strncmp(type, "unavailable", 11) == 0) {
+        char *from;
+        xmpp_ibb_session_t * sess;
+        xmpp_ibb_userdata_t * udata = (xmpp_ibb_userdata_t *) userdata;
+        from = xmpp_stanza_get_attribute(stanza, "from");
+        sess = ilist_finditem_func(g_list, _find_peer, from);
+        if (sess != NULL) {
+            //printf("target '%s' unavailable\n", from);
+            if (udata != NULL && udata->close_cb != NULL)
+                udata->close_cb(sess, "result");
+            _ibb_session_release(sess);
+        }
+    }
+    time(&glast_ping_time);
+    return 1;
+}
+
+static int _ibb_error_handler(xmpp_conn_t * const conn, xmpp_stanza_t * const stanza, void * const userdata)
+{
+    xmpp_ibb_session_t * sess;
+    char *id;
+
+    id = xmpp_stanza_get_id(stanza);
+    sess = ilist_finditem_func(g_list, _find_id, id);
+    if (sess != NULL) {
+        xmpp_stanza_t *error;
+        xmpperror_t xerr;
+
+        error = xmpp_stanza_get_child_by_name(stanza, "error");
+        xmpp_error_stanza(error, &xerr);
+        xmpp_ibb_userdata_t * udata = (xmpp_ibb_userdata_t *) userdata;
+        sess->state = STATE_FAILED;
+        if (udata != NULL && udata->error_cb != NULL)
+            udata->error_cb(sess, &xerr);
+        _ibb_session_release(sess);
+    }
+
+    time(&glast_ping_time);
+    return 1;
+}
+
+void xmpp_ibb_register(xmpp_conn_t * const conn, xmpp_ibb_reg_funcs_t *reg)
+{
+    static xmpp_ibb_userdata_t s_ibb_udata;
+
+    if (conn == NULL || reg == NULL) {
+        return;
+    }
+
+    srand(time(NULL)); //for generate random string
+    s_ibb_udata.open_cb = reg->open_cb;
+    s_ibb_udata.close_cb = reg->close_cb;
+    s_ibb_udata.recv_cb = reg->recv_cb;
+    s_ibb_udata.error_cb = reg->error_cb;
+    if (g_list != NULL) {
+        ilist_destroy(g_list);
+    }
+    g_list = ilist_new();
+    xmpp_handler_add(conn, _ibb_set_handler, XMLNS_IBB, "iq", "set", &s_ibb_udata);
+    xmpp_handler_add(conn, _ibb_result_handler, NULL, "iq", "result", &s_ibb_udata);
+    xmpp_handler_add(conn, _ibb_error_handler, NULL, "iq", "error", &s_ibb_udata);
+    xmpp_handler_add(conn, _ibb_pres_handler, NULL, "presence", "unavailable", &s_ibb_udata);
+}
+
+void xmpp_ibb_unregister(xmpp_conn_t * const conn)
+{
+    xmpp_handler_delete(conn, _ibb_set_handler);
+    xmpp_handler_delete(conn, _ibb_result_handler);
+    xmpp_handler_delete(conn, _ibb_error_handler);
+    xmpp_handler_delete(conn, _ibb_pres_handler);
+    ilist_destroy(g_list);
+}
+
+int xmpp_ibb_send_data(xmpp_ibb_session_t *sess, xmppdata_t *xdata)
+{
+    int i;
+    xmpp_stanza_t *iq, *data, *text;
+    char *encode, seqchar[16] = "";
+    xmpp_ctx_t *ctx;
+    if (sess == NULL || xdata == NULL) {
+        return -1;
+    }
+    if (xdata->size > (sess->block_size / 4 * 3)) {
+        return -1;
+    }
+    const char *jid = xmpp_conn_get_bound_jid(sess->conn);
+
+    for (i = 0; i < 50; i++) {
+        if (sess->state == STATE_READY) {
+            break ;
+        } else if (sess->state == STATE_SENDING) {
+            fprintf(stderr, "skip invalid state(%d).\n", sess->state);
+            break ;
+        } else if (sess->state == STATE_OPENING) {
+            usleep(100000);
+        } else {
+            fprintf(stderr, "invalid state(%d).\n", sess->state);
+            break ;
+        }
+    }
+
+    if (sess->state != STATE_SENDING && sess->state != STATE_READY) {
+        fprintf(stderr, "xmpp_ibb_send_data() failed. state(%d) not ready.\n", sess->state);
+        return -1;
+    }
+
+    if (!ilist_foundinlist(g_list, sess)) {
+        fprintf(stderr, "session is not in handle, may be closed.\n");
+        return -1;
+    }
+
+    ctx = xmpp_conn_get_context(sess->conn);
+
+    iq = xmpp_stanza_new(ctx);
+    data = xmpp_stanza_new(ctx);
+    text = xmpp_stanza_new(ctx);
+    nmtoken_generate(sess->id, 8);
+
+    xmpp_stanza_set_name(iq, "iq");
+    xmpp_stanza_set_type(iq, "set");
+    xmpp_stanza_set_id(iq, sess->id);
+    xmpp_stanza_set_attribute(iq, "to", sess->peer);
+    xmpp_stanza_set_attribute(iq, "from", jid);
+
+    xmpp_stanza_set_name(data, "data");
+    xmpp_stanza_set_ns(data, XMLNS_IBB);
+    xmpp_stanza_set_attribute(data, "sid", sess->sid);
+    snprintf(seqchar, sizeof(seqchar), "%d", ++(sess->send_seq));
+    xmpp_stanza_set_attribute(data, "seq", seqchar);
+
+    xmpp_b64encode(xdata->data, xdata->size, &encode);
+    if (encode == NULL) {
+        xmpp_stanza_set_text_with_size(text, "", 0);
+    } else {
+        xmpp_stanza_set_text_with_size(text, encode, strlen(encode));
+    }
+
+    xmpp_stanza_add_child(data, text);
+    xmpp_stanza_add_child(iq, data);
+    sess->state = STATE_SENDING;
+    xmpp_send(sess->conn, iq);
+
+    xmpp_stanza_release(text);
+    xmpp_stanza_release(data);
+    xmpp_stanza_release(iq);
+    xmpp_b64free(encode);
+
+    return sess->send_seq;
+}
+
+xmpp_conn_t * xmpp_ibb_get_conn(xmpp_ibb_session_t *sess)
+{
+    if (sess == NULL)
+        return NULL;
+
+    return sess->conn;
+}
+
+char * xmpp_ibb_get_sid(xmpp_ibb_session_t *sess)
+{
+    if (sess == NULL)
+        return NULL;
+
+    return sess->sid;
+}
+
+char * xmpp_ibb_get_remote_jid(xmpp_ibb_session_t *sess)
+{
+    if (sess == NULL)
+        return NULL;
+
+    return sess->peer;
+}
+
+xmpp_ibb_session_t *xmpp_ibb_open(xmpp_conn_t * const conn, char * const peer, char * const sid)
+{
+    xmpp_ibb_session_t *sess;
+    xmpp_stanza_t *iq, *open;
+    xmpp_ctx_t *ctx;
+    const char *jid = xmpp_conn_get_bound_jid(conn);
+    char sizetemp[6] = "";
+    int size;
+
+    if (peer == NULL || strlen(peer) == 0) {
+        return NULL;
+    }
+    sess = _ibb_session_init(conn, peer, sid);
+    if (sess == NULL) {
+        return NULL;
+    }
+    size = snprintf(sizetemp, sizeof(sizetemp), "%d", sess->block_size);
+    if (size < sizeof(sizetemp)) {
+        sizetemp[size] = '\0';
+    }
+    nmtoken_generate(sess->id, 8);
+
+    ctx = xmpp_conn_get_context(conn);
+    iq = xmpp_stanza_new(ctx);
+    xmpp_stanza_set_name(iq, "iq");
+    xmpp_stanza_set_type(iq, "set");
+    xmpp_stanza_set_id(iq, sess->id);
+    xmpp_stanza_set_attribute(iq, "from", jid);
+    xmpp_stanza_set_attribute(iq, "to", sess->peer);
+
+    open = xmpp_stanza_new(ctx);
+    xmpp_stanza_set_name(open, "open");
+    xmpp_stanza_set_ns(open, XMLNS_IBB);
+    xmpp_stanza_set_attribute(open, "block-size", sizetemp);
+    xmpp_stanza_set_attribute(open, "sid", sess->sid);
+    xmpp_stanza_set_attribute(open, "stanza", "iq");
+
+    xmpp_stanza_add_child(iq, open);
+    xmpp_send(conn, iq);
+    xmpp_stanza_release(open);
+    xmpp_stanza_release(iq);
+
+    ilist_add(g_list, sess);
+
+    return sess;
+}
+
+int xmpp_ibb_close(xmpp_ibb_session_t *sess)
+{
+    xmpp_stanza_t *iq, *close;
+    xmpp_ctx_t *ctx;
+    const char *jid;
+
+    if (sess == NULL) { return -1; }
+
+    if (!ilist_foundinlist(g_list, sess)) {
+        fprintf(stderr, "session is not in handle, may be closed.\n");
+        return -1;
+    }
+
+    jid = xmpp_conn_get_bound_jid(sess->conn);
+    ctx = xmpp_conn_get_context(sess->conn);
+
+    iq = xmpp_stanza_new(ctx);
+    close = xmpp_stanza_new(ctx);
+    nmtoken_generate(sess->id, 8);
+
+    xmpp_stanza_set_name(iq, "iq");
+    xmpp_stanza_set_type(iq, "set");
+    xmpp_stanza_set_id(iq, sess->id);
+    xmpp_stanza_set_attribute(iq, "to", sess->peer);
+    xmpp_stanza_set_attribute(iq, "from", jid);
+
+    xmpp_stanza_set_name(close, "close");
+    xmpp_stanza_set_ns(close, XMLNS_IBB);
+    xmpp_stanza_set_attribute(close, "sid", sess->sid);
+
+    xmpp_stanza_add_child(iq, close);
+    xmpp_send(sess->conn, iq);
+    xmpp_stanza_release(close);
+    xmpp_stanza_release(iq);
+
+    sess->state = STATE_CLOSING;
+
+    return 0;
+}
+
+xmpp_ibb_session_t *xmpp_ibb_get_session_by_sid(char *sid)
+{
+    return ilist_finditem_func(g_list, _find_sid, sid);
+}
+
+int xmpp_ibb_userdata_alloc(xmpp_ibb_session_t *sess, void **udata, int size)
+{
+    if (udata == NULL) {
+        return -1;
+    }
+    *udata = NULL;
+    if (sess == NULL || size <= 0) {
+        return -1;
+    }
+    if (!ilist_foundinlist(g_list, sess)) {
+        fprintf(stderr, "session is not in handle, may be closed.\n");
+        return -1;
+    }
+
+    if (sess->userdata != NULL) {
+        //printf("%s() called again, free userdata.\n", __FUNCTION__);
+        free(sess->userdata);
+    }
+
+    sess->userdata = malloc(size);
+    if (sess->userdata == NULL) {
+        fprintf(stderr, "can not allocate memory.\n");
+        return -1;
+    }
+    *udata = sess->userdata;
+
+    return 0;
+}
+
+int xmpp_ibb_get_blocksize(xmpp_ibb_session_t *sess)
+{
+    if (sess == NULL) {
+        return 0;
+    }
+    return sess->block_size;
+}
+
+void xmpp_ibb_set_blocksize(xmpp_ibb_session_t *sess, int bsize)
+{
+    if (sess == NULL) {
+        return;
+    }
+    sess->block_size = bsize;
+}
diff --git a/extlibs/wksxmppxep/wks_xep0047/source/xmpp_utils.c b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_utils.c
new file mode 100644
index 000000000..5d8af70fd
--- /dev/null
+++ b/extlibs/wksxmppxep/wks_xep0047/source/xmpp_utils.c
@@ -0,0 +1,243 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+#include <openssl/bio.h>
+#include <openssl/evp.h>
+
+#include "xmpp_utils.h"
+
+void nmtoken_generate(char *dst, int length)
+{
+    int i, random;
+
+    for (i = 0; i < length; i++) {
+        random = rand() % (26 + 26 + 10);
+        if (random < 26)
+            dst[i] = 'a' + random;
+        else if (random < 26 + 26)
+            dst[i] = 'A' + random - 26;
+        else
+            dst[i] = '0' + random - 26 - 26;
+    }
+    dst[length] = '\0';
+
+}
+
+char *xmpp_b64encode(const char *data, size_t dlen, char **encdata)
+{
+    BIO *bio, *b64;
+    FILE *stream;
+    int encSize = 4 * ceil((double) dlen / 3);
+
+    if (encdata == NULL) {
+        return NULL;
+    }
+    if (data == NULL || dlen <= 0) {
+        *encdata = NULL;
+        return NULL;
+    }
+
+    *encdata = (char *) malloc(encSize + 1);
+    stream = fmemopen((void *) *encdata, encSize + 1, "w");
+
+    b64 = BIO_new(BIO_f_base64());
+    bio = BIO_new_fp(stream, BIO_NOCLOSE);
+    bio = BIO_push(b64, bio);
+    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
+    BIO_write(bio, data, dlen);
+    BIO_flush(bio);
+
+    BIO_free_all(bio);
+    fclose(stream);
+
+    return *encdata;
+}
+
+static size_t decDataLength(const char* encdata)
+{
+
+    int len = strlen(encdata);
+    int padding = 0;
+
+    if (encdata[len - 1] == '=' && encdata[len - 2] == '=') //last two chars are =
+        padding = 2;
+    else if (encdata[len - 1] == '=') //last char is =
+        padding = 1;
+
+    return (size_t) ((len * 3) / 4) - padding;
+}
+
+char *xmpp_b64decode(const char *encdata, char **decdata, size_t *dlen)
+{
+    BIO *bio, *b64;
+    FILE *stream;
+    int len;
+
+    if (decdata == NULL || dlen == NULL) {
+        return NULL;
+    }
+    if (encdata == NULL) {
+        *decdata = NULL;
+        *dlen = 0;
+        return NULL;
+    }
+
+    *dlen = decDataLength(encdata);
+    *decdata = (char *) malloc((*dlen) + 1);
+    stream = fmemopen((void *) encdata, strlen(encdata), "r");
+
+    b64 = BIO_new(BIO_f_base64());
+    bio = BIO_new_fp(stream, BIO_NOCLOSE);
+    bio = BIO_push(b64, bio);
+    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
+    len = BIO_read(bio, *decdata, strlen(encdata));
+    (*decdata)[len] = '\0';
+    BIO_free_all(bio);
+    fclose(stream);
+
+    return *decdata;
+}
+
+void xmpp_b64free(void *ptr)
+{
+    if (ptr == NULL) {
+        return;
+    }
+    free(ptr);
+}
+
+typedef struct _node_t
+{
+    void *item;
+    struct _node_t *next;
+} node_t;
+
+struct _ilist_t
+{
+    int size;
+    node_t *head;
+//    node_t *tail;
+};
+
+ilist_t * ilist_new()
+{
+    ilist_t *il;
+    il = (ilist_t *) malloc(sizeof(struct _ilist_t));
+    if (il == NULL) {
+        return NULL;
+    }
+    il->size = 0;
+    il->head = NULL;
+//    il->tail = NULL;
+    return il;
+}
+
+static node_t * ilist_find_node(ilist_t *il, void *item)
+{
+    node_t *nd;
+    if (il == NULL || item == NULL) {
+        return NULL;
+    }
+    for (nd = il->head; nd != NULL; nd = nd->next) {
+        if (nd->item == item)
+            return nd;
+    }
+    return NULL;
+}
+
+static void ilist_remove_node(ilist_t *il, node_t *nd)
+{
+    node_t *tmp;
+    if (il == NULL) {
+        return;
+    }
+    if (nd == NULL)
+        return;
+    if (il->head == nd) {
+        il->head = nd->next;
+    } else {
+        for (tmp = il->head; tmp != NULL; tmp = tmp->next) {
+            if (tmp->next == nd) {
+                tmp->next = nd->next;
+                break;
+            }
+        }
+    }
+    il->size--;
+    free(nd);
+}
+
+void ilist_destroy(ilist_t *il)
+{
+    node_t *nd;
+    if (il == NULL) {
+        return;
+    }
+    while ((nd = il->head) != NULL) {
+        ilist_remove_node(il, nd);
+    }
+    free(il);
+}
+
+void ilist_add(ilist_t *il, void *item)
+{
+    node_t *nd;
+    if (il == NULL || item == NULL) {
+        return;
+    }
+    nd = (node_t *) malloc(sizeof(struct _node_t));
+    nd->item = item;
+    nd->next = il->head;
+    il->head = nd;
+    il->size++;
+}
+
+void ilist_remove(ilist_t *il, void *item)
+{
+    node_t *nd;
+    if (il == NULL || item == NULL) {
+        return;
+    }
+    nd = ilist_find_node(il, item);
+    if (nd != NULL) {
+        ilist_remove_node(il, nd);
+    }
+}
+
+void * ilist_finditem_func(ilist_t *il, find_fp ff, void *key)
+{
+    node_t *nd;
+    if (il == NULL || ff == NULL || key == NULL)
+        return NULL;
+    for (nd = il->head; nd != NULL; nd = nd->next) {
+        if (ff(nd->item, key)) {
+//            printf("\n  %s-%d: %s(%s) found!!", __FILE__, __LINE__, __FUNCTION__, (char *) key);
+            return nd->item;
+        }
+    }
+    return NULL;
+}
+
+bool ilist_foundinlist(ilist_t *il, void * item)
+{
+    node_t *nd;
+    if (il == NULL) {
+        return false;
+    }
+    for (nd = il->head; nd != NULL; nd = nd->next) {
+        if (nd->item == item) {
+            return true;
+        }
+    }
+    return false;
+}
+
+int ilist_size(ilist_t *il)
+{
+    if (il == NULL) {
+        return -1;
+    }
+    return il->size;
+}
+
-- 
2.16.1.windows.1

