From 0a7a0c5f37252e09ef6023cfd976fa432ae041bd Mon Sep 17 00:00:00 2001
From: "sungmok.shin" <sungmok.shin@lge.com>
Date: Wed, 14 Nov 2018 20:38:25 +0900
Subject: [PATCH] webOS: Refactor oc{server,client}basicops for CTT

Change-Id: I8de9a9ba298ce92de53f408463d757b8d50f01f3
Signed-off-by: sungmok.shin <sungmok.shin@lge.com>
---
 .../secure/occlientbasicops/occlientbasicops.cpp   | 969 +++++++++++++++++++--
 .../secure/ocserverbasicops/ocserverbasicops.cpp   | 516 +++++++++--
 2 files changed, 1333 insertions(+), 152 deletions(-)

diff --git a/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.cpp b/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.cpp
index 5c434f5f0..ece70fed8 100644
--- a/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.cpp
+++ b/resource/csdk/stack/samples/webos/secure/occlientbasicops/occlientbasicops.cpp
@@ -38,20 +38,33 @@
 #include "oic_string.h"
 #include "common.h"
 
-
 /// This example is using experimental API, so there is no guarantee of support for future release,
 /// nor any there any guarantee that breaking changes will not occur across releases.
-#include "experimental/logger.h"
+#include "logger.h"
 
 #include <luna-service2/lunaservice.h>
 #include <pbnjson.h>
 #include <pthread.h>
 #include "logging.h"
 
+#include <iostream>
+#include <sstream>
+#include <cstdlib>
+#include <cstdio>
+#include <fstream>
+#include <regex>
+#include <iomanip>
+
+using namespace std;
+
+#define TAG "occlientbasicops"
+#define MAX_RESOURCE_TYPE_SIZE      (32)
+#define MAX_RESOURCES_REMEMBERED    (100)
+#define MAX_USER_INPUT              (100)
+
 pthread_t threadId_client;
 PmLogContext gLogContext;
 
-#define TAG "occlientbasicops"
 static int UnicastDiscovery = 0;
 static int TestCase = 0;
 static int ConnType = 0;
@@ -70,6 +83,8 @@ static OCConnectivityType ocConnType;
 //of other devices which the client trusts
 static char CRED_FILE_DEVOWNER[] = "oic_svr_db_client_devowner.dat";
 static char CRED_FILE_NONDEVOWNER[] = "oic_svr_db_client_nondevowner.dat";
+static char CRED_FILE_CLIENT[] = "oic_svr_db_client.dat";
+static const char INTROSPECTION_SWAGGER_FILE[] = "introspection_swagger.dat";
 
 //Standard uri prefix for secure virtual resources
 const char * OIC_STD_URI_PREFIX = "/oic/";
@@ -85,6 +100,441 @@ const char * COAPS_TCP_STR = "coaps+tcp";
 static LSHandle *pLsHandle = NULL;
 static GMainLoop *mainloop = NULL;
 static const char *gResourceUri = "/a/led";
+static const char *g_ocfVer = "ocf.1.3.0";
+
+static const char *gPlatformId = "0A3E0D6F-DBF5-404E-8719-D6880042463A";
+static const char *gManufacturerName = "myName";
+static const char *gManufacturerLink = "https://www.iotivity.org";
+static const char *gModelNumber = "myModelNumber";
+static const char *gDateOfManufacture = "2016-01-15";
+static const char *gPlatformVersion = "myPlatformVersion";
+static const char *gOperatingSystemVersion = "myOS";
+static const char *gHardwareVersion = "myHardwareVersion";
+static const char *gFirmwareVersion = "myFirmwareVersion";
+static const char *gSupportLink = "https://www.iotivity.org";
+//static const char *gSystemTime = "2015-05-15T11.04";
+static const char *gSystemTime = "2017-12-01T12:00:00.52Z";
+
+//static const char *gDeviceName = "Binary Switch";
+static const char *gDeviceName = "Smart Home Client Device";
+//static const char *gDeviceType = "oic.d.light";
+static const char *gDeviceType = "oic.wk.d";
+static const char *gSpecVersion = "ocf.1.3.0";
+
+//static const char *gDataModelVersions = "ocf.res.1.3.0,ocf.sh.1.3.0";
+static const char *gDataModelVersions = "ocf.res.1.3.0";
+
+static const char *gProtocolIndependentID = "fa008167-3bbf-4c9d-8604-c9bcb96cb712";
+
+OCPlatformInfo platformInfo;
+
+void DeletePlatformInfo();
+void initializePlatform();
+
+OCStackResult SetDeviceInfo();
+
+const char* decode_oc_stack_result (OCStackResult result)
+{
+    switch (result)
+    {
+        case OC_STACK_OK:
+            return "OC_STACK_OK";
+        case OC_STACK_RESOURCE_DELETED:
+            return "OC_STACK_RESOURCE_DELETED";
+        case OC_STACK_CONTINUE:
+            return "OC_STACK_CONTINUE";
+        case OC_STACK_RESOURCE_CREATED:
+            return "OC_STACK_RESOURCE_CREATED";
+        case OC_STACK_RESOURCE_CHANGED:
+            return "OC_STACK_RESOURCE_CHANGED";
+        case OC_STACK_INVALID_URI:
+            return "OC_STACK_INVALID_URI";
+        case OC_STACK_INVALID_QUERY:
+            return "OC_STACK_INVALID_QUERY";
+        case OC_STACK_INVALID_IP:
+            return "OC_STACK_INVALID_IP";
+        case OC_STACK_INVALID_PORT:
+            return "OC_STACK_INVALID_PORT";
+        case OC_STACK_INVALID_CALLBACK:
+            return "OC_STACK_INVALID_CALLBACK";
+        case OC_STACK_INVALID_METHOD:
+            return "OC_STACK_INVALID_METHOD";
+        case OC_STACK_INVALID_PARAM:
+            return "OC_STACK_INVALID_PARAM";
+        case OC_STACK_INVALID_OBSERVE_PARAM:
+            return "OC_STACK_INVALID_OBSERVE_PARAM";
+        case OC_STACK_NO_MEMORY:
+            return "OC_STACK_NO_MEMORY";
+        case OC_STACK_COMM_ERROR:
+            return "OC_STACK_COMM_ERROR";
+        case OC_STACK_TIMEOUT:
+            return "OC_STACK_TIMEOUT";
+        case OC_STACK_ADAPTER_NOT_ENABLED:
+            return "OC_STACK_ADAPTER_NOT_ENABLED";
+        case OC_STACK_NOTIMPL:
+            return "OC_STACK_NOTIMPL";
+        case OC_STACK_NO_RESOURCE:
+            return "OC_STACK_NO_RESOURCE";
+        case OC_STACK_RESOURCE_ERROR:
+            return "OC_STACK_RESOURCE_ERROR";
+        case OC_STACK_SLOW_RESOURCE:
+            return "OC_STACK_SLOW_RESOURCE";
+        case OC_STACK_DUPLICATE_REQUEST:
+            return "OC_STACK_DUPLICATE_REQUEST";
+        case OC_STACK_NO_OBSERVERS:
+            return "OC_STACK_NO_OBSERVERS";
+        case OC_STACK_OBSERVER_NOT_FOUND:
+            return "OC_STACK_OBSERVER_NOT_FOUND";
+        case OC_STACK_VIRTUAL_DO_NOT_HANDLE:
+            return "OC_STACK_VIRTUAL_DO_NOT_HANDLE";
+        case OC_STACK_INVALID_OPTION:
+            return "OC_STACK_INVALID_OPTION";
+        case OC_STACK_MALFORMED_RESPONSE:
+            return "OC_STACK_MALFORMED_RESPONSE";
+        case OC_STACK_PERSISTENT_BUFFER_REQUIRED:
+            return "OC_STACK_PERSISTENT_BUFFER_REQUIRED";
+        case OC_STACK_INVALID_REQUEST_HANDLE:
+            return "OC_STACK_INVALID_REQUEST_HANDLE";
+        case OC_STACK_INVALID_DEVICE_INFO:
+            return "OC_STACK_INVALID_DEVICE_INFO";
+        case OC_STACK_INVALID_JSON:
+            return "OC_STACK_INVALID_JSON";
+        case OC_STACK_UNAUTHORIZED_REQ:
+            return "OC_STACK_UNAUTHORIZED_REQ";
+        case OC_STACK_PDM_IS_NOT_INITIALIZED:
+            return "OC_STACK_PDM_IS_NOT_INITIALIZED";
+        case OC_STACK_DUPLICATE_UUID:
+            return "OC_STACK_DUPLICATE_UUID";
+        case OC_STACK_INCONSISTENT_DB:
+            return "OC_STACK_INCONSISTENT_DB";
+        case OC_STACK_AUTHENTICATION_FAILURE:
+            return "OC_STACK_AUTHENTICATION_FAILURE";
+        case OC_STACK_ERROR:
+            return "OC_STACK_ERROR";
+        case OC_STACK_TOO_LARGE_REQ:
+            return "OC_STACK_TOO_LARGE_REQ";
+        case OC_STACK_NOT_ALLOWED_OXM:
+            return "OC_STACK_NOT_ALLOWED_OXM";
+        case OC_STACK_BAD_ENDPOINT:
+            return "OC_STACK_BAD_ENDPOINT";
+        case OC_STACK_USER_DENIED_REQ:
+            return "OC_STACK_USER_DENIED_REQ";
+        case OC_STACK_NOT_ACCEPTABLE:
+            return "OC_STACK_NOT_ACCEPTABLE";
+        case OC_STACK_FORBIDDEN_REQ:
+            return "OC_STACK_FORBIDDEN_REQ";
+        case OC_STACK_INTERNAL_SERVER_ERROR:
+            return "OC_STACK_INTERNAL_SERVER_ERROR";
+        case OC_STACK_GATEWAY_TIMEOUT:
+            return "OC_STACK_GATEWAY_TIMEOUT";
+        case OC_STACK_SERVICE_UNAVAILABLE:
+            return "OC_STACK_SERVICE_UNAVAILABLE";
+    #ifdef WITH_PRESENCE
+        case OC_STACK_PRESENCE_STOPPED:
+            return "OC_STACK_PRESENCE_STOPPED";
+        case OC_STACK_PRESENCE_TIMEOUT:
+            return "OC_STACK_PRESENCE_TIMEOUT";
+        case OC_STACK_PRESENCE_DO_NOT_HANDLE:
+            return "OC_STACK_PRESENCE_DO_NOT_HANDLE";
+    #endif
+        default:
+            return "Unknown result!";
+    }
+}
+
+const char* decode_oc_eh_result (OCEntityHandlerResult result)
+{
+    switch(result)
+    {
+        case OC_EH_OK:
+            return "OC_EH_OK";
+        case OC_EH_ERROR:
+            return "OC_EH_ERROR";
+        case OC_EH_SLOW:
+            return "OC_EH_SLOW";
+        case OC_EH_RESOURCE_CREATED:
+            return "OC_EH_RESOURCE_CREATED";
+        case OC_EH_RESOURCE_DELETED:
+            return "OC_EH_RESOURCE_DELETED";
+        case OC_EH_VALID:
+            return "OC_EH_VALID";
+        case OC_EH_CHANGED:
+            return "OC_EH_CHANGED";
+        case OC_EH_CONTENT:
+            return "OC_EH_CONTENT";
+        case OC_EH_BAD_REQ:
+            return "OC_EH_BAD_REQ";
+        case OC_EH_UNAUTHORIZED_REQ:
+            return "OC_EH_UNAUTHORIZED_REQ";
+        case OC_EH_BAD_OPT:
+            return "OC_EH_BAD_OPT";
+        case OC_EH_FORBIDDEN:
+            return "OC_EH_FORBIDDEN";
+        case OC_EH_RESOURCE_NOT_FOUND:
+            return "OC_EH_RESOURCE_NOT_FOUND";
+        case OC_EH_METHOD_NOT_ALLOWED:
+            return "OC_EH_METHOD_NOT_ALLOWED";
+        case OC_EH_NOT_ACCEPTABLE:
+            return "OC_EH_NOT_ACCEPTABLE";
+        case OC_EH_TOO_LARGE:
+            return "OC_EH_TOO_LARGE";
+        case OC_EH_UNSUPPORTED_MEDIA_TYPE:
+            return "OC_EH_UNSUPPORTED_MEDIA_TYPE";
+        case OC_EH_INTERNAL_SERVER_ERROR:
+            return "OC_EH_INTERNAL_SERVER_ERROR";
+        case OC_EH_BAD_GATEWAY:
+            return "OC_EH_BAD_GATEWAY";
+        case OC_EH_SERVICE_UNAVAILABLE:
+            return "OC_EH_SERVICE_UNAVAILABLE";
+        case OC_EH_RETRANSMIT_TIMEOUT:
+            return "OC_EH_RETRANSMIT_TIMEOUT";
+        default:
+            return "Unknown result!";
+    }
+}
+
+const char* decode_oc_method (OCMethod method)
+{
+    switch(method)
+    {
+        case OC_REST_NOMETHOD:
+            return "OC_REST_NOMETHOD";
+        case OC_REST_GET:
+            return "OC_REST_GET";
+        case OC_REST_PUT:
+            return "OC_REST_PUT";
+        case OC_REST_POST:
+            return "OC_REST_POST";
+        case OC_REST_DELETE:
+            return "OC_REST_DELETE";
+        case OC_REST_OBSERVE:
+            return "OC_REST_OBSERVE";
+        case OC_REST_OBSERVE_ALL:
+            return "OC_REST_OBSERVE_ALL";
+        case OC_REST_DISCOVER:
+            return "OC_REST_DISCOVER";
+    #ifdef WITH_PRESENCE
+        case OC_REST_PRESENCE:
+            return "OC_REST_PRESENCE";
+    #endif
+        default:
+            return "Unknown method";
+    }
+}
+
+const char* decode_oc_eh_flag (OCEntityHandlerFlag flag)
+{
+    switch(flag)
+    {
+        case OC_REQUEST_FLAG:
+            return "OC_REQUEST_FLAG";
+        case OC_OBSERVE_FLAG:
+            return "OC_OBSERVE_FLAG";
+        default:
+            return "Unknown oc eh flag";
+    }
+}
+
+void DeletePlatformInfo()
+{
+    free(platformInfo.platformID);
+    free(platformInfo.manufacturerName);
+    free(platformInfo.manufacturerUrl);
+    free(platformInfo.modelNumber);
+    free(platformInfo.dateOfManufacture);
+    free(platformInfo.platformVersion);
+    free(platformInfo.operatingSystemVersion);
+    free(platformInfo.hardwareVersion);
+    free(platformInfo.firmwareVersion);
+    free(platformInfo.supportUrl);
+    free(platformInfo.systemTime);
+}
+
+bool DuplicateString(char** targetString, const char* sourceString)
+{
+    if(!sourceString)
+    {
+        return false;
+    }
+    else
+    {
+        *targetString = (char *) malloc(strlen(sourceString) + 1);
+
+        if(*targetString)
+        {
+            strncpy(*targetString, sourceString, (strlen(sourceString) + 1));
+            return true;
+        }
+    }
+    return false;
+}
+
+
+OCStackResult SetDeviceInfo()
+{
+    OCStackResult result = OC_STACK_ERROR;
+
+    // OC_RSRVD_DEVICE_URI = "/oic/d"
+    OCResourceHandle resourceHandle = OCGetResourceHandleAtUri(OC_RSRVD_DEVICE_URI);
+    if (resourceHandle == NULL)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Device Resource does not exist.");
+        return result;
+    }
+
+    result = OCBindResourceTypeToResource(resourceHandle, gDeviceType);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to add device type");
+        return result;
+    }
+    // OC_RSRVD_DEVICE_NAME = "n"
+    result = OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, gDeviceName);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set device name");
+        return result;
+    }
+    // OC_RSRVD_DATA_MODEL_VERSION = "dmv"
+    result = OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DATA_MODEL_VERSION,
+                                      gDataModelVersions);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set data model versions");
+        return result;
+    }
+    // OC_RSRVD_SPEC_VERSION = "icv"
+    result = OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_SPEC_VERSION, gSpecVersion);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set spec version");
+        return result;
+    }
+    // OC_RSRVD_PROTOCOL_INDEPENDENT_ID = "piid"
+    result = OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_PROTOCOL_INDEPENDENT_ID,
+                                      gProtocolIndependentID);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set piid");
+        return result;
+    }
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Device information initialized successfully.");
+    return OC_STACK_OK;
+}
+
+OCStackResult SetPlatformInfo(const char* platformID, const char *manufacturerName,
+    const char *manufacturerUrl, const char *modelNumber, const char *dateOfManufacture,
+    const char *platformVersion, const char* operatingSystemVersion, const char* hardwareVersion,
+    const char *firmwareVersion, const char* supportUrl, const char* systemTime)
+{
+
+    bool success = true;
+
+    if(manufacturerName != NULL && (strlen(manufacturerName) > MAX_PLATFORM_NAME_LENGTH))
+    {
+        return OC_STACK_INVALID_PARAM;
+    }
+
+    if(manufacturerUrl != NULL && (strlen(manufacturerUrl) > MAX_PLATFORM_URL_LENGTH))
+    {
+        return OC_STACK_INVALID_PARAM;
+    }
+
+    if(!DuplicateString(&platformInfo.platformID, platformID))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.manufacturerName, manufacturerName))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.manufacturerUrl, manufacturerUrl))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.modelNumber, modelNumber))
+    {
+        success = false;
+    }
+if(!DuplicateString(&platformInfo.dateOfManufacture, dateOfManufacture))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.platformVersion, platformVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.operatingSystemVersion, operatingSystemVersion))
+    {
+        success = false;
+    }
+    if(!DuplicateString(&platformInfo.hardwareVersion, hardwareVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.firmwareVersion, firmwareVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.supportUrl, supportUrl))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.systemTime, systemTime))
+    {
+        success = false;
+    }
+
+    if(success)
+    {
+        return OC_STACK_OK;
+    }
+
+    DeletePlatformInfo();
+    return OC_STACK_ERROR;
+}
+
+
+void initializePlatform()
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Running initializePlatform...");
+
+    // initialize "oic/p"
+    OCSAMPLE_LOG_INFO(TAG, 0, "oic/p");
+    OCStackResult result = SetPlatformInfo(gPlatformId, gManufacturerName, gManufacturerLink,
+            gModelNumber, gDateOfManufacture, gPlatformVersion, gOperatingSystemVersion,
+            gHardwareVersion, gFirmwareVersion, gSupportLink, gSystemTime);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Platform info setting failed locally!");
+        return;
+    }
+
+    result = OCSetPlatformInfo(platformInfo);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Platform Registration failed!");
+        return;
+    }
+
+    // initialize "oic/d"
+    OCSAMPLE_LOG_INFO(TAG, 0, "oic/d");
+    result = SetDeviceInfo();
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Device Registration failed!");
+        return;
+    }
+}
 
 /* SIGINT handler: set gQuitFlag to 1 for graceful termination */
 void handleSigInt(int signum)
@@ -381,21 +831,423 @@ FILE *client_fopen_nondevowner(const char *path, const char *mode)
     }
 }
 
-static gboolean clientStarter(gpointer user_data)
+FILE *client_fopen(const char *path, const char *mode)
 {
-    if (!gQuitFlag)
-    {   
+    if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
+    {
+        return fopen(CRED_FILE_CLIENT, mode);
+    }
+    else if (0 == strcmp(path, OC_INTROSPECTION_FILE_NAME))
+    {
+        return fopen(INTROSPECTION_SWAGGER_FILE, mode);
+    }
+
+    else
+    {
+        return fopen(path, mode);
+    }
+}
+
+//static gboolean clientStarter(gpointer user_data)
+void *clientStarter(gpointer user_data)
+{
+    struct timespec timeout;
+
+    timeout.tv_sec  = 0;
+    timeout.tv_nsec = 100000000L;
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "clientStarter...");
+    while (!gQuitFlag)
+    {
         if (OCProcess() != OC_STACK_OK)
         {
             OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack process error");
+            return 0;
         }
-        return TRUE;
-    }   
+        nanosleep(&timeout, NULL);
+    }
+}
+
+static gboolean getInput(gpointer user_data)
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "getInput....");
+    char input[10] = {0};
+    //char * ret = fgets(input, sizeof(input), stdin);
+}
+
+typedef struct
+{
+    char uri[MAX_URI_LENGTH];
+    char resourceType[MAX_RESOURCE_TYPE_SIZE];
+    OCDevAddr address;
+
+} DiscoveredResourceInfo;
+
+static uint32_t DISC_RES_COUNTER = 0;
+static DiscoveredResourceInfo DISC_RES[MAX_RESOURCES_REMEMBERED];
+static bool PROMPT_USER = false;
+static bool DISCOVERING = false;
+
+static void
+PrintDiscoveredResources(void)
+{
+    printf("\n");
+    printf("=============================================================\n");
+    printf("Discovered Resources:\n");
+    for(uint32_t i = 0; i < DISC_RES_COUNTER; ++i)
+    {
+        DiscoveredResourceInfo currentResource = DISC_RES[i];
+
+        printf("\t#%u: uri:%s\taddr:%s\tport: %u\tresource type: %s\n",
+               i,
+               currentResource.uri,
+               currentResource.address.addr,
+               currentResource.address.port,
+               currentResource.resourceType);
+    }
+}
+
+void
+RegisterDiscoveredResources(OCClientResponse *clientResponse)
+{
+    DISC_RES_COUNTER = 0;
+    if (!(OCDiscoveryPayload*)clientResponse->payload)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0,
+            "[%s] Could not discover any resources.", __func__);
+        return;
+    }
+    OCResourcePayload* discoveredResource =
+    ((OCDiscoveryPayload*)(clientResponse->payload))->resources;
+    while (discoveredResource && discoveredResource != discoveredResource->next)
+    {
+        if (DISC_RES_COUNTER == MAX_RESOURCES_REMEMBERED)
+        {
+            OCSAMPLE_LOG_INFO(TAG, 0,
+                "[%s] Max of %u resources reached. Ignoring the rest.",
+                __func__, MAX_RESOURCES_REMEMBERED);
+            break;
+        }
+
+        strncpy(DISC_RES[DISC_RES_COUNTER].uri,
+            discoveredResource->uri, MAX_URI_LENGTH - 1);
+
+       strncpy(DISC_RES[DISC_RES_COUNTER].resourceType,
+            discoveredResource->types->value, MAX_RESOURCE_TYPE_SIZE - 1);
+        DISC_RES[DISC_RES_COUNTER].address = clientResponse->devAddr;
+        // secure the endpoint of the discovered secure resource.
+        if (discoveredResource->eps->family & OC_FLAG_SECURE)
+        {
+            if (0 == strcmp(discoveredResource->eps->tps, "coaps"))
+            {
+                strncpy(clientResponse->devAddr.addr,
+                        discoveredResource->eps->addr,
+                        sizeof(clientResponse->devAddr.addr));
+                clientResponse->devAddr.port = discoveredResource->eps->port;
+                clientResponse->devAddr.flags =
+                (OCTransportFlags)(discoveredResource->eps->family | OC_SECURE);
+                OCSAMPLE_LOG_INFO(TAG, 0, "[%s] DTLS port: %d",
+                          __func__,
+                          clientResponse->devAddr.port);
+            }
+        }
+        ++DISC_RES_COUNTER;
+        discoveredResource = discoveredResource->next;
+    }
+
+}
+
+void
+PrintFormattedResult(OCClientResponse *clientResponse)
+{
+    OCStackResult clientResult = clientResponse->result;
+    printf("\n==========================================================\n");
+    printf("Result: (%d) - %s\n", clientResult,
+            decode_oc_stack_result(clientResult));
+    OCSAMPLE_LOG_PAYLOAD(INFO, clientResponse->payload);
+    printf("==========================================================\n");
+}
+
+OCStackApplicationResult
+DiscoveryRequestCallBack(void* ctx,
+                         OCDoHandle handle,
+                         OCClientResponse * clientResponse)
+{
+    OC_UNUSED(handle);
+    OC_UNUSED(ctx);
+    if (!clientResponse)
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "[%s] Client discovery response is NULL", __func__);
+        printf("Discovery result is null.......\n");
+        DISCOVERING = false;
+        return OC_STACK_KEEP_TRANSACTION;
+    }
+    OCSAMPLE_LOG_INFO(TAG, 0, "[%s] Discovered addr:%s\tport:%d",
+          __func__,
+          clientResponse->devAddr.addr,
+          clientResponse->devAddr.port);
+    PrintFormattedResult(clientResponse);
+    RegisterDiscoveredResources(clientResponse);
+
+    PROMPT_USER = true;
+    DISCOVERING = false;
+
+    return OC_STACK_KEEP_TRANSACTION;
+}
+
+OCStackApplicationResult
+ResponseCallbacks(void* ctx,
+                  OCDoHandle handle,
+                  OCClientResponse * clientResponse)
+{
+    OC_UNUSED(handle);
+    OC_UNUSED(ctx);
+    if (clientResponse == NULL)
+    {
+        OIC_LOG_V(INFO, TAG, "[%s] Client request response is NULL", __func__);
+        return   OC_STACK_DELETE_TRANSACTION;
+    }
+    PrintFormattedResult(clientResponse);
+    PROMPT_USER = true;
+    return OC_STACK_KEEP_TRANSACTION;
+}
+
+OCStackResult
+InvokeOCDoRequest(const char *requestUri,
+                  OCPayload *payload,
+                  OCMethod method,
+                  OCClientResponseHandler cb,
+                  OCDevAddr *address)
+{
+    OCCallbackData cbData;
+
+    cbData.cb = cb;
+    cbData.context = (void*)DEFAULT_CONTEXT_VALUE;
+    cbData.cd = NULL;
+
+    OCConnectivityType connType = CT_ADAPTER_IP;
+    OCQualityOfService qos = OC_LOW_QOS;
+    OCDoHandle handle = NULL;
+    uint8_t numOptions = 0;
+
+    OCStackResult ret = OCDoRequest(&handle,
+                                    method,
+                                    requestUri,
+                                    address,
+                                    payload,
+                                    connType,
+                                    qos,
+                                    &cbData,
+                                    NULL,
+                                    numOptions);
+    if (ret != OC_STACK_OK)
+    {
+        PROMPT_USER = true;
+        OCSAMPLE_LOG_ERROR(TAG, 0,
+                  "[%s] OCDoRequest with method %s returns error (%d): %s",
+                  __func__,
+                  decode_oc_method(method),
+                  ret,
+                  decode_oc_stack_result(ret));
+    }
+    return ret;
+}
+
+OCPayload*
+GetCustomPostPayload(void)
+{
+    OCRepPayload* payload = OCRepPayloadCreate();
+    if (!payload)
+    {
+        OIC_LOG_V(ERROR, TAG, "[%s] Failed to create payload object", __func__);
+        exit(1);
+    }
+
+    char key[MAX_USER_INPUT] = {0};
+    char input[MAX_USER_INPUT] = {0};
+    char valueString[MAX_USER_INPUT] = {0};
+    int value = 0;
+    double valueDouble = 0.0;
+    int type = -1;
+    printf("\nNeed to create a custom POST payload");
+    printf("\nEnter key value pairs as:\t<type(int)> <key> <value>");
+    printf("\nType: 0:bool \t 1:int \t 2:double \t 3:string\n");
+    while (true)
+    {
+        printf("press ENTER to finish :");
+        char *ret = fgets(input, sizeof(input), stdin);
+        (void) ret;
+        int inCount = sscanf(input, "%d %s %s", &type, key, valueString);
+
+        if (inCount <= 0)
+        {
+            break;
+        }
+        if (inCount != 3)
+        {
+            printf("Invalid input\n");
+            OCRepPayloadDestroy(payload);
+            PROMPT_USER = true;
+            return NULL;
+        }
+
+        if (type == 0)  //bool
+        {
+            if (sscanf(valueString, "%d", &value) == 1)
+            {
+                OCRepPayloadSetPropBool(payload, key, value);
+            }
+        }
+        else if (type == 1)  //int
+        {
+            if (sscanf(valueString, "%d", &value) == 1)
+            {
+                OCRepPayloadSetPropInt(payload, key, value);
+            }
+        }
+        else if (type == 2)  //double
+        {
+            if (sscanf(valueString, "%lf", &valueDouble) == 1)
+            {
+                OCRepPayloadSetPropDouble(payload, key, valueDouble);
+            }
+        }
+        else if (type == 3)  //string
+        {
+            OCRepPayloadSetPropString(payload, key, valueString);
+        }
+        else
+        {
+            OIC_LOG_V(ERROR, TAG,
+                      "[%s] Invalid entry. stopping accepting key-values",
+                      __func__);
+            OCRepPayloadDestroy(payload);
+            PROMPT_USER = true;
+            return NULL;
+        }
+        memset(input, 0, sizeof (input));
+        memset(key, 0, sizeof (key));
+        memset(valueString, 0, sizeof (valueString));
+    }
+
+    if (payload->values)
+    {
+        return (OCPayload *) payload;
+    }
     else
-    {   
-        OCSAMPLE_LOG_INFO(TAG, 0, "Stopping clientStarter loop...");
-        return FALSE;
-    }   
+    {
+        OCRepPayloadDestroy(payload);
+        return NULL;
+    }
+}
+
+
+void
+ProcessUserInput(int resourceNo, int clientMethod)
+{
+    const char *resourceUri = DISC_RES[resourceNo].uri;
+    OCDevAddr resourceAddr = DISC_RES[resourceNo].address;
+    switch (clientMethod)
+    {
+        case OC_REST_GET:
+            OIC_LOG_V(INFO, TAG,
+                      "[%s] Initializing GET request for resource: %s",
+                      __func__,
+                      resourceUri);
+            InvokeOCDoRequest(resourceUri,
+                              NULL,
+                              OC_REST_GET,
+                              ResponseCallbacks,
+                              &resourceAddr);
+            break;
+        case OC_REST_POST:
+        {
+            OIC_LOG_V(INFO, TAG,
+                      "[%s] Initializing POST request for resource: %s",
+                      __func__,
+                      resourceUri);
+            OCPayload *payload = GetCustomPostPayload();
+            if (payload)
+            {
+                InvokeOCDoRequest(resourceUri,
+                                  payload,
+                                  OC_REST_POST,
+                                  ResponseCallbacks,
+                                  &resourceAddr);
+            }
+            else
+            {
+                OIC_LOG_V(ERROR, TAG,
+                          "[%s] Error creating POST payload. Aborting",
+                          __func__);
+                PROMPT_USER = true;
+            }
+            break;
+        }
+        case OC_REST_OBSERVE:
+        {
+            OIC_LOG_V(INFO, TAG,
+                      "[%s] Initializing OBSERVE request for resource: %s",
+                      __func__,
+                      resourceUri);
+            InvokeOCDoRequest(resourceUri,
+                              NULL,
+                              OC_REST_OBSERVE,
+                              ResponseCallbacks,
+                              &resourceAddr);
+            break;
+        }
+
+        default:
+            PROMPT_USER = true;
+            OIC_LOG_V(INFO, TAG, "[%s] Invalid client request method (%d) %s",
+                      __func__,
+                      clientMethod,
+                      decode_oc_method((OCMethod)clientMethod));
+    }
+}
+
+
+void
+GetUserInput(void)
+{
+    PrintDiscoveredResources();
+    printf("#####################################################\n");
+    printf("%d: GET\n", OC_REST_GET);
+    printf("%d: POST\n", OC_REST_POST);
+    printf("%d: OBSERVE\n", OC_REST_OBSERVE);
+    printf("9999: Go back to main menu\n");
+    printf("Usage:<resource number> <request method>\n");
+    printf("#####################################################\n");
+    printf("Select your choice: ");
+
+    char input[10] = {0};
+    uint32_t resourceNo = 0;
+    int requestMethod = 0;
+
+    char * ret = fgets(input, sizeof(input), stdin);
+    (void) ret;
+    int inCount = sscanf(input, "%d %d", &resourceNo, &requestMethod);
+
+    if (resourceNo == 9999)
+    {
+        PROMPT_USER = false;
+        return;
+    }
+
+    if (inCount != 2)
+    {
+        printf("Invalid input\n");
+        PROMPT_USER = true;
+        return;
+    }
+    if (resourceNo >= DISC_RES_COUNTER)
+    {
+        printf("Invalid resource\n");
+        PROMPT_USER = true;
+        return;
+    }
+    ProcessUserInput(resourceNo, requestMethod);
 }
 
 int main(int argc, char *argv[])
@@ -404,6 +1256,8 @@ int main(int argc, char *argv[])
     struct timespec timeout;
     OCPersistentStorage ps;
 
+    OCStackResult res = OC_STACK_OK;
+
     LSError lserror;
     LSErrorInit(&lserror);
 
@@ -428,47 +1282,6 @@ int main(int argc, char *argv[])
         return 0;
     }
 
-    while ((opt = getopt(argc, argv, "u:t:c:d:p:")) != -1)
-    {
-        switch (opt)
-        {
-            case 'u':
-                UnicastDiscovery = atoi(optarg);
-                break;
-            case 't':
-                TestCase = atoi(optarg);
-                break;
-            case 'c':
-                ConnType = atoi(optarg);
-                break;
-            case 'd':
-                DevOwner = atoi(optarg);
-                break;
-            case 'p':
-                {
-                    WithTcp = atoi(optarg);
-                    if (WithTcp > 1)
-                    {
-                        PrintUsage();
-                        return -1;
-                    }
-                }
-                break;
-            default:
-                PrintUsage();
-                return -1;
-        }
-    }
-
-    if ((UnicastDiscovery != 0 && UnicastDiscovery != 1) ||
-        (TestCase < TEST_DISCOVER_REQ || TestCase >= MAX_TESTS) ||
-        (ConnType < CT_ADAPTER_DEFAULT || ConnType >= MAX_CT))
-    {
-        PrintUsage();
-        return -1;
-    }
-
-
     if (ConnType == CT_ADAPTER_DEFAULT || ConnType ==  CT_IP)
     {
         discoveryReqConnType = CT_DEFAULT;
@@ -481,10 +1294,7 @@ int main(int argc, char *argv[])
 
 
     // Initialize Persistent Storage for SVR database
-    if (DevOwner)
-        ps = { client_fopen_devowner, fread, fwrite, fclose, unlink };
-    else
-        ps = { client_fopen_nondevowner, fread, fwrite, fclose, unlink };
+    ps = { client_fopen, fread, fwrite, fclose, unlink };
     OCRegisterPersistentStorageHandler(&ps);
 
     /* Initialize OCStack*/
@@ -494,7 +1304,7 @@ int main(int argc, char *argv[])
         return 0;
     }
 
-    InitDiscovery();
+    initializePlatform();
 
     timeout.tv_sec  = 0;
     timeout.tv_nsec = 100000000L;
@@ -502,8 +1312,47 @@ int main(int argc, char *argv[])
     // Break from loop with Ctrl+C
     OCSAMPLE_LOG_INFO(TAG, 0, "Entering clientStarter main loop...");
     signal(SIGINT, handleSigInt);
-    g_timeout_add_seconds(1, clientStarter, NULL);
-    g_main_loop_run(mainloop);
+    pthread_create(&threadId_client, NULL, clientStarter, (void *)NULL);
+    while (!gQuitFlag)
+    {
+        if (PROMPT_USER && !DISCOVERING)
+        {
+            GetUserInput();
+        }
+        else if (!PROMPT_USER && !DISCOVERING)
+        {
+            char input[10] = {0};
+            printf("*********************************\n");
+            printf("******** IoTivity Client ********\n");
+            printf("*********************************\n");
+            printf("Control the server remotely:\n");
+            printf("1: Discover Resource\n");
+            printf("99: quit the menu\n");
+            printf("*********************************\n");
+            printf("Select your choice: ");
+            char * ret = fgets(input, sizeof(input), stdin);
+            printf("\n");
+            switch (atoi(input))
+            {
+                case 1:
+                    printf("Discovering resources..................\n");
+                    // initiate discovery request
+                    res = InvokeOCDoRequest(OC_RSRVD_WELL_KNOWN_URI, 0,
+                                      OC_REST_DISCOVER,
+                                      DiscoveryRequestCallBack,
+                                      0);
+                    DISCOVERING = true;
+                    break;
+                case 99:
+                    gQuitFlag = true;
+                    break;
+
+            default:
+                printf("Invalid selection...\n");
+                    break;
+            }
+        }
+    }
 
     OCSAMPLE_LOG_INFO(TAG, 0, "Exiting occlient main loop...");
 
diff --git a/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.cpp b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.cpp
index c34c12304..9868a13ca 100644
--- a/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.cpp
+++ b/resource/csdk/stack/samples/webos/secure/ocserverbasicops/ocserverbasicops.cpp
@@ -39,7 +39,7 @@
 
 /// This example is using experimental API, so there is no guarantee of support for future release,
 /// nor any there any guarantee that breaking changes will not occur across releases.
-#include "experimental/logger.h"
+#include "logger.h"
 
 #include <luna-service2/lunaservice.h>
 #include <glib.h>
@@ -47,6 +47,17 @@
 #include <pthread.h>
 #include "logging.h"
 
+#define SAMPLE_MAX_NUM_POST_INSTANCE  2
+#define SAMPLE_MAX_NUM_OBSERVATIONS     8
+
+/* Structure to represent the observers */
+typedef struct
+{
+    OCObservationId observationId;
+    bool valid;
+    OCResourceHandle resourceHandle;
+} Observers;
+
 pthread_t threadId_server;
 PmLogContext gLogContext;
 PmLogContext gLogLibContext;
@@ -57,19 +68,248 @@ static LEDResource LED;
 // This variable determines instance number of the LED resource.
 // Used by POST method to create a new instance of LED resource.
 static int gCurrLedInstance = 0;
-#define SAMPLE_MAX_NUM_POST_INSTANCE  2
 static LEDResource gLedInstance[SAMPLE_MAX_NUM_POST_INSTANCE];
 
-char *gResourceUri= (char *)"/a/led";
+char *gResourceUri= (char *)"/binaryswitch";
 
 //Secure Virtual Resource database for Iotivity Server
 //It contains Server's Identity and the PSK credentials
 //of other devices which the server trusts
 static char CRED_FILE[] = "oic_svr_db_server.dat";
+static char INTROSPECTION_FILE[] = "server_introspection.dat";
 
 static LSHandle *pLsHandle = NULL;
 static GMainLoop *mainloop = NULL;
 
+OCObservationId obsNotify[(SAMPLE_MAX_NUM_OBSERVATIONS)/2];
+Observers interestedObservers[SAMPLE_MAX_NUM_OBSERVATIONS];
+
+// Set of strings for each of platform Info fields
+static const char *gPlatformId = "0A3E0D6F-DBF5-404E-8719-D6880042463A";
+static const char *gManufacturerName = "myName";
+static const char *gManufacturerLink = "https://www.iotivity.org";
+static const char *gModelNumber = "myModelNumber";
+static const char *gDateOfManufacture = "2016-01-15";
+static const char *gPlatformVersion = "myPlatformVersion";
+static const char *gOperatingSystemVersion = "myOS";
+static const char *gHardwareVersion = "myHardwareVersion";
+static const char *gFirmwareVersion = "myFirmwareVersion";
+static const char *gSupportLink = "https://www.iotivity.org";
+static const char *gSystemTime = "2017-12-01T12:00:00.52Z";
+
+static const char *gDeviceName = "Binary Switch";
+static const char *gDeviceType = "oic.d.light";
+static const char *gSpecVersion = "ocf.1.3.0";
+static const char *gDataModelVersions = "ocf.res.1.3.0,ocf.sh.1.3.0";
+static const char *gProtocolIndependentID = "fa008167-3bbf-4c9d-8604-c9bcb96cb712";
+
+OCPlatformInfo platformInfo;
+
+// forward declarations
+void DeletePlatformInfo();
+void initializePlatform();
+OCStackResult SetDeviceInfo();
+OCStackResult SetPlatformInfo(const char *platformID, const char *manufacturerName,
+        const char *manufacturerUrl, const char *modelNumber, const char *dateOfManufacture,
+        const char *platformVersion, const char *operatingSystemVersion,
+        const char *hardwareVersion, const char *firmwareVersion, const char *supportUrl,
+        const char *systemTime);
+
+void DeletePlatformInfo()
+{
+    free(platformInfo.platformID);
+    free(platformInfo.manufacturerName);
+    free(platformInfo.manufacturerUrl);
+    free(platformInfo.modelNumber);
+    free(platformInfo.dateOfManufacture);
+    free(platformInfo.platformVersion);
+    free(platformInfo.operatingSystemVersion);
+    free(platformInfo.hardwareVersion);
+    free(platformInfo.firmwareVersion);
+    free(platformInfo.supportUrl);
+    free(platformInfo.systemTime);
+}
+
+bool DuplicateString(char** targetString, const char* sourceString)
+{
+    if(!sourceString)
+    {
+        return false;
+    }
+    else
+    {
+        *targetString = (char *) malloc(strlen(sourceString) + 1);
+
+        if(*targetString)
+        {
+            strncpy(*targetString, sourceString, (strlen(sourceString) + 1));
+            return true;
+        }
+    }
+    return false;
+}
+
+OCStackResult SetPlatformInfo(const char* platformID, const char *manufacturerName,
+    const char *manufacturerUrl, const char *modelNumber, const char *dateOfManufacture,
+    const char *platformVersion, const char* operatingSystemVersion, const char* hardwareVersion,
+    const char *firmwareVersion, const char* supportUrl, const char* systemTime)
+{
+
+    bool success = true;
+
+    if(manufacturerName != NULL && (strlen(manufacturerName) > MAX_PLATFORM_NAME_LENGTH))
+    {
+        return OC_STACK_INVALID_PARAM;
+    }
+
+    if(manufacturerUrl != NULL && (strlen(manufacturerUrl) > MAX_PLATFORM_URL_LENGTH))
+    {
+        return OC_STACK_INVALID_PARAM;
+    }
+
+    if(!DuplicateString(&platformInfo.platformID, platformID))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.manufacturerName, manufacturerName))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.manufacturerUrl, manufacturerUrl))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.modelNumber, modelNumber))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.dateOfManufacture, dateOfManufacture))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.platformVersion, platformVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.operatingSystemVersion, operatingSystemVersion))
+    {
+        success = false;
+    }
+    if(!DuplicateString(&platformInfo.hardwareVersion, hardwareVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.firmwareVersion, firmwareVersion))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.supportUrl, supportUrl))
+    {
+        success = false;
+    }
+
+    if(!DuplicateString(&platformInfo.systemTime, systemTime))
+    {
+        success = false;
+    }
+
+    if(success)
+    {
+        return OC_STACK_OK;
+    }
+
+    DeletePlatformInfo();
+    return OC_STACK_ERROR;
+}
+
+OCStackResult SetDeviceInfo()
+{
+    OCStackResult result = OC_STACK_ERROR;
+
+    OCResourceHandle resourceHandle = OCGetResourceHandleAtUri(OC_RSRVD_DEVICE_URI);
+    if (resourceHandle == NULL)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Device Resource does not exist.");
+        return result;
+    }
+
+    result = OCBindResourceTypeToResource(resourceHandle, gDeviceType);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to add device type");
+        return result;
+    }
+    result = OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, gDeviceName);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set device name");
+        return result;
+    }
+    result = OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DATA_MODEL_VERSION,
+                                      gDataModelVersions);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set data model versions");
+        return result;
+    }
+    result = OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_SPEC_VERSION, gSpecVersion);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set spec version");
+        return result;
+    }
+    result = OCSetPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_PROTOCOL_INDEPENDENT_ID,
+                                      gProtocolIndependentID);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to set piid");
+        return result;
+    }
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Device information initialized successfully.");
+    return OC_STACK_OK;
+}
+
+void initializePlatform()
+{
+    OCSAMPLE_LOG_INFO(TAG, 0, "Running initializePlatform...");
+
+    // initialize "oic/p"
+    OCSAMPLE_LOG_INFO(TAG, 0, "oic/p");
+    OCStackResult result = SetPlatformInfo(gPlatformId, gManufacturerName, gManufacturerLink,
+            gModelNumber, gDateOfManufacture, gPlatformVersion, gOperatingSystemVersion,
+            gHardwareVersion, gFirmwareVersion, gSupportLink, gSystemTime);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Platform info setting failed locally!");
+        return;
+    }
+
+    result = OCSetPlatformInfo(platformInfo);
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Platform Registration failed!");
+        return;
+    }
+
+    // initialize "oic/d"
+    OCSAMPLE_LOG_INFO(TAG, 0, "oic/d");
+    result = SetDeviceInfo();
+    if (result != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Device Registration failed!");
+        return;
+    }
+}
+
 OCRepPayload* getPayload(const char* uri, int64_t power, bool state)
 {
     OCRepPayload* payload = OCRepPayloadCreate();
@@ -79,9 +319,11 @@ OCRepPayload* getPayload(const char* uri, int64_t power, bool state)
         return nullptr;
     }
 
-    OCRepPayloadSetUri(payload, uri);
-    OCRepPayloadSetPropBool(payload, "state", state);
-    OCRepPayloadSetPropInt(payload, "power", power);
+    OCRepPayloadSetPropBool(payload, "value", state);
+    OCRepPayloadSetPropString(payload, "n", "");
+    OCRepPayloadAddResourceType(payload, "oic.r.switch.binary");
+    OCRepPayloadAddInterface(payload, "oic.if.baseline");
+    OCRepPayloadAddInterface(payload, "oic.if.a");
 
     return payload;
 }
@@ -99,29 +341,11 @@ OCRepPayload* constructResponse (OCEntityHandlerRequest *ehRequest)
 
     LEDResource *currLEDResource = &LED;
 
-    if (ehRequest->resource == gLedInstance[0].handle)
-    {
-        currLEDResource = &gLedInstance[0];
-        gResourceUri = (char *) "/a/led/0";
-    }
-    else if (ehRequest->resource == gLedInstance[1].handle)
-    {
-        currLEDResource = &gLedInstance[1];
-        gResourceUri = (char *) "/a/led/1";
-    }
-
     if(OC_REST_PUT == ehRequest->method
         || OC_REST_POST == ehRequest->method)
     {
-        // Get pointer to query
-        int64_t pow;
-        if(OCRepPayloadGetPropInt(input, "power", &pow))
-        {
-            currLEDResource->power = pow;
-        }
-
         bool state;
-        if(OCRepPayloadGetPropBool(input, "state", &state))
+        if(OCRepPayloadGetPropBool(input, "value", &state))
         {
             currLEDResource->state = state;
         }
@@ -176,78 +400,67 @@ OCEntityHandlerResult ProcessPostRequest (OCEntityHandlerRequest *ehRequest,
     OCRepPayload *respPLPost_led = nullptr;
     OCEntityHandlerResult ehResult = OC_EH_OK;
 
-    /*
-     * The entity handler determines how to process a POST request.
-     * Per the REST paradigm, POST can also be used to update representation of existing
-     * resource or create a new resource.
-     * In the sample below, if the POST is for /a/led then a new instance of the LED
-     * resource is created with default representation (if representation is included in
-     * POST payload it can be used as initial values) as long as the instance is
-     * lesser than max new instance count. Once max instance count is reached, POST on
-     * /a/led updated the representation of /a/led.
-     */
+    OCRepPayload *postResp = constructResponse(ehRequest);
 
-    if (ehRequest->resource == LED.handle)
+    // Notify the list of observers
+    int j = 0;
+    for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; (i=i+2))
     {
-        if (gCurrLedInstance < SAMPLE_MAX_NUM_POST_INSTANCE)
+        printf("interestedObservers[i].valid = %d\n", interestedObservers[i].valid);
+        printf("interestedObservers[i].observationId = %d\n", interestedObservers[i].observationId);
+        if (interestedObservers[i].valid == true)
         {
-            // Create new LED instance
-            char newLedUri[15] = "/a/led/";
-            size_t newLedUriLength = strlen(newLedUri);
-            snprintf((newLedUri + newLedUriLength), (sizeof(newLedUri) - newLedUriLength), "%d", gCurrLedInstance);
-
-            respPLPost_led = OCRepPayloadCreate();
-            OCRepPayloadSetUri(respPLPost_led, gResourceUri);
-            OCRepPayloadSetPropString(respPLPost_led, "createduri", newLedUri);
-
-            if (0 == createLEDResource (newLedUri, &gLedInstance[gCurrLedInstance], false, 0))
-            {
-                OCSAMPLE_LOG_INFO(TAG, 0, "Created new LED instance");
-                gLedInstance[gCurrLedInstance].state = 0;
-                gLedInstance[gCurrLedInstance].power = 0;
-                gCurrLedInstance++;
-                strncpy ((char *)response->resourceUri, newLedUri, MAX_URI_LENGTH);
-                ehResult = OC_EH_RESOURCE_CREATED;
-            }
-        }
-        else
-        {
-            respPLPost_led = constructResponse(ehRequest);
-        }
-    }
-    else
-    {
-        for (int i = 0; i < SAMPLE_MAX_NUM_POST_INSTANCE; i++)
-        {
-            if (ehRequest->resource == gLedInstance[i].handle)
-            {
-                if (i == 0)
-                {
-                    respPLPost_led = constructResponse(ehRequest);
-                    break;
-                }
-                else if (i == 1)
-                {
-                    respPLPost_led = constructResponse(ehRequest);
-                }
-            }
+            obsNotify[j] = interestedObservers[i].observationId;
+            j++;
+            printf("obsNotify[j]=%d\n", j);
         }
     }
 
-    if (respPLPost_led != NULL)
+    printf("POST_LED.state=%d\n", LED.state);
+    OCStackResult res = OCNotifyListOfObservers (LED.handle, obsNotify, j, postResp, OC_NA_QOS);
+
+    if(postResp)
     {
-        *payload = respPLPost_led;
+        *payload = postResp;
         ehResult = OC_EH_OK;
     }
     else
     {
-        OCSAMPLE_LOG_INFO(TAG, 0, "Payload was NULL");
         ehResult = OC_EH_ERROR;
     }
 
     return ehResult;
 }
 
+void ProcessObserveRegister (OCEntityHandlerRequest *ehRequest)
+{
+    OIC_LOG_V (INFO, TAG, "Received observation registration request with observation Id %d",
+            ehRequest->obsInfo.obsId);
+
+    for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
+    {
+        if (interestedObservers[i].valid == false)
+        {
+            interestedObservers[i].observationId = ehRequest->obsInfo.obsId;
+            interestedObservers[i].valid = true;
+            break;
+        }
+    }
+}
+
+void ProcessObserveDeregister (OCEntityHandlerRequest *ehRequest)
+{
+    OIC_LOG_V (INFO, TAG, "Received observation deregistration request for observation Id %d",
+            ehRequest->obsInfo.obsId);
+    for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; i++)
+    {
+        if (interestedObservers[i].observationId == ehRequest->obsInfo.obsId)
+        {
+            interestedObservers[i].valid = false;
+        }
+    }
+}
+
 OCEntityHandlerResult
 OCEntityHandlerCb (OCEntityHandlerFlag flag,
         OCEntityHandlerRequest *entityHandlerRequest,
@@ -316,6 +529,23 @@ OCEntityHandlerCb (OCEntityHandlerFlag flag,
         }
     }
 
+    // Handle observe request
+    if (flag & OC_OBSERVE_FLAG)
+    {
+        OIC_LOG(INFO, TAG, "Flag includes OC_OBSERVE_FLAG");
+
+        if (OC_OBSERVE_REGISTER == entityHandlerRequest->obsInfo.action)
+        {
+            OIC_LOG (INFO, TAG, "Received OC_OBSERVE_REGISTER from client");
+            ProcessObserveRegister (entityHandlerRequest);
+        }
+        else if (OC_OBSERVE_DEREGISTER == entityHandlerRequest->obsInfo.action)
+        {
+            OIC_LOG (INFO, TAG, "Received OC_OBSERVE_DEREGISTER from client");
+            ProcessObserveDeregister (entityHandlerRequest);
+        }
+    }
+
     OCRepPayloadDestroy(payload);
     return ehResult;
 }
@@ -334,29 +564,30 @@ FILE* server_fopen(const char *path, const char *mode)
 {
     if (0 == strcmp(path, OC_SECURITY_DB_DAT_FILE_NAME))
     {
+        OCSAMPLE_LOG_INFO(TAG, 0, "reading security file 'oic_svr_db_server.dat' ptr...");
         return fopen(CRED_FILE, mode);
     }
+    else if (0 == strcmp(path, OC_INTROSPECTION_FILE_NAME))
+    {
+        OCSAMPLE_LOG_INFO(TAG, 0, "reading introspection file  'server_introspection.dat' ptr...");
+        return fopen(INTROSPECTION_FILE, mode);
+    }
     else
     {
         return fopen(path, mode);
     }
 }
 
-static gboolean serverStarter(gpointer user_data)
+void *serverStarter(gpointer user_data)
 {
-    if (!gQuitFlag)
+    while (!gQuitFlag)
     {
         if (OCProcess() != OC_STACK_OK)
         {
             OCSAMPLE_LOG_ERROR(TAG, 0, "OCStack process error");
         }
-        return TRUE;
-    }
-    else
-    {
-        OCSAMPLE_LOG_INFO(TAG, 0, "Stopping serverStarter loop...");
-        return FALSE;
     }
+    OCSAMPLE_LOG_INFO(TAG, 0, "Stopping serverStarter loop...");
 }
 
 int main(int /*argc*/, char* /*argv*/[])
@@ -400,6 +631,8 @@ int main(int /*argc*/, char* /*argv*/[])
         return 0;
     }
 
+    initializePlatform();
+
     /*
      * Declare and create the example resource: LED
      */
@@ -412,10 +645,100 @@ int main(int /*argc*/, char* /*argv*/[])
     OCSAMPLE_LOG_INFO(TAG, 0, "Entering ocserver main loop...");
     signal(SIGINT, handleSigInt);
 
-    //pthread_create(&threadId_server, NULL, serverStarter, (void *)NULL);
+    pthread_create(&threadId_server, NULL, serverStarter, (void *)NULL);
     OCSAMPLE_LOG_INFO(TAG, 0, "Entering serverStarter main loop...");
-    g_timeout_add_seconds(1, serverStarter, NULL);
-    g_main_loop_run(mainloop);
+
+    char input[10] = {0};
+    uint8_t j = 0;
+
+    // Initialize observations data structure for the resource
+    for (uint8_t p = 0; p < SAMPLE_MAX_NUM_OBSERVATIONS; p++)
+    {
+        interestedObservers[p].valid = false;
+    }
+
+    OCRepPayload* payload = nullptr;
+
+    OCStackResult res = OC_STACK_OK;
+    while (!gQuitFlag)
+    {
+		printf("\n");
+		printf("*********************************\n");
+		printf("****** Binaryswitch Server ******\n");
+		printf("*********************************\n");
+		printf("Control the server locally:\n");
+        printf("1: turn on the switch\n");
+        printf("0: turn off the switch\n");
+		printf("2: show current status\n");
+		printf("99: quit the menu\n");
+		printf("*********************************\n");
+		printf("Select your choice: ");
+        char * ret = fgets(input, sizeof(input), stdin);
+        switch (atoi(input))
+        {
+            case 1:
+                printf("Power up...\n");
+                LED.state = true;
+                j = 0;
+                for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; (i=i+2))
+                {
+                    printf("interestedObservers[i].valid = %d\n", interestedObservers[i].valid);
+                    printf("interestedObservers[i].observationId = %d\n", interestedObservers[i].observationId);
+                    if (interestedObservers[i].valid == true)
+                    {
+                        obsNotify[j] = interestedObservers[i].observationId;
+                        j++;
+                        printf("obsNotify[j]=%d\n", j);
+                    }
+                }
+
+                payload = getPayload(gResourceUri, 0, LED.state);
+                printf("LED.state=%d\n", LED.state);
+                res = OCNotifyListOfObservers (LED.handle, obsNotify, j, payload, OC_NA_QOS);
+                if (res != OC_STACK_OK)
+                    printf("Notify failed\n");
+                else
+                    printf("Notify succeeded\n");
+
+                OCRepPayloadDestroy(payload);
+
+                break;
+            case 0:
+                printf("Power down...\n");
+                LED.state = false;
+                j = 0;
+                for (uint8_t i = 0; i < SAMPLE_MAX_NUM_OBSERVATIONS; (i=i+2))
+                {
+                    if (interestedObservers[i].valid == true)
+                    {
+                        obsNotify[j] = interestedObservers[i].observationId;
+                        j++;
+                    }
+                }
+
+                payload = getPayload(gResourceUri, 0, LED.state);
+                OCNotifyListOfObservers (LED.handle, obsNotify, j,
+                        payload, OC_HIGH_QOS);
+                if (res != OC_STACK_OK)
+                    printf("Notify failed\n");
+                else
+                    printf("Notify succeeded\n");
+                OCRepPayloadDestroy(payload);
+                break;
+
+            case 2:
+                printf("\n*****************************************************\n");
+				printf("Status of the binary swtich: %d\n", LED.state);
+                printf("*****************************************************\n");
+                break;
+            case 99:
+                gQuitFlag = true;
+                break;
+            default:
+                printf("Invalid selection...\n");
+                break;
+        }
+    }
 
     OCSAMPLE_LOG_INFO(TAG, 0, "Exiting ocserver main loop...");
 
@@ -439,13 +762,22 @@ int createLEDResource (char *uri, LEDResource *ledResource, bool resourceState,
     ledResource->state = resourceState;
     ledResource->power= resourcePower;
     OCStackResult res = OCCreateResource(&(ledResource->handle),
-            "core.led",
+            "oic.r.switch.binary",
             OC_RSRVD_INTERFACE_DEFAULT,
             uri,
             OCEntityHandlerCb,
             NULL,
             OC_DISCOVERABLE|OC_OBSERVABLE | OC_SECURE);
+
     OCSAMPLE_LOG_INFO(TAG, 0, "Created LED resource with result: %s", getResult(res));
 
+    res = OCBindResourceInterfaceToResource(ledResource->handle, "oic.if.a");
+    if (res != OC_STACK_OK)
+    {
+        OCSAMPLE_LOG_ERROR(TAG, 0, "Failed to Bind resource interface...");
+    }
+
+    OCSAMPLE_LOG_INFO(TAG, 0, "Bind interface with result: %s", getResult(res));
+
     return 0;
 }
-- 
2.16.1.windows.1

